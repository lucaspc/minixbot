#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Bot/BasicBot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BOT_BASICBOT';
  package Bot::BasicBot;
  BEGIN {
    $Bot::BasicBot::AUTHORITY = 'cpan:HINRIK';
  }
  BEGIN {
    $Bot::BasicBot::VERSION = '0.89';
  }
  
  use strict;
  use warnings;
  
  use Carp;
  use Encode qw(encode);
  use Exporter;
  use IRC::Utils qw(decode_irc);
  use POE::Kernel;
  use POE::Session;
  use POE::Wheel::Run;
  use POE::Filter::Line;
  use POE::Component::IRC::State;
  use POE::Component::IRC::Plugin::Connector;
  use Text::Wrap ();
  
  use base 'Exporter';
  our @EXPORT = qw(say emote);
  
  sub new {
      my $class = shift;
      my $self = bless {}, $class;
  
      $self->{IRCNAME} = 'wanna'.int(rand(100000));
      $self->{ALIASNAME} = 'pony'.int(rand(100000));
  
      # call the set methods
      my %args = @_;
      for my $method (keys %args) {
          if ($self->can($method)) {
              $self->$method($args{$method});
          }
          else {
              $self->{$method} = $args{$method};
              #croak "Invalid argument '$method'";
          }
      }
      $self->{charset} = 'utf8' if !defined $self->{charset};
  
      $self->init or die "init did not return a true value - dying";
  
      return $self;
  }
  
  sub run {
      my $self = shift;
  
      # create the callbacks to the object states
      POE::Session->create(
          object_states => [
              $self => {
                  _start => "start_state",
                  die    => "die_state",
  
                  irc_001          => "irc_001_state",
                  irc_msg          => "irc_said_state",
                  irc_public       => "irc_said_state",
                  irc_ctcp_action  => "irc_emoted_state",
                  irc_notice       => "irc_noticed_state",
  
                  irc_disconnected => "irc_disconnected_state",
                  irc_error        => "irc_error_state",
  
                  irc_join         => "irc_chanjoin_state",
                  irc_part         => "irc_chanpart_state",
                  irc_kick         => "irc_kicked_state",
                  irc_nick         => "irc_nick_state",
                  irc_quit         => "irc_quit_state",
  
                  fork_close       => "fork_close_state",
                  fork_error       => "fork_error_state",
  
                  irc_366          => "names_done_state",
  
                  irc_332          => "topic_raw_state",
                  irc_topic        => "topic_state",
  
                  irc_shutdown     => "shutdown_state",
  
                  tick => "tick_state",
              }
          ]
      );
  
      # and say that we want to recive said messages
      $poe_kernel->post($self->{IRCNAME}, 'register', 'all');
  
      # run
      $poe_kernel->run() if !$self->{no_run};
      return;
  }
  
  sub init { return 1; }
  
  sub said { return }
  
  sub emoted {
      return shift->said(@_);
  }
  
  sub noticed {
      return shift->said(@_);
  }
  
  sub chanjoin { return }
  
  sub chanpart { return }
  
  sub got_names { return }
  
  sub topic { return }
  
  sub nick_change { return }
  
  sub kicked { return }
  
  sub tick { return 0; }
  
  sub help { return "Sorry, this bot has no interactive help." }
  
  sub connected { return }
  
  sub userquit {
      my ($self, $mess) = @_;
      return;
  }
  
  sub schedule_tick {
      my $self = shift;
      my $time = shift || 5;
      $poe_kernel->delay('tick', $time);
      return;
  }
  
  sub forkit {
      my $self = shift;
      my $args;
  
      if (ref($_[0])) {
          $args = shift;
      }
      else {
          my %args = @_;
          $args = \%args;
      }
  
      return if !$args->{run};
  
      $args->{handler}   = $args->{handler}   || "_fork_said";
      $args->{arguments} = $args->{arguments} || [];
  
      #install a new handler in the POE kernel pointing to
      # $self->{$args{handler}}
      $poe_kernel->state( $args->{handler}, $args->{callback} || $self  );
  
      my $run;
      if (ref($args->{run}) =~ /^CODE/) {
          $run = sub {
              $args->{run}->($args->{body}, @{ $args->{arguments} })
          };
      }
      else {
          $run = $args->{run};
      }
  
      my $wheel = POE::Wheel::Run->new(
          Program      => $run,
          StdoutFilter => POE::Filter::Line->new(),
          StderrFilter => POE::Filter::Line->new(),
          StdoutEvent  => "$args->{handler}",
          StderrEvent  => "fork_error",
          CloseEvent   => "fork_close"
      );
  
      # Use a signal handler to reap dead processes
      $poe_kernel->sig_child($wheel->PID, "got_sigchld");
  
      # store the wheel object in our bot, so we can retrieve/delete easily
  
      $self->{forks}{ $wheel->ID } = {
          wheel => $wheel,
          args  => {
              channel => $args->{channel},
              who     => $args->{who},
              address => $args->{address}
          }
      };
      return;
  }
  
  sub _fork_said {
      my ($self, $body, $wheel_id) = @_[OBJECT, ARG0, ARG1];
      chomp $body;    # remove newline necessary to move data;
  
      # pick up the default arguments we squirreled away earlier
      my $args = $self->{forks}{$wheel_id}{args};
      $args->{body} = $body;
  
      $self->say($args);
      return;
  }
  
  sub say {
      # If we're called without an object ref, then we're handling saying
      # stuff from inside a forked subroutine, so we'll freeze it, and toss
      # it out on STDOUT so that POE::Wheel::Run's handler can pick it up.
      if (!ref $_[0]) {
          print $_[0], "\n";
          return 1;
      }
  
      # Otherwise, this is a standard object method
  
      my $self = shift;
      my $args;
      if (ref $_[0]) {
          $args = shift;
      }
      else {
          my %args = @_;
          $args = \%args;
      }
  
      my $body = $args->{body};
  
      # add the "Foo: bar" at the start
      if ($args->{channel} ne "msg" && defined $args->{address}) {
          $body = "$args->{who}: $body";
      }
  
      # work out who we're going to send the message to
      my $who = $args->{channel} eq "msg" ? $args->{who} : $args->{channel};
  
      if (!defined $who || !defined $body) {
          $self->log("Can't send a message without target and body\n"
                . " called from "
                . ( [caller]->[0] )
                . " line "
                . ( [caller]->[2] ) . "\n"
                . " who = '$who'\n body = '$body'\n");
          return;
      }
  
      # if we have a long body, split it up..
      local $Text::Wrap::columns = 300;
      local $Text::Wrap::unexpand = 0; # no tabs
      my $wrapped = Text::Wrap::wrap('', '..', $body); #  =~ m!(.{1,300})!g;
      # I think the Text::Wrap docs lie - it doesn't do anything special
      # in list context
      my @bodies = split /\n+/, $wrapped;
  
      # Allows to override the default "PRIVMSG". Used by notice()
      my $irc_command = defined $args->{irc_command}
          && $args->{irc_command} eq 'notice'
          ? 'notice'
          : 'privmsg';
  
      # post an event that will send the message
      for my $body (@bodies) {
          my ($enc_who, $enc_body) = $self->charset_encode($who, $body);
          #warn "$enc_who => $enc_body\n";
          $poe_kernel->post(
              $self->{IRCNAME},
              $irc_command,
              $enc_who,
              $enc_body,
          );
      }
  
      return;
  }
  
  sub emote {
      # If we're called without an object ref, then we're handling emoting
      # stuff from inside a forked subroutine, so we'll freeze it, and
      # toss it out on STDOUT so that POE::Wheel::Run's handler can pick
      # it up.
      if (!ref $_[0]) {
          print $_[0], "\n";
          return 1;
      }
  
      # Otherwise, this is a standard object method
  
      my $self = shift;
      my $args;
      if (ref $_[0]) {
          $args = shift;
      }
      else {
          my %args = @_;
          $args = \%args;
      }
  
      my $body = $args->{body};
  
      # Work out who we're going to send the message to
      my $who = $args->{channel} eq "msg"
          ? $args->{who}
          : $args->{channel};
  
      # post an event that will send the message
      # if there's a better way of sending actions i'd love to know - jw
      # me too; i'll look at it in v0.5 - sb
  
      $poe_kernel->post(
          $self->{IRCNAME},
          'ctcp',
          $self->charset_encode($who, "ACTION $body"),
      );
      return;
  }
  
  sub notice {
      if (!ref $_[0]) {
          print $_[0], "\n";
          return 1;
      }
  
      my $self = shift;
      my $args;
      if (ref $_[0]) {
          $args = shift;
      }
      else {
          my %args = @_;
          $args = \%args;
      }
  
      # Don't modify '$args' hashref in-place, or we might
      # make all subsequent calls into notices
      return $self->say(
          %{ $args },
          irc_command => 'notice'
      );
  
  }
  
  sub pocoirc {
      my $self = shift;
      return $self->{IRCOBJ};
  }
  
  sub reply {
      my $self = shift;
      my ($mess, $body) = @_;
      my %hash = %$mess;
      $hash{body} = $body;
      return $self->say(%hash);
  }
  
  sub channel_data {
      my $self = shift;
      my $channel = shift or return;
      my $irc = $self->{IRCOBJ};
      my $channels = $irc->channels();
      return if !exists $channels->{$channel};
  
      return {
          map {
              $_ => {
                  op    => $irc->is_channel_operator($channel, $_) || 0,
                  voice => $irc->has_channel_voice($channel, $_) || 0,
              }
          } $irc->channel_list($channel)
      };
  }
  
  sub server {
      my $self = shift;
      $self->{server} = shift if @_;
      return $self->{server} || "irc.perl.org";
  }
  
  sub port {
      my $self = shift;
      $self->{port} = shift if @_;
      return $self->{port} || "6667";
  }
  
  sub password {
      my $self = shift;
      $self->{password} = shift if @_;
      return $self->{password} || undef;
  }
  
  sub ssl {
      my $self = shift;
      $self->{ssl} = shift if @_;
      return $self->{ssl} || 0;
  }
  
  sub localaddr {
      my $self = shift;
      $self->{localaddr} = shift if @_;
      return $self->{localaddr} || 0;
  }
  
  sub useipv6 {
      my $self = shift;
      $self->{useipv6} = shift if @_;
      return $self->{useipv6} || 0;
  }
  
  sub nick {
      my $self = shift;
      $self->{nick} = shift if @_;
      return $self->{nick} if defined $self->{nick};
      return _random_nick();
  }
  
  sub _random_nick {
      my @things = ( 'a' .. 'z' );
      return join '', ( map { @things[ rand @things ] } 0 .. 4 ), "bot";
  }
  
  sub alt_nicks {
      my $self = shift;
      if (@_) {
          # make sure we copy
          my @args = ( ref $_[0] eq "ARRAY" ) ? @{ $_[0] } : @_;
          $self->{alt_nicks} = \@args;
      }
      return @{ $self->{alt_nicks} || [] };
  }
  
  sub username {
      my $self = shift;
      $self->{username} = shift if @_;
      return defined $self->{username} ? $self->{username} : $self->nick;
  }
  
  sub name {
      my $self = shift;
      $self->{name} = shift if @_;
      return defined $self->{name} ? $self->{name} : $self->nick . " bot";
  }
  
  sub channels {
      my $self = shift;
      if (@_) {
          # make sure we copy
          my @args = ( ref $_[0] eq "ARRAY" ) ? @{ $_[0] } : @_;
          $self->{channels} = \@args;
      }
      return @{ $self->{channels} || [] };
  }
  
  sub quit_message {
      my $self = shift;
      $self->{quit_message} = shift if @_;
      return defined $self->{quit_message} ? $self->{quit_message} : "Bye";
  }
  
  sub ignore_list {
      my $self = shift;
      if (@_) {
          # make sure we copy
          my @args = ( ref $_[0] eq "ARRAY" ) ? @{ $_[0] } : @_;
          $self->{ignore_list} = \@args;
      }
      return @{ $self->{ignore_list} || [] };
  }
  
  sub charset {
      my $self = shift;
      if (@_) {
          $self->{charset} = shift;
      }
      return $self->{charset};
  }
  
  sub flood {
      my $self = shift;
      $self->{flood} = shift if @_;
      return $self->{flood};
  }
  
  sub no_run {
      my $self = shift;
      $self->{no_run} = shift if @_;
      return $self->{no_run};
  }
  
  sub start_state {
      my ($self, $kernel, $session) = @_[OBJECT, KERNEL, SESSION];
      $kernel->sig('DIE', 'die');
      $self->{session} = $session;
  
      # Make an alias for our session, to keep it from getting GC'ed.
      $kernel->alias_set($self->{ALIASNAME});
      $kernel->delay('tick', 30);
  
      $self->{IRCOBJ} = POE::Component::IRC::State->spawn(
          alias => $self->{IRCNAME},
      );
      $self->{IRCOBJ}->plugin_add(
          'Connector',
          POE::Component::IRC::Plugin::Connector->new(),
      );
      $kernel->post($self->{IRCNAME}, 'register', 'all');
  
      $kernel->post(
  	$self->{IRCNAME},
  	'connect',
  	{
  	    Nick      => $self->nick,
  	    Server    => $self->server,
  	    Port      => $self->port,
  	    Password  => $self->password,
  	    UseSSL    => $self->ssl,
  	    Flood     => $self->flood,
  	    LocalAddr => $self->localaddr,
              useipv6   => $self->useipv6,
  	    $self->charset_encode(
  		Nick     => $self->nick,
  		Username => $self->username,
  		Ircname  => $self->name,
  	    ),
  	},
      );
  
      return;
  }
  
  sub die_state {
      my ($kernel, $self, $ex) = @_[KERNEL, OBJECT, ARG1];
      warn $ex->{error_str};
      $self->{IRCOBJ}->yield('shutdown');
      $kernel->sig_handled();
      return;
  }
  
  sub irc_001_state {
      my ($self, $kernel) = @_[OBJECT, KERNEL];
  
      # ignore all messages from ourselves
      $kernel->post(
          $self->{IRCNAME},
          'ignore',
          $self->charset_encode($self->nick),
      );
  
      # connect to the channel
      for my $channel ($self->channels) {
          $self->log("Trying to connect to '$channel'\n");
          $kernel->post(
              $self->{IRCNAME},
              'join',
              $self->charset_encode($channel),
          );
      }
  
      $self->schedule_tick(5);
      $self->connected();
      return;
  }
  
  sub irc_disconnected_state {
      my ($self, $kernel, $server) = @_[OBJECT, KERNEL, ARG0];
      $self->log("Lost connection to server $server.\n");
      return;
  }
  
  sub irc_error_state {
      my ($self, $err, $kernel) = @_[OBJECT, ARG0, KERNEL];
      $self->log("Server error occurred! $err\n");
      return;
  }
  
  sub irc_kicked_state {
      my ($self, $kernel, $heap, $session) = @_[OBJECT, KERNEL, HEAP, SESSION];
      my ($nickstring, $channel, $kicked, $reason) = @_[ARG0..$#_];
      my $nick = $self->nick_strip($nickstring);
      $_[OBJECT]->_remove_from_channel( $channel, $kicked );
      $self->kicked(
          {
              channel => $channel,
              who     => $nick,
              kicked  => $kicked,
              reason  => $reason,
          }
      );
      return;
  }
  
  sub irc_join_state {
      my ($self, $nick) = @_[OBJECT, ARG0];
      return;
  }
  
  sub irc_nick_state {
      my ($self, $nick, $newnick) = @_[OBJECT, ARG0, ARG1];
      $nick = $self->nick_strip($nick);
      $self->nick_change($nick, $newnick);
      return;
  }
  
  sub irc_quit_state {
      my ($self, $kernel, $session) = @_[OBJECT, KERNEL, SESSION];
      my ($nick, $message) = @_[ARG0..$#_];
  
      $nick = $self->nick_strip($nick);
      $self->userquit({ who => $nick, body => $message });
      return;
  }
  
  sub irc_said_state {
      irc_received_state( 'said', 'say', @_ );
      return;
  }
  
  sub irc_emoted_state {
      irc_received_state( 'emoted', 'emote', @_ );
      return;
  }
  
  sub irc_noticed_state {
      irc_received_state( 'noticed', 'emote', @_ );
      return;
  }
  
  sub irc_received_state {
      my $received = shift;
      my $respond  = shift;
      my ($self, $nick, $to, $body) = @_[OBJECT, ARG0, ARG1, ARG2];
  
      ($nick, $to, $body) = $self->charset_decode($nick, $to, $body);
  
      my $return;
      my $mess = {};
  
      # pass the raw body through
      $mess->{raw_body} = $body;
  
      # work out who it was from
      $mess->{who} = $self->nick_strip($nick);
      $mess->{raw_nick} = $nick;
  
      # right, get the list of places this message was
      # sent to and work out the first one that we're
      # either a memeber of is is our nick.
      # The IRC protocol allows messages to be sent to multiple
      # targets, which is pretty clever. However, noone actually
      # /does/ this, so we can get away with this:
  
      my $channel = $to->[0];
      if (lc($channel) eq lc($self->nick)) {
          $mess->{channel} = "msg";
          $mess->{address} = "msg";
      }
      else {
          $mess->{channel} = $channel;
      }
  
      # okay, work out if we're addressed or not
  
      $mess->{body} = $body;
      if ($mess->{channel} ne "msg") {
          my $own_nick = $self->nick;
  
          if ($mess->{body} =~ s/^(\Q$own_nick\E)\s*[:,-]?\s*//i) {
            $mess->{address} = $1;
          }
  
          for my $alt_nick ($self->alt_nicks) {
              last if $mess->{address};
              if ($mess->{body} =~ s/^(\Q$alt_nick\E)\s*[:,-]?\s*//i) {
                $mess->{address} = $1;
              }
          }
      }
  
      # strip off whitespace before and after the message
      $mess->{body} =~ s/^\s+//;
      $mess->{body} =~ s/\s+$//;
  
      # check if someone was asking for help
      if ($mess->{address} && $mess->{body} =~ /^help/i) {
          $mess->{body} = $self->help($mess) or return;
          $self->say($mess);
          return;
      }
  
      # okay, call the said/emoted method
      $return = $self->$received($mess);
  
      ### what did we get back?
  
      # nothing? Say nothing then
      return if !defined $return;
  
      # a string?  Say it how we were addressed then
      if (!ref $return && length $return) {
          $mess->{body} = $return;
          $self->$respond($mess);
          return;
      }
  }
  
  sub irc_chanjoin_state {
      my $self = $_[OBJECT];
      my ($channel, $nick) = @_[ ARG1, ARG0 ];
      $nick = $_[OBJECT]->nick_strip($nick);
  
      if ($self->nick eq $nick) {
        my @channels = $self->channels;
        push @channels, $channel unless grep { $_ eq $channel } @channels;
        $self->channels(\@channels);
      }
      irc_chan_received_state('chanjoin', 'say', @_);
      return;
  }
  
  sub irc_chanpart_state {
      my $self = $_[OBJECT];
      my ($channel, $nick) = @_[ ARG1, ARG0 ];
      $nick = $_[OBJECT]->nick_strip($nick);
  
      if ($self->nick eq $nick) {
        my @channels = $self->channels;
        @channels = grep { $_ ne $channel } @channels;
        $self->channels(\@channels);
      }
      irc_chan_received_state('chanpart', 'say', @_);
      return;
  }
  
  sub irc_chan_received_state {
      my $received = shift;
      my $respond  = shift;
      my ($self, $nick, $channel) = @_[OBJECT, ARG0, ARG1];
  
      my $return;
      my $mess = {};
      $mess->{who} = $self->nick_strip($nick);
  
      $mess->{channel} = $channel;
      $mess->{body} = $received; #chanjoin or chanpart
      $mess->{address} = "chan";
  
      # okay, call the chanjoin/chanpart method
      $return = $self->$received($mess);
  
      ### what did we get back?
  
      # nothing? Say nothing then
      return if !defined $return;
  
      # a string?  Say it how we were addressed then
      if (!ref $return) {
          $mess->{body} = $return;
          $self->$respond($mess);
          return;
      }
  }
  
  
  sub fork_close_state {
      my ($self, $wheel_id) = @_[OBJECT, ARG0];
      delete $self->{forks}{$wheel_id};
      return;
  }
  
  sub fork_error_state { }
  
  sub tick_state {
      my ($self, $kernel, $heap) = @_[OBJECT, KERNEL, HEAP];
      my $delay = $self->tick();
      $self->schedule_tick($delay) if $delay;
      return;
  }
  
  sub names_done_state {
      my ($self, $kernel, $server, $message) = @_[OBJECT, KERNEL, ARG0, ARG1];
      my ($channel) = split /\s/, $message;
      $self->got_names(
          {
              channel => $channel,
              names   => $self->channel_data($channel),
          }
      );
    return;
  }
  
  sub topic_raw_state {
      my ($self, $kernel, $server, $raw) = @_[OBJECT, KERNEL, ARG0, ARG1];
      my ($channel, $topic) = split / :/, $raw, 2;
      $self->topic(
          {
              channel => $channel,
              who     => undef,
              topic   => $topic,
          }
      );
      return;
  }
  
  sub topic_state {
      my ($self, $kernel, $nickraw, $channel, $topic)
          = @_[OBJECT, KERNEL, ARG0, ARG1, ARG2];
      my $nick = $self->nick_strip($nickraw);
      $self->topic(
          {
              channel => $channel,
              who     => $nick,
              topic   => $topic,
          }
      );
      return;
  }
  
  sub shutdown_state {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      $kernel->delay('tick');
      $kernel->alias_remove($self->{ALIASNAME});
      for my $fork (values %{ $self->{forks} }) {
          $fork->{wheel}->kill();
      }
      return;
  }
  
  sub AUTOLOAD {
      my $self = shift;
      our $AUTOLOAD;
      $AUTOLOAD =~ s/.*:://;
      $poe_kernel->post(
          $self->{IRCNAME},
          $AUTOLOAD,
          $self->charset_encode(@_),
      );
      return;
  }
  
  # so it won't get AUTOLOADed
  sub DESTROY { return }
  
  sub log {
      my $self = shift;
      for (@_) {
        my $log_entry = $_;
        chomp $log_entry;
        print STDERR "$log_entry\n";
      }
      return;
  }
  
  sub ignore_nick {
      local $_ = undef;
      my $self = shift;
      my $nick = shift;
      return grep { $nick eq $_ } @{ $self->{ignore_list} };
  }
  
  sub nick_strip {
      my $self = shift;
      my $combined = shift || "";
      my ($nick) = $combined =~ m/(.*?)!/;
      return $nick;
  }
  
  sub charset_decode {
      my $self = shift;
  
      my @r;
      for (@_) {
          if (ref($_) eq 'ARRAY') {
              push @r, [ $self->charset_decode(@$_) ];
          }
          elsif (ref($_) eq "HASH") {
              push @r, { $self->charset_decode(%$_) };
          }
          elsif (ref($_)) {
              die "Can't decode object $_\n";
          }
          else {
              push @r, decode_irc($_);
          }
      }
      #warn Dumper({ decoded => \@r });
      return @r;
  }
  
  sub charset_encode {
      my $self = shift;
  
      my @r;
      for (@_) {
          if (ref($_) eq 'ARRAY') {
              push @r, [ $self->charset_encode(@$_) ];
          }
          elsif (ref($_) eq "HASH") {
              push @r, { $self->charset_encode(%$_) };
          }
          elsif (ref($_)) {
              die "Can't encode object $_\n";
          }
          else {
              push @r, encode($self->charset, $_);
          }
      }
      #warn Dumper({ encoded => \@r });
      return @r;
  }
  
  1;
  
  =head1 NAME
  
  Bot::BasicBot - simple irc bot baseclass
  
  =head1 SYNOPSIS
  
    # with all defaults
    my $bot = Bot::BasicBot->new( channels => ["#bottest"] );
    $bot->run();
  
    # with all known options
    my $bot = Bot::BasicBot->new(
  
      server => "irc.example.com",
      port   => "6667",
      channels => ["#bottest"],
  
      nick      => "basicbot",
      alt_nicks => ["bbot", "simplebot"],
      username  => "bot",
      name      => "Yet Another Bot",
  
      ignore_list => [qw(dipsy dadadodo laotse)],
  
    );
    $bot->run();
  
  
  =head1 DESCRIPTION
  
  Basic bot system designed to make it easy to do simple bots, optionally
  forking longer processes (like searches) concurrently in the background.
  
  There are several examples of bots using Bot::BasicBot in the examples/
  folder in the Bot::BasicBot tarball.
  
  A quick summary, though - You want to define your own package that
  subclasses Bot::BasicBot, override various methods (documented below),
  then call L<C<new>|/new> and L<C<run>|/run> on it.
  
  =head1 STARTING THE BOT
  
  =head2 C<new>
  
  Creates a new instance of the class. Key/value pairs may be passed
  which will have the same effect as calling the method of that name
  with the value supplied. Returns a Bot::BasicBot object, that you can
  call 'run' on later.
  
  eg:
  
    my $bot = Bot::BasicBot->new( nick => 'superbot', channels => [ '#superheroes' ] );
  
  =head2 C<run>
  
  Runs the bot.  Hands the control over to the POE core.
  
  =head1 STOPPING THE BOT
  
  To shut down the bot cleanly, use the L<C<shutdown>|/shutdown> method,
  which will (through L<C<AUTOLOAD>|/AUTOLOAD>) send an
  L<event|POE::Component::IRC/shutdown> of the same name to
  POE::Component::IRC, so it takes the same arguments:
  
   $bot->shutdown( $bot->quit_message() );
  
  =head1 METHODS TO OVERRIDE
  
  In your Bot::BasicBot subclass, you want to override some of the following
  methods to define how your bot works. These are all object methods - the
  (implicit) first parameter to all of them will be the bot object.
  
  =head2 C<init>
  
  called when the bot is created, as part of new(). Override to provide
  your own init. Return a true value for a successful init, or undef if
  you failed, in which case new() will die.
  
  =head2 C<said>
  
  This is the main method that you'll want to override in your subclass -
  it's the one called by default whenever someone says anything that we
  can hear, either in a public channel or to us in private that we
  shouldn't ignore.
  
  You'll be passed a hashref that contains the arguments described below. 
  Feel free to alter the values of this hash - it won't be used later on.
  
  =over 4
  
  =item who
  
  Who said it (the nick that said it)
  
  =item raw_nick
  
  The raw IRC nick string of the person who said it. Only really useful
  if you want more security for some reason.
  
  =item channel
  
  The channel in which they said it.  Has special value "msg" if it was in
  a message.  Actually, you can send a message to many channels at once in
  the IRC spec, but no-one actually does this so this is just the first
  one in the list.
  
  =item body
  
  The body of the message (i.e. the actual text)
  
  =item address
  
  The text that indicates how we were addressed.  Contains the string
  "msg" for private messages, otherwise contains the string off the text
  that was stripped off the front of the message if we were addressed,
  e.g. "Nick: ".  Obviously this can be simply checked for truth if you
  just want to know if you were addressed or not.
  
  =back
  
  You should return what you want to say.  This can either be a simple
  string (which will be sent back to whoever was talking to you as a
  message or in public depending on how they were talking) or a hashref
  that contains values that are compatible with say (just changing
  the body and returning the structure you were passed works very well.)
  
  Returning undef will cause nothing to be said.
  
  =head2 C<emoted>
  
  This is a secondary method that you may wish to override. It gets called
  when someone in channel 'emotes', instead of talking. In its default
  configuration, it will simply pass anything emoted on channel through to
  the C<said> handler.
  
  C<emoted> receives the same data hash as C<said>.
  
  =head2 C<noticed>
  
  This is like C<said>, except for notices instead of normal messages.
  
  =head2 C<chanjoin>
  
  Called when someone joins a channel. It receives a hashref argument
  similar to the one received by said(). The key 'who' is the nick of the
  user who joined, while 'channel' is the channel they joined.
  
  This is a do-nothing implementation, override this in your subclass.
  
  =head2 C<chanpart>
  
  Called when someone joins a channel. It receives a hashref argument
  similar to the one received by said(). The key 'who' is the nick of the
  user who parted, while 'channel' is the channel they parted.
  
  This is a do-nothing implementation, override this in your subclass.
  
  =head2 C<got_names>
  
  Whenever we have been given a definitive list of 'who is in the channel',
  this function will be called. It receives a hash reference as an argument.
  The key 'channel' will be the channel we have information for, 'names' is a
  hashref where the keys are the nicks of the users, and the values are more
  hashes, containing the two keys 'op' and 'voice', indicating if the user is
  a chanop or voiced respectively.
  
  The reply value is ignored.
  
  Normally, I wouldn't override this method - instead, just use the L<names>
  call when you want to know who's in the channel. Override this only if you
  want to be able to do something as soon as possible. Also be aware that
  the names list can be changed by other events - kicks, joins, etc, and this
  method won't be called when that happens.
  
  =head2 C<topic>
  
  Called when the topic of the channel changes. It receives a hashref
  argument. The key 'channel' is the channel the topic was set in, and 'who'
  is the nick of the user who changed the channel, 'topic' will be the new
  topic of the channel.
  
  =head2 C<nick_change>
  
  When a user changes nicks, this will be called. It receives two arguments:
  the old nickname and the new nickname.
  
  =head2 C<kicked>
  
  Called when a user is kicked from the channel. It receives a hashref which
  will look like this:
  
    {
      channel => "#channel",
      who => "nick",
      kicked => "kicked",
      reason => "reason",
    }
  
  The reply value is ignored.
  
  =head2 C<tick>
  
  This is an event called every regularly. The function should return the
  amount of time until the tick event should next be called. The default
  tick is called 5 seconds after the bot starts, and the default
  implementation returns '0', which disables the tick. Override this and
  return non-zero values to have an ongoing tick event.
  
  Use this function if you want the bot to do something periodically, and
  don't want to mess with 'real' POE things.
  
  Call the L<schedule_tick> event to schedule a tick event without waiting
  for the next tick.
  
  =head2 C<help>
  
  This is the other method that you should override.  This is the text
  that the bot will respond to if someone simply says help to it.  This
  should be considered a special case which you should not attempt to
  process yourself.  Saying help to a bot should have no side effects
  whatsoever apart from returning this text.
  
  =head2 C<connected>
  
  An optional method to override, gets called after we have connected
  to the server
  
  =head2 C<userquit>
  
  Receives a hashref which will look like:
  
      {
        who => "nick that quit",
        body => "quit message",
      }
  
  =head1 BOT METHODS
  
  There are a few methods you can call on the bot object to do things. These
  are as follows:
  
  =head2 C<schedule_tick>
  
  Takes an integer as an argument. Causes the L<tick> event to be called
  after that many seconds (or 5 seconds if no argument is provided). Note
  that if the tick event is due to be called already, this will override it.
  You can't schedule multiple future events with this funtction.
  
  =head2 C<forkit>
  
  This method allows you to fork arbitrary background processes. They
  will run concurrently with the main bot, returning their output to a
  handler routine. You should call C<forkit> in response to specific
  events in your C<said> routine, particularly for longer running
  processes like searches, which will block the bot from receiving or
  sending on channel whilst they take place if you don't fork them.
  
  Inside the subroutine called by forkit, you can send output back to the
  channel by printing lines (followd by C<\n>) to STDOUT. This has the same
  effect as calling L<C<< Bot::BasicBot->say >>|say>.
  
  C<forkit> takes the following arguments:
  
  =over 4
  
  =item run
  
  A coderef to the routine which you want to run. Bear in mind that the
  routine doesn't automatically get the text of the query - you'll need
  to pass it in C<arguments> (see below) if you want to use it at all.
  
  Apart from that, your C<run> routine just needs to print its output to
  C<STDOUT>, and it will be passed on to your designated handler.
  
  =item handler
  
  Optional. A method name within your current package which we can
  return the routine's data to. Defaults to the built-in method
  C<say_fork_return> (which simply sends data to channel).
  
  =item callback
  
  Optional. A coderef to execute in place of the handler. If used, the value
  of the handler argument is used to name the POE event. This allows using
  closures and/or having multiple simultanious calls to forkit with unique
  handler for each call.
  
  =item body
  
  Optional. Use this to pass on the body of the incoming message that
  triggered you to fork this process. Useful for interactive proceses
  such as searches, so that you can act on specific terms in the user's
  instructions.
  
  =item who
  
  The nick of who you want any response to reach (optional inside a
  channel.)
  
  =item channel
  
  Where you want to say it to them in.  This may be the special channel
  "msg" if you want to speak to them directly
  
  =item address
  
  Optional.  Setting this to a true value causes the person to be
  addressed (i.e. to have "Nick: " prepended to the front of returned
  message text if the response is going to a public forum.
  
  =item arguments
  
  Optional. This should be an anonymous array of values, which will be
  passed to your C<run> routine. Bear in mind that this is not
  intelligent - it will blindly spew arguments at C<run> in the order
  that you specify them, and it is the responsibility of your C<run>
  routine to pick them up and make sense of them.
  
  =back
  
  =head2 C<say>
  
  Say something to someone. Takes a list of key/value pairs as arguments.
  You should pass the following arguments:
  
  =over 4
  
  =item who
  
  The nick of who you are saying this to (optional inside a channel.)
  
  =item channel
  
  Where you want to say it to them in.  This may be the special channel
  "msg" if you want to speak to them directly
  
  =item body
  
  The body of the message.  I.e. what you want to say.
  
  =item address
  
  Optional.  Setting this to a true value causes the person to be
  addressed (i.e. to have "Nick: " prepended to the front of the message
  text if this message is going to a pulbic forum.
  
  =back
  
  You can also make non-OO calls to C<say>, which will be interpreted as
  coming from a process spawned by C<forkit>. The routine will serialise
  any data it is sent, and throw it to STDOUT, where L<POE::Wheel::Run> can
  pass it on to a handler.
  
  =head2 C<emote>
  
  C<emote> will return data to channel, but emoted (as if you'd said "/me
  writes a spiffy new bot" in most clients). It takes the same arguments
  as C<say>, listed above.
  
  =head2 C<notice>
  
  C<notice> will send a IRC notice to the channel. This is typically used by
  bots to not break the IRC conversations flow. The message will appear as:
  
      -nick- message here
  
  It takes the same arguments as C<say>, listed above. Example:
  
      $bot->notice(
          channel => '#bot_basicbot_test',
          body => 'This is a notice'
      );
  
  =head2 C<reply>
  
  Takes two arguments, a hashref containing information about an incoming
  message, and a reply message. It will reply in a privmsg if the incoming
  one was a privmsg, in channel if not, and with prefixes if the incoming
  one was prefixed. Mostly a shortcut method - it's roughly equivalent to
  
   $mess->{body} = $body;
   $self->say($mess);
  
  =head2 C<pocoirc>
  
  Takes no arguments. Returns the underlying
  L<POE::Component::IRC::State|POE::Component::IRC::State> object used by
  Bot::BasicBot.
  
  =head2 C<channel_data>
  
  Takes a channel names as a parameter, and returns a hash of hashes. The
  keys are the nicknames in the channel, the values are hashes containing
  the keys "voice" and "op", indicating whether these users are voiced or
  opped in the channel. This method is only here for backwards compatability.
  You'll probably get more use out of
  L<POE::Component::IRC::State|POE::Component::IRC::State>'s methods (which
  this method is merely a wrapper for). You can access the
  POE::Component::IRC::State object through Bot::BasicBot's C<pocoirc>
  method.
  
  =head1 ATTRIBUTES
  
  Get or set methods.  Changing most of these values when connected
  won't cause sideffects.  e.g. changing the server will not
  cause a disconnect and a reconnect to another server.
  
  Attributes that accept multiple values always return lists and
  either accept an arrayref or a complete list as an argument.
  
  The usual way of calling these is as keys to the hash passed to the
  'new' method.
  
  =head2 C<server>
  
  The server we're going to connect to.  Defaults to
  "irc.perl.org".
  
  =head2 C<port>
  
  The port we're going to use.  Defaults to "6667"
  
  =head2 C<password>
  
  The server password for the server we're going to connect to.  Defaults to
  undef.
  
  =head2 C<ssl>
  
  A boolean to indicate whether or not the server we're going to connect to
  is an SSL server.  Defaults to 0.
  
  =head2 C<localaddr>
  
  The local address to use, for multihomed boxes.  Defaults to undef (use whatever
  source IP address the system deigns is appropriate).
  
  =head C<useipv6>
  
  A boolean to indicate whether IPv6 should be used.  Defaults to undef (use
  IPv4).
  
  =head2 C<nick>
  
  The nick we're going to use.  Defaults to five random letters
  and numbers followed by the word "bot"
  
  =head2 C<alt_nicks>
  
  Alternate nicks that this bot will be known by.  These are not nicks
  that the bot will try if it's main nick is taken, but rather other
  nicks that the bot will recognise if it is addressed in a public
  channel as the nick.  This is useful for bots that are replacements
  for other bots...e.g, your bot can answer to the name "infobot: "
  even though it isn't really.
  
  =head2 C<username>
  
  The username we'll claim to have at our ip/domain.  By default this
  will be the same as our nick.
  
  =head2 C<name>
  
  The name that the bot will identify itself as.  Defaults to
  "$nick bot" where $nick is the nick that the bot uses.
  
  =head2 C<channels>
  
  The channels we're going to connect to.
  
  =head2 C<quit_message>
  
  The quit message.  Defaults to "Bye".
  
  =head2 C<ignore_list>
  
  The list of irc nicks to ignore B<public> messages from (normally
  other bots.)  Useful for stopping bot cascades.
  
  =head2 C<charset>
  
  IRC has no defined character set for putting high-bit chars into channel.
  This attribute sets the encoding to be used for outgoing messages. Defaults
  to 'utf8'.
  
  =head2 C<flood>
  
  Set to '1' to disable the built-in flood protection of POE::Compoent::IRC
  
  =head2 C<no_run>
  
  Tells Bot::BasicBot to B<not> run the L<POE kernel|POE::Kernel> at the end
  of L<C<run>|/run>, in case you want to do that yourself.
  
  =head1 OTHER METHODS
  
  =head2 C<AUTOLOAD>
  
  Bot::BasicBot implements AUTOLOAD for sending arbitrary states to the
  underlying L<POE::Component::IRC|POE::Component::IRC> component. So for a
  C<$bot> object, sending
  
      $bot->foo("bar");
  
  is equivalent to
  
      $poe_kernel->post(BASICBOT_ALIAS, "foo", "bar");
  
  =head2 C<log>
  
  Logs the message. This method merely prints to STDERR - If you want smarter
  logging, override this method - it will have simple text strings passed in
  @_.
  
  =head2 C<ignore_nick>
  
  Takes a nick name as an argument. Return true if this nick should be
  ignored. Ignores anything in the ignore list
  
  =head2 C<nick_strip>
  
  Takes a nick and hostname (of the form "nick!hostname") and
  returns just the nick
  
  =head2 C<charset_decode>
  
  Converts a string of bytes from IRC (uses
  L<C<decode_irc>|IRC::Utils/decode_irc> from L<IRC::Utils|IRC::Utils>
  internally) and returns a Perl string.
  
  It can also takes a list (or arrayref or hashref) of strings, and return
  a list of strings
  
  =head2 C<charset_encode>
  
  Converts a list of perl strings into a list of byte sequences, using
  the bot's charset. See L<charset_decode>.
  
  =head1 HELP AND SUPPORT
  
  If you have any questions or issues, you can drop by in #poe @
  irc.perl.org, where I (Hinrik) am usually around.
  
  =head1 AUTHOR
  
  Tom Insam E<lt>tom@jerakeen.orgE<gt>
  
  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =head1 CREDITS
  
  The initial version of Bot::BasicBot was written by Mark Fowler,
  and many thanks are due to him.
  
  Nice code for dealing with emotes thanks to Jo Walsh.
  
  Various patches from Tom Insam, including much improved rejoining,
  AUTOLOAD stuff, better interactive help, and a few API tidies.
  
  Maintainership for a while was in the hands of Simon Kent
  E<lt>simon@hitherto.netE<gt>. Don't know what he did. :-)
  
  I (Tom Insam) recieved patches for tracking joins and parts from Silver,
  sat on them for two months, and have finally applied them. Thanks, dude.
  He also sent me changes for the tick event API, which made sense.
  
  In November 2010, maintainership moved to Hinrik E<Ouml>rn
  SigurE<eth>sson (L<hinrik.sig@gmail.com>).
  
  =head1 SEE ALSO
  
  L<POE>, L<POE::Component::IRC>
  
  Possibly Infobot, at http://www.infobot.org
  
  =cut
BOT_BASICBOT

$fatpacked{"HTTP/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_CONFIG';
  package HTTP::Config;
  
  use strict;
  use URI;
  use vars qw($VERSION);
  
  $VERSION = "6.00";
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub entries {
      my $self = shift;
      @$self;
  }
  
  sub empty {
      my $self = shift;
      not @$self;
  }
  
  sub add {
      if (@_ == 2) {
          my $self = shift;
          push(@$self, shift);
          return;
      }
      my($self, %spec) = @_;
      push(@$self, \%spec);
      return;
  }
  
  sub find2 {
      my($self, %spec) = @_;
      my @found;
      my @rest;
   ITEM:
      for my $item (@$self) {
          for my $k (keys %spec) {
              if (!exists $item->{$k} || $spec{$k} ne $item->{$k}) {
                  push(@rest, $item);
                  next ITEM;
              }
          }
          push(@found, $item);
      }
      return \@found unless wantarray;
      return \@found, \@rest;
  }
  
  sub find {
      my $self = shift;
      my $f = $self->find2(@_);
      return @$f if wantarray;
      return $f->[0];
  }
  
  sub remove {
      my($self, %spec) = @_;
      my($removed, $rest) = $self->find2(%spec);
      @$self = @$rest if @$removed;
      return @$removed;
  }
  
  my %MATCH = (
      m_scheme => sub {
          my($v, $uri) = @_;
          return $uri->_scheme eq $v;  # URI known to be canonical
      },
      m_secure => sub {
          my($v, $uri) = @_;
          my $secure = $uri->can("secure") ? $uri->secure : $uri->_scheme eq "https";
          return $secure == !!$v;
      },
      m_host_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host_port");
          return $uri->host_port eq $v, 7;
      },
      m_host => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          return $uri->host eq $v, 6;
      },
      m_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("port");
          return $uri->port eq $v;
      },
      m_domain => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          my $h = $uri->host;
          $h = "$h.local" unless $h =~ /\./;
          $v = ".$v" unless $v =~ /^\./;
          return length($v), 5 if substr($h, -length($v)) eq $v;
          return 0;
      },
      m_path => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path eq $v, 4;
      },
      m_path_prefix => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          my $path = $uri->path;
          my $len = length($v);
          return $len, 3 if $path eq $v;
          return 0 if length($path) <= $len;
          $v .= "/" unless $v =~ m,/\z,,;
          return $len, 3 if substr($path, 0, length($v)) eq $v;
          return 0;
      },
      m_path_match => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path =~ $v;
      },
      m_uri__ => sub {
          my($v, $k, $uri) = @_;
          return unless $uri->can($k);
          return 1 unless defined $v;
          return $uri->$k eq $v;
      },
      m_method => sub {
          my($v, $uri, $request) = @_;
          return $request && $request->method eq $v;
      },
      m_proxy => sub {
          my($v, $uri, $request) = @_;
          return $request && ($request->{proxy} || "") eq $v;
      },
      m_code => sub {
          my($v, $uri, $request, $response) = @_;
          $v =~ s/xx\z//;
          return unless $response;
          return length($v), 2 if substr($response->code, 0, length($v)) eq $v;
      },
      m_media_type => sub {  # for request too??
          my($v, $uri, $request, $response) = @_;
          return unless $response;
          return 1, 1 if $v eq "*/*";
          my $ct = $response->content_type;
          return 2, 1 if $v =~ s,/\*\z,, && $ct =~ m,^\Q$v\E/,;
          return 3, 1 if $v eq "html" && $response->content_is_html;
          return 4, 1 if $v eq "xhtml" && $response->content_is_xhtml;
          return 10, 1 if $v eq $ct;
          return 0;
      },
      m_header__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $request;
          return 1 if $request->header($k) eq $v;
          return 1 if $response && $response->header($k) eq $v;
          return 0;
      },
      m_response_attr__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $response;
          return 1 if !defined($v) && exists $response->{$k};
          return 0 unless exists $response->{$k};
          return 1 if $response->{$k} eq $v;
          return 0;
      },
  );
  
  sub matching {
      my $self = shift;
      if (@_ == 1) {
          if ($_[0]->can("request")) {
              unshift(@_, $_[0]->request);
              unshift(@_, undef) unless defined $_[0];
          }
          unshift(@_, $_[0]->uri_canonical) if $_[0] && $_[0]->can("uri_canonical");
      }
      my($uri, $request, $response) = @_;
      $uri = URI->new($uri) unless ref($uri);
  
      my @m;
   ITEM:
      for my $item (@$self) {
          my $order;
          for my $ikey (keys %$item) {
              my $mkey = $ikey;
              my $k;
              $k = $1 if $mkey =~ s/__(.*)/__/;
              if (my $m = $MATCH{$mkey}) {
                  #print "$ikey $mkey\n";
                  my($c, $o);
                  my @arg = (
                      defined($k) ? $k : (),
                      $uri, $request, $response
                  );
                  my $v = $item->{$ikey};
                  $v = [$v] unless ref($v) eq "ARRAY";
                  for (@$v) {
                      ($c, $o) = $m->($_, @arg);
                      #print "  - $_ ==> $c $o\n";
                      last if $c;
                  }
                  next ITEM unless $c;
                  $order->[$o || 0] += $c;
              }
          }
          $order->[7] ||= 0;
          $item->{_order} = join(".", reverse map sprintf("%03d", $_ || 0), @$order);
          push(@m, $item);
      }
      @m = sort { $b->{_order} cmp $a->{_order} } @m;
      delete $_->{_order} for @m;
      return @m if wantarray;
      return $m[0];
  }
  
  sub add_item {
      my $self = shift;
      my $item = shift;
      return $self->add(item => $item, @_);
  }
  
  sub remove_items {
      my $self = shift;
      return map $_->{item}, $self->remove(@_);
  }
  
  sub matching_items {
      my $self = shift;
      return map $_->{item}, $self->matching(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Config - Configuration for request and response objects
  
  =head1 SYNOPSIS
  
   use HTTP::Config;
   my $c = HTTP::Config->new;
   $c->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
   
   use HTTP::Request;
   my $request = HTTP::Request->new(GET => "http://www.example.com");
   
   if (my @m = $c->matching($request)) {
      print "Yadayada\n" if $m[0]->{verbose};
   }
  
  =head1 DESCRIPTION
  
  An C<HTTP::Config> object is a list of entries that
  can be matched against request or request/response pairs.  Its
  purpose is to hold configuration data that can be looked up given a
  request or response object.
  
  Each configuration entry is a hash.  Some keys specify matching to
  occur against attributes of request/response objects.  Other keys can
  be used to hold user data.
  
  The following methods are provided:
  
  =over 4
  
  =item $conf = HTTP::Config->new
  
  Constructs a new empty C<HTTP::Config> object and returns it.
  
  =item $conf->entries
  
  Returns the list of entries in the configuration object.
  In scalar context returns the number of entries.
  
  =item $conf->empty
  
  Return true if there are no entries in the configuration object.
  This is just a shorthand for C<< not $conf->entries >>.
  
  =item $conf->add( %matchspec, %other )
  
  =item $conf->add( \%entry )
  
  Adds a new entry to the configuration.
  You can either pass separate key/value pairs or a hash reference.
  
  =item $conf->remove( %spec )
  
  Removes (and returns) the entries that have matches for all the key/value pairs in %spec.
  If %spec is empty this will match all entries; so it will empty the configuation object.
  
  =item $conf->matching( $uri, $request, $response )
  
  =item $conf->matching( $uri )
  
  =item $conf->matching( $request )
  
  =item $conf->matching( $response )
  
  Returns the entries that match the given $uri, $request and $response triplet.
  
  If called with a single $request object then the $uri is obtained by calling its 'uri_canonical' method.
  If called with a single $response object, then the request object is obtained by calling its 'request' method;
  and then the $uri is obtained as if a single $request was provided.
  
  The entries are returned with the most specific matches first.
  In scalar context returns the most specific match or C<undef> in none match.
  
  =item $conf->add_item( $item, %matchspec )
  
  =item $conf->remove_items( %spec )
  
  =item $conf->matching_items( $uri, $request, $response )
  
  Wrappers that hides the entries themselves.
  
  =back
  
  =head2 Matching
  
  The following keys on a configuration entry specify matching.  For all
  of these you can provide an array of values instead of a single value.
  The entry matches if at least one of the values in the array matches.
  
  Entries that require match against a response object attribute will never match
  unless a response object was provided.
  
  =over
  
  =item m_scheme => $scheme
  
  Matches if the URI uses the specified scheme; e.g. "http".
  
  =item m_secure => $bool
  
  If $bool is TRUE; matches if the URI uses a secure scheme.  If $bool
  is FALSE; matches if the URI does not use a secure scheme.  An example
  of a secure scheme is "https".
  
  =item m_host_port => "$hostname:$port"
  
  Matches if the URI's host_port method return the specified value.
  
  =item m_host => $hostname
  
  Matches if the URI's host method returns the specified value.
  
  =item m_port => $port
  
  Matches if the URI's port method returns the specified value.
  
  =item m_domain => ".$domain"
  
  Matches if the URI's host method return a value that within the given
  domain.  The hostname "www.example.com" will for instance match the
  domain ".com".
  
  =item m_path => $path
  
  Matches if the URI's path method returns the specified value.
  
  =item m_path_prefix => $path
  
  Matches if the URI's path is the specified path or has the specified
  path as prefix.
  
  =item m_path_match => $Regexp
  
  Matches if the regular expression matches the URI's path.  Eg. qr/\.html$/.
  
  =item m_method => $method
  
  Matches if the request method matches the specified value. Eg. "GET" or "POST".
  
  =item m_code => $digit
  
  =item m_code => $status_code
  
  Matches if the response status code matches.  If a single digit is
  specified; matches for all response status codes beginning with that digit.
  
  =item m_proxy => $url
  
  Matches if the request is to be sent to the given Proxy server.
  
  =item m_media_type => "*/*"
  
  =item m_media_type => "text/*"
  
  =item m_media_type => "html"
  
  =item m_media_type => "xhtml"
  
  =item m_media_type => "text/html"
  
  Matches if the response media type matches.
  
  With a value of "html" matches if $response->content_is_html returns TRUE.
  With a value of "xhtml" matches if $response->content_is_xhtml returns TRUE.
  
  =item m_uri__I<$method> => undef
  
  Matches if the URI object provides the method.
  
  =item m_uri__I<$method> => $string
  
  Matches if the URI's $method method returns the given value.
  
  =item m_header__I<$field> => $string
  
  Matches if either the request or the response have a header $field with the given value.
  
  =item m_response_attr__I<$key> => undef
  
  =item m_response_attr__I<$key> => $string
  
  Matches if the response object has that key, or the entry has the given value.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<HTTP::Request>, L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 2008, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_CONFIG

$fatpacked{"HTTP/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_DATE';
  package HTTP::Date;
  
  $VERSION = "6.02";
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(time2str str2time);
  @EXPORT_OK = qw(parse_date time2iso time2isoz);
  
  use strict;
  require Time::Local;
  
  use vars qw(@DoW @MoY %MoY);
  @DoW = qw(Sun Mon Tue Wed Thu Fri Sat);
  @MoY = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  @MoY{@MoY} = (1..12);
  
  my %GMT_ZONE = (GMT => 1, UTC => 1, UT => 1, Z => 1);
  
  
  sub time2str (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($time);
      sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
  	    $DoW[$wday],
  	    $mday, $MoY[$mon], $year+1900,
  	    $hour, $min, $sec);
  }
  
  
  sub str2time ($;$)
  {
      my $str = shift;
      return undef unless defined $str;
  
      # fast exit for strictly conforming string
      if ($str =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/) {
  	return eval {
  	    my $t = Time::Local::timegm($6, $5, $4, $1, $MoY{$2}-1, $3);
  	    $t < 0 ? undef : $t;
  	};
      }
  
      my @d = parse_date($str);
      return undef unless @d;
      $d[1]--;        # month
  
      my $tz = pop(@d);
      unless (defined $tz) {
  	unless (defined($tz = shift)) {
  	    return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  			  my $t = Time::Local::timelocal(reverse @d) + $frac;
  			  $t < 0 ? undef : $t;
  		        };
  	}
      }
  
      my $offset = 0;
      if ($GMT_ZONE{uc $tz}) {
  	# offset already zero
      }
      elsif ($tz =~ /^([-+])?(\d\d?):?(\d\d)?$/) {
  	$offset = 3600 * $2;
  	$offset += 60 * $3 if $3;
  	$offset *= -1 if $1 && $1 eq '-';
      }
      else {
  	eval { require Time::Zone } || return undef;
  	$offset = Time::Zone::tz_offset($tz);
  	return undef unless defined $offset;
      }
  
      return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  		  my $t = Time::Local::timegm(reverse @d) + $frac;
  		  $t < 0 ? undef : $t - $offset;
  		};
  }
  
  
  sub parse_date ($)
  {
      local($_) = shift;
      return unless defined;
  
      # More lax parsing below
      s/^\s+//;  # kill leading space
      s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i; # Useless weekday
  
      my($day, $mon, $yr, $hr, $min, $sec, $tz, $ampm);
  
      # Then we are able to check for most of the formats with this regexp
      (($day,$mon,$yr,$hr,$min,$sec,$tz) =
          /^
  	 (\d\d?)               # day
  	    (?:\s+|[-\/])
  	 (\w+)                 # month
  	    (?:\s+|[-\/])
  	 (\d+)                 # year
  	 (?:
  	       (?:\s+|:)       # separator before clock
  	    (\d\d?):(\d\d)     # hour:min
  	    (?::(\d\d))?       # optional seconds
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
  	    \s*
  	 (?:\(\w+\)|\w{3,})?   # ASCII representation of timezone.
  	    \s*$
  	/x)
  
      ||
  
      # Try the ctime and asctime format
      (($mon, $day, $hr, $min, $sec, $tz, $yr) =
  	/^
  	 (\w{1,3})             # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (\d\d?):(\d\d)        # hour:min
  	 (?::(\d\d))?          # optional seconds
  	    \s+
  	 (?:([A-Za-z]+)\s+)?   # optional timezone
  	 (\d+)                 # year
  	    \s*$               # allow trailing whitespace
  	/x)
  
      ||
  
      # Then the Unix 'ls -l' date format
      (($mon, $day, $yr, $hr, $min, $sec) =
  	/^
  	 (\w{3})               # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (?:
  	    (\d\d\d\d) |       # year
  	    (\d{1,2}):(\d{2})  # hour:min
              (?::(\d\d))?       # optional seconds
  	 )
  	 \s*$
         /x)
  
      ||
  
      # ISO 8601 format '1996-02-29 12:00:00 -0100' and variants
      (($yr, $mon, $day, $hr, $min, $sec, $tz) =
  	/^
  	  (\d{4})              # year
  	     [-\/]?
  	  (\d\d?)              # numerical month
  	     [-\/]?
  	  (\d\d?)              # day
  	 (?:
  	       (?:\s+|[-:Tt])  # separator before clock
  	    (\d\d?):?(\d\d)    # hour:min
  	    (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d\d?:?(:?\d\d)?
  	  |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
  	    \s*$
  	/x)
  
      ||
  
      # Windows 'dir' 11-12-96  03:52PM
      (($mon, $day, $yr, $hr, $min, $ampm) =
          /^
            (\d{2})                # numerical month
               -
            (\d{2})                # day
               -
            (\d{2})                # year
               \s+
            (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
               \s*$
          /x)
  
      ||
      return;  # unrecognized format
  
      # Translate month name to number
      $mon = $MoY{$mon} ||
             $MoY{"\u\L$mon"} ||
  	   ($mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon)) ||
             return;
  
      # If the year is missing, we assume first date before the current,
      # because of the formats we support such dates are mostly present
      # on "ls -l" listings.
      unless (defined $yr) {
  	my $cur_mon;
  	($cur_mon, $yr) = (localtime)[4, 5];
  	$yr += 1900;
  	$cur_mon++;
  	$yr-- if $mon > $cur_mon;
      }
      elsif (length($yr) < 3) {
  	# Find "obvious" year
  	my $cur_yr = (localtime)[5] + 1900;
  	my $m = $cur_yr % 100;
  	my $tmp = $yr;
  	$yr += $cur_yr - $m;
  	$m -= $tmp;
  	$yr += ($m > 0) ? 100 : -100
  	    if abs($m) > 50;
      }
  
      # Make sure clock elements are defined
      $hr  = 0 unless defined($hr);
      $min = 0 unless defined($min);
      $sec = 0 unless defined($sec);
  
      # Compensate for AM/PM
      if ($ampm) {
  	$ampm = uc $ampm;
  	$hr = 0 if $hr == 12 && $ampm eq 'AM';
  	$hr += 12 if $ampm eq 'PM' && $hr != 12;
      }
  
      return($yr, $mon, $day, $hr, $min, $sec, $tz)
  	if wantarray;
  
      if (defined $tz) {
  	$tz = "Z" if $tz =~ /^(GMT|UTC?|[-+]?0+)$/;
      }
      else {
  	$tz = "";
      }
      return sprintf("%04d-%02d-%02d %02d:%02d:%02d%s",
  		   $yr, $mon, $day, $hr, $min, $sec, $tz);
  }
  
  
  sub time2iso (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = localtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02d",
  	    $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  
  sub time2isoz (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = gmtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02dZ",
              $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Date - date conversion routines
  
  =head1 SYNOPSIS
  
   use HTTP::Date;
  
   $string = time2str($time);    # Format as GMT ASCII time
   $time = str2time($string);    # convert ASCII date to machine time
  
  =head1 DESCRIPTION
  
  This module provides functions that deal the date formats used by the
  HTTP protocol (and then some more).  Only the first two functions,
  time2str() and str2time(), are exported by default.
  
  =over 4
  
  =item time2str( [$time] )
  
  The time2str() function converts a machine time (seconds since epoch)
  to a string.  If the function is called without an argument or with an
  undefined argument, it will use the current time.
  
  The string returned is in the format preferred for the HTTP protocol.
  This is a fixed length subset of the format defined by RFC 1123,
  represented in Universal Time (GMT).  An example of a time stamp
  in this format is:
  
     Sun, 06 Nov 1994 08:49:37 GMT
  
  =item str2time( $str [, $zone] )
  
  The str2time() function converts a string to machine time.  It returns
  C<undef> if the format of $str is unrecognized, otherwise whatever the
  C<Time::Local> functions can make out of the parsed time.  Dates
  before the system's epoch may not work on all operating systems.  The
  time formats recognized are the same as for parse_date().
  
  The function also takes an optional second argument that specifies the
  default time zone to use when converting the date.  This parameter is
  ignored if the zone is found in the date string itself.  If this
  parameter is missing, and the date string format does not contain any
  zone specification, then the local time zone is assumed.
  
  If the zone is not "C<GMT>" or numerical (like "C<-0800>" or
  "C<+0100>"), then the C<Time::Zone> module must be installed in order
  to get the date recognized.
  
  =item parse_date( $str )
  
  This function will try to parse a date string, and then return it as a
  list of numerical values followed by a (possible undefined) time zone
  specifier; ($year, $month, $day, $hour, $min, $sec, $tz).  The $year
  will be the full 4-digit year, and $month numbers start with 1 (for January).
  
  In scalar context the numbers are interpolated in a string of the
  "YYYY-MM-DD hh:mm:ss TZ"-format and returned.
  
  If the date is unrecognized, then the empty list is returned (C<undef> in
  scalar context).
  
  The function is able to parse the following formats:
  
   "Wed, 09 Feb 1994 22:23:32 GMT"       -- HTTP format
   "Thu Feb  3 17:03:55 GMT 1994"        -- ctime(3) format
   "Thu Feb  3 00:00:00 1994",           -- ANSI C asctime() format
   "Tuesday, 08-Feb-94 14:15:29 GMT"     -- old rfc850 HTTP format
   "Tuesday, 08-Feb-1994 14:15:29 GMT"   -- broken rfc850 HTTP format
  
   "03/Feb/1994:17:03:55 -0700"   -- common logfile format
   "09 Feb 1994 22:23:32 GMT"     -- HTTP format (no weekday)
   "08-Feb-94 14:15:29 GMT"       -- rfc850 format (no weekday)
   "08-Feb-1994 14:15:29 GMT"     -- broken rfc850 format (no weekday)
  
   "1994-02-03 14:15:29 -0100"    -- ISO 8601 format
   "1994-02-03 14:15:29"          -- zone is optional
   "1994-02-03"                   -- only date
   "1994-02-03T14:15:29"          -- Use T as separator
   "19940203T141529Z"             -- ISO 8601 compact format
   "19940203"                     -- only date
  
   "08-Feb-94"         -- old rfc850 HTTP format    (no weekday, no time)
   "08-Feb-1994"       -- broken rfc850 HTTP format (no weekday, no time)
   "09 Feb 1994"       -- proposed new HTTP format  (no weekday, no time)
   "03/Feb/1994"       -- common logfile format     (no time, no offset)
  
   "Feb  3  1994"      -- Unix 'ls -l' format
   "Feb  3 17:03"      -- Unix 'ls -l' format
  
   "11-15-96  03:52PM" -- Windows 'dir' format
  
  The parser ignores leading and trailing whitespace.  It also allow the
  seconds to be missing and the month to be numerical in most formats.
  
  If the year is missing, then we assume that the date is the first
  matching date I<before> current month.  If the year is given with only
  2 digits, then parse_date() will select the century that makes the
  year closest to the current date.
  
  =item time2iso( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ss"-formatted
  string representing time in the local time zone.
  
  =item time2isoz( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ssZ"-formatted
  string representing Universal Time.
  
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc/time>, L<Time::Zone>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1999, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_DATE

$fatpacked{"HTTP/Headers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS';
  package HTTP::Headers;
  
  use strict;
  use Carp ();
  
  use vars qw($VERSION $TRANSLATE_UNDERSCORE);
  $VERSION = "6.05";
  
  # The $TRANSLATE_UNDERSCORE variable controls whether '_' can be used
  # as a replacement for '-' in header field names.
  $TRANSLATE_UNDERSCORE = 1 unless defined $TRANSLATE_UNDERSCORE;
  
  # "Good Practice" order of HTTP message headers:
  #    - General-Headers
  #    - Request-Headers
  #    - Response-Headers
  #    - Entity-Headers
  
  my @general_headers = qw(
      Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
      Via Warning
  );
  
  my @request_headers = qw(
      Accept Accept-Charset Accept-Encoding Accept-Language
      Authorization Expect From Host
      If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
      Max-Forwards Proxy-Authorization Range Referer TE User-Agent
  );
  
  my @response_headers = qw(
      Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
      Vary WWW-Authenticate
  );
  
  my @entity_headers = qw(
      Allow Content-Encoding Content-Language Content-Length Content-Location
      Content-MD5 Content-Range Content-Type Expires Last-Modified
  );
  
  my %entity_header = map { lc($_) => 1 } @entity_headers;
  
  my @header_order = (
      @general_headers,
      @request_headers,
      @response_headers,
      @entity_headers,
  );
  
  # Make alternative representations of @header_order.  This is used
  # for sorting and case matching.
  my %header_order;
  my %standard_case;
  
  {
      my $i = 0;
      for (@header_order) {
  	my $lc = lc $_;
  	$header_order{$lc} = ++$i;
  	$standard_case{$lc} = $_;
      }
  }
  
  
  
  sub new
  {
      my($class) = shift;
      my $self = bless {}, $class;
      $self->header(@_) if @_; # set up initial headers
      $self;
  }
  
  
  sub header
  {
      my $self = shift;
      Carp::croak('Usage: $h->header($field, ...)') unless @_;
      my(@old);
      my %seen;
      while (@_) {
  	my $field = shift;
          my $op = @_ ? ($seen{lc($field)}++ ? 'PUSH' : 'SET') : 'GET';
  	@old = $self->_header($field, shift, $op);
      }
      return @old if wantarray;
      return $old[0] if @old <= 1;
      join(", ", @old);
  }
  
  sub clear
  {
      my $self = shift;
      %$self = ();
  }
  
  
  sub push_header
  {
      my $self = shift;
      return $self->_header(@_, 'PUSH_H') if @_ == 2;
      while (@_) {
  	$self->_header(splice(@_, 0, 2), 'PUSH_H');
      }
  }
  
  
  sub init_header
  {
      Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
      shift->_header(@_, 'INIT');
  }
  
  
  sub remove_header
  {
      my($self, @fields) = @_;
      my $field;
      my @values;
      foreach $field (@fields) {
  	$field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
  	my $v = delete $self->{lc $field};
  	push(@values, ref($v) eq 'ARRAY' ? @$v : $v) if defined $v;
      }
      return @values;
  }
  
  sub remove_content_headers
  {
      my $self = shift;
      unless (defined(wantarray)) {
  	# fast branch that does not create return object
  	delete @$self{grep $entity_header{$_} || /^content-/, keys %$self};
  	return;
      }
  
      my $c = ref($self)->new;
      for my $f (grep $entity_header{$_} || /^content-/, keys %$self) {
  	$c->{$f} = delete $self->{$f};
      }
      if (exists $self->{'::std_case'}) {
  	$c->{'::std_case'} = $self->{'::std_case'};
      }
      $c;
  }
  
  
  sub _header
  {
      my($self, $field, $val, $op) = @_;
  
      Carp::croak("Illegal field name '$field'")
          if rindex($field, ':') > 1 || !length($field);
  
      unless ($field =~ /^:/) {
  	$field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
  	my $old = $field;
  	$field = lc $field;
  	unless($standard_case{$field} || $self->{'::std_case'}{$field}) {
  	    # generate a %std_case entry for this field
  	    $old =~ s/\b(\w)/\u$1/g;
  	    $self->{'::std_case'}{$field} = $old;
  	}
      }
  
      $op ||= defined($val) ? 'SET' : 'GET';
      if ($op eq 'PUSH_H') {
  	# Like PUSH but where we don't care about the return value
  	if (exists $self->{$field}) {
  	    my $h = $self->{$field};
  	    if (ref($h) eq 'ARRAY') {
  		push(@$h, ref($val) eq "ARRAY" ? @$val : $val);
  	    }
  	    else {
  		$self->{$field} = [$h, ref($val) eq "ARRAY" ? @$val : $val]
  	    }
  	    return;
  	}
  	$self->{$field} = $val;
  	return;
      }
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : (defined($h) ? ($h) : ());
  
      unless ($op eq 'GET' || ($op eq 'INIT' && @old)) {
  	if (defined($val)) {
  	    my @new = ($op eq 'PUSH') ? @old : ();
  	    if (ref($val) ne 'ARRAY') {
  		push(@new, $val);
  	    }
  	    else {
  		push(@new, @$val);
  	    }
  	    $self->{$field} = @new > 1 ? \@new : $new[0];
  	}
  	elsif ($op ne 'PUSH') {
  	    delete $self->{$field};
  	}
      }
      @old;
  }
  
  
  sub _sorted_field_names
  {
      my $self = shift;
      return [ sort {
          ($header_order{$a} || 999) <=> ($header_order{$b} || 999) ||
           $a cmp $b
      } grep !/^::/, keys %$self ];
  }
  
  
  sub header_field_names {
      my $self = shift;
      return map $standard_case{$_} || $self->{'::std_case'}{$_} || $_, @{ $self->_sorted_field_names },
  	if wantarray;
      return grep !/^::/, keys %$self;
  }
  
  
  sub scan
  {
      my($self, $sub) = @_;
      my $key;
      for $key (@{ $self->_sorted_field_names }) {
  	my $vals = $self->{$key};
  	if (ref($vals) eq 'ARRAY') {
  	    my $val;
  	    for $val (@$vals) {
  		$sub->($standard_case{$key} || $self->{'::std_case'}{$key} || $key, $val);
  	    }
  	}
  	else {
  	    $sub->($standard_case{$key} || $self->{'::std_case'}{$key} || $key, $vals);
  	}
      }
  }
  
  
  sub as_string
  {
      my($self, $endl) = @_;
      $endl = "\n" unless defined $endl;
  
      my @result = ();
      for my $key (@{ $self->_sorted_field_names }) {
  	next if index($key, '_') == 0;
  	my $vals = $self->{$key};
  	if ( ref($vals) eq 'ARRAY' ) {
  	    for my $val (@$vals) {
  		my $field = $standard_case{$key} || $self->{'::std_case'}{$key} || $key;
  		$field =~ s/^://;
  		if ( index($val, "\n") >= 0 ) {
  		    $val = _process_newline($val, $endl);
  		}
  		push @result, $field . ': ' . $val;
  	    }
  	}
  	else {
  	    my $field = $standard_case{$key} || $self->{'::std_case'}{$key} || $key;
  	    $field =~ s/^://;
  	    if ( index($vals, "\n") >= 0 ) {
  		$vals = _process_newline($vals, $endl);
  	    }
  	    push @result, $field . ': ' . $vals;
  	}
      }
  
      join($endl, @result, '');
  }
  
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # initial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  
  
  if (eval { require Storable; 1 }) {
      *clone = \&Storable::dclone;
  } else {
      *clone = sub {
  	my $self = shift;
  	my $clone = HTTP::Headers->new;
  	$self->scan(sub { $clone->push_header(@_);} );
  	$clone;
      };
  }
  
  
  sub _date_header
  {
      require HTTP::Date;
      my($self, $header, $time) = @_;
      my($old) = $self->_header($header);
      if (defined $time) {
  	$self->_header($header, HTTP::Date::time2str($time));
      }
      $old =~ s/;.*// if defined($old);
      HTTP::Date::str2time($old);
  }
  
  
  sub date                { shift->_date_header('Date',                @_); }
  sub expires             { shift->_date_header('Expires',             @_); }
  sub if_modified_since   { shift->_date_header('If-Modified-Since',   @_); }
  sub if_unmodified_since { shift->_date_header('If-Unmodified-Since', @_); }
  sub last_modified       { shift->_date_header('Last-Modified',       @_); }
  
  # This is used as a private LWP extension.  The Client-Date header is
  # added as a timestamp to a response when it has been received.
  sub client_date         { shift->_date_header('Client-Date',         @_); }
  
  # The retry_after field is dual format (can also be a expressed as
  # number of seconds from now), so we don't provide an easy way to
  # access it until we have know how both these interfaces can be
  # addressed.  One possibility is to return a negative value for
  # relative seconds and a positive value for epoch based time values.
  #sub retry_after       { shift->_date_header('Retry-After',       @_); }
  
  sub content_type      {
      my $self = shift;
      my $ct = $self->{'content-type'};
      $self->{'content-type'} = shift if @_;
      $ct = $ct->[0] if ref($ct) eq 'ARRAY';
      return '' unless defined($ct) && length($ct);
      my @ct = split(/;\s*/, $ct, 2);
      for ($ct[0]) {
  	s/\s+//g;
  	$_ = lc($_);
      }
      wantarray ? @ct : $ct[0];
  }
  
  sub content_type_charset {
      my $self = shift;
      require HTTP::Headers::Util;
      my $h = $self->{'content-type'};
      $h = $h->[0] if ref($h);
      $h = "" unless defined $h;
      my @v = HTTP::Headers::Util::split_header_words($h);
      if (@v) {
  	my($ct, undef, %ct_param) = @{$v[0]};
  	my $charset = $ct_param{charset};
  	if ($ct) {
  	    $ct = lc($ct);
  	    $ct =~ s/\s+//;
  	}
  	if ($charset) {
  	    $charset = uc($charset);
  	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
  	    undef($charset) if $charset eq "";
  	}
  	return $ct, $charset if wantarray;
  	return $charset;
      }
      return undef, undef if wantarray;
      return undef;
  }
  
  sub content_is_text {
      my $self = shift;
      return $self->content_type =~ m,^text/,;
  }
  
  sub content_is_html {
      my $self = shift;
      return $self->content_type eq 'text/html' || $self->content_is_xhtml;
  }
  
  sub content_is_xhtml {
      my $ct = shift->content_type;
      return $ct eq "application/xhtml+xml" ||
             $ct eq "application/vnd.wap.xhtml+xml";
  }
  
  sub content_is_xml {
      my $ct = shift->content_type;
      return 1 if $ct eq "text/xml";
      return 1 if $ct eq "application/xml";
      return 1 if $ct =~ /\+xml$/;
      return 0;
  }
  
  sub referer           {
      my $self = shift;
      if (@_ && $_[0] =~ /#/) {
  	# Strip fragment per RFC 2616, section 14.36.
  	my $uri = shift;
  	if (ref($uri)) {
  	    $uri = $uri->clone;
  	    $uri->fragment(undef);
  	}
  	else {
  	    $uri =~ s/\#.*//;
  	}
  	unshift @_, $uri;
      }
      ($self->_header('Referer', @_))[0];
  }
  *referrer = \&referer;  # on tchrist's request
  
  sub title             { (shift->_header('Title',            @_))[0] }
  sub content_encoding  { (shift->_header('Content-Encoding', @_))[0] }
  sub content_language  { (shift->_header('Content-Language', @_))[0] }
  sub content_length    { (shift->_header('Content-Length',   @_))[0] }
  
  sub user_agent        { (shift->_header('User-Agent',       @_))[0] }
  sub server            { (shift->_header('Server',           @_))[0] }
  
  sub from              { (shift->_header('From',             @_))[0] }
  sub warning           { (shift->_header('Warning',          @_))[0] }
  
  sub www_authenticate  { (shift->_header('WWW-Authenticate', @_))[0] }
  sub authorization     { (shift->_header('Authorization',    @_))[0] }
  
  sub proxy_authenticate  { (shift->_header('Proxy-Authenticate',  @_))[0] }
  sub proxy_authorization { (shift->_header('Proxy-Authorization', @_))[0] }
  
  sub authorization_basic       { shift->_basic_auth("Authorization",       @_) }
  sub proxy_authorization_basic { shift->_basic_auth("Proxy-Authorization", @_) }
  
  sub _basic_auth {
      require MIME::Base64;
      my($self, $h, $user, $passwd) = @_;
      my($old) = $self->_header($h);
      if (defined $user) {
  	Carp::croak("Basic authorization user name can't contain ':'")
  	  if $user =~ /:/;
  	$passwd = '' unless defined $passwd;
  	$self->_header($h => 'Basic ' .
                               MIME::Base64::encode("$user:$passwd", ''));
      }
      if (defined $old && $old =~ s/^\s*Basic\s+//) {
  	my $val = MIME::Base64::decode($old);
  	return $val unless wantarray;
  	return split(/:/, $val, 2);
      }
      return;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers - Class encapsulating HTTP Message headers
  
  =head1 SYNOPSIS
  
   require HTTP::Headers;
   $h = HTTP::Headers->new;
  
   $h->header('Content-Type' => 'text/plain');  # set
   $ct = $h->header('Content-Type');            # get
   $h->remove_header('Content-Type');           # delete
  
  =head1 DESCRIPTION
  
  The C<HTTP::Headers> class encapsulates HTTP-style message headers.
  The headers consist of attribute-value pairs also called fields, which
  may be repeated, and which are printed in a particular order.  The
  field names are cases insensitive.
  
  Instances of this class are usually created as member variables of the
  C<HTTP::Request> and C<HTTP::Response> classes, internal to the
  library.
  
  The following methods are available:
  
  =over 4
  
  =item $h = HTTP::Headers->new
  
  Constructs a new C<HTTP::Headers> object.  You might pass some initial
  attribute-value pairs as parameters to the constructor.  I<E.g.>:
  
   $h = HTTP::Headers->new(
         Date         => 'Thu, 03 Feb 1994 00:00:00 GMT',
         Content_Type => 'text/html; version=3.2',
         Content_Base => 'http://www.perl.org/');
  
  The constructor arguments are passed to the C<header> method which is
  described below.
  
  =item $h->clone
  
  Returns a copy of this C<HTTP::Headers> object.
  
  =item $h->header( $field )
  
  =item $h->header( $field => $value )
  
  =item $h->header( $f1 => $v1, $f2 => $v2, ... )
  
  Get or set the value of one or more header fields.  The header field
  name ($field) is not case sensitive.  To make the life easier for perl
  users who wants to avoid quoting before the => operator, you can use
  '_' as a replacement for '-' in header names.
  
  The header() method accepts multiple ($field => $value) pairs, which
  means that you can update several fields with a single invocation.
  
  The $value argument may be a plain string or a reference to an array
  of strings for a multi-valued field. If the $value is provided as
  C<undef> then the field is removed.  If the $value is not given, then
  that header field will remain unchanged.
  
  The old value (or values) of the last of the header fields is returned.
  If no such field exists C<undef> will be returned.
  
  A multi-valued field will be returned as separate values in list
  context and will be concatenated with ", " as separator in scalar
  context.  The HTTP spec (RFC 2616) promise that joining multiple
  values in this way will not change the semantic of a header field, but
  in practice there are cases like old-style Netscape cookies (see
  L<HTTP::Cookies>) where "," is used as part of the syntax of a single
  field value.
  
  Examples:
  
   $header->header(MIME_Version => '1.0',
  		 User_Agent   => 'My-Web-Client/0.01');
   $header->header(Accept => "text/html, text/plain, image/*");
   $header->header(Accept => [qw(text/html text/plain image/*)]);
   @accepts = $header->header('Accept');  # get multiple values
   $accepts = $header->header('Accept');  # get values as a single string
  
  =item $h->push_header( $field => $value )
  
  =item $h->push_header( $f1 => $v1, $f2 => $v2, ... )
  
  Add a new field value for the specified header field.  Previous values
  for the same field are retained.
  
  As for the header() method, the field name ($field) is not case
  sensitive and '_' can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
   $header->push_header(Accept => 'image/jpeg');
   $header->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
  
  =item $h->init_header( $field => $value )
  
  Set the specified header to the given value, but only if no previous
  value for that field is set.
  
  The header field name ($field) is not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
  =item $h->remove_header( $field, ... )
  
  This function removes the header fields with the specified names.
  
  The header field names ($field) are not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The return value is the values of the fields removed.  In scalar
  context the number of fields removed is returned.
  
  Note that if you pass in multiple field names then it is generally not
  possible to tell which of the returned values belonged to which field.
  
  =item $h->remove_content_headers
  
  This will remove all the header fields used to describe the content of
  a message.  All header field names prefixed with C<Content-> fall
  into this category, as well as C<Allow>, C<Expires> and
  C<Last-Modified>.  RFC 2616 denotes these fields as I<Entity Header
  Fields>.
  
  The return value is a new C<HTTP::Headers> object that contains the
  removed headers only.
  
  =item $h->clear
  
  This will remove all header fields.
  
  =item $h->header_field_names
  
  Returns the list of distinct names for the fields present in the
  header.  The field names have case as suggested by HTTP spec, and the
  names are returned in the recommended "Good Practice" order.
  
  In scalar context return the number of distinct field names.
  
  =item $h->scan( \&process_header_field )
  
  Apply a subroutine to each header field in turn.  The callback routine
  is called with two parameters; the name of the field and a single
  value (a string).  If a header field is multi-valued, then the
  routine is called once for each value.  The field name passed to the
  callback routine has case as suggested by HTTP spec, and the headers
  will be visited in the recommended "Good Practice" order.
  
  Any return values of the callback routine are ignored.  The loop can
  be broken by raising an exception (C<die>), but the caller of scan()
  would have to trap the exception itself.
  
  =item $h->as_string
  
  =item $h->as_string( $eol )
  
  Return the header fields as a formatted MIME header.  Since it
  internally uses the C<scan> method to build the string, the result
  will use case as suggested by HTTP spec, and it will follow
  recommended "Good Practice" of ordering the header fields.  Long header
  values are not folded.
  
  The optional $eol parameter specifies the line ending sequence to
  use.  The default is "\n".  Embedded "\n" characters in header field
  values will be substituted with this line ending sequence.
  
  =back
  
  =head1 CONVENIENCE METHODS
  
  The most frequently used headers can also be accessed through the
  following convenience methods.  Most of these methods can both be used to read
  and to set the value of a header.  The header value is set if you pass
  an argument to the method.  The old header value is always returned.
  If the given header did not exist then C<undef> is returned.
  
  Methods that deal with dates/times always convert their value to system
  time (seconds since Jan 1, 1970) and they also expect this kind of
  value when the header value is set.
  
  =over 4
  
  =item $h->date
  
  This header represents the date and time at which the message was
  originated. I<E.g.>:
  
    $h->date(time);  # set current date
  
  =item $h->expires
  
  This header gives the date and time after which the entity should be
  considered stale.
  
  =item $h->if_modified_since
  
  =item $h->if_unmodified_since
  
  These header fields are used to make a request conditional.  If the requested
  resource has (or has not) been modified since the time specified in this field,
  then the server will return a C<304 Not Modified> response instead of
  the document itself.
  
  =item $h->last_modified
  
  This header indicates the date and time at which the resource was last
  modified. I<E.g.>:
  
    # check if document is more than 1 hour old
    if (my $last_mod = $h->last_modified) {
        if ($last_mod < time - 60*60) {
  	  ...
        }
    }
  
  =item $h->content_type
  
  The Content-Type header field indicates the media type of the message
  content. I<E.g.>:
  
    $h->content_type('text/html');
  
  The value returned will be converted to lower case, and potential
  parameters will be chopped off and returned as a separate value if in
  an array context.  If there is no such header field, then the empty
  string is returned.  This makes it safe to do the following:
  
    if ($h->content_type eq 'text/html') {
       # we enter this place even if the real header value happens to
       # be 'TEXT/HTML; version=3.0'
       ...
    }
  
  =item $h->content_type_charset
  
  Returns the upper-cased charset specified in the Content-Type header.  In list
  context return the lower-cased bare content type followed by the upper-cased
  charset.  Both values will be C<undef> if not specified in the header.
  
  =item $h->content_is_text
  
  Returns TRUE if the Content-Type header field indicate that the
  content is textual.
  
  =item $h->content_is_html
  
  Returns TRUE if the Content-Type header field indicate that the
  content is some kind of HTML (including XHTML).  This method can't be
  used to set Content-Type.
  
  =item $h->content_is_xhtml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XHTML.  This method can't be used to set Content-Type.
  
  =item $h->content_is_xml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XML.  This method can't be used to set Content-Type.
  
  =item $h->content_encoding
  
  The Content-Encoding header field is used as a modifier to the
  media type.  When present, its value indicates what additional
  encoding mechanism has been applied to the resource.
  
  =item $h->content_length
  
  A decimal number indicating the size in bytes of the message content.
  
  =item $h->content_language
  
  The natural language(s) of the intended audience for the message
  content.  The value is one or more language tags as defined by RFC
  1766.  Eg. "no" for some kind of Norwegian and "en-US" for English the
  way it is written in the US.
  
  =item $h->title
  
  The title of the document.  In libwww-perl this header will be
  initialized automatically from the E<lt>TITLE>...E<lt>/TITLE> element
  of HTML documents.  I<This header is no longer part of the HTTP
  standard.>
  
  =item $h->user_agent
  
  This header field is used in request messages and contains information
  about the user agent originating the request.  I<E.g.>:
  
    $h->user_agent('Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)');
  
  =item $h->server
  
  The server header field contains information about the software being
  used by the originating server program handling the request.
  
  =item $h->from
  
  This header should contain an Internet e-mail address for the human
  user who controls the requesting user agent.  The address should be
  machine-usable, as defined by RFC822.  E.g.:
  
    $h->from('King Kong <king@kong.com>');
  
  I<This header is no longer part of the HTTP standard.>
  
  =item $h->referer
  
  Used to specify the address (URI) of the document from which the
  requested resource address was obtained.
  
  The "Free On-line Dictionary of Computing" as this to say about the
  word I<referer>:
  
       <World-Wide Web> A misspelling of "referrer" which
       somehow made it into the {HTTP} standard.  A given {web
       page}'s referer (sic) is the {URL} of whatever web page
       contains the link that the user followed to the current
       page.  Most browsers pass this information as part of a
       request.
  
       (1998-10-19)
  
  By popular demand C<referrer> exists as an alias for this method so you
  can avoid this misspelling in your programs and still send the right
  thing on the wire.
  
  When setting the referrer, this method removes the fragment from the
  given URI if it is present, as mandated by RFC2616.  Note that
  the removal does I<not> happen automatically if using the header(),
  push_header() or init_header() methods to set the referrer.
  
  =item $h->www_authenticate
  
  This header must be included as part of a C<401 Unauthorized> response.
  The field value consist of a challenge that indicates the
  authentication scheme and parameters applicable to the requested URI.
  
  =item $h->proxy_authenticate
  
  This header must be included in a C<407 Proxy Authentication Required>
  response.
  
  =item $h->authorization
  
  =item $h->proxy_authorization
  
  A user agent that wishes to authenticate itself with a server or a
  proxy, may do so by including these headers.
  
  =item $h->authorization_basic
  
  This method is used to get or set an authorization header that use the
  "Basic Authentication Scheme".  In array context it will return two
  values; the user name and the password.  In scalar context it will
  return I<"uname:password"> as a single string value.
  
  When used to set the header value, it expects two arguments.  I<E.g.>:
  
    $h->authorization_basic($uname, $password);
  
  The method will croak if the $uname contains a colon ':'.
  
  =item $h->proxy_authorization_basic
  
  Same as authorization_basic() but will set the "Proxy-Authorization"
  header instead.
  
  =back
  
  =head1 NON-CANONICALIZED FIELD NAMES
  
  The header field name spelling is normally canonicalized including the
  '_' to '-' translation.  There are some application where this is not
  appropriate.  Prefixing field names with ':' allow you to force a
  specific spelling.  For example if you really want a header field name
  to show up as C<foo_bar> instead of "Foo-Bar", you might set it like
  this:
  
    $h->header(":foo_bar" => 1);
  
  These field names are returned with the ':' intact for
  $h->header_field_names and the $h->scan callback, but the colons do
  not show in $h->as_string.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS

$fatpacked{"HTTP/Headers/Auth.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_AUTH';
  package HTTP::Headers::Auth;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "6.00";
  
  use HTTP::Headers;
  
  package HTTP::Headers;
  
  BEGIN {
      # we provide a new (and better) implementations below
      undef(&www_authenticate);
      undef(&proxy_authenticate);
  }
  
  require HTTP::Headers::Util;
  
  sub _parse_authenticate
  {
      my @ret;
      for (HTTP::Headers::Util::split_header_words(@_)) {
  	if (!defined($_->[1])) {
  	    # this is a new auth scheme
  	    push(@ret, shift(@$_) => {});
  	    shift @$_;
  	}
  	if (@ret) {
  	    # this a new parameter pair for the last auth scheme
  	    while (@$_) {
  		my $k = shift @$_;
  		my $v = shift @$_;
  	        $ret[-1]{$k} = $v;
  	    }
  	}
  	else {
  	    # something wrong, parameter pair without any scheme seen
  	    # IGNORE
  	}
      }
      @ret;
  }
  
  sub _authenticate
  {
      my $self = shift;
      my $header = shift;
      my @old = $self->_header($header);
      if (@_) {
  	$self->remove_header($header);
  	my @new = @_;
  	while (@new) {
  	    my $a_scheme = shift(@new);
  	    if ($a_scheme =~ /\s/) {
  		# assume complete valid value, pass it through
  		$self->push_header($header, $a_scheme);
  	    }
  	    else {
  		my @param;
  		if (@new) {
  		    my $p = $new[0];
  		    if (ref($p) eq "ARRAY") {
  			@param = @$p;
  			shift(@new);
  		    }
  		    elsif (ref($p) eq "HASH") {
  			@param = %$p;
  			shift(@new);
  		    }
  		}
  		my $val = ucfirst(lc($a_scheme));
  		if (@param) {
  		    my $sep = " ";
  		    while (@param) {
  			my $k = shift @param;
  			my $v = shift @param;
  			if ($v =~ /[^0-9a-zA-Z]/ || lc($k) eq "realm") {
  			    # must quote the value
  			    $v =~ s,([\\\"]),\\$1,g;
  			    $v = qq("$v");
  			}
  			$val .= "$sep$k=$v";
  			$sep = ", ";
  		    }
  		}
  		$self->push_header($header, $val);
  	    }
  	}
      }
      return unless defined wantarray;
      wantarray ? _parse_authenticate(@old) : join(", ", @old);
  }
  
  
  sub www_authenticate    { shift->_authenticate("WWW-Authenticate", @_)   }
  sub proxy_authenticate  { shift->_authenticate("Proxy-Authenticate", @_) }
  
  1;
HTTP_HEADERS_AUTH

$fatpacked{"HTTP/Headers/ETag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_ETAG';
  package HTTP::Headers::ETag;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "6.00";
  
  require HTTP::Date;
  
  require HTTP::Headers;
  package HTTP::Headers;
  
  sub _etags
  {
      my $self = shift;
      my $header = shift;
      my @old = _split_etag_list($self->_header($header));
      if (@_) {
  	$self->_header($header => join(", ", _split_etag_list(@_)));
      }
      wantarray ? @old : join(", ", @old);
  }
  
  sub etag          { shift->_etags("ETag", @_); }
  sub if_match      { shift->_etags("If-Match", @_); }
  sub if_none_match { shift->_etags("If-None-Match", @_); }
  
  sub if_range {
      # Either a date or an entity-tag
      my $self = shift;
      my @old = $self->_header("If-Range");
      if (@_) {
  	my $new = shift;
  	if (!defined $new) {
  	    $self->remove_header("If-Range");
  	}
  	elsif ($new =~ /^\d+$/) {
  	    $self->_date_header("If-Range", $new);
  	}
  	else {
  	    $self->_etags("If-Range", $new);
  	}
      }
      return unless defined(wantarray);
      for (@old) {
  	my $t = HTTP::Date::str2time($_);
  	$_ = $t if $t;
      }
      wantarray ? @old : join(", ", @old);
  }
  
  
  # Split a list of entity tag values.  The return value is a list
  # consisting of one element per entity tag.  Suitable for parsing
  # headers like C<If-Match>, C<If-None-Match>.  You might even want to
  # use it on C<ETag> and C<If-Range> entity tag values, because it will
  # normalize them to the common form.
  #
  #  entity-tag	  = [ weak ] opaque-tag
  #  weak		  = "W/"
  #  opaque-tag	  = quoted-string
  
  
  sub _split_etag_list
  {
      my(@val) = @_;
      my @res;
      for (@val) {
          while (length) {
              my $weak = "";
  	    $weak = "W/" if s,^\s*[wW]/,,;
              my $etag = "";
  	    if (s/^\s*(\"[^\"\\]*(?:\\.[^\"\\]*)*\")//) {
  		push(@res, "$weak$1");
              }
              elsif (s/^\s*,//) {
                  push(@res, qq(W/"")) if $weak;
              }
              elsif (s/^\s*([^,\s]+)//) {
                  $etag = $1;
  		$etag =~ s/([\"\\])/\\$1/g;
  	        push(@res, qq($weak"$etag"));
              }
              elsif (s/^\s+// || !length) {
                  push(@res, qq(W/"")) if $weak;
              }
              else {
  	 	die "This should not happen: '$_'";
              }
          }
     }
     @res;
  }
  
  1;
HTTP_HEADERS_ETAG

$fatpacked{"HTTP/Headers/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_UTIL';
  package HTTP::Headers::Util;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT_OK);
  
  $VERSION = "6.03";
  
  require Exporter;
  @ISA=qw(Exporter);
  
  @EXPORT_OK=qw(split_header_words _split_header_words join_header_words);
  
  
  
  sub split_header_words {
      my @res = &_split_header_words;
      for my $arr (@res) {
  	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
  	    $arr->[$i] = lc($arr->[$i]);
  	}
      }
      return @res;
  }
  
  sub _split_header_words
  {
      my(@val) = @_;
      my @res;
      for (@val) {
  	my @cur;
  	while (length) {
  	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
  		push(@cur, $1);
  		# a quoted value
  		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
  		    my $val = $1;
  		    $val =~ s/\\(.)/$1/g;
  		    push(@cur, $val);
  		# some unquoted value
  		}
  		elsif (s/^\s*=\s*([^;,\s]*)//) {
  		    my $val = $1;
  		    $val =~ s/\s+$//;
  		    push(@cur, $val);
  		# no value, a lone token
  		}
  		else {
  		    push(@cur, undef);
  		}
  	    }
  	    elsif (s/^\s*,//) {
  		push(@res, [@cur]) if @cur;
  		@cur = ();
  	    }
  	    elsif (s/^\s*;// || s/^\s+//) {
  		# continue
  	    }
  	    else {
  		die "This should not happen: '$_'";
  	    }
  	}
  	push(@res, \@cur) if @cur;
      }
      @res;
  }
  
  
  sub join_header_words
  {
      @_ = ([@_]) if @_ && !ref($_[0]);
      my @res;
      for (@_) {
  	my @cur = @$_;
  	my @attr;
  	while (@cur) {
  	    my $k = shift @cur;
  	    my $v = shift @cur;
  	    if (defined $v) {
  		if ($v =~ /[\x00-\x20()<>@,;:\\\"\/\[\]?={}\x7F-\xFF]/ || !length($v)) {
  		    $v =~ s/([\"\\])/\\$1/g;  # escape " and \
  		    $k .= qq(="$v");
  		}
  		else {
  		    # token
  		    $k .= "=$v";
  		}
  	    }
  	    push(@attr, $k);
  	}
  	push(@res, join("; ", @attr)) if @attr;
      }
      join(", ", @res);
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers::Util - Header value parsing utility functions
  
  =head1 SYNOPSIS
  
    use HTTP::Headers::Util qw(split_header_words);
    @values = split_header_words($h->header("Content-Type"));
  
  =head1 DESCRIPTION
  
  This module provides a few functions that helps parsing and
  construction of valid HTTP header values.  None of the functions are
  exported by default.
  
  The following functions are available:
  
  =over 4
  
  
  =item split_header_words( @header_values )
  
  This function will parse the header values given as argument into a
  list of anonymous arrays containing key/value pairs.  The function
  knows how to deal with ",", ";" and "=" as well as quoted values after
  "=".  A list of space separated tokens are parsed as if they were
  separated by ";".
  
  If the @header_values passed as argument contains multiple values,
  then they are treated as if they were a single value separated by
  comma ",".
  
  This means that this function is useful for parsing header fields that
  follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
  the requirement for tokens).
  
    headers           = #header
    header            = (token | parameter) *( [";"] (token | parameter))
  
    token             = 1*<any CHAR except CTLs or separators>
    separators        = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
  
    quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
    qdtext            = <any TEXT except <">>
    quoted-pair       = "\" CHAR
  
    parameter         = attribute "=" value
    attribute         = token
    value             = token | quoted-string
  
  Each I<header> is represented by an anonymous array of key/value
  pairs.  The keys will be all be forced to lower case.
  The value for a simple token (not part of a parameter) is C<undef>.
  Syntactically incorrect headers will not necessarily be parsed as you
  would want.
  
  This is easier to describe with some examples:
  
     split_header_words('foo="bar"; port="80,81"; DISCARD, BAR=baz');
     split_header_words('text/html; charset="iso-8859-1"');
     split_header_words('Basic realm="\\"foo\\\\bar\\""');
  
  will return
  
     [foo=>'bar', port=>'80,81', discard=> undef], [bar=>'baz' ]
     ['text/html' => undef, charset => 'iso-8859-1']
     [basic => undef, realm => "\"foo\\bar\""]
  
  If you don't want the function to convert tokens and attribute keys to
  lower case you can call it as C<_split_header_words> instead (with a
  leading underscore).
  
  =item join_header_words( @arrays )
  
  This will do the opposite of the conversion done by split_header_words().
  It takes a list of anonymous arrays as arguments (or a list of
  key/value pairs) and produces a single header value.  Attribute values
  are quoted if needed.
  
  Example:
  
     join_header_words(["text/plain" => undef, charset => "iso-8859/1"]);
     join_header_words("text/plain" => undef, charset => "iso-8859/1");
  
  will both return the string:
  
     text/plain; charset="iso-8859/1"
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS_UTIL

$fatpacked{"HTTP/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_MESSAGE';
  package HTTP::Message;
  
  use strict;
  use vars qw($VERSION $AUTOLOAD);
  $VERSION = "6.06";
  
  require HTTP::Headers;
  require Carp;
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  unless ($HTTP::URI_CLASS) {
      if ($ENV{PERL_HTTP_URI_CLASS}
      &&  $ENV{PERL_HTTP_URI_CLASS} =~ /^([\w:]+)$/) {
          $HTTP::URI_CLASS = $1;
      } else {
          $HTTP::URI_CLASS = "URI";
      }
  }
  eval "require $HTTP::URI_CLASS"; die $@ if $@;
  
  *_utf8_downgrade = defined(&utf8::downgrade) ?
      sub {
          utf8::downgrade($_[0], 1) or
              Carp::croak("HTTP::Message content must be bytes")
      }
      :
      sub {
      };
  
  sub new
  {
      my($class, $header, $content) = @_;
      if (defined $header) {
  	Carp::croak("Bad header argument") unless ref $header;
          if (ref($header) eq "ARRAY") {
  	    $header = HTTP::Headers->new(@$header);
  	}
  	else {
  	    $header = $header->clone;
  	}
      }
      else {
  	$header = HTTP::Headers->new;
      }
      if (defined $content) {
          _utf8_downgrade($content);
      }
      else {
          $content = '';
      }
  
      bless {
  	'_headers' => $header,
  	'_content' => $content,
      }, $class;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
  
      my @hdr;
      while (1) {
  	if ($str =~ s/^([^\s:]+)[ \t]*: ?(.*)\n?//) {
  	    push(@hdr, $1, $2);
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	elsif (@hdr && $str =~ s/^([ \t].*)\n?//) {
  	    $hdr[-1] .= "\n$1";
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	else {
  	    $str =~ s/^\r?\n//;
  	    last;
  	}
      }
      local $HTTP::Headers::TRANSLATE_UNDERSCORE;
      new($class, \@hdr, $str);
  }
  
  
  sub clone
  {
      my $self  = shift;
      my $clone = HTTP::Message->new($self->headers,
  				   $self->content);
      $clone->protocol($self->protocol);
      $clone;
  }
  
  
  sub clear {
      my $self = shift;
      $self->{_headers}->clear;
      $self->content("");
      delete $self->{_parts};
      return;
  }
  
  
  sub protocol {
      shift->_elem('_protocol',  @_);
  }
  
  sub headers {
      my $self = shift;
  
      # recalculation of _content might change headers, so we
      # need to force it now
      $self->_content unless exists $self->{_content};
  
      $self->{_headers};
  }
  
  sub headers_as_string {
      shift->headers->as_string(@_);
  }
  
  
  sub content  {
  
      my $self = $_[0];
      if (defined(wantarray)) {
  	$self->_content unless exists $self->{_content};
  	my $old = $self->{_content};
  	$old = $$old if ref($old) eq "SCALAR";
  	&_set_content if @_ > 1;
  	return $old;
      }
  
      if (@_ > 1) {
  	&_set_content;
      }
      else {
  	Carp::carp("Useless content call in void context") if $^W;
      }
  }
  
  
  sub _set_content {
      my $self = $_[0];
      _utf8_downgrade($_[1]);
      if (!ref($_[1]) && ref($self->{_content}) eq "SCALAR") {
  	${$self->{_content}} = $_[1];
      }
      else {
  	die "Can't set content to be a scalar reference" if ref($_[1]) eq "SCALAR";
  	$self->{_content} = $_[1];
  	delete $self->{_content_ref};
      }
      delete $self->{_parts} unless $_[2];
  }
  
  
  sub add_content
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      my $chunkref = \$_[0];
      $chunkref = $$chunkref if ref($$chunkref);  # legacy
  
      _utf8_downgrade($$chunkref);
  
      my $ref = ref($self->{_content});
      if (!$ref) {
  	$self->{_content} .= $$chunkref;
      }
      elsif ($ref eq "SCALAR") {
  	${$self->{_content}} .= $$chunkref;
      }
      else {
  	Carp::croak("Can't append to $ref content");
      }
      delete $self->{_parts};
  }
  
  sub add_content_utf8 {
      my($self, $buf)  = @_;
      utf8::upgrade($buf);
      utf8::encode($buf);
      $self->add_content($buf);
  }
  
  sub content_ref
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      delete $self->{_parts};
      my $old = \$self->{_content};
      my $old_cref = $self->{_content_ref};
      if (@_) {
  	my $new = shift;
  	Carp::croak("Setting content_ref to a non-ref") unless ref($new);
  	delete $self->{_content};  # avoid modifying $$old
  	$self->{_content} = $new;
  	$self->{_content_ref}++;
      }
      $old = $$old if $old_cref;
      return $old;
  }
  
  
  sub content_charset
  {
      my $self = shift;
      if (my $charset = $self->content_type_charset) {
  	return $charset;
      }
  
      # time to start guessing
      my $cref = $self->decoded_content(ref => 1, charset => "none");
  
      # Unicode BOM
      for ($$cref) {
  	return "UTF-8"     if /^\xEF\xBB\xBF/;
  	return "UTF-32LE" if /^\xFF\xFE\x00\x00/;
  	return "UTF-32BE" if /^\x00\x00\xFE\xFF/;
  	return "UTF-16LE" if /^\xFF\xFE/;
  	return "UTF-16BE" if /^\xFE\xFF/;
      }
  
      if ($self->content_is_xml) {
  	# http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing
  	# XML entity not accompanied by external encoding information and not
  	# in UTF-8 or UTF-16 encoding must begin with an XML encoding declaration,
  	# in which the first characters must be '<?xml'
  	for ($$cref) {
  	    return "UTF-32BE" if /^\x00\x00\x00</;
  	    return "UTF-32LE" if /^<\x00\x00\x00/;
  	    return "UTF-16BE" if /^(?:\x00\s)*\x00</;
  	    return "UTF-16LE" if /^(?:\s\x00)*<\x00/;
  	    if (/^\s*(<\?xml[^\x00]*?\?>)/) {
  		if ($1 =~ /\sencoding\s*=\s*(["'])(.*?)\1/) {
  		    my $enc = $2;
  		    $enc =~ s/^\s+//; $enc =~ s/\s+\z//;
  		    return $enc if $enc;
  		}
  	    }
  	}
  	return "UTF-8";
      }
      elsif ($self->content_is_html) {
  	# look for <META charset="..."> or <META content="...">
  	# http://dev.w3.org/html5/spec/Overview.html#determining-the-character-encoding
  	require IO::HTML;
  	# Use relaxed search to match previous versions of HTTP::Message:
  	my $encoding = IO::HTML::find_charset_in($$cref, { encoding    => 1,
  	                                                   need_pragma => 0 });
  	return $encoding->mime_name if $encoding;
      }
      elsif ($self->content_type eq "application/json") {
  	for ($$cref) {
  	    # RFC 4627, ch 3
  	    return "UTF-32BE" if /^\x00\x00\x00./s;
  	    return "UTF-32LE" if /^.\x00\x00\x00/s;
  	    return "UTF-16BE" if /^\x00.\x00./s;
  	    return "UTF-16LE" if /^.\x00.\x00/s;
  	    return "UTF-8";
  	}
      }
      if ($self->content_type =~ /^text\//) {
  	for ($$cref) {
  	    if (length) {
  		return "US-ASCII" unless /[\x80-\xFF]/;
  		require Encode;
  		eval {
  		    Encode::decode_utf8($_, Encode::FB_CROAK() | Encode::LEAVE_SRC());
  		};
  		return "UTF-8" unless $@;
  		return "ISO-8859-1";
  	    }
  	}
      }
  
      return undef;
  }
  
  
  sub decoded_content
  {
      my($self, %opt) = @_;
      my $content_ref;
      my $content_ref_iscopy;
  
      eval {
  	$content_ref = $self->content_ref;
  	die "Can't decode ref content" if ref($content_ref) ne "SCALAR";
  
  	if (my $h = $self->header("Content-Encoding")) {
  	    $h =~ s/^\s+//;
  	    $h =~ s/\s+$//;
  	    for my $ce (reverse split(/\s*,\s*/, lc($h))) {
  		next unless $ce;
  		next if $ce eq "identity";
  		if ($ce eq "gzip" || $ce eq "x-gzip") {
  		    require IO::Uncompress::Gunzip;
  		    my $output;
  		    IO::Uncompress::Gunzip::gunzip($content_ref, \$output, Transparent => 0)
  			or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "x-bzip2" or $ce eq "bzip2") {
  		    require IO::Uncompress::Bunzip2;
  		    my $output;
  		    IO::Uncompress::Bunzip2::bunzip2($content_ref, \$output, Transparent => 0)
  			or die "Can't bunzip content: $IO::Uncompress::Bunzip2::Bunzip2Error";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "deflate") {
  		    require IO::Uncompress::Inflate;
  		    my $output;
  		    my $status = IO::Uncompress::Inflate::inflate($content_ref, \$output, Transparent => 0);
  		    my $error = $IO::Uncompress::Inflate::InflateError;
  		    unless ($status) {
  			# "Content-Encoding: deflate" is supposed to mean the
  			# "zlib" format of RFC 1950, but Microsoft got that
  			# wrong, so some servers sends the raw compressed
  			# "deflate" data.  This tries to inflate this format.
  			$output = undef;
  			require IO::Uncompress::RawInflate;
  			unless (IO::Uncompress::RawInflate::rawinflate($content_ref, \$output)) {
  			    $self->push_header("Client-Warning" =>
  				"Could not raw inflate content: $IO::Uncompress::RawInflate::RawInflateError");
  			    $output = undef;
  			}
  		    }
  		    die "Can't inflate content: $error" unless defined $output;
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "compress" || $ce eq "x-compress") {
  		    die "Can't uncompress content";
  		}
  		elsif ($ce eq "base64") {  # not really C-T-E, but should be harmless
  		    require MIME::Base64;
  		    $content_ref = \MIME::Base64::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "quoted-printable") { # not really C-T-E, but should be harmless
  		    require MIME::QuotedPrint;
  		    $content_ref = \MIME::QuotedPrint::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		else {
  		    die "Don't know how to decode Content-Encoding '$ce'";
  		}
  	    }
  	}
  
  	if ($self->content_is_text || (my $is_xml = $self->content_is_xml)) {
  	    my $charset = lc(
  	        $opt{charset} ||
  		$self->content_type_charset ||
  		$opt{default_charset} ||
  		$self->content_charset ||
  		"ISO-8859-1"
  	    );
  	    if ($charset eq "none") {
  		# leave it asis
  	    }
  	    elsif ($charset eq "us-ascii" || $charset eq "iso-8859-1") {
  		if ($$content_ref =~ /[^\x00-\x7F]/ && defined &utf8::upgrade) {
  		    unless ($content_ref_iscopy) {
  			my $copy = $$content_ref;
  			$content_ref = \$copy;
  			$content_ref_iscopy++;
  		    }
  		    utf8::upgrade($$content_ref);
  		}
  	    }
  	    else {
  		require Encode;
  		eval {
  		    $content_ref = \Encode::decode($charset, $$content_ref,
  			 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC());
  		};
  		if ($@) {
  		    my $retried;
  		    if ($@ =~ /^Unknown encoding/) {
  			my $alt_charset = lc($opt{alt_charset} || "");
  			if ($alt_charset && $charset ne $alt_charset) {
  			    # Retry decoding with the alternative charset
  			    $content_ref = \Encode::decode($alt_charset, $$content_ref,
  				 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC())
  			        unless $alt_charset eq "none";
  			    $retried++;
  			}
  		    }
  		    die unless $retried;
  		}
  		die "Encode::decode() returned undef improperly" unless defined $$content_ref;
  		if ($is_xml) {
  		    # Get rid of the XML encoding declaration if present
  		    $$content_ref =~ s/^\x{FEFF}//;
  		    if ($$content_ref =~ /^(\s*<\?xml[^\x00]*?\?>)/) {
  			substr($$content_ref, 0, length($1)) =~ s/\sencoding\s*=\s*(["']).*?\1//;
  		    }
  		}
  	    }
  	}
      };
      if ($@) {
  	Carp::croak($@) if $opt{raise_error};
  	return undef;
      }
  
      return $opt{ref} ? $content_ref : $$content_ref;
  }
  
  
  sub decodable
  {
      # should match the Content-Encoding values that decoded_content can deal with
      my $self = shift;
      my @enc;
      # XXX preferably we should determine if the modules are available without loading
      # them here
      eval {
          require IO::Uncompress::Gunzip;
          push(@enc, "gzip", "x-gzip");
      };
      eval {
          require IO::Uncompress::Inflate;
          require IO::Uncompress::RawInflate;
          push(@enc, "deflate");
      };
      eval {
          require IO::Uncompress::Bunzip2;
          push(@enc, "x-bzip2");
      };
      # we don't care about announcing the 'identity', 'base64' and
      # 'quoted-printable' stuff
      return wantarray ? @enc : join(", ", @enc);
  }
  
  
  sub decode
  {
      my $self = shift;
      return 1 unless $self->header("Content-Encoding");
      if (defined(my $content = $self->decoded_content(charset => "none"))) {
  	$self->remove_header("Content-Encoding", "Content-Length", "Content-MD5");
  	$self->content($content);
  	return 1;
      }
      return 0;
  }
  
  
  sub encode
  {
      my($self, @enc) = @_;
  
      Carp::croak("Can't encode multipart/* messages") if $self->content_type =~ m,^multipart/,;
      Carp::croak("Can't encode message/* messages") if $self->content_type =~ m,^message/,;
  
      return 1 unless @enc;  # nothing to do
  
      my $content = $self->content;
      for my $encoding (@enc) {
  	if ($encoding eq "identity") {
  	    # nothing to do
  	}
  	elsif ($encoding eq "base64") {
  	    require MIME::Base64;
  	    $content = MIME::Base64::encode($content);
  	}
  	elsif ($encoding eq "gzip" || $encoding eq "x-gzip") {
  	    require IO::Compress::Gzip;
  	    my $output;
  	    IO::Compress::Gzip::gzip(\$content, \$output, Minimal => 1)
  		or die "Can't gzip content: $IO::Compress::Gzip::GzipError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "deflate") {
  	    require IO::Compress::Deflate;
  	    my $output;
  	    IO::Compress::Deflate::deflate(\$content, \$output)
  		or die "Can't deflate content: $IO::Compress::Deflate::DeflateError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "x-bzip2") {
  	    require IO::Compress::Bzip2;
  	    my $output;
  	    IO::Compress::Bzip2::bzip2(\$content, \$output)
  		or die "Can't bzip2 content: $IO::Compress::Bzip2::Bzip2Error";
  	    $content = $output;
  	}
  	elsif ($encoding eq "rot13") {  # for the fun of it
  	    $content =~ tr/A-Za-z/N-ZA-Mn-za-m/;
  	}
  	else {
  	    return 0;
  	}
      }
      my $h = $self->header("Content-Encoding");
      unshift(@enc, $h) if $h;
      $self->header("Content-Encoding", join(", ", @enc));
      $self->remove_header("Content-Length", "Content-MD5");
      $self->content($content);
      return 1;
  }
  
  
  sub as_string
  {
      my($self, $eol) = @_;
      $eol = "\n" unless defined $eol;
  
      # The calculation of content might update the headers
      # so we need to do that first.
      my $content = $self->content;
  
      return join("", $self->{'_headers'}->as_string($eol),
  		    $eol,
  		    $content,
  		    (@_ == 1 && length($content) &&
  		     $content !~ /\n\z/) ? "\n" : "",
  		);
  }
  
  
  sub dump
  {
      my($self, %opt) = @_;
      my $content = $self->content;
      my $chopped = 0;
      if (!ref($content)) {
  	my $maxlen = $opt{maxlength};
  	$maxlen = 512 unless defined($maxlen);
  	if ($maxlen && length($content) > $maxlen * 1.1 + 3) {
  	    $chopped = length($content) - $maxlen;
  	    $content = substr($content, 0, $maxlen) . "...";
  	}
  
  	$content =~ s/\\/\\\\/g;
  	$content =~ s/\t/\\t/g;
  	$content =~ s/\r/\\r/g;
  
  	# no need for 3 digits in escape for these
  	$content =~ s/([\0-\11\13-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
  	$content =~ s/([\0-\11\13-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
  	$content =~ s/([^\12\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
  	# remaining whitespace
  	$content =~ s/( +)\n/("\\40" x length($1)) . "\n"/eg;
  	$content =~ s/(\n+)\n/("\\n" x length($1)) . "\n"/eg;
  	$content =~ s/\n\z/\\n/;
  
  	my $no_content = $opt{no_content};
  	$no_content = "(no content)" unless defined $no_content;
  	if ($content eq $no_content) {
  	    # escape our $no_content marker
  	    $content =~ s/^(.)/sprintf('\\x%02X',ord($1))/eg;
  	}
  	elsif ($content eq "") {
  	    $content = $no_content;
  	}
      }
  
      my @dump;
      push(@dump, $opt{preheader}) if $opt{preheader};
      push(@dump, $self->{_headers}->as_string, $content);
      push(@dump, "(+ $chopped more bytes not shown)") if $chopped;
  
      my $dump = join("\n", @dump, "");
      $dump =~ s/^/$opt{prefix}/gm if $opt{prefix};
  
      print $dump unless defined wantarray;
      return $dump;
  }
  
  
  sub parts {
      my $self = shift;
      if (defined(wantarray) && (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR")) {
  	$self->_parts;
      }
      my $old = $self->{_parts};
      if (@_) {
  	my @parts = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	my $ct = $self->content_type || "";
  	if ($ct =~ m,^message/,) {
  	    Carp::croak("Only one part allowed for $ct content")
  		if @parts > 1;
  	}
  	elsif ($ct !~ m,^multipart/,) {
  	    $self->remove_content_headers;
  	    $self->content_type("multipart/mixed");
  	}
  	$self->{_parts} = \@parts;
  	_stale_content($self);
      }
      return @$old if wantarray;
      return $old->[0];
  }
  
  sub add_part {
      my $self = shift;
      if (($self->content_type || "") !~ m,^multipart/,) {
  	my $p = HTTP::Message->new($self->remove_content_headers,
  				   $self->content(""));
  	$self->content_type("multipart/mixed");
  	$self->{_parts} = [];
          if ($p->headers->header_field_names || $p->content ne "") {
              push(@{$self->{_parts}}, $p);
          }
      }
      elsif (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR") {
  	$self->_parts;
      }
  
      push(@{$self->{_parts}}, @_);
      _stale_content($self);
      return;
  }
  
  sub _stale_content {
      my $self = shift;
      if (ref($self->{_content}) eq "SCALAR") {
  	# must recalculate now
  	$self->_content;
      }
      else {
  	# just invalidate cache
  	delete $self->{_content};
  	delete $self->{_content_ref};
      }
  }
  
  
  # delegate all other method calls the the headers object.
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { local $Carp::Internal{+__PACKAGE__} = 1; shift->headers->$method(@_) };
      goto &$method;
  }
  
  
  sub DESTROY {}  # avoid AUTOLOADing it
  
  
  # Private method to access members in %$self
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = $_[0] if @_;
      return $old;
  }
  
  
  # Create private _parts attribute from current _content
  sub _parts {
      my $self = shift;
      my $ct = $self->content_type;
      if ($ct =~ m,^multipart/,) {
  	require HTTP::Headers::Util;
  	my @h = HTTP::Headers::Util::split_header_words($self->header("Content-Type"));
  	die "Assert" unless @h;
  	my %h = @{$h[0]};
  	if (defined(my $b = $h{boundary})) {
  	    my $str = $self->content;
  	    $str =~ s/\r?\n--\Q$b\E--.*//s;
  	    if ($str =~ s/(^|.*?\r?\n)--\Q$b\E\r?\n//s) {
  		$self->{_parts} = [map HTTP::Message->parse($_),
  				   split(/\r?\n--\Q$b\E\r?\n/, $str)]
  	    }
  	}
      }
      elsif ($ct eq "message/http") {
  	require HTTP::Request;
  	require HTTP::Response;
  	my $content = $self->content;
  	my $class = ($content =~ m,^(HTTP/.*)\n,) ?
  	    "HTTP::Response" : "HTTP::Request";
  	$self->{_parts} = [$class->parse($content)];
      }
      elsif ($ct =~ m,^message/,) {
  	$self->{_parts} = [ HTTP::Message->parse($self->content) ];
      }
  
      $self->{_parts} ||= [];
  }
  
  
  # Create private _content attribute from current _parts
  sub _content {
      my $self = shift;
      my $ct = $self->{_headers}->header("Content-Type") || "multipart/mixed";
      if ($ct =~ m,^\s*message/,i) {
  	_set_content($self, $self->{_parts}[0]->as_string($CRLF), 1);
  	return;
      }
  
      require HTTP::Headers::Util;
      my @v = HTTP::Headers::Util::split_header_words($ct);
      Carp::carp("Multiple Content-Type headers") if @v > 1;
      @v = @{$v[0]};
  
      my $boundary;
      my $boundary_index;
      for (my @tmp = @v; @tmp;) {
  	my($k, $v) = splice(@tmp, 0, 2);
  	if ($k eq "boundary") {
  	    $boundary = $v;
  	    $boundary_index = @v - @tmp - 1;
  	    last;
  	}
      }
  
      my @parts = map $_->as_string($CRLF), @{$self->{_parts}};
  
      my $bno = 0;
      $boundary = _boundary() unless defined $boundary;
   CHECK_BOUNDARY:
      {
  	for (@parts) {
  	    if (index($_, $boundary) >= 0) {
  		# must have a better boundary
  		$boundary = _boundary(++$bno);
  		redo CHECK_BOUNDARY;
  	    }
  	}
      }
  
      if ($boundary_index) {
  	$v[$boundary_index] = $boundary;
      }
      else {
  	push(@v, boundary => $boundary);
      }
  
      $ct = HTTP::Headers::Util::join_header_words(@v);
      $self->{_headers}->header("Content-Type", $ct);
  
      _set_content($self, "--$boundary$CRLF" .
  	                join("$CRLF--$boundary$CRLF", @parts) .
  			"$CRLF--$boundary--$CRLF",
                          1);
  }
  
  
  sub _boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Message - HTTP style message (base class)
  
  =head1 SYNOPSIS
  
   use base 'HTTP::Message';
  
  =head1 DESCRIPTION
  
  An C<HTTP::Message> object contains some headers and a content body.
  The following methods are available:
  
  =over 4
  
  =item $mess = HTTP::Message->new
  
  =item $mess = HTTP::Message->new( $headers )
  
  =item $mess = HTTP::Message->new( $headers, $content )
  
  This constructs a new message object.  Normally you would want
  construct C<HTTP::Request> or C<HTTP::Response> objects instead.
  
  The optional $header argument should be a reference to an
  C<HTTP::Headers> object or a plain array reference of key/value pairs.
  If an C<HTTP::Headers> object is provided then a copy of it will be
  embedded into the constructed message, i.e. it will not be owned and
  can be modified afterwards without affecting the message.
  
  The optional $content argument should be a string of bytes.
  
  =item $mess = HTTP::Message->parse( $str )
  
  This constructs a new message object by parsing the given string.
  
  =item $mess->headers
  
  Returns the embedded C<HTTP::Headers> object.
  
  =item $mess->headers_as_string
  
  =item $mess->headers_as_string( $eol )
  
  Call the as_string() method for the headers in the
  message.  This will be the same as
  
      $mess->headers->as_string
  
  but it will make your program a whole character shorter :-)
  
  =item $mess->content
  
  =item $mess->content( $bytes )
  
  The content() method sets the raw content if an argument is given.  If no
  argument is given the content is not touched.  In either case the
  original raw content is returned.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $mess->add_content( $bytes )
  
  The add_content() methods appends more data bytes to the end of the
  current content buffer.
  
  =item $mess->add_content_utf8( $string )
  
  The add_content_utf8() method appends the UTF-8 bytes representing the
  string to the end of the current content buffer.
  
  =item $mess->content_ref
  
  =item $mess->content_ref( \$bytes )
  
  The content_ref() method will return a reference to content buffer string.
  It can be more efficient to access the content this way if the content
  is huge, and it can even be used for direct manipulation of the content,
  for instance:
  
    ${$res->content_ref} =~ s/\bfoo\b/bar/g;
  
  This example would modify the content buffer in-place.
  
  If an argument is passed it will setup the content to reference some
  external source.  The content() and add_content() methods
  will automatically dereference scalar references passed this way.  For
  other references content() will return the reference itself and
  add_content() will refuse to do anything.
  
  =item $mess->content_charset
  
  This returns the charset used by the content in the message.  The
  charset is either found as the charset attribute of the
  C<Content-Type> header or by guessing.
  
  See L<http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding>
  for details about how charset is determined.
  
  =item $mess->decoded_content( %options )
  
  Returns the content with any C<Content-Encoding> undone and for textual content
  the raw content encoded to Perl's Unicode strings.  If the C<Content-Encoding>
  or C<charset> of the message is unknown this method will fail by returning
  C<undef>.
  
  The following options can be specified.
  
  =over
  
  =item C<charset>
  
  This override the charset parameter for text content.  The value
  C<none> can used to suppress decoding of the charset.
  
  =item C<default_charset>
  
  This override the default charset guessed by content_charset() or
  if that fails "ISO-8859-1".
  
  =item C<alt_charset>
  
  If decoding fails because the charset specified in the Content-Type header
  isn't recognized by Perl's Encode module, then try decoding using this charset
  instead of failing.  The C<alt_charset> might be specified as C<none> to simply
  return the string without any decoding of charset as alternative.
  
  =item C<charset_strict>
  
  Abort decoding if malformed characters is found in the content.  By
  default you get the substitution character ("\x{FFFD}") in place of
  malformed characters.
  
  =item C<raise_error>
  
  If TRUE then raise an exception if not able to decode content.  Reason
  might be that the specified C<Content-Encoding> or C<charset> is not
  supported.  If this option is FALSE, then decoded_content() will return
  C<undef> on errors, but will still set $@.
  
  =item C<ref>
  
  If TRUE then a reference to decoded content is returned.  This might
  be more efficient in cases where the decoded content is identical to
  the raw content as no data copying is required in this case.
  
  =back
  
  =item $mess->decodable
  
  =item HTTP::Message::decodable()
  
  This returns the encoding identifiers that decoded_content() can
  process.  In scalar context returns a comma separated string of
  identifiers.
  
  This value is suitable for initializing the C<Accept-Encoding> request
  header field.
  
  =item $mess->decode
  
  This method tries to replace the content of the message with the
  decoded version and removes the C<Content-Encoding> header.  Returns
  TRUE if successful and FALSE if not.
  
  If the message does not have a C<Content-Encoding> header this method
  does nothing and returns TRUE.
  
  Note that the content of the message is still bytes after this method
  has been called and you still need to call decoded_content() if you
  want to process its content as a string.
  
  =item $mess->encode( $encoding, ... )
  
  Apply the given encodings to the content of the message.  Returns TRUE
  if successful. The "identity" (non-)encoding is always supported; other
  currently supported encodings, subject to availability of required
  additional modules, are "gzip", "deflate", "x-bzip2" and "base64".
  
  A successful call to this function will set the C<Content-Encoding>
  header.
  
  Note that C<multipart/*> or C<message/*> messages can't be encoded and
  this method will croak if you try.
  
  =item $mess->parts
  
  =item $mess->parts( @parts )
  
  =item $mess->parts( \@parts )
  
  Messages can be composite, i.e. contain other messages.  The composite
  messages have a content type of C<multipart/*> or C<message/*>.  This
  method give access to the contained messages.
  
  The argumentless form will return a list of C<HTTP::Message> objects.
  If the content type of $msg is not C<multipart/*> or C<message/*> then
  this will return the empty list.  In scalar context only the first
  object is returned.  The returned message parts should be regarded as
  read-only (future versions of this library might make it possible
  to modify the parent by modifying the parts).
  
  If the content type of $msg is C<message/*> then there will only be
  one part returned.
  
  If the content type is C<message/http>, then the return value will be
  either an C<HTTP::Request> or an C<HTTP::Response> object.
  
  If a @parts argument is given, then the content of the message will be
  modified. The array reference form is provided so that an empty list
  can be provided.  The @parts array should contain C<HTTP::Message>
  objects.  The @parts objects are owned by $mess after this call and
  should not be modified or made part of other messages.
  
  When updating the message with this method and the old content type of
  $mess is not C<multipart/*> or C<message/*>, then the content type is
  set to C<multipart/mixed> and all other content headers are cleared.
  
  This method will croak if the content type is C<message/*> and more
  than one part is provided.
  
  =item $mess->add_part( $part )
  
  This will add a part to a message.  The $part argument should be
  another C<HTTP::Message> object.  If the previous content type of
  $mess is not C<multipart/*> then the old content (together with all
  content headers) will be made part #1 and the content type made
  C<multipart/mixed> before the new part is added.  The $part object is
  owned by $mess after this call and should not be modified or made part
  of other messages.
  
  There is no return value.
  
  =item $mess->clear
  
  Will clear the headers and set the content to the empty string.  There
  is no return value
  
  =item $mess->protocol
  
  =item $mess->protocol( $proto )
  
  Sets the HTTP protocol used for the message.  The protocol() is a string
  like C<HTTP/1.0> or C<HTTP/1.1>.
  
  =item $mess->clone
  
  Returns a copy of the message object.
  
  =item $mess->as_string
  
  =item $mess->as_string( $eol )
  
  Returns the message formatted as a single string.
  
  The optional $eol parameter specifies the line ending sequence to use.
  The default is "\n".  If no $eol is given then as_string will ensure
  that the returned string is newline terminated (even when the message
  content is not).  No extra newline is appended if an explicit $eol is
  passed.
  
  =item $mess->dump( %opt )
  
  Returns the message formatted as a string.  In void context print the string.
  
  This differs from C<< $mess->as_string >> in that it escapes the bytes
  of the content so that it's safe to print them and it limits how much
  content to print.  The escapes syntax used is the same as for Perl's
  double quoted strings.  If there is no content the string "(no
  content)" is shown in its place.
  
  Options to influence the output can be passed as key/value pairs. The
  following options are recognized:
  
  =over
  
  =item maxlength => $num
  
  How much of the content to show.  The default is 512.  Set this to 0
  for unlimited.
  
  If the content is longer then the string is chopped at the limit and
  the string "...\n(### more bytes not shown)" appended.
  
  =item no_content => $str
  
  Replaces the "(no content)" marker.
  
  =item prefix => $str
  
  A string that will be prefixed to each line of the dump.
  
  =back
  
  =back
  
  All methods unknown to C<HTTP::Message> itself are delegated to the
  C<HTTP::Headers> object that is part of every message.  This allows
  convenient access to these methods.  Refer to L<HTTP::Headers> for
  details of these methods:
  
      $mess->header( $field => $val )
      $mess->push_header( $field => $val )
      $mess->init_header( $field => $val )
      $mess->remove_header( $field )
      $mess->remove_content_headers
      $mess->header_field_names
      $mess->scan( \&doit )
  
      $mess->date
      $mess->expires
      $mess->if_modified_since
      $mess->if_unmodified_since
      $mess->last_modified
      $mess->content_type
      $mess->content_encoding
      $mess->content_length
      $mess->content_language
      $mess->title
      $mess->user_agent
      $mess->server
      $mess->from
      $mess->referer
      $mess->www_authenticate
      $mess->authorization
      $mess->proxy_authorization
      $mess->authorization_basic
      $mess->proxy_authorization_basic
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_MESSAGE

$fatpacked{"HTTP/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_REQUEST';
  package HTTP::Request;
  
  require HTTP::Message;
  @ISA = qw(HTTP::Message);
  $VERSION = "6.00";
  
  use strict;
  
  
  
  sub new
  {
      my($class, $method, $uri, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->method($method);
      $self->uri($uri);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $request_line;
      if ($str =~ s/^(.*)\n//) {
  	$request_line = $1;
      }
      else {
  	$request_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($method, $uri, $protocol) = split(' ', $request_line);
      $self->method($method) if defined($method);
      $self->uri($uri) if defined($uri);
      $self->protocol($protocol) if $protocol;
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->method($self->method);
      $clone->uri($self->uri);
      $clone;
  }
  
  
  sub method
  {
      shift->_elem('_method', @_);
  }
  
  
  sub uri
  {
      my $self = shift;
      my $old = $self->{'_uri'};
      if (@_) {
  	my $uri = shift;
  	if (!defined $uri) {
  	    # that's ok
  	}
  	elsif (ref $uri) {
  	    Carp::croak("A URI can't be a " . ref($uri) . " reference")
  		if ref($uri) eq 'HASH' or ref($uri) eq 'ARRAY';
  	    Carp::croak("Can't use a " . ref($uri) . " object as a URI")
  		unless $uri->can('scheme');
  	    $uri = $uri->clone;
  	    unless ($HTTP::URI_CLASS eq "URI") {
  		# Argh!! Hate this... old LWP legacy!
  		eval { local $SIG{__DIE__}; $uri = $uri->abs; };
  		die $@ if $@ && $@ !~ /Missing base argument/;
  	    }
  	}
  	else {
  	    $uri = $HTTP::URI_CLASS->new($uri);
  	}
  	$self->{'_uri'} = $uri;
          delete $self->{'_uri_canonical'};
      }
      $old;
  }
  
  *url = \&uri;  # legacy
  
  sub uri_canonical
  {
      my $self = shift;
      return $self->{'_uri_canonical'} ||= $self->{'_uri'}->canonical;
  }
  
  
  sub accept_decodable
  {
      my $self = shift;
      $self->header("Accept-Encoding", scalar($self->decodable));
  }
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $req_line = $self->method || "-";
      my $uri = $self->uri;
      $uri = (defined $uri) ? $uri->as_string : "-";
      $req_line .= " $uri";
      my $proto = $self->protocol;
      $req_line .= " $proto" if $proto;
  
      return join($eol, $req_line, $self->SUPER::as_string(@_));
  }
  
  sub dump
  {
      my $self = shift;
      my @pre = ($self->method || "-", $self->uri || "-");
      if (my $prot = $self->protocol) {
  	push(@pre, $prot);
      }
  
      return $self->SUPER::dump(
          preheader => join(" ", @pre),
  	@_,
      );
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request - HTTP style request message
  
  =head1 SYNOPSIS
  
   require HTTP::Request;
   $request = HTTP::Request->new(GET => 'http://www.example.com/');
  
  and usually used like this:
  
   $ua = LWP::UserAgent->new;
   $response = $ua->request($request);
  
  =head1 DESCRIPTION
  
  C<HTTP::Request> is a class encapsulating HTTP style requests,
  consisting of a request line, some headers, and a content body. Note
  that the LWP library uses HTTP style requests even for non-HTTP
  protocols.  Instances of this class are usually passed to the
  request() method of an C<LWP::UserAgent> object.
  
  C<HTTP::Request> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Request->new( $method, $uri )
  
  =item $r = HTTP::Request->new( $method, $uri, $header )
  
  =item $r = HTTP::Request->new( $method, $uri, $header, $content )
  
  Constructs a new C<HTTP::Request> object describing a request on the
  object $uri using method $method.  The $method argument must be a
  string.  The $uri argument can be either a string, or a reference to a
  C<URI> object.  The optional $header argument should be a reference to
  an C<HTTP::Headers> object or a plain array reference of key/value
  pairs.  The optional $content argument should be a string of bytes.
  
  =item $r = HTTP::Request->parse( $str )
  
  This constructs a new request object by parsing the given string.
  
  =item $r->method
  
  =item $r->method( $val )
  
  This is used to get/set the method attribute.  The method should be a
  short string like "GET", "HEAD", "PUT" or "POST".
  
  =item $r->uri
  
  =item $r->uri( $val )
  
  This is used to get/set the uri attribute.  The $val can be a
  reference to a URI object or a plain string.  If a string is given,
  then it should be parseable as an absolute URI.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->accept_decodable
  
  This will set the C<Accept-Encoding> header to the list of encodings
  that decoded_content() can decode.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Method returning a textual representation of the request.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Request::Common>,
  L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_REQUEST

$fatpacked{"HTTP/Request/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_REQUEST_COMMON';
  package HTTP::Request::Common;
  
  use strict;
  use vars qw(@EXPORT @EXPORT_OK $VERSION $DYNAMIC_FILE_UPLOAD);
  
  $DYNAMIC_FILE_UPLOAD ||= 0;  # make it defined (don't know why)
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT =qw(GET HEAD PUT POST);
  @EXPORT_OK = qw($DYNAMIC_FILE_UPLOAD DELETE);
  
  require HTTP::Request;
  use Carp();
  
  $VERSION = "6.04";
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  
  sub GET  { _simple_req('GET',  @_); }
  sub HEAD { _simple_req('HEAD', @_); }
  sub PUT  { _simple_req('PUT' , @_); }
  sub DELETE { _simple_req('DELETE', @_); }
  
  sub POST
  {
      my $url = shift;
      my $req = HTTP::Request->new(POST => $url);
      my $content;
      $content = shift if @_ and ref $_[0];
      my($k, $v);
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $content = $v;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      my $ct = $req->header('Content-Type');
      unless ($ct) {
  	$ct = 'application/x-www-form-urlencoded';
      }
      elsif ($ct eq 'form-data') {
  	$ct = 'multipart/form-data';
      }
  
      if (ref $content) {
  	if ($ct =~ m,^multipart/form-data\s*(;|$),i) {
  	    require HTTP::Headers::Util;
  	    my @v = HTTP::Headers::Util::split_header_words($ct);
  	    Carp::carp("Multiple Content-Type headers") if @v > 1;
  	    @v = @{$v[0]};
  
  	    my $boundary;
  	    my $boundary_index;
  	    for (my @tmp = @v; @tmp;) {
  		my($k, $v) = splice(@tmp, 0, 2);
  		if ($k eq "boundary") {
  		    $boundary = $v;
  		    $boundary_index = @v - @tmp - 1;
  		    last;
  		}
  	    }
  
  	    ($content, $boundary) = form_data($content, $boundary, $req);
  
  	    if ($boundary_index) {
  		$v[$boundary_index] = $boundary;
  	    }
  	    else {
  		push(@v, boundary => $boundary);
  	    }
  
  	    $ct = HTTP::Headers::Util::join_header_words(@v);
  	}
  	else {
  	    # We use a temporary URI object to format
  	    # the application/x-www-form-urlencoded content.
  	    require URI;
  	    my $url = URI->new('http:');
  	    $url->query_form(ref($content) eq "HASH" ? %$content : @$content);
  	    $content = $url->query;
  
  	    # HTML/4.01 says that line breaks are represented as "CR LF" pairs (i.e., `%0D%0A')
  	    $content =~ s/(?<!%0D)%0A/%0D%0A/g if defined($content);
  	}
      }
  
      $req->header('Content-Type' => $ct);  # might be redundant
      if (defined($content)) {
  	$req->header('Content-Length' =>
  		     length($content)) unless ref($content);
  	$req->content($content);
      }
      else {
          $req->header('Content-Length' => 0);
      }
      $req;
  }
  
  
  sub _simple_req
  {
      my($method, $url) = splice(@_, 0, 2);
      my $req = HTTP::Request->new($method => $url);
      my($k, $v);
      my $content;
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $req->add_content($v);
              $content++;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      if ($content && !defined($req->header("Content-Length"))) {
          $req->header("Content-Length", length(${$req->content_ref}));
      }
      $req;
  }
  
  
  sub form_data   # RFC1867
  {
      my($data, $boundary, $req) = @_;
      my @data = ref($data) eq "HASH" ? %$data : @$data;  # copy
      my $fhparts;
      my @parts;
      my($k,$v);
      while (($k,$v) = splice(@data, 0, 2)) {
  	if (!ref($v)) {
  	    $k =~ s/([\\\"])/\\$1/g;  # escape quotes and backslashes
  	    push(@parts,
  		 qq(Content-Disposition: form-data; name="$k"$CRLF$CRLF$v));
  	}
  	else {
  	    my($file, $usename, @headers) = @$v;
  	    unless (defined $usename) {
  		$usename = $file;
  		$usename =~ s,.*/,, if defined($usename);
  	    }
              $k =~ s/([\\\"])/\\$1/g;
  	    my $disp = qq(form-data; name="$k");
              if (defined($usename) and length($usename)) {
                  $usename =~ s/([\\\"])/\\$1/g;
                  $disp .= qq(; filename="$usename");
              }
  	    my $content = "";
  	    my $h = HTTP::Headers->new(@headers);
  	    if ($file) {
  		open(my $fh, "<", $file) or Carp::croak("Can't open file $file: $!");
  		binmode($fh);
  		if ($DYNAMIC_FILE_UPLOAD) {
  		    # will read file later, close it now in order to
                      # not accumulate to many open file handles
                      close($fh);
  		    $content = \$file;
  		}
  		else {
  		    local($/) = undef; # slurp files
  		    $content = <$fh>;
  		    close($fh);
  		}
  		unless ($h->header("Content-Type")) {
  		    require LWP::MediaTypes;
  		    LWP::MediaTypes::guess_media_type($file, $h);
  		}
  	    }
  	    if ($h->header("Content-Disposition")) {
  		# just to get it sorted first
  		$disp = $h->header("Content-Disposition");
  		$h->remove_header("Content-Disposition");
  	    }
  	    if ($h->header("Content")) {
  		$content = $h->header("Content");
  		$h->remove_header("Content");
  	    }
  	    my $head = join($CRLF, "Content-Disposition: $disp",
  			           $h->as_string($CRLF),
  			           "");
  	    if (ref $content) {
  		push(@parts, [$head, $$content]);
  		$fhparts++;
  	    }
  	    else {
  		push(@parts, $head . $content);
  	    }
  	}
      }
      return ("", "none") unless @parts;
  
      my $content;
      if ($fhparts) {
  	$boundary = boundary(10) # hopefully enough randomness
  	    unless $boundary;
  
  	# add the boundaries to the @parts array
  	for (1..@parts-1) {
  	    splice(@parts, $_*2-1, 0, "$CRLF--$boundary$CRLF");
  	}
  	unshift(@parts, "--$boundary$CRLF");
  	push(@parts, "$CRLF--$boundary--$CRLF");
  
  	# See if we can generate Content-Length header
  	my $length = 0;
  	for (@parts) {
  	    if (ref $_) {
  	 	my ($head, $f) = @$_;
  		my $file_size;
  		unless ( -f $f && ($file_size = -s _) ) {
  		    # The file is either a dynamic file like /dev/audio
  		    # or perhaps a file in the /proc file system where
  		    # stat may return a 0 size even though reading it
  		    # will produce data.  So we cannot make
  		    # a Content-Length header.  
  		    undef $length;
  		    last;
  		}
  	    	$length += $file_size + length $head;
  	    }
  	    else {
  		$length += length;
  	    }
          }
          $length && $req->header('Content-Length' => $length);
  
  	# set up a closure that will return content piecemeal
  	$content = sub {
  	    for (;;) {
  		unless (@parts) {
  		    defined $length && $length != 0 &&
  		    	Carp::croak "length of data sent did not match calculated Content-Length header.  Probably because uploaded file changed in size during transfer.";
  		    return;
  		}
  		my $p = shift @parts;
  		unless (ref $p) {
  		    $p .= shift @parts while @parts && !ref($parts[0]);
  		    defined $length && ($length -= length $p);
  		    return $p;
  		}
  		my($buf, $fh) = @$p;
                  unless (ref($fh)) {
                      my $file = $fh;
                      undef($fh);
                      open($fh, "<", $file) || Carp::croak("Can't open file $file: $!");
                      binmode($fh);
                  }
  		my $buflength = length $buf;
  		my $n = read($fh, $buf, 2048, $buflength);
  		if ($n) {
  		    $buflength += $n;
  		    unshift(@parts, ["", $fh]);
  		}
  		else {
  		    close($fh);
  		}
  		if ($buflength) {
  		    defined $length && ($length -= $buflength);
  		    return $buf 
  	    	}
  	    }
  	};
  
      }
      else {
  	$boundary = boundary() unless $boundary;
  
  	my $bno = 0;
        CHECK_BOUNDARY:
  	{
  	    for (@parts) {
  		if (index($_, $boundary) >= 0) {
  		    # must have a better boundary
  		    $boundary = boundary(++$bno);
  		    redo CHECK_BOUNDARY;
  		}
  	    }
  	    last;
  	}
  	$content = "--$boundary$CRLF" .
  	           join("$CRLF--$boundary$CRLF", @parts) .
  		   "$CRLF--$boundary--$CRLF";
      }
  
      wantarray ? ($content, $boundary) : $content;
  }
  
  
  sub boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request::Common - Construct common HTTP::Request objects
  
  =head1 SYNOPSIS
  
    use HTTP::Request::Common;
    $ua = LWP::UserAgent->new;
    $ua->request(GET 'http://www.sn.no/');
    $ua->request(POST 'http://somewhere/foo', [foo => bar, bar => foo]);
  
  =head1 DESCRIPTION
  
  This module provide functions that return newly created C<HTTP::Request>
  objects.  These functions are usually more convenient to use than the
  standard C<HTTP::Request> constructor for the most common requests.  The
  following functions are provided:
  
  =over 4
  
  =item GET $url
  
  =item GET $url, Header => Value,...
  
  The GET() function returns an C<HTTP::Request> object initialized with
  the "GET" method and the specified URL.  It is roughly equivalent to the
  following call
  
    HTTP::Request->new(
       GET => $url,
       HTTP::Headers->new(Header => Value,...),
    )
  
  but is less cluttered.  What is different is that a header named
  C<Content> will initialize the content part of the request instead of
  setting a header field.  Note that GET requests should normally not
  have a content, so this hack makes more sense for the PUT() and POST()
  functions described below.
  
  The get(...) method of C<LWP::UserAgent> exists as a shortcut for
  $ua->request(GET ...).
  
  =item HEAD $url
  
  =item HEAD $url, Header => Value,...
  
  Like GET() but the method in the request is "HEAD".
  
  The head(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(HEAD ...).
  
  =item PUT $url
  
  =item PUT $url, Header => Value,...
  
  =item PUT $url, Header => Value,..., Content => $content
  
  Like GET() but the method in the request is "PUT".
  
  The content of the request can be specified using the "Content"
  pseudo-header.  This steals a bit of the header field namespace as
  there is no way to directly specify a header that is actually called
  "Content".  If you really need this you must update the request
  returned in a separate statement.
  
  =item DELETE $url
  
  =item DELETE $url, Header => Value,...
  
  Like GET() but the method in the request is "DELETE".  This function
  is not exported by default.
  
  =item POST $url
  
  =item POST $url, Header => Value,...
  
  =item POST $url, $form_ref, Header => Value,...
  
  =item POST $url, Header => Value,..., Content => $form_ref
  
  =item POST $url, Header => Value,..., Content => $content
  
  This works mostly like PUT() with "POST" as the method, but this
  function also takes a second optional array or hash reference
  parameter $form_ref.  As for PUT() the content can also be specified
  directly using the "Content" pseudo-header, and you may also provide
  the $form_ref this way.
  
  The $form_ref argument can be used to pass key/value pairs for the
  form content.  By default we will initialize a request using the
  C<application/x-www-form-urlencoded> content type.  This means that
  you can emulate an HTML E<lt>form> POSTing like this:
  
    POST 'http://www.perl.org/survey.cgi',
         [ name   => 'Gisle Aas',
           email  => 'gisle@aas.no',
           gender => 'M',
           born   => '1964',
           perc   => '3%',
         ];
  
  This will create an HTTP::Request object that looks like this:
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 66
    Content-Type: application/x-www-form-urlencoded
  
    name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
  
  Multivalued form fields can be specified by either repeating the field
  name or by passing the value as an array reference.
  
  The POST method also supports the C<multipart/form-data> content used
  for I<Form-based File Upload> as specified in RFC 1867.  You trigger
  this content format by specifying a content type of C<'form-data'> as
  one of the request headers.  If one of the values in the $form_ref is
  an array reference, then it is treated as a file part specification
  with the following interpretation:
  
    [ $file, $filename, Header => Value... ]
    [ undef, $filename, Header => Value,..., Content => $content ]
  
  The first value in the array ($file) is the name of a file to open.
  This file will be read and its content placed in the request.  The
  routine will croak if the file can't be opened.  Use an C<undef> as
  $file value if you want to specify the content directly with a
  C<Content> header.  The $filename is the filename to report in the
  request.  If this value is undefined, then the basename of the $file
  will be used.  You can specify an empty string as $filename if you
  want to suppress sending the filename when you provide a $file value.
  
  If a $file is provided by no C<Content-Type> header, then C<Content-Type>
  and C<Content-Encoding> will be filled in automatically with the values
  returned by LWP::MediaTypes::guess_media_type()
  
  Sending my F<~/.profile> to the survey used as example above can be
  achieved by this:
  
    POST 'http://www.perl.org/survey.cgi',
         Content_Type => 'form-data',
         Content      => [ name  => 'Gisle Aas',
                           email => 'gisle@aas.no',
                           gender => 'M',
                           born   => '1964',
                           init   => ["$ENV{HOME}/.profile"],
                         ]
  
  This will create an HTTP::Request object that almost looks this (the
  boundary and the content of your F<~/.profile> is likely to be
  different):
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 388
    Content-Type: multipart/form-data; boundary="6G+f"
  
    --6G+f
    Content-Disposition: form-data; name="name"
  
    Gisle Aas
    --6G+f
    Content-Disposition: form-data; name="email"
  
    gisle@aas.no
    --6G+f
    Content-Disposition: form-data; name="gender"
  
    M
    --6G+f
    Content-Disposition: form-data; name="born"
  
    1964
    --6G+f
    Content-Disposition: form-data; name="init"; filename=".profile"
    Content-Type: text/plain
  
    PATH=/local/perl/bin:$PATH
    export PATH
  
    --6G+f--
  
  If you set the $DYNAMIC_FILE_UPLOAD variable (exportable) to some TRUE
  value, then you get back a request object with a subroutine closure as
  the content attribute.  This subroutine will read the content of any
  files on demand and return it in suitable chunks.  This allow you to
  upload arbitrary big files without using lots of memory.  You can even
  upload infinite files like F</dev/audio> if you wish; however, if
  the file is not a plain file, there will be no Content-Length header
  defined for the request.  Not all servers (or server
  applications) like this.  Also, if the file(s) change in size between
  the time the Content-Length is calculated and the time that the last
  chunk is delivered, the subroutine will C<Croak>.
  
  The post(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(POST ...).
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Request>, L<LWP::UserAgent>
  
  
  =head1 COPYRIGHT
  
  Copyright 1997-2004, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
HTTP_REQUEST_COMMON

$fatpacked{"HTTP/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_RESPONSE';
  package HTTP::Response;
  
  require HTTP::Message;
  @ISA = qw(HTTP::Message);
  $VERSION = "6.04";
  
  use strict;
  use HTTP::Status ();
  
  
  
  sub new
  {
      my($class, $rc, $msg, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->code($rc);
      $self->message($msg);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $status_line;
      if ($str =~ s/^(.*)\n//) {
  	$status_line = $1;
      }
      else {
  	$status_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($protocol, $code, $message);
      if ($status_line =~ /^\d{3} /) {
         # Looks like a response created by HTTP::Response->new
         ($code, $message) = split(' ', $status_line, 2);
      } else {
         ($protocol, $code, $message) = split(' ', $status_line, 3);
      }
      $self->protocol($protocol) if $protocol;
      $self->code($code) if defined($code);
      $self->message($message) if defined($message);
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->code($self->code);
      $clone->message($self->message);
      $clone->request($self->request->clone) if $self->request;
      # we don't clone previous
      $clone;
  }
  
  
  sub code      { shift->_elem('_rc',      @_); }
  sub message   { shift->_elem('_msg',     @_); }
  sub previous  { shift->_elem('_previous',@_); }
  sub request   { shift->_elem('_request', @_); }
  
  
  sub status_line
  {
      my $self = shift;
      my $code = $self->{'_rc'}  || "000";
      my $mess = $self->{'_msg'} || HTTP::Status::status_message($code) || "Unknown code";
      return "$code $mess";
  }
  
  
  sub base
  {
      my $self = shift;
      my $base = (
  	$self->header('Content-Base'),        # used to be HTTP/1.1
  	$self->header('Content-Location'),    # HTTP/1.1
  	$self->header('Base'),                # HTTP/1.0
      )[0];
      if ($base && $base =~ /^$URI::scheme_re:/o) {
  	# already absolute
  	return $HTTP::URI_CLASS->new($base);
      }
  
      my $req = $self->request;
      if ($req) {
          # if $base is undef here, the return value is effectively
          # just a copy of $self->request->uri.
          return $HTTP::URI_CLASS->new_abs($base, $req->uri);
      }
  
      # can't find an absolute base
      return undef;
  }
  
  
  sub redirects {
      my $self = shift;
      my @r;
      my $r = $self;
      while (my $p = $r->previous) {
          push(@r, $p);
          $r = $p;
      }
      return @r unless wantarray;
      return reverse @r;
  }
  
  
  sub filename
  {
      my $self = shift;
      my $file;
  
      my $cd = $self->header('Content-Disposition');
      if ($cd) {
  	require HTTP::Headers::Util;
  	if (my @cd = HTTP::Headers::Util::split_header_words($cd)) {
  	    my ($disposition, undef, %cd_param) = @{$cd[-1]};
  	    $file = $cd_param{filename};
  
  	    # RFC 2047 encoded?
  	    if ($file && $file =~ /^=\?(.+?)\?(.+?)\?(.+)\?=$/) {
  		my $charset = $1;
  		my $encoding = uc($2);
  		my $encfile = $3;
  
  		if ($encoding eq 'Q' || $encoding eq 'B') {
  		    local($SIG{__DIE__});
  		    eval {
  			if ($encoding eq 'Q') {
  			    $encfile =~ s/_/ /g;
  			    require MIME::QuotedPrint;
  			    $encfile = MIME::QuotedPrint::decode($encfile);
  			}
  			else { # $encoding eq 'B'
  			    require MIME::Base64;
  			    $encfile = MIME::Base64::decode($encfile);
  			}
  
  			require Encode;
  			require Encode::Locale;
  			Encode::from_to($encfile, $charset, "locale_fs");
  		    };
  
  		    $file = $encfile unless $@;
  		}
  	    }
  	}
      }
  
      unless (defined($file) && length($file)) {
  	my $uri;
  	if (my $cl = $self->header('Content-Location')) {
  	    $uri = URI->new($cl);
  	}
  	elsif (my $request = $self->request) {
  	    $uri = $request->uri;
  	}
  
  	if ($uri) {
  	    $file = ($uri->path_segments)[-1];
  	}
      }
  
      if ($file) {
  	$file =~ s,.*[\\/],,;  # basename
      }
  
      if ($file && !length($file)) {
  	$file = undef;
      }
  
      $file;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return join($eol, $status_line, $self->SUPER::as_string(@_));
  }
  
  
  sub dump
  {
      my $self = shift;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return $self->SUPER::dump(
  	preheader => $status_line,
          @_,
      );
  }
  
  
  sub is_info     { HTTP::Status::is_info     (shift->{'_rc'}); }
  sub is_success  { HTTP::Status::is_success  (shift->{'_rc'}); }
  sub is_redirect { HTTP::Status::is_redirect (shift->{'_rc'}); }
  sub is_error    { HTTP::Status::is_error    (shift->{'_rc'}); }
  
  
  sub error_as_HTML
  {
      my $self = shift;
      my $title = 'An Error Occurred';
      my $body  = $self->status_line;
      $body =~ s/&/&amp;/g;
      $body =~ s/</&lt;/g;
      return <<EOM;
  <html>
  <head><title>$title</title></head>
  <body>
  <h1>$title</h1>
  <p>$body</p>
  </body>
  </html>
  EOM
  }
  
  
  sub current_age
  {
      my $self = shift;
      my $time = shift;
  
      # Implementation of RFC 2616 section 13.2.3
      # (age calculations)
      my $response_time = $self->client_date;
      my $date = $self->date;
  
      my $age = 0;
      if ($response_time && $date) {
  	$age = $response_time - $date;  # apparent_age
  	$age = 0 if $age < 0;
      }
  
      my $age_v = $self->header('Age');
      if ($age_v && $age_v > $age) {
  	$age = $age_v;   # corrected_received_age
      }
  
      if ($response_time) {
  	my $request = $self->request;
  	if ($request) {
  	    my $request_time = $request->date;
  	    if ($request_time && $request_time < $response_time) {
  		# Add response_delay to age to get 'corrected_initial_age'
  		$age += $response_time - $request_time;
  	    }
  	}
  	$age += ($time || time) - $response_time;
      }
      return $age;
  }
  
  
  sub freshness_lifetime
  {
      my($self, %opt) = @_;
  
      # First look for the Cache-Control: max-age=n header
      for my $cc ($self->header('Cache-Control')) {
  	for my $cc_dir (split(/\s*,\s*/, $cc)) {
  	    return $1 if $cc_dir =~ /^max-age\s*=\s*(\d+)/i;
  	}
      }
  
      # Next possibility is to look at the "Expires" header
      my $date = $self->date || $self->client_date || $opt{time} || time;
      if (my $expires = $self->expires) {
  	return $expires - $date;
      }
  
      # Must apply heuristic expiration
      return undef if exists $opt{heuristic_expiry} && !$opt{heuristic_expiry};
  
      # Default heuristic expiration parameters
      $opt{h_min} ||= 60;
      $opt{h_max} ||= 24 * 3600;
      $opt{h_lastmod_fraction} ||= 0.10; # 10% since last-mod suggested by RFC2616
      $opt{h_default} ||= 3600;
  
      # Should give a warning if more than 24 hours according to
      # RFC 2616 section 13.2.4.  Here we just make this the default
      # maximum value.
  
      if (my $last_modified = $self->last_modified) {
  	my $h_exp = ($date - $last_modified) * $opt{h_lastmod_fraction};
  	return $opt{h_min} if $h_exp < $opt{h_min};
  	return $opt{h_max} if $h_exp > $opt{h_max};
  	return $h_exp;
      }
  
      # default when all else fails
      return $opt{h_min} if $opt{h_min} > $opt{h_default};
      return $opt{h_default};
  }
  
  
  sub is_fresh
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f > $self->current_age($opt{time});
  }
  
  
  sub fresh_until
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f - $self->current_age($opt{time}) + $opt{time};
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Response - HTTP style response message
  
  =head1 SYNOPSIS
  
  Response objects are returned by the request() method of the C<LWP::UserAgent>:
  
      # ...
      $response = $ua->request($request)
      if ($response->is_success) {
          print $response->decoded_content;
      }
      else {
          print STDERR $response->status_line, "\n";
      }
  
  =head1 DESCRIPTION
  
  The C<HTTP::Response> class encapsulates HTTP style responses.  A
  response consists of a response line, some headers, and a content
  body. Note that the LWP library uses HTTP style responses even for
  non-HTTP protocol schemes.  Instances of this class are usually
  created and returned by the request() method of an C<LWP::UserAgent>
  object.
  
  C<HTTP::Response> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Response->new( $code )
  
  =item $r = HTTP::Response->new( $code, $msg )
  
  =item $r = HTTP::Response->new( $code, $msg, $header )
  
  =item $r = HTTP::Response->new( $code, $msg, $header, $content )
  
  Constructs a new C<HTTP::Response> object describing a response with
  response code $code and optional message $msg.  The optional $header
  argument should be a reference to an C<HTTP::Headers> object or a
  plain array reference of key/value pairs.  The optional $content
  argument should be a string of bytes.  The meanings of these arguments are
  described below.
  
  =item $r = HTTP::Response->parse( $str )
  
  This constructs a new response object by parsing the given string.
  
  =item $r->code
  
  =item $r->code( $code )
  
  This is used to get/set the code attribute.  The code is a 3 digit
  number that encode the overall outcome of an HTTP response.  The
  C<HTTP::Status> module provide constants that provide mnemonic names
  for the code attribute.
  
  =item $r->message
  
  =item $r->message( $message )
  
  This is used to get/set the message attribute.  The message is a short
  human readable single line string that explains the response code.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the raw content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  =item $r->decoded_content( %options )
  
  This will return the content after any C<Content-Encoding> and
  charsets have been decoded.  See L<HTTP::Message> for details.
  
  =item $r->request
  
  =item $r->request( $request )
  
  This is used to get/set the request attribute.  The request attribute
  is a reference to the the request that caused this response.  It does
  not have to be the same request passed to the $ua->request() method,
  because there might have been redirects and authorization retries in
  between.
  
  =item $r->previous
  
  =item $r->previous( $response )
  
  This is used to get/set the previous attribute.  The previous
  attribute is used to link together chains of responses.  You get
  chains of responses if the first response is redirect or unauthorized.
  The value is C<undef> if this is the first response in a chain.
  
  Note that the method $r->redirects is provided as a more convenient
  way to access the response chain.
  
  =item $r->status_line
  
  Returns the string "E<lt>code> E<lt>message>".  If the message attribute
  is not set then the official name of E<lt>code> (see L<HTTP::Status>)
  is substituted.
  
  =item $r->base
  
  Returns the base URI for this response.  The return value will be a
  reference to a URI object.
  
  The base URI is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  Embedded in the document content, for instance <BASE HREF="...">
  in HTML documents.
  
  =item 2.
  
  A "Content-Base:" or a "Content-Location:" header in the response.
  
  For backwards compatibility with older HTTP implementations we will
  also look for the "Base:" header.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If none of these sources provide an absolute URI, undef is returned.
  
  When the LWP protocol modules produce the HTTP::Response object, then
  any base URI embedded in the document (step 1) will already have
  initialized the "Content-Base:" header. This means that this method
  only performs the last 2 steps (the content is not always available
  either).
  
  =item $r->filename
  
  Returns a filename for this response.  Note that doing sanity checks
  on the returned filename (eg. removing characters that cannot be used
  on the target filesystem where the filename would be used, and
  laundering it for security purposes) are the caller's responsibility;
  the only related thing done by this method is that it makes a simple
  attempt to return a plain filename with no preceding path segments.
  
  The filename is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  A "Content-Disposition:" header in the response.  Proper decoding of
  RFC 2047 encoded filenames requires the C<MIME::QuotedPrint> (for "Q"
  encoding), C<MIME::Base64> (for "B" encoding), and C<Encode> modules.
  
  =item 2.
  
  A "Content-Location:" header in the response.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If a filename cannot be derived from any of these sources, undef is
  returned.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Returns a textual representation of the response.
  
  =item $r->is_info
  
  =item $r->is_success
  
  =item $r->is_redirect
  
  =item $r->is_error
  
  These methods indicate if the response was informational, successful, a
  redirection, or an error.  See L<HTTP::Status> for the meaning of these.
  
  =item $r->error_as_HTML
  
  Returns a string containing a complete HTML document indicating what
  error occurred.  This method should only be called when $r->is_error
  is TRUE.
  
  =item $r->redirects
  
  Returns the list of redirect responses that lead up to this response
  by following the $r->previous chain.  The list order is oldest first.
  
  In scalar context return the number of redirect responses leading up
  to this one.
  
  =item $r->current_age
  
  Calculates the "current age" of the response as specified by RFC 2616
  section 13.2.3.  The age of a response is the time since it was sent
  by the origin server.  The returned value is a number representing the
  age in seconds.
  
  =item $r->freshness_lifetime( %opt )
  
  Calculates the "freshness lifetime" of the response as specified by
  RFC 2616 section 13.2.4.  The "freshness lifetime" is the length of
  time between the generation of a response and its expiration time.
  The returned value is the number of seconds until expiry.
  
  If the response does not contain an "Expires" or a "Cache-Control"
  header, then this function will apply some simple heuristic based on
  the "Last-Modified" header to determine a suitable lifetime.  The
  following options might be passed to control the heuristics:
  
  =over
  
  =item heuristic_expiry => $bool
  
  If passed as a FALSE value, don't apply heuristics and just return
  C<undef> when "Expires" or "Cache-Control" is lacking.
  
  =item h_lastmod_fraction => $num
  
  This number represent the fraction of the difference since the
  "Last-Modified" timestamp to make the expiry time.  The default is
  C<0.10>, the suggested typical setting of 10% in RFC 2616.
  
  =item h_min => $sec
  
  This is the lower limit of the heuristic expiry age to use.  The
  default is C<60> (1 minute).
  
  =item h_max => $sec
  
  This is the upper limit of the heuristic expiry age to use.  The
  default is C<86400> (24 hours).
  
  =item h_default => $sec
  
  This is the expiry age to use when nothing else applies.  The default
  is C<3600> (1 hour) or "h_min" if greater.
  
  =back
  
  =item $r->is_fresh( %opt )
  
  Returns TRUE if the response is fresh, based on the values of
  freshness_lifetime() and current_age().  If the response is no longer
  fresh, then it has to be re-fetched or re-validated by the origin
  server.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =item $r->fresh_until( %opt )
  
  Returns the time (seconds since epoch) when this entity is no longer fresh.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Status>, L<HTTP::Request>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_RESPONSE

$fatpacked{"HTTP/Status.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_STATUS';
  package HTTP::Status;
  
  use strict;
  require 5.002;   # because we use prototypes
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(is_info is_success is_redirect is_error status_message);
  @EXPORT_OK = qw(is_client_error is_server_error);
  $VERSION = "6.03";
  
  # Note also addition of mnemonics to @EXPORT below
  
  # Unmarked codes are from RFC 2616
  # See also: http://en.wikipedia.org/wiki/List_of_HTTP_status_codes
  
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      208 => 'Already Reported',		      # RFC 5842
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      418 => 'I\'m a teapot',		      # RFC 2324
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      428 => 'Precondition Required',
      429 => 'Too Many Requests',
      431 => 'Request Header Fields Too Large',
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
      511 => 'Network Authentication Required',
  );
  
  my $mnemonicCode = '';
  my ($code, $message);
  while (($code, $message) = each %StatusCode) {
      # create mnemonic subroutines
      $message =~ s/I'm/I am/;
      $message =~ tr/a-z \-/A-Z__/;
      $mnemonicCode .= "sub HTTP_$message () { $code }\n";
      $mnemonicCode .= "*RC_$message = \\&HTTP_$message;\n";  # legacy
      $mnemonicCode .= "push(\@EXPORT_OK, 'HTTP_$message');\n";
      $mnemonicCode .= "push(\@EXPORT, 'RC_$message');\n";
  }
  eval $mnemonicCode; # only one eval for speed
  die if $@;
  
  # backwards compatibility
  *RC_MOVED_TEMPORARILY = \&RC_FOUND;  # 302 was renamed in the standard
  push(@EXPORT, "RC_MOVED_TEMPORARILY");
  
  %EXPORT_TAGS = (
     constants => [grep /^HTTP_/, @EXPORT_OK],
     is => [grep /^is_/, @EXPORT, @EXPORT_OK],
  );
  
  
  sub status_message  ($) { $StatusCode{$_[0]}; }
  
  sub is_info         ($) { $_[0] >= 100 && $_[0] < 200; }
  sub is_success      ($) { $_[0] >= 200 && $_[0] < 300; }
  sub is_redirect     ($) { $_[0] >= 300 && $_[0] < 400; }
  sub is_error        ($) { $_[0] >= 400 && $_[0] < 600; }
  sub is_client_error ($) { $_[0] >= 400 && $_[0] < 500; }
  sub is_server_error ($) { $_[0] >= 500 && $_[0] < 600; }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Status - HTTP Status code processing
  
  =head1 SYNOPSIS
  
   use HTTP::Status qw(:constants :is status_message);
  
   if ($rc != HTTP_OK) {
       print status_message($rc), "\n";
   }
  
   if (is_success($rc)) { ... }
   if (is_error($rc)) { ... }
   if (is_redirect($rc)) { ... }
  
  =head1 DESCRIPTION
  
  I<HTTP::Status> is a library of routines for defining and
  classifying HTTP status codes for libwww-perl.  Status codes are
  used to encode the overall outcome of an HTTP response message.  Codes
  correspond to those defined in RFC 2616 and RFC 2518.
  
  =head1 CONSTANTS
  
  The following constant functions can be used as mnemonic status code
  names.  None of these are exported by default.  Use the C<:constants>
  tag to import them all.
  
     HTTP_CONTINUE                        (100)
     HTTP_SWITCHING_PROTOCOLS             (101)
     HTTP_PROCESSING                      (102)
  
     HTTP_OK                              (200)
     HTTP_CREATED                         (201)
     HTTP_ACCEPTED                        (202)
     HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
     HTTP_NO_CONTENT                      (204)
     HTTP_RESET_CONTENT                   (205)
     HTTP_PARTIAL_CONTENT                 (206)
     HTTP_MULTI_STATUS                    (207)
     HTTP_ALREADY_REPORTED		(208)
  
     HTTP_MULTIPLE_CHOICES                (300)
     HTTP_MOVED_PERMANENTLY               (301)
     HTTP_FOUND                           (302)
     HTTP_SEE_OTHER                       (303)
     HTTP_NOT_MODIFIED                    (304)
     HTTP_USE_PROXY                       (305)
     HTTP_TEMPORARY_REDIRECT              (307)
  
     HTTP_BAD_REQUEST                     (400)
     HTTP_UNAUTHORIZED                    (401)
     HTTP_PAYMENT_REQUIRED                (402)
     HTTP_FORBIDDEN                       (403)
     HTTP_NOT_FOUND                       (404)
     HTTP_METHOD_NOT_ALLOWED              (405)
     HTTP_NOT_ACCEPTABLE                  (406)
     HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
     HTTP_REQUEST_TIMEOUT                 (408)
     HTTP_CONFLICT                        (409)
     HTTP_GONE                            (410)
     HTTP_LENGTH_REQUIRED                 (411)
     HTTP_PRECONDITION_FAILED             (412)
     HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
     HTTP_REQUEST_URI_TOO_LARGE           (414)
     HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
     HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
     HTTP_EXPECTATION_FAILED              (417)
     HTTP_I_AM_A_TEAPOT			(418)
     HTTP_UNPROCESSABLE_ENTITY            (422)
     HTTP_LOCKED                          (423)
     HTTP_FAILED_DEPENDENCY               (424)
     HTTP_NO_CODE                         (425)
     HTTP_UPGRADE_REQUIRED                (426)
     HTTP_PRECONDITION_REQUIRED		(428)
     HTTP_TOO_MANY_REQUESTS		(429)
     HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE (431)
     HTTP_RETRY_WITH                      (449)
  
     HTTP_INTERNAL_SERVER_ERROR           (500)
     HTTP_NOT_IMPLEMENTED                 (501)
     HTTP_BAD_GATEWAY                     (502)
     HTTP_SERVICE_UNAVAILABLE             (503)
     HTTP_GATEWAY_TIMEOUT                 (504)
     HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
     HTTP_VARIANT_ALSO_NEGOTIATES         (506)
     HTTP_INSUFFICIENT_STORAGE            (507)
     HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)
     HTTP_NOT_EXTENDED                    (510)
     HTTP_NETWORK_AUTHENTICATION_REQUIRED (511)
  
  =head1 FUNCTIONS
  
  The following additional functions are provided.  Most of them are
  exported by default.  The C<:is> import tag can be used to import all
  the classification functions.
  
  =over 4
  
  =item status_message( $code )
  
  The status_message() function will translate status codes to human
  readable strings. The string is the same as found in the constant
  names above.  If the $code is unknown, then C<undef> is returned.
  
  =item is_info( $code )
  
  Return TRUE if C<$code> is an I<Informational> status code (1xx).  This
  class of status code indicates a provisional response which can't have
  any content.
  
  =item is_success( $code )
  
  Return TRUE if C<$code> is a I<Successful> status code (2xx).
  
  =item is_redirect( $code )
  
  Return TRUE if C<$code> is a I<Redirection> status code (3xx). This class of
  status code indicates that further action needs to be taken by the
  user agent in order to fulfill the request.
  
  =item is_error( $code )
  
  Return TRUE if C<$code> is an I<Error> status code (4xx or 5xx).  The function
  returns TRUE for both client and server error status codes.
  
  =item is_client_error( $code )
  
  Return TRUE if C<$code> is a I<Client Error> status code (4xx). This class
  of status code is intended for cases in which the client seems to have
  erred.
  
  This function is B<not> exported by default.
  
  =item is_server_error( $code )
  
  Return TRUE if C<$code> is a I<Server Error> status code (5xx). This class
  of status codes is intended for cases in which the server is aware
  that it has erred or is incapable of performing the request.
  
  This function is B<not> exported by default.
  
  =back
  
  =head1 BUGS
  
  For legacy reasons all the C<HTTP_> constants are exported by default
  with the prefix C<RC_>.  It's recommended to use explicit imports and
  the C<:constants> tag instead of relying on this.
HTTP_STATUS

$fatpacked{"IO/Pipely.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_PIPELY';
  package IO::Pipely;
  {
    $IO::Pipely::VERSION = '0.005';
  }
  
  use warnings;
  use strict;
  
  use Symbol qw(gensym);
  use IO::Socket qw(
    AF_UNIX
    PF_INET
    PF_UNSPEC
    SOCK_STREAM
    SOL_SOCKET
    SOMAXCONN
    SO_ERROR
    SO_REUSEADDR
    inet_aton
    pack_sockaddr_in
    unpack_sockaddr_in
  );
  use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
  use Errno qw(EINPROGRESS EWOULDBLOCK);
  
  our @EXPORT_OK = qw(pipely socketpairly);
  use base qw(Exporter);
  
  # The order of pipe primitives depends on the platform.
  
  # It's not always safe to assume that a function can be used if it's
  # present.
  
  my (@oneway_pipe_types, @twoway_pipe_types);
  if ($^O eq "MSWin32" or $^O eq "MacOS") {
    @oneway_pipe_types = qw(inet socketpair pipe);
    @twoway_pipe_types = qw(inet socketpair pipe);
  }
  elsif ($^O eq "cygwin") {
    @oneway_pipe_types = qw(pipe inet socketpair);
    @twoway_pipe_types = qw(inet pipe socketpair);
  }
  else {
    @oneway_pipe_types = qw(pipe socketpair inet);
    @twoway_pipe_types = qw(socketpair inet pipe);
  }
  
  # Provide dummy constants so things at least compile.  These constants
  # aren't used if we're RUNNING_IN_HELL, but Perl needs to see them.
  
  BEGIN {
    # older perls than 5.10 needs a kick in the arse to AUTOLOAD the constant...
    eval "F_GETFL" if $] < 5.010;
  
    if ( ! defined &Fcntl::F_GETFL ) {
      if ( ! defined prototype "F_GETFL" ) {
        *F_GETFL = sub { 0 };
        *F_SETFL = sub { 0 };
      } else {
        *F_GETFL = sub () { 0 };
        *F_SETFL = sub () { 0 };
      }
    }
  }
  
  # Make a socket.  This is a homebrew socketpair() for systems that
  # don't support it.  The things I must do to make Windows happy.
  
  sub _make_socket {
  
    ### Server side.
  
    my $acceptor = gensym();
    my $accepted = gensym();
  
    my $tcp = getprotobyname('tcp') or die "getprotobyname: $!";
    socket( $acceptor, PF_INET, SOCK_STREAM, $tcp ) or die "socket: $!";
  
    setsockopt( $acceptor, SOL_SOCKET, SO_REUSEADDR, 1) or die "reuse: $!";
  
    my $server_addr = inet_aton('127.0.0.1') or die "inet_aton: $!";
    $server_addr = pack_sockaddr_in(0, $server_addr)
      or die "sockaddr_in: $!";
  
    bind( $acceptor, $server_addr ) or die "bind: $!";
  
    $acceptor->blocking(0);
  
    $server_addr = getsockname($acceptor);
  
    listen( $acceptor, SOMAXCONN ) or die "listen: $!";
  
    ### Client side.
  
    my $connector = gensym();
  
    socket( $connector, PF_INET, SOCK_STREAM, $tcp ) or die "socket: $!";
  
    $connector->blocking(0);
  
    unless (connect( $connector, $server_addr )) {
      die "connect: $!" if $! and ($! != EINPROGRESS) and ($! != EWOULDBLOCK);
    }
  
    my $connector_address = getsockname($connector);
    my ($connector_port, $connector_addr) =
      unpack_sockaddr_in($connector_address);
  
    ### Loop around 'til it's all done.  I thought I was done writing
    ### select loops.  Damnit.
  
    my $in_read  = '';
    my $in_write = '';
  
    vec( $in_read,  fileno($acceptor),  1 ) = 1;
    vec( $in_write, fileno($connector), 1 ) = 1;
  
    my $done = 0;
    while ($done != 0x11) {
      my $hits = select( my $out_read   = $in_read,
                         my $out_write  = $in_write,
                         undef,
                         5
                       );
      unless ($hits) {
        next if ($! and ($! == EINPROGRESS) or ($! == EWOULDBLOCK));
        die "select: $!" unless $hits;
      }
  
      # Accept happened.
      if (vec($out_read, fileno($acceptor), 1)) {
        my $peer = accept($accepted, $acceptor);
        my ($peer_port, $peer_addr) = unpack_sockaddr_in($peer);
  
        if ( $peer_port == $connector_port and
             $peer_addr eq $connector_addr
           ) {
          vec($in_read, fileno($acceptor), 1) = 0;
          $done |= 0x10;
        }
      }
  
      # Connect happened.
      if (vec($out_write, fileno($connector), 1)) {
        $! = unpack('i', getsockopt($connector, SOL_SOCKET, SO_ERROR));
        die "connect: $!" if $!;
  
        vec($in_write, fileno($connector), 1) = 0;
        $done |= 0x01;
      }
    }
  
    # Turn blocking back on, damnit.
    $accepted->blocking(1);
    $connector->blocking(1);
  
    return ($accepted, $connector);
  }
  
  sub pipely {
    my %arg = @_;
  
    my $conduit_type = delete($arg{type});
    my $debug        = delete($arg{debug}) || 0;
  
    # Generate symbols to be used as filehandles for the pipe's ends.
    #
    # Filehandle autovivification isn't used for portability with older
    # versions of Perl.
  
    my ($a_read, $b_write)  = (gensym(), gensym());
  
    # Try the specified conduit type only.  No fallback.
  
    if (defined $conduit_type) {
      return ($a_read, $b_write) if _try_oneway_type(
        $conduit_type, $debug, \$a_read, \$b_write
      );
    }
  
    # Otherwise try all available conduit types until one works.
    # Conduit types that fail are discarded for speed.
  
    while (my $try_type = $oneway_pipe_types[0]) {
      return ($a_read, $b_write) if _try_oneway_type(
        $try_type, $debug, \$a_read, \$b_write
      );
      shift @oneway_pipe_types;
    }
  
    # There's no conduit type left.  Bummer!
  
    $debug and warn "nothing worked";
    return;
  }
  
  sub socketpairly {
    my %arg = @_;
  
    my $conduit_type = delete($arg{type});
    my $debug        = delete($arg{debug}) || 0;
  
    # Generate symbols to be used as filehandles for the pipe's ends.
    #
    # Filehandle autovivification isn't used for portability with older
    # versions of Perl.
  
    my ($a_read, $a_write) = (gensym(), gensym());
    my ($b_read, $b_write) = (gensym(), gensym());
  
    if (defined $conduit_type) {
      return ($a_read, $a_write, $b_read, $b_write) if _try_twoway_type(
        $conduit_type, $debug,
        \$a_read, \$a_write,
        \$b_read, \$b_write
      );
    }
  
    while (my $try_type = $twoway_pipe_types[0]) {
      return ($a_read, $a_write, $b_read, $b_write) if _try_twoway_type(
        $try_type, $debug,
        \$a_read, \$a_write,
        \$b_read, \$b_write
      );
      shift @oneway_pipe_types;
    }
  
    # There's no conduit type left.  Bummer!
  
    $debug and warn "nothing worked";
    return;
  }
  
  # Try a pipe by type.
  
  sub _try_oneway_type {
    my ($type, $debug, $a_read, $b_write) = @_;
  
    # Try a pipe().
    if ($type eq "pipe") {
      eval {
        pipe($$a_read, $$b_write) or die "pipe failed: $!";
      };
  
      # Pipe failed.
      if (length $@) {
        warn "pipe failed: $@" if $debug;
        return;
      }
  
      $debug and do {
        warn "using a pipe";
        warn "ar($$a_read) bw($$b_write)\n";
      };
  
      # Turn off buffering.  POE::Kernel does this for us, but
      # someone might want to use the pipe class elsewhere.
      select((select($$b_write), $| = 1)[0]);
      return 1;
    }
  
    # Try a UNIX-domain socketpair.
    if ($type eq "socketpair") {
      eval {
        socketpair($$a_read, $$b_write, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
          or die "socketpair failed: $!";
      };
  
      if (length $@) {
        warn "socketpair failed: $@" if $debug;
        return;
      }
  
      $debug and do {
        warn "using a UNIX domain socketpair";
        warn "ar($$a_read) bw($$b_write)\n";
      };
  
      # It's one-way, so shut down the unused directions.
      shutdown($$a_read,  1);
      shutdown($$b_write, 0);
  
      # Turn off buffering.  POE::Kernel does this for us, but someone
      # might want to use the pipe class elsewhere.
      select((select($$b_write), $| = 1)[0]);
      return 1;
    }
  
    # Try a pair of plain INET sockets.
    if ($type eq "inet") {
      eval {
        ($$a_read, $$b_write) = _make_socket();
      };
  
      if (length $@) {
        warn "make_socket failed: $@" if $debug;
        return;
      }
  
      $debug and do {
        warn "using a plain INET socket";
        warn "ar($$a_read) bw($$b_write)\n";
      };
  
      # It's one-way, so shut down the unused directions.
      shutdown($$a_read,  1);
      shutdown($$b_write, 0);
  
      # Turn off buffering.  POE::Kernel does this for us, but someone
      # might want to use the pipe class elsewhere.
      select((select($$b_write), $| = 1)[0]);
      return 1;
    }
  
    # There's nothing left to try.
    $debug and warn "unknown pipely() socket type ``$type''";
    return;
  }
  
  # Try a pipe by type.
  
  sub _try_twoway_type {
    my ($type, $debug, $a_read, $a_write, $b_read, $b_write) = @_;
  
    # Try a socketpair().
    if ($type eq "socketpair") {
      eval {
        socketpair($$a_read, $$b_read, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
          or die "socketpair 1 failed: $!";
      };
  
      # Socketpair failed.
      if (length $@) {
        warn "socketpair failed: $@" if $debug;
        return;
      }
  
      $debug and do {
        warn "using UNIX domain socketpairs";
        warn "ar($$a_read) aw($$a_write) br($$b_read) bw($$b_write)\n";
      };
  
      # It's two-way, so each reader is also a writer.
      $$a_write = $$a_read;
      $$b_write = $$b_read;
  
      # Turn off buffering.  POE::Kernel does this for us, but someone
      # might want to use the pipe class elsewhere.
      select((select($$a_write), $| = 1)[0]);
      select((select($$b_write), $| = 1)[0]);
      return 1;
    }
  
    # Try a couple pipe() calls.
    if ($type eq "pipe") {
      eval {
        pipe($$a_read, $$b_write) or die "pipe 1 failed: $!";
        pipe($$b_read, $$a_write) or die "pipe 2 failed: $!";
      };
  
      # Pipe failed.
      if (length $@) {
        warn "pipe failed: $@" if $debug;
        return;
      }
  
      $debug and do {
        warn "using a pipe";
        warn "ar($$a_read) aw($$a_write) br($$b_read) bw($$b_write)\n";
      };
  
      # Turn off buffering.  POE::Kernel does this for us, but someone
      # might want to use the pipe class elsewhere.
      select((select($$a_write), $| = 1)[0]);
      select((select($$b_write), $| = 1)[0]);
      return 1;
    }
  
    # Try a pair of plain INET sockets.
    if ($type eq "inet") {
      eval {
        ($$a_read, $$b_read) = _make_socket();
      };
  
      # Sockets failed.
      if (length $@) {
        warn "make_socket failed: $@" if $debug;
        return;
      }
  
      $debug and do {
        warn "using a plain INET socket";
        warn "ar($$a_read) aw($$a_write) br($$b_read) bw($$b_write)\n";
      };
  
      $$a_write = $$a_read;
      $$b_write = $$b_read;
  
      # Turn off buffering.  POE::Kernel does this for us, but someone
      # might want to use the pipe class elsewhere.
      select((select($$a_write), $| = 1)[0]);
      select((select($$b_write), $| = 1)[0]);
      return 1;
    }
  
    $debug and warn "unknown pipely(2) socket type ``$type''";
    return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Pipely - Portably create pipe() or pipe-like handles, one way or another.
  
  =head1 VERSION
  
  version 0.005
  
  =head1 SYNOPSIS
  
  Please read DESCRIPTION for detailed semantics and caveats.
  
    use IO::Pipely qw(pipely socketpairly);
  
    # Create a one-directional pipe() or pipe-like thing
    # the best conduit type available.
  
    my ($read, $write) = pipely();
  
    # Create a one-directional pipe-like thing using an
    # INET socket specifically.  Other types are available.
  
    my ($read, $write) = pipely(type => 'inet');
  
    # Create a bidirectional pipe-like thing using
    # the best conduit type available.
  
    my (
      $side_a_read,  $side_b_read,
      $side_a_write, $side_b_write,
    ) = socketpairly();
  
    # Create a bidirectional pipe-like thing using an INET socket
    # specifically.
  
    my (
      $side_a_read,  $side_b_read,
      $side_a_write, $side_b_write,
    ) = socketpairly(type => 'inet');
  
  =head1 DESCRIPTION
  
  Pipes are troublesome beasts because there are a few different,
  incompatible ways to create them.  Not all platforms support all ways,
  and some platforms may have hidden difficulties like incomplete or
  buggy support.
  
  IO::Pipely provides a couple functions to portably create one- and
  two-way pipes and pipe-like socket pairs.  It acknowledges and works
  around known platform issues so you don't have to.
  
  On the other hand, it doesn't work around unknown issues, so please
  report any problems early and often.
  
  IO::Pipely currently understands pipe(), UNIX-domain socketpair() and
  regular IPv4 localhost sockets.  This covers every platform tested so
  far, but it's hardly complete.  Please help support other mechanisms,
  such as INET-domain socketpair() and IPv6 localhost sockets.
  
  IO::Pipely will use different kinds of pipes or sockets depending on
  the operating system's capabilities and the number of directions
  requested.  The autodetection may be overridden by specifying a
  particular pipe type.
  
  =head2 pipely
  
  pipely() creates a one-directional pipe() or socket.  It's modeled
  after Perl's built-in pipe() function, but it creates and returns
  handles rather than opening ones given to it.
  
  On success, pipely() returns two file handles, the first to read from
  the pipe, and the second writes into the pipe.  It returns nothing on
  failure.
  
    use IO::Pipely qw(pipely);
    my ($a_read, $b_write) = pipely();
    die "pipely() failed: $!" unless $a_read;
  
  When given a choice, it will prefer to use leaner pipe() calls instead
  of socketpair() and socket().
  
  pipely()'s choice can be forced using an optional named "type"
  parameter.  See L</PIPE TYPES> for the types that can be used.
  
    my ($a_read, $b_write) = pipely(
      type => 'pipe',
    );
  
  On most systems, pipely() will prefer to open a pipe() first.  It will
  fall back to a UNIX socketpair() or two localhost Internet sockets, in
  that order.
  
  On Windows (ActiveState and Strawberry Perl), pipely() prefers two
  localhost Internet sockets.  It will fall back to socketpair() and
  pipe(), both of which will probably fail.
  
  Cygwin Perl prefers pipe() first, localhost Internet sockets, and then
  socketpair().  socketpair() has been known to have problems on Cygwin.
  
  MacPerl (MacOS 9 and earlier) has similar capaibilities to Windows.
  
  =head2 socketpairly
  
  socketpairly() creates a two-directional socket pair.  It's modeled
  after Perl's built-in socketpair(), but it creates and returns handles
  rather than opening ones given to it.
  
  On success, socketpairly() returns four file handles, read and write
  for one end, and read and write for the other.  On failure, it returns
  nothing.
  
    use IO::Pipely qw(socketpairly);
    my ($a_read, $b_read, $a_write, $b_write) = socketpairly();
    die "socketpairly() failed: $!" unless $a_read;
  
  socketpairly() returns two extra "writer" handles.  They exist for the
  fallback case where two pipe() calls are needed instead of one socket
  pair.  The extra handles can be ignored whenever pipe() will never be
  used.  For example:
  
    use IO::Pipely qw(socketpairly);
    my ($side_a, $side_b) = socketpairly( type => 'socketpair' );
    die "socketpairly() failed: $!" unless $side_a;
  
  When given a choice, it will prefer bidirectional sockets instead of
  pipe() calls.
  
  socketpairly()'s choice can be forced using an optional named "type"
  parameter.  See L</PIPE TYPES> for the types that can be used.  In
  this example, two unidirectional pipes wil be used instead of a more
  efficient pair of sockets:
  
    my ($a_read, $a_write, $b_read, $b_write) = pipely(
      type => 'pipe',
    );
  
  On most systems, socketpairly() will try to open a UNIX socketpair()
  first.  It will then fall back to a pair of localhost Internet
  sockets, and finally it will try a pair of pipe() calls.
  
  On Windows (ActiveState and Strawberry Perl), socketpairly() prefers a
  pair of localhost Internet sockets first.  It will then fall back to a
  UNIX socketpair(), and finally a couple of pipe() calls.  The fallback
  options will probably fail, but the code remains hopeful.
  
  Cygwin Perl prefers localhost Internet sockets first, followed by a
  pair of pipe() calls, and finally a UNIX socketpair().  Those who know
  may find this counter-intuitive, but it works around known issues in
  some versions of Cygwin socketpair().
  
  MacPerl (MacOS 9 and earlier) has similar capaibilities to Windows.
  
  =head2 PIPE TYPES
  
  IO::Pipely currently supports three types of pipe and socket.  Other
  types are possible, but these three cover all known uses so far.
  Please ask (or send patches) if additional types are needed.
  
  =head3 pipe
  
  Attempt to establish a one-way pipe using one pipe() filehandle pair
  (2 file descriptors), or a two-way pipe-like connection using two
  pipe() pairs (4 file descriptors).
  
  IO::Pipely prefers to use pipe() for one-way pipes and some form of
  socket pair for two-way pipelike things.
  
  =head3 socketpair
  
  Attempt to establish a one- or two-way pipelike connection using a
  single socketpair() call.  This uses two file descriptors regardless
  whether the connection is one- or two-way.
  
  IO::Pipely prefers socketpair() for two-way connections, unless the
  current platform has known issues with the socketpair() call.
  
  Socket pairs are UNIX domain only for now.  INET domain may be added
  if it improves compatibility on some platform, or if someone
  contributes the code.
  
  =head3 inet
  
  Attempt to establish a one- or two-way pipelike connection using
  localhost socket() calls.  This uses two file descriptors regardless
  whether the connection is one- or two-way.
  
  Localhost INET domain sockets are a last resort for platforms that
  don't support something better.  They are the least secure method of
  communication since tools like tcpdump and Wireshark can tap into
  them.  On the other hand, this makes them easiest to debug.
  
  =head1 KNOWN ISSUES
  
  These are issues known to the developers at the time of this writing.
  Things change, so check back now and then.
  
  =head2 Cygwin
  
  CygWin seems to have a problem with socketpair() and exec().  When
  an exec'd process closes, any data on sockets created with
  socketpair() is not flushed.  From irc.perl.org channel #poe:
  
    <dngnand>   Sounds like a lapse in cygwin's exec implementation.
                It works ok under Unix-ish systems?
    <jdeluise2> yes, it works perfectly
    <jdeluise2> but, if we just use POE::Pipe::TwoWay->new("pipe")
                it always works fine on cygwin
    <jdeluise2> by the way, it looks like the reason is that
                POE::Pipe::OneWay works because it tries to make a
                pipe first instead of a socketpair
    <jdeluise2> this socketpair problem seems like a long-standing
                one with cygwin, according to searches on google,
                but never been fixed.
  
  =head2 MacOS 9
  
  IO::Pipely supports MacOS 9 for historical reasons.
  It's unclear whether anyone still uses MacPerl, but the support is
  cheap since pipes and sockets there have many of the same caveats as
  they do on Windows.
  
  =head2 Symbol::gensym
  
  IO::Pipely uses Symbol::gensym() instead of autovivifying file
  handles.  The main reasons against gensym() have been stylistic ones
  so far.  Meanwhile, gensym() is compatible farther back than handle
  autovivification.
  
  =head2 Windows
  
  ActiveState and Strawberry Perl don't support pipe() or UNIX
  socketpair().  Localhost Internet sockets are used for everything
  there, including one-way pipes.
  
  For one-way pipes, the unused socket directions are shut down to avoid
  sending data the wrong way through them.  Use socketpairly() instead.
  
  =head1 BUGS
  
  The functions implemented here die outright upon failure, requiring
  eval{} around their calls.
  
  The following conduit types are currently unsupported because nobody
  has needed them so far.  Please submit a request (and/or a patch) if
  any of these is needed:
  
    UNIX socket()
    INET-domain socketpair()
    IPv4-specific localhost sockets
    IPv6-specific localhost sockets
  
  =head1 AUTHOR & COPYRIGHT
  
  IO::Pipely is copyright 2000-2013 by Rocco Caputo.
  All rights reserved.
  IO::Pipely is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 HISTORY
  
  IO::Pipely is a spin-off of the L<POE> project's portable pipes.
  Earlier versions of the code have been tested and used in production
  systems for over a decade.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
IO_PIPELY

$fatpacked{"IRC/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IRC_UTILS';
  package IRC::Utils;
  BEGIN {
    $IRC::Utils::AUTHORITY = 'cpan:HINRIK';
  }
  BEGIN {
    $IRC::Utils::VERSION = '0.12';
  }
  
  use strict;
  use warnings FATAL => 'all';
  
  use Encode qw(decode);
  use Encode::Guess;
  
  require Exporter;
  use base qw(Exporter);
  our @EXPORT_OK = qw(
      uc_irc lc_irc parse_mode_line normalize_mask matches_mask matches_mask_array
      unparse_mode_line gen_mode_change parse_user is_valid_nick_name eq_irc
      decode_irc is_valid_chan_name has_color has_formatting strip_color
      strip_formatting NORMAL BOLD UNDERLINE REVERSE ITALIC FIXED WHITE BLACK
      BLUE GREEN RED BROWN PURPLE ORANGE YELLOW LIGHT_GREEN TEAL LIGHT_CYAN
      LIGHT_BLUE PINK GREY LIGHT_GREY numeric_to_name name_to_numeric
  );
  our %EXPORT_TAGS = ( ALL => [@EXPORT_OK] );
  
  use constant {
      # cancel all formatting and colors
      NORMAL      => "\x0f",
  
      # formatting
      BOLD        => "\x02",
      UNDERLINE   => "\x1f",
      REVERSE     => "\x16",
      ITALIC      => "\x1d",
      FIXED       => "\x11",
      BLINK       => "\x06",
  
      # mIRC colors
      WHITE       => "\x0300",
      BLACK       => "\x0301",
      BLUE        => "\x0302",
      GREEN       => "\x0303",
      RED         => "\x0304",
      BROWN       => "\x0305",
      PURPLE      => "\x0306",
      ORANGE      => "\x0307",
      YELLOW      => "\x0308",
      LIGHT_GREEN => "\x0309",
      TEAL        => "\x0310",
      LIGHT_CYAN  => "\x0311",
      LIGHT_BLUE  => "\x0312",
      PINK        => "\x0313",
      GREY        => "\x0314",
      LIGHT_GREY  => "\x0315",
  };
  
  # list originally snatched from AnyEvent::IRC::Util
  our %NUMERIC2NAME = (
     '001' => 'RPL_WELCOME',           # RFC2812
     '002' => 'RPL_YOURHOST',          # RFC2812
     '003' => 'RPL_CREATED',           # RFC2812
     '004' => 'RPL_MYINFO',            # RFC2812
     '005' => 'RPL_ISUPPORT',          # draft-brocklesby-irc-isupport-03
     '008' => 'RPL_SNOMASK',           # Undernet
     '009' => 'RPL_STATMEMTOT',        # Undernet
     '010' => 'RPL_STATMEM',           # Undernet
     '020' => 'RPL_CONNECTING',        # IRCnet
     '014' => 'RPL_YOURCOOKIE',        # IRCnet
     '042' => 'RPL_YOURID',            # IRCnet
     '043' => 'RPL_SAVENICK',          # IRCnet
     '050' => 'RPL_ATTEMPTINGJUNC',    # aircd
     '051' => 'RPL_ATTEMPTINGREROUTE', # aircd
     '200' => 'RPL_TRACELINK',         # RFC1459
     '201' => 'RPL_TRACECONNECTING',   # RFC1459
     '202' => 'RPL_TRACEHANDSHAKE',    # RFC1459
     '203' => 'RPL_TRACEUNKNOWN',      # RFC1459
     '204' => 'RPL_TRACEOPERATOR',     # RFC1459
     '205' => 'RPL_TRACEUSER',         # RFC1459
     '206' => 'RPL_TRACESERVER',       # RFC1459
     '207' => 'RPL_TRACESERVICE',      # RFC2812
     '208' => 'RPL_TRACENEWTYPE',      # RFC1459
     '209' => 'RPL_TRACECLASS',        # RFC2812
     '210' => 'RPL_STATS',             # aircd
     '211' => 'RPL_STATSLINKINFO',     # RFC1459
     '212' => 'RPL_STATSCOMMANDS',     # RFC1459
     '213' => 'RPL_STATSCLINE',        # RFC1459
     '214' => 'RPL_STATSNLINE',        # RFC1459
     '215' => 'RPL_STATSILINE',        # RFC1459
     '216' => 'RPL_STATSKLINE',        # RFC1459
     '217' => 'RPL_STATSQLINE',        # RFC1459
     '218' => 'RPL_STATSYLINE',        # RFC1459
     '219' => 'RPL_ENDOFSTATS',        # RFC1459
     '221' => 'RPL_UMODEIS',           # RFC1459
     '231' => 'RPL_SERVICEINFO',       # RFC1459
     '233' => 'RPL_SERVICE',           # RFC1459
     '234' => 'RPL_SERVLIST',          # RFC1459
     '235' => 'RPL_SERVLISTEND',       # RFC1459
)->run();     '239' => 'RPL_STATSIAUTH',        # IRCnet
     '241' => 'RPL_STATSLLINE',        # RFC1459
     '242' => 'RPL_STATSUPTIME',       # RFC1459
     '243' => 'RPL_STATSOLINE',        # RFC1459
     '244' => 'RPL_STATSHLINE',        # RFC1459
     '245' => 'RPL_STATSSLINE',        # Bahamut, IRCnet, Hybrid
     '250' => 'RPL_STATSCONN',         # ircu, Unreal
     '251' => 'RPL_LUSERCLIENT',       # RFC1459
     '252' => 'RPL_LUSEROP',           # RFC1459
     '253' => 'RPL_LUSERUNKNOWN',      # RFC1459
     '254' => 'RPL_LUSERCHANNELS',     # RFC1459
     '255' => 'RPL_LUSERME',           # RFC1459
     '256' => 'RPL_ADMINME',           # RFC1459
     '257' => 'RPL_ADMINLOC1',         # RFC1459
     '258' => 'RPL_ADMINLOC2',         # RFC1459
     '259' => 'RPL_ADMINEMAIL',        # RFC1459
     '261' => 'RPL_TRACELOG',          # RFC1459
     '262' => 'RPL_TRACEEND',          # RFC2812
     '263' => 'RPL_TRYAGAIN',          # RFC2812
     '265' => 'RPL_LOCALUSERS',        # aircd, Bahamut, Hybrid
     '266' => 'RPL_GLOBALUSERS',       # aircd, Bahamut, Hybrid
     '267' => 'RPL_START_NETSTAT',     # aircd
     '268' => 'RPL_NETSTAT',           # aircd
     '269' => 'RPL_END_NETSTAT',       # aircd
     '270' => 'RPL_PRIVS',             # ircu
     '271' => 'RPL_SILELIST',          # ircu
     '272' => 'RPL_ENDOFSILELIST',     # ircu
     '300' => 'RPL_NONE',              # RFC1459
     '301' => 'RPL_AWAY',              # RFC1459
     '302' => 'RPL_USERHOST',          # RFC1459
     '303' => 'RPL_ISON',              # RFC1459
     '305' => 'RPL_UNAWAY',            # RFC1459
     '306' => 'RPL_NOWAWAY',           # RFC1459
     '307' => 'RPL_WHOISREGNICK',      # Bahamut, Unreal, Plexus
     '310' => 'RPL_WHOISMODES',        # Plexus
     '311' => 'RPL_WHOISUSER',         # RFC1459
     '312' => 'RPL_WHOISSERVER',       # RFC1459
     '313' => 'RPL_WHOISOPERATOR',     # RFC1459
     '314' => 'RPL_WHOWASUSER',        # RFC1459
     '315' => 'RPL_ENDOFWHO',          # RFC1459
     '317' => 'RPL_WHOISIDLE',         # RFC1459
     '318' => 'RPL_ENDOFWHOIS',        # RFC1459
     '319' => 'RPL_WHOISCHANNELS',     # RFC1459
     '321' => 'RPL_LISTSTART',         # RFC1459
     '322' => 'RPL_LIST',              # RFC1459
     '323' => 'RPL_LISTEND',           # RFC1459
     '324' => 'RPL_CHANNELMODEIS',     # RFC1459
     '325' => 'RPL_UNIQOPIS',          # RFC2812
     '328' => 'RPL_CHANNEL_URL',       # Bahamut, AustHex
     '329' => 'RPL_CREATIONTIME',      # Bahamut
     '330' => 'RPL_WHOISACCOUNT',      # ircu
     '331' => 'RPL_NOTOPIC',           # RFC1459
     '332' => 'RPL_TOPIC',             # RFC1459
     '333' => 'RPL_TOPICWHOTIME',      # ircu
     '338' => 'RPL_WHOISACTUALLY',     # Bahamut, ircu
     '340' => 'RPL_USERIP',            # ircu
     '341' => 'RPL_INVITING',          # RFC1459
     '342' => 'RPL_SUMMONING',         # RFC1459
     '345' => 'RPL_INVITED',           # GameSurge
     '346' => 'RPL_INVITELIST',        # RFC2812
     '347' => 'RPL_ENDOFINVITELIST',   # RFC2812
     '348' => 'RPL_EXCEPTLIST',        # RFC2812
     '349' => 'RPL_ENDOFEXCEPTLIST',   # RFC2812
     '351' => 'RPL_VERSION',           # RFC1459
     '352' => 'RPL_WHOREPLY',          # RFC1459
     '353' => 'RPL_NAMREPLY',          # RFC1459
     '354' => 'RPL_WHOSPCRPL',         # ircu
     '355' => 'RPL_NAMREPLY_',         # QuakeNet
     '361' => 'RPL_KILLDONE',          # RFC1459
     '362' => 'RPL_CLOSING',           # RFC1459
     '363' => 'RPL_CLOSEEND',          # RFC1459
     '364' => 'RPL_LINKS',             # RFC1459
     '365' => 'RPL_ENDOFLINKS',        # RFC1459
     '366' => 'RPL_ENDOFNAMES',        # RFC1459
     '367' => 'RPL_BANLIST',           # RFC1459
     '368' => 'RPL_ENDOFBANLIST',      # RFC1459
     '369' => 'RPL_ENDOFWHOWAS',       # RFC1459
     '371' => 'RPL_INFO',              # RFC1459
     '372' => 'RPL_MOTD',              # RFC1459
     '373' => 'RPL_INFOSTART',         # RFC1459
     '374' => 'RPL_ENDOFINFO',         # RFC1459
     '375' => 'RPL_MOTDSTART',         # RFC1459
     '376' => 'RPL_ENDOFMOTD',         # RFC1459
     '381' => 'RPL_YOUREOPER',         # RFC1459
     '382' => 'RPL_REHASHING',         # RFC1459
     '383' => 'RPL_YOURESERVICE',      # RFC2812
     '384' => 'RPL_MYPORTIS',          # RFC1459
     '385' => 'RPL_NOTOPERANYMORE',    # AustHex, Hybrid, Unreal
     '391' => 'RPL_TIME',              # RFC1459
     '392' => 'RPL_USERSSTART',        # RFC1459
     '393' => 'RPL_USERS',             # RFC1459
     '394' => 'RPL_ENDOFUSERS',        # RFC1459
     '395' => 'RPL_NOUSERS',           # RFC1459
     '396' => 'RPL_HOSTHIDDEN',        # Undernet
     '401' => 'ERR_NOSUCHNICK',        # RFC1459
     '402' => 'ERR_NOSUCHSERVER',      # RFC1459
     '403' => 'ERR_NOSUCHCHANNEL',     # RFC1459
     '404' => 'ERR_CANNOTSENDTOCHAN',  # RFC1459
     '405' => 'ERR_TOOMANYCHANNELS',   # RFC1459
     '406' => 'ERR_WASNOSUCHNICK',     # RFC1459
     '407' => 'ERR_TOOMANYTARGETS',    # RFC1459
     '408' => 'ERR_NOSUCHSERVICE',     # RFC2812
     '409' => 'ERR_NOORIGIN',          # RFC1459
     '411' => 'ERR_NORECIPIENT',       # RFC1459
     '412' => 'ERR_NOTEXTTOSEND',      # RFC1459
     '413' => 'ERR_NOTOPLEVEL',        # RFC1459
     '414' => 'ERR_WILDTOPLEVEL',      # RFC1459
     '415' => 'ERR_BADMASK',           # RFC2812
     '421' => 'ERR_UNKNOWNCOMMAND',    # RFC1459
     '422' => 'ERR_NOMOTD',            # RFC1459
     '423' => 'ERR_NOADMININFO',       # RFC1459
     '424' => 'ERR_FILEERROR',         # RFC1459
     '425' => 'ERR_NOOPERMOTD',        # Unreal
     '429' => 'ERR_TOOMANYAWAY',       # Bahamut
     '430' => 'ERR_EVENTNICKCHANGE',   # AustHex
     '431' => 'ERR_NONICKNAMEGIVEN',   # RFC1459
     '432' => 'ERR_ERRONEUSNICKNAME',  # RFC1459
     '433' => 'ERR_NICKNAMEINUSE',     # RFC1459
     '436' => 'ERR_NICKCOLLISION',     # RFC1459
     '439' => 'ERR_TARGETTOOFAST',     # ircu
     '440' => 'ERR_SERCVICESDOWN',     # Bahamut, Unreal
     '441' => 'ERR_USERNOTINCHANNEL',  # RFC1459
     '442' => 'ERR_NOTONCHANNEL',      # RFC1459
     '443' => 'ERR_USERONCHANNEL',     # RFC1459
     '444' => 'ERR_NOLOGIN',           # RFC1459
     '445' => 'ERR_SUMMONDISABLED',    # RFC1459
     '446' => 'ERR_USERSDISABLED',     # RFC1459
     '447' => 'ERR_NONICKCHANGE',      # Unreal
     '449' => 'ERR_NOTIMPLEMENTED',    # Undernet
     '451' => 'ERR_NOTREGISTERED',     # RFC1459
     '455' => 'ERR_HOSTILENAME',       # Unreal
     '459' => 'ERR_NOHIDING',          # Unreal
     '460' => 'ERR_NOTFORHALFOPS',     # Unreal
     '461' => 'ERR_NEEDMOREPARAMS',    # RFC1459
     '462' => 'ERR_ALREADYREGISTRED',  # RFC1459
     '463' => 'ERR_NOPERMFORHOST',     # RFC1459
     '464' => 'ERR_PASSWDMISMATCH',    # RFC1459
     '465' => 'ERR_YOUREBANNEDCREEP',  # RFC1459
     '466' => 'ERR_YOUWILLBEBANNED',   # RFC1459
     '467' => 'ERR_KEYSET',            # RFC1459
     '469' => 'ERR_LINKSET',           # Unreal
     '471' => 'ERR_CHANNELISFULL',     # RFC1459
     '472' => 'ERR_UNKNOWNMODE',       # RFC1459
     '473' => 'ERR_INVITEONLYCHAN',    # RFC1459
     '474' => 'ERR_BANNEDFROMCHAN',    # RFC1459
     '475' => 'ERR_BADCHANNELKEY',     # RFC1459
     '476' => 'ERR_BADCHANMASK',       # RFC2812
     '477' => 'ERR_NOCHANMODES',       # RFC2812
     '478' => 'ERR_BANLISTFULL',       # RFC2812
     '481' => 'ERR_NOPRIVILEGES',      # RFC1459
     '482' => 'ERR_CHANOPRIVSNEEDED',  # RFC1459
     '483' => 'ERR_CANTKILLSERVER',    # RFC1459
     '484' => 'ERR_RESTRICTED',        # RFC2812
     '485' => 'ERR_UNIQOPPRIVSNEEDED', # RFC2812
     '488' => 'ERR_TSLESSCHAN',        # IRCnet
     '491' => 'ERR_NOOPERHOST',        # RFC1459
     '492' => 'ERR_NOSERVICEHOST',     # RFC1459
     '493' => 'ERR_NOFEATURE',         # ircu
     '494' => 'ERR_BADFEATURE',        # ircu
     '495' => 'ERR_BADLOGTYPE',        # ircu
     '496' => 'ERR_BADLOGSYS',         # ircu
     '497' => 'ERR_BADLOGVALUE',       # ircu
     '498' => 'ERR_ISOPERLCHAN',       # ircu
     '501' => 'ERR_UMODEUNKNOWNFLAG',  # RFC1459
     '502' => 'ERR_USERSDONTMATCH',    # RFC1459
     '503' => 'ERR_GHOSTEDCLIENT',     # Hybrid
  );
  
  our %NAME2NUMERIC;
  while (my ($key, $val) = each %NUMERIC2NAME) {
      $NAME2NUMERIC{$val} = $key;
  }
  
  sub numeric_to_name {
     my ($code) = @_;
     return $NUMERIC2NAME{$code};
  }
  
  sub name_to_numeric {
     my ($name) = @_;
     return $NAME2NUMERIC{$name};
  }
  
  sub uc_irc {
      my ($value, $type) = @_;
      return if !defined $value;
      $type = 'rfc1459' if !defined $type;
      $type = lc $type;
  
      if ($type eq 'ascii') {
          $value =~ tr/a-z/A-Z/;
      }
      elsif ($type eq 'strict-rfc1459') {
          $value =~ tr/a-z{}|/A-Z[]\\/;
      }
      else {
          $value =~ tr/a-z{}|^/A-Z[]\\~/;
      }
  
      return $value;
  }
  
  sub lc_irc {
      my ($value, $type) = @_;
      return if !defined $value;
      $type = 'rfc1459' if !defined $type;
      $type = lc $type;
  
      if ($type eq 'ascii') {
          $value =~ tr/A-Z/a-z/;
      }
      elsif ($type eq 'strict-rfc1459') {
          $value =~ tr/A-Z[]\\/a-z{}|/;
      }
      else {
          $value =~ tr/A-Z[]\\~/a-z{}|^/;
      }
  
      return $value;
  }
  
  sub eq_irc {
      my ($first, $second, $type) = @_;
      return if !defined $first || !defined $second;
      return 1 if lc_irc($first, $type) eq lc_irc($second, $type);
      return;
  }
  
  sub parse_mode_line {
      my @args = @_;
  
      my $chanmodes = [qw(beI k l imnpstaqr)];
      my $statmodes = 'ohv';
      my $hashref = { };
      my $count = 0;
  
      while (my $arg = shift @args) {
          if ( ref $arg eq 'ARRAY' ) {
             $chanmodes = $arg;
             next;
          }
          elsif (ref $arg eq 'HASH') {
             $statmodes = join '', keys %{ $arg };
             next;
          }
          elsif ($arg =~ /^[-+]/ or $count == 0) {
              my $action = '+';
              for my $char (split //, $arg) {
                  if ($char eq '+' or $char eq '-') {
                     $action = $char;
                  }
                  else {
                     push @{ $hashref->{modes} }, $action . $char;
                  }
  
                  if (length $chanmodes->[0] && length $chanmodes->[1] && length $statmodes
                      && $char =~ /[$statmodes$chanmodes->[0]$chanmodes->[1]]/) {
                      push @{ $hashref->{args} }, shift @args;
                  }
  
                  if (length $chanmodes->[2] && $action eq '+' && $char =~ /[$chanmodes->[2]]/) {
                      push @{ $hashref->{args} }, shift @args;
                  }
              }
          }
          else {
              push @{ $hashref->{args} }, $arg;
          }
          $count++;
      }
  
      return $hashref;
  }
  
  sub normalize_mask {
      my ($arg) = @_;
      return if !defined $arg;
  
      $arg =~ s/\*{2,}/*/g;
      my @mask;
      my $remainder;
      if ($arg !~ /!/ and $arg =~ /@/) {
          $remainder = $arg;
          $mask[0] = '*';
      }
      else {
          ($mask[0], $remainder) = split /!/, $arg, 2;
      }
  
      $remainder =~ s/!//g if defined $remainder;
      @mask[1..2] = split(/@/, $remainder, 2) if defined $remainder;
      $mask[2] =~ s/@//g if defined $mask[2];
  
      for my $i (1..2) {
          $mask[$i] = '*' if !defined $mask[$i];
      }
      return $mask[0] . '!' . $mask[1] . '@' . $mask[2];
  }
  
  sub unparse_mode_line {
      my ($line) = @_;
      return if !defined $line || !length $line;
  
      my $action; my $return;
      for my $mode ( split(//,$line) ) {
         if ($mode =~ /^(\+|-)$/ && (!$action || $mode ne $action)) {
           $return .= $mode;
           $action = $mode;
           next;
         }
         $return .= $mode if ($mode ne '+' and $mode ne '-');
      }
      $return =~ s/[+-]$//;
      return $return;
  }
  
  sub gen_mode_change {
      my ($before, $after) = @_;
      $before = '' if !defined $before;
      $after = '' if !defined $after;
  
      my @before = split //, $before;
      my @after  = split //, $after;
      my $string = '';
      my @hunks = _diff(\@before, \@after);
      $string .= $_->[0] . $_->[1] for @hunks;
  
      return unparse_mode_line($string);
  }
  
  sub is_valid_nick_name {
      my ($nickname) = @_;
      return if !defined $nickname || !length $nickname;
      return 1 if $nickname =~ /^[A-Za-z_`\-^\|\\\{}\[\]][A-Za-z_0-9`\-^\|\\\{}\[\]]*$/;
      return;
  }
  
  sub is_valid_chan_name {
      my $channel = shift;
      my $chantypes = shift || ['#', '&'];
      return if !@$chantypes;
      my $chanprefix = join '', @$chantypes;
      return if !defined $channel || !length $channel;
  
      return if bytes::length($channel) > 200;
      return 1 if $channel =~ /^[$chanprefix][^ \a\0\012\015,:]+$/;
      return;
  }
  
  sub matches_mask_array {
      my ($masks, $matches, $mapping) = @_;
  
      return if !defined $masks || !defined $matches;
      return if ref $masks ne 'ARRAY';
      return if ref $matches ne 'ARRAY';
      my $ref = { };
  
      for my $mask (@$masks) {
          for my $match (@$matches) {
              if (matches_mask($mask, $match, $mapping)) {
                  push @{ $ref->{ $mask } }, $match;
              }
          }
      }
  
      return $ref;
  }
  
  sub matches_mask {
      my ($mask, $match, $mapping) = @_;
      return if !defined $mask || !length $mask;
      return if !defined $match || !length $match;
  
      my $umask = quotemeta uc_irc($mask, $mapping);
      $umask =~ s/\\\*/[\x01-\xFF]{0,}/g;
      $umask =~ s/\\\?/[\x01-\xFF]{1,1}/g;
      $match = uc_irc($match, $mapping);
  
      return 1 if $match =~ /^$umask$/;
      return;
  }
  
  sub parse_user {
      my ($user) = @_;
      return if !defined $user;
  
      my ($n, $u, $h) = split /[!@]/, $user;
      return ($n, $u, $h) if wantarray();
      return $n;
  }
  
  sub has_color {
      my ($string) = @_;
      return if !defined $string;
      return 1 if $string =~ /[\x03\x04\x1B]/;
      return;
  }
  
  sub has_formatting {
      my ($string) = @_;
      return if !defined $string;
      return 1 if $string =~/[\x02\x1f\x16\x1d\x11\x06]/;
      return;
  }
  
  sub strip_color {
      my ($string) = @_;
      return if !defined $string;
  
      # mIRC colors
      $string =~ s/\x03(?:,\d{1,2}|\d{1,2}(?:,\d{1,2})?)?//g;
  
      # RGB colors supported by some clients
      $string =~ s/\x04[0-9a-fA-F]{0,6}//ig;
  
      # see ECMA-48 + advice by urxvt author
      $string =~ s/\x1B\[.*?[\x00-\x1F\x40-\x7E]//g;
  
      # strip cancellation codes too if there are no formatting codes
      $string =~ s/\x0f//g if !has_formatting($string);
      return $string;
  }
  
  sub strip_formatting {
      my ($string) = @_;
      return if !defined $string;
      $string =~ s/[\x02\x1f\x16\x1d\x11\x06]//g;
  
      # strip cancellation codes too if there are no color codes
      $string =~ s/\x0f//g if !has_color($string);
  
      return $string;
  }
  
  sub decode_irc {
      my ($line) = @_;
      my $utf8 = guess_encoding($line, 'utf8');
      return ref $utf8 ? decode('utf8', $line) : decode('cp1252', $line);
  }
  
  sub _diff {
      my ($before, $after) = @_;
      my %in_before;
      @in_before{@$before} = ();
      my %in_after;
      @in_after{@$after} = ();
      my (@diff, %seen);
  
      for my $seen (@$before) {
          next if exists $seen{$seen} || exists $in_after{$seen};
          $seen{$seen} = 1;
          push @diff, ['-', $seen];
      }
  
      %seen = ();
  
      for my $seen (@$after) {
          next if exists $seen{$seen} || exists $in_before{$seen};
          $seen{$seen} = 1;
          push @diff, ['+', $seen];
      }
  
      return @diff;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  IRC::Utils - Common utilities for IRC-related tasks
  
  =head1 SYNOPSIS
  
   use strict;
   use warnings;
  
   use IRC::Utils ':ALL';
  
   my $nickname = '^Lame|BOT[moo]';
   my $uppercase_nick = uc_irc($nickname);
   my $lowercase_nick = lc_irc($nickname);
  
   print "They're equivalent\n" if eq_irc($uppercase_nick, $lowercase_nick);
  
   my $mode_line = 'ov+b-i Bob sue stalin*!*@*';
   my $hashref = parse_mode_line($mode_line);
  
   my $banmask = 'stalin*';
   my $full_banmask = normalize_mask($banmask);
  
   if (matches_mask($full_banmask, 'stalin!joe@kremlin.ru')) {
       print "EEK!";
   }
  
   my $decoded = irc_decode($raw_irc_message);
   print $decoded, "\n";
  
   if (has_color($message)) {
      print 'COLOR CODE ALERT!\n";
   }
  
   my $results_hashref = matches_mask_array(\@masks, \@items_to_match_against);
  
   my $nick = parse_user('stalin!joe@kremlin.ru');
   my ($nick, $user, $host) = parse_user('stalin!joe@kremlin.ru');
  
  =head1 DESCRIPTION
  
  The functions in this module take care of many of the tasks you are faced
  with when working with IRC. Mode lines, ban masks, message encoding and
  formatting, etc.
  
  =head1 FUNCTIONS
  
  =head2 C<uc_irc>
  
  Takes one mandatory parameter, a string to convert to IRC uppercase, and one
  optional parameter, the casemapping of the ircd (which can be B<'rfc1459'>,
  B<'strict-rfc1459'> or B<'ascii'>. Default is B<'rfc1459'>). Returns the IRC
  uppercase equivalent of the passed string.
  
  =head2 C<lc_irc>
  
  Takes one mandatory parameter, a string to convert to IRC lowercase, and one
  optional parameter, the casemapping of the ircd (which can be B<'rfc1459'>,
  B<'strict-rfc1459'> or B<'ascii'>. Default is B<'rfc1459'>). Returns the IRC
  lowercase equivalent of the passed string.
  
  =head2 C<eq_irc>
  
  Takes two mandatory parameters, IRC strings (channels or nicknames) to
  compare. A third, optional parameter specifies the casemapping. Returns true
  if the two strings are equivalent, false otherwise
  
   # long version
   lc_irc($one, $map) eq lc_irc($two, $map)
  
   # short version
   eq_irc($one, $two, $map)
  
  =head2 C<parse_mode_line>
  
  Takes a list representing an IRC mode line. Returns a hashref. Optionally
  you can also supply an arrayref and a hashref to specify valid channel
  modes (default: C<[qw(beI k l imnpstaqr)]>) and status modes (default:
  C<< {o => '@', h => '%', v => '+'} >>), respectively.
  
  If the modeline
  couldn't be parsed the hashref will be empty. On success the following keys
  will be available in the hashref:
  
  B<'modes'>, an arrayref of normalised modes;
  
  B<'args'>, an arrayref of applicable arguments to the modes;
  
  Example:
  
   my $hashref = parse_mode_line( 'ov+b-i', 'Bob', 'sue', 'stalin*!*@*' );
  
   # $hashref will be:
   {
      modes => [ '+o', '+v', '+b', '-i' ],
      args  => [ 'Bob', 'sue', 'stalin*!*@*' ],
   }
  
  =head2 C<normalize_mask>
  
  Takes one parameter, a string representing an IRC mask. Returns a normalised
  full mask.
  
  Example:
  
   $fullbanmask = normalize_mask( 'stalin*' );
  
   # $fullbanmask will be: 'stalin*!*@*';
  
  =head2 C<matches_mask>
  
  Takes two parameters, a string representing an IRC mask and something to
  match against the IRC mask, such as a nick!user@hostname string. Returns
  a true value if they match, a false value otherwise. Optionally, one may
  pass the casemapping (see L<C<uc_irc>|/uc_irc>), as this function uses
  C<uc_irc> internally.
  
  =head2 C<matches_mask_array>
  
  Takes two array references, the first being a list of strings representing
  IRC masks, the second a list of somethings to test against the masks. Returns
  an empty hashref if there are no matches. Otherwise, the keys will be the
  masks matched, each value being an arrayref of the strings that matched it.
  Optionally, one may pass the casemapping (see L<C<uc_irc>|/uc_irc>), as
  this function uses C<uc_irc> internally.
  
  =head2 C<unparse_mode_line>
  
  Takes one argument, a string representing a number of mode changes. Returns
  a condensed version of the changes.
  
    my $mode_line = unparse_mode_line('+o+o+o-v+v');
    $mode_line is now '+ooo-v+v'
  
  =head2 C<gen_mode_change>
  
  Takes two arguments, strings representing a set of IRC user modes before and
  after a change. Returns a string representing what changed.
  
    my $mode_change = gen_mode_change('abcde', 'befmZ');
    $mode_change is now '-acd+fmZ'
  
  =head2 C<parse_user>
  
  Takes one parameter, a string representing a user in the form
  nick!user@hostname. In a scalar context it returns just the nickname.
  In a list context it returns a list consisting of the nick, user and hostname,
  respectively.
  
  =head2 C<is_valid_chan_name>
  
  Takes one argument, a channel name to validate. Returns true or false if the
  channel name is valid or not. You can supply a second argument, an array of
  characters of allowed channel prefixes. Defaults to C<['#', '&']>.
  
  =head2 C<is_valid_nick_name>
  
  Takes one argument, a nickname to validate. Returns true or false if the
  nickname is valid or not.
  
  =head2 C<numeric_to_name>
  
  Takes an IRC server numerical reply code (e.g. '001') as an argument, and
  returns the corresponding name (e.g. 'RPL_WELCOME').
  
  =head2 C<name_to_numeric>
  
  Takes an IRC server reply name (e.g. 'RPL_WELCOME') as an argument, and returns the
  corresponding numerical code (e.g. '001').
  
  =head2 C<has_color>
  
  Takes one parameter, a string of IRC text. Returns true if it contains any IRC
  color codes, false otherwise. Useful if you want your bot to kick users for
  (ab)using colors. :)
  
  =head2 C<has_formatting>
  
  Takes one parameter, a string of IRC text. Returns true if it contains any IRC
  formatting codes, false otherwise.
  
  =head2 C<strip_color>
  
  Takes one parameter, a string of IRC text. Returns the string stripped of all
  IRC color codes.
  
  =head2 C<strip_formatting>
  
  Takes one parameter, a string of IRC text. Returns the string stripped of all
  IRC formatting codes.
  
  =head2 C<decode_irc>
  
  This function takes a byte string (i.e. an unmodified IRC message) and
  returns a text string. Since the source encoding might have been UTF-8,
  you should store it with UTF-8 or some other Unicode encoding in your
  file/database/whatever to be safe. For a more detailed discussion, see
  L</ENCODING>.
  
   use IRC::Utils qw(decode_irc);
  
   sub message_handler {
       my ($nick, $channel, $message) = @_;
  
       # not wise, $message is a byte string of unkown encoding
       print $message, "\n";
  
       $message = decode_irc($what);
  
       # good, $message is a text string
       print $message, "\n";
   }
  
  =head1 CONSTANTS
  
  Use the following constants to add formatting and mIRC color codes to IRC
  messages.
  
  Normal text:
  
   NORMAL
  
  Formatting:
  
   BOLD
   UNDERLINE
   REVERSE
   ITALIC
   FIXED
  
  Colors:
  
   WHITE
   BLACK
   BLUE
   GREEN
   RED
   BROWN
   PURPLE
   ORANGE
   YELLOW
   LIGHT_GREEN
   TEAL
   LIGHT_CYAN
   LIGHT_BLUE
   PINK
   GREY
   LIGHT_GREY
  
  Individual non-color formatting codes can be cancelled with their
  corresponding constant, but you can also cancel all of them at once with
  C<NORMAL>. To cancel the effect of color codes, you must use C<NORMAL>.
  which of course has the side effect of cancelling all other formatting codes
  as well.
  
   $msg = 'This word is '.YELLOW.'yellow'.NORMAL.' while this word is'.BOLD.'bold'.BOLD;
   $msg = UNDERLINE.BOLD.'This sentence is both underlined and bold.'.NORMAL;
  
  =head1 ENCODING
  
  =head2 Messages
  
  The only encoding requirement the IRC protocol places on its messages is
  that they be 8-bits and ASCII-compatible. This has resulted in most of the
  Western world settling on ASCII-compatible Latin-1 (usually Microsoft's
  CP1252, a Latin-1 variant) as a convention. Recently, popular IRC clients
  (mIRC, xchat, certain irssi configurations) have begun sending a mixture of
  CP1252 and UTF-8 over the wire to allow more characters without breaking
  backward compatibility (too much). They send CP1252 encoded messages if the
  characters fit within that encoding, otherwise falling back to UTF-8, and
  likewise autodetecting the encoding (UTF-8 or CP1252) of incoming messages.
  Since writing text with mixed encoding to a file, terminal, or database is
  not a good idea, you need a way to decode messages from IRC.
  L<C<decode_irc>|/decode_irc> will do that.
  
  =head2 Channel names
  
  The matter is complicated further by the fact that some servers allow
  non-ASCII characters in channel names. IRC modules generally don't
  explicitly encode or decode any IRC traffic, but they do have to
  concatenate parts of a message (e.g. a channel name and a message) before
  sending it over the wire. So when you do something like
  C<< privmsg($channel, 'æði') >>, where C<$channel> is the unmodified
  channel name (a byte string) you got from an earlier IRC message, the
  channel name will get double-encoded when concatenated with your message (a
  non-ASCII text string) if the channel name contains non-ASCII bytes.
  
  To prevent this, you can't simply L<decode|/decode_irc> the channel name and
  then use it. C<'#æði'> in CP1252 is not the same channel as C<'#æði'> in
  UTF-8, since they are encoded as different sequences of bytes, and the IRC
  server only cares about the byte representation. Therefore, when using a
  channel name you got from the server (e.g. when replying to message), you
  should use the original byte string (before it has been decoded with
  L<C<decode_irc>|/decode_irc>), and encode any other parameters (with
  L<C<encode_utf8>|Encode>) so that your message will be concatenated
  correctly. At some point, you'll probably want to print the channel name,
  write it to a log file or use it in a filename, so you'll eventually have to
  decode it, at which point the UTF-8 C<#æði> and CP1252 C<#æði> will have to
  be considered equivalent.
  
   use Encode qw(encode_utf8 encode);
  
   sub message_handler {
       # these three are all byte strings
       my ($nick, $channel, $message) = @_;
  
       # bad: if $channel has any non-ASCII bytes, they will get double-encoded
       privmsg($channel, 'æði');
  
       # bad: if $message has any non-ASCII bytes, they will get double-encoded
       privmsg('#æði', $message);
  
       # good: both are byte strings already, so they will concatenate correctly
       privmsg($channel, $message);
  
       # good: both are text strings (Latin1 as per Perl's default), so
       # they'll be concatenated correctly
       privmsg('#æði', 'æði');
  
       # good: similar to the last one, except now they're using UTF-8, which
       # means that the channel is actually not the same as above
       use utf8;
       privmsg('#æði', 'æði');
  
       # good: $channel and $msg_bytes are both byte strings
       my $msg_bytes = encode_utf8('æði');
       privmsg($channel, $msg_bytes);
  
       # good: $chan_bytes and $message are both byte strings
       # here we're sending a message to the utf8-encoded #æði
       my $utf8_bytes = encode_utf8('#æði');
       privmsg($utf8_bytes, $message);
  
       # good: $chan_bytes and $message are both byte strings
       # here we're sending a message to the cp1252-encoded #æði
       my $cp1252_bytes = encode('cp1252', '#æði');
       privmsg($cp1252_bytes, $message);
  
       # bad: $channel is in an undetermined encoding
       log_message("Got message from $channel");
  
       # good: using the decoded version of $channel
       log_message("Got message from ".decode_irc($channel));
   }
  
  See also L<Encode|Encode>, L<perluniintro|perluniintro>,
  L<perlunitut|perlunitut>, L<perlunicode|perlunicode>, and
  L<perlunifaq|perlunifaq>.
  
  =head1 AUTHOR
  
  Hinrik E<Ouml>rn SigurE<eth>sson <hinrik.sig@gmail.com> (C<Hinrik> irc.perl.org, or C<literal> @ FreeNode).
  
  Chris C<BinGOs> Williams <chris@bingosnet.co.uk>
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  L<POE::Component::Server::IRC|POE::Component::Server::IRC>
  
  =cut
IRC_UTILS

$fatpacked{"LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP';
  package LWP;
  
  $VERSION = "6.07";
  sub Version { $VERSION; }
  
  require 5.008;
  require LWP::UserAgent;  # this should load everything you need
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  LWP - The World-Wide Web library for Perl
  
  =head1 SYNOPSIS
  
    use LWP;
    print "This is libwww-perl-$LWP::VERSION\n";
  
  
  =head1 DESCRIPTION
  
  The libwww-perl collection is a set of Perl modules which provides a
  simple and consistent application programming interface (API) to the
  World-Wide Web.  The main focus of the library is to provide classes
  and functions that allow you to write WWW clients. The library also
  contain modules that are of more general use and even classes that
  help you implement simple HTTP servers.
  
  Most modules in this library provide an object oriented API.  The user
  agent, requests sent and responses received from the WWW server are
  all represented by objects.  This makes a simple and powerful
  interface to these services.  The interface is easy to extend
  and customize for your own needs.
  
  The main features of the library are:
  
  =over 3
  
  =item *
  
  Contains various reusable components (modules) that can be
  used separately or together.
  
  =item *
  
  Provides an object oriented model of HTTP-style communication.  Within
  this framework we currently support access to http, https, gopher, ftp, news,
  file, and mailto resources.
  
  =item *
  
  Provides a full object oriented interface or
  a very simple procedural interface.
  
  =item *
  
  Supports the basic and digest authorization schemes.
  
  =item *
  
  Supports transparent redirect handling.
  
  =item *
  
  Supports access through proxy servers.
  
  =item *
  
  Provides parser for F<robots.txt> files and a framework for constructing robots.
  
  =item *
  
  Supports parsing of HTML forms.
  
  =item *
  
  Implements HTTP content negotiation algorithm that can
  be used both in protocol modules and in server scripts (like CGI
  scripts).
  
  =item *
  
  Supports HTTP cookies.
  
  =item *
  
  Some simple command line clients, for instance C<lwp-request> and C<lwp-download>.
  
  =back
  
  
  =head1 HTTP STYLE COMMUNICATION
  
  
  The libwww-perl library is based on HTTP style communication. This
  section tries to describe what that means.
  
  Let us start with this quote from the HTTP specification document
  <URL:http://www.w3.org/Protocols/>:
  
  =over 3
  
  =item
  
  The HTTP protocol is based on a request/response paradigm. A client
  establishes a connection with a server and sends a request to the
  server in the form of a request method, URI, and protocol version,
  followed by a MIME-like message containing request modifiers, client
  information, and possible body content. The server responds with a
  status line, including the message's protocol version and a success or
  error code, followed by a MIME-like message containing server
  information, entity meta-information, and possible body content.
  
  =back
  
  What this means to libwww-perl is that communication always take place
  through these steps: First a I<request> object is created and
  configured. This object is then passed to a server and we get a
  I<response> object in return that we can examine. A request is always
  independent of any previous requests, i.e. the service is stateless.
  The same simple model is used for any kind of service we want to
  access.
  
  For example, if we want to fetch a document from a remote file server,
  then we send it a request that contains a name for that document and
  the response will contain the document itself.  If we access a search
  engine, then the content of the request will contain the query
  parameters and the response will contain the query result.  If we want
  to send a mail message to somebody then we send a request object which
  contains our message to the mail server and the response object will
  contain an acknowledgment that tells us that the message has been
  accepted and will be forwarded to the recipient(s).
  
  It is as simple as that!
  
  
  =head2 The Request Object
  
  The libwww-perl request object has the class name C<HTTP::Request>.
  The fact that the class name uses C<HTTP::> as a
  prefix only implies that we use the HTTP model of communication.  It
  does not limit the kind of services we can try to pass this I<request>
  to.  For instance, we will send C<HTTP::Request>s both to ftp and
  gopher servers, as well as to the local file system.
  
  The main attributes of the request objects are:
  
  =over 3
  
  =item *
  
  B<method> is a short string that tells what kind of
  request this is.  The most common methods are B<GET>, B<PUT>,
  B<POST> and B<HEAD>.
  
  =item *
  
  B<uri> is a string denoting the protocol, server and
  the name of the "document" we want to access.  The B<uri> might
  also encode various other parameters.
  
  =item *
  
  B<headers> contains additional information about the
  request and can also used to describe the content.  The headers
  are a set of keyword/value pairs.
  
  =item *
  
  B<content> is an arbitrary amount of data.
  
  =back
  
  =head2 The Response Object
  
  The libwww-perl response object has the class name C<HTTP::Response>.
  The main attributes of objects of this class are:
  
  =over 3
  
  =item *
  
  B<code> is a numerical value that indicates the overall
  outcome of the request.
  
  =item *
  
  B<message> is a short, human readable string that
  corresponds to the I<code>.
  
  =item *
  
  B<headers> contains additional information about the
  response and describe the content.
  
  =item *
  
  B<content> is an arbitrary amount of data.
  
  =back
  
  Since we don't want to handle all possible I<code> values directly in
  our programs, a libwww-perl response object has methods that can be
  used to query what kind of response this is.  The most commonly used
  response classification methods are:
  
  =over 3
  
  =item is_success()
  
  The request was successfully received, understood or accepted.
  
  =item is_error()
  
  The request failed.  The server or the resource might not be
  available, access to the resource might be denied or other things might
  have failed for some reason.
  
  =back
  
  =head2 The User Agent
  
  Let us assume that we have created a I<request> object. What do we
  actually do with it in order to receive a I<response>?
  
  The answer is that you pass it to a I<user agent> object and this
  object takes care of all the things that need to be done
  (like low-level communication and error handling) and returns
  a I<response> object. The user agent represents your
  application on the network and provides you with an interface that
  can accept I<requests> and return I<responses>.
  
  The user agent is an interface layer between
  your application code and the network.  Through this interface you are
  able to access the various servers on the network.
  
  The class name for the user agent is C<LWP::UserAgent>.  Every
  libwww-perl application that wants to communicate should create at
  least one object of this class. The main method provided by this
  object is request(). This method takes an C<HTTP::Request> object as
  argument and (eventually) returns a C<HTTP::Response> object.
  
  The user agent has many other attributes that let you
  configure how it will interact with the network and with your
  application.
  
  =over 3
  
  =item *
  
  B<timeout> specifies how much time we give remote servers to
  respond before the library disconnects and creates an
  internal I<timeout> response.
  
  =item *
  
  B<agent> specifies the name that your application uses when it
  presents itself on the network.
  
  =item *
  
  B<from> can be set to the e-mail address of the person
  responsible for running the application.  If this is set, then the
  address will be sent to the servers with every request.
  
  =item *
  
  B<parse_head> specifies whether we should initialize response
  headers from the E<lt>head> section of HTML documents.
  
  =item *
  
  B<proxy> and B<no_proxy> specify if and when to go through
  a proxy server. <URL:http://www.w3.org/History/1994/WWW/Proxies/>
  
  =item *
  
  B<credentials> provides a way to set up user names and
  passwords needed to access certain services.
  
  =back
  
  Many applications want even more control over how they interact
  with the network and they get this by sub-classing
  C<LWP::UserAgent>.  The library includes a
  sub-class, C<LWP::RobotUA>, for robot applications.
  
  =head2 An Example
  
  This example shows how the user agent, a request and a response are
  represented in actual perl code:
  
    # Create a user agent object
    use LWP::UserAgent;
    my $ua = LWP::UserAgent->new;
    $ua->agent("MyApp/0.1 ");
  
    # Create a request
    my $req = HTTP::Request->new(POST => 'http://search.cpan.org/search');
    $req->content_type('application/x-www-form-urlencoded');
    $req->content('query=libwww-perl&mode=dist');
  
    # Pass request to the user agent and get a response back
    my $res = $ua->request($req);
  
    # Check the outcome of the response
    if ($res->is_success) {
        print $res->content;
    }
    else {
        print $res->status_line, "\n";
    }
  
  The $ua is created once when the application starts up.  New request
  objects should normally created for each request sent.
  
  
  =head1 NETWORK SUPPORT
  
  This section discusses the various protocol schemes and
  the HTTP style methods that headers may be used for each.
  
  For all requests, a "User-Agent" header is added and initialized from
  the $ua->agent attribute before the request is handed to the network
  layer.  In the same way, a "From" header is initialized from the
  $ua->from attribute.
  
  For all responses, the library adds a header called "Client-Date".
  This header holds the time when the response was received by
  your application.  The format and semantics of the header are the
  same as the server created "Date" header.  You may also encounter other
  "Client-XXX" headers.  They are all generated by the library
  internally and are not received from the servers.
  
  =head2 HTTP Requests
  
  HTTP requests are just handed off to an HTTP server and it
  decides what happens.  Few servers implement methods beside the usual
  "GET", "HEAD", "POST" and "PUT", but CGI-scripts may implement
  any method they like.
  
  If the server is not available then the library will generate an
  internal error response.
  
  The library automatically adds a "Host" and a "Content-Length" header
  to the HTTP request before it is sent over the network.
  
  For a GET request you might want to add a "If-Modified-Since" or
  "If-None-Match" header to make the request conditional.
  
  For a POST request you should add the "Content-Type" header.  When you
  try to emulate HTML E<lt>FORM> handling you should usually let the value
  of the "Content-Type" header be "application/x-www-form-urlencoded".
  See L<lwpcook> for examples of this.
  
  The libwww-perl HTTP implementation currently support the HTTP/1.1
  and HTTP/1.0 protocol.
  
  The library allows you to access proxy server through HTTP.  This
  means that you can set up the library to forward all types of request
  through the HTTP protocol module.  See L<LWP::UserAgent> for
  documentation of this.
  
  
  =head2 HTTPS Requests
  
  HTTPS requests are HTTP requests over an encrypted network connection
  using the SSL protocol developed by Netscape.  Everything about HTTP
  requests above also apply to HTTPS requests.  In addition the library
  will add the headers "Client-SSL-Cipher", "Client-SSL-Cert-Subject" and
  "Client-SSL-Cert-Issuer" to the response.  These headers denote the
  encryption method used and the name of the server owner.
  
  The request can contain the header "If-SSL-Cert-Subject" in order to
  make the request conditional on the content of the server certificate.
  If the certificate subject does not match, no request is sent to the
  server and an internally generated error response is returned.  The
  value of the "If-SSL-Cert-Subject" header is interpreted as a Perl
  regular expression.
  
  
  =head2 FTP Requests
  
  The library currently supports GET, HEAD and PUT requests.  GET
  retrieves a file or a directory listing from an FTP server.  PUT
  stores a file on a ftp server.
  
  You can specify a ftp account for servers that want this in addition
  to user name and password.  This is specified by including an "Account"
  header in the request.
  
  User name/password can be specified using basic authorization or be
  encoded in the URL.  Failed logins return an UNAUTHORIZED response with
  "WWW-Authenticate: Basic" and can be treated like basic authorization
  for HTTP.
  
  The library supports ftp ASCII transfer mode by specifying the "type=a"
  parameter in the URL. It also supports transfer of ranges for FTP transfers
  using the "Range" header.
  
  Directory listings are by default returned unprocessed (as returned
  from the ftp server) with the content media type reported to be
  "text/ftp-dir-listing". The C<File::Listing> module provides methods
  for parsing of these directory listing.
  
  The ftp module is also able to convert directory listings to HTML and
  this can be requested via the standard HTTP content negotiation
  mechanisms (add an "Accept: text/html" header in the request if you
  want this).
  
  For normal file retrievals, the "Content-Type" is guessed based on the
  file name suffix. See L<LWP::MediaTypes>.
  
  The "If-Modified-Since" request header works for servers that implement
  the MDTM command.  It will probably not work for directory listings though.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'ftp://me:passwd@ftp.some.where.com/');
    $req->header(Accept => "text/html, */*;q=0.1");
  
  =head2 News Requests
  
  Access to the USENET News system is implemented through the NNTP
  protocol.  The name of the news server is obtained from the
  NNTP_SERVER environment variable and defaults to "news".  It is not
  possible to specify the hostname of the NNTP server in news: URLs.
  
  The library supports GET and HEAD to retrieve news articles through the
  NNTP protocol.  You can also post articles to newsgroups by using
  (surprise!) the POST method.
  
  GET on newsgroups is not implemented yet.
  
  Examples:
  
    $req = HTTP::Request->new(GET => 'news:abc1234@a.sn.no');
  
    $req = HTTP::Request->new(POST => 'news:comp.lang.perl.test');
    $req->header(Subject => 'This is a test',
                 From    => 'me@some.where.org');
    $req->content(<<EOT);
    This is the content of the message that we are sending to
    the world.
    EOT
  
  
  =head2 Gopher Request
  
  The library supports the GET and HEAD methods for gopher requests.  All
  request header values are ignored.  HEAD cheats and returns a
  response without even talking to server.
  
  Gopher menus are always converted to HTML.
  
  The response "Content-Type" is generated from the document type
  encoded (as the first letter) in the request URL path itself.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'gopher://gopher.sn.no/');
  
  
  
  =head2 File Request
  
  The library supports GET and HEAD methods for file requests.  The
  "If-Modified-Since" header is supported.  All other headers are
  ignored.  The I<host> component of the file URL must be empty or set
  to "localhost".  Any other I<host> value will be treated as an error.
  
  Directories are always converted to an HTML document.  For normal
  files, the "Content-Type" and "Content-Encoding" in the response are
  guessed based on the file suffix.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'file:/etc/passwd');
  
  
  =head2 Mailto Request
  
  You can send (aka "POST") mail messages using the library.  All
  headers specified for the request are passed on to the mail system.
  The "To" header is initialized from the mail address in the URL.
  
  Example:
  
    $req = HTTP::Request->new(POST => 'mailto:libwww@perl.org');
    $req->header(Subject => "subscribe");
    $req->content("Please subscribe me to the libwww-perl mailing list!\n");
  
  =head2 CPAN Requests
  
  URLs with scheme C<cpan:> are redirected to the a suitable CPAN
  mirror.  If you have your own local mirror of CPAN you might tell LWP
  to use it for C<cpan:> URLs by an assignment like this:
  
    $LWP::Protocol::cpan::CPAN = "file:/local/CPAN/";
  
  Suitable CPAN mirrors are also picked up from the configuration for
  the CPAN.pm, so if you have used that module a suitable mirror should
  be picked automatically.  If neither of these apply, then a redirect
  to the generic CPAN http location is issued.
  
  Example request to download the newest perl:
  
    $req = HTTP::Request->new(GET => "cpan:src/latest.tar.gz");
  
  
  =head1 OVERVIEW OF CLASSES AND PACKAGES
  
  This table should give you a quick overview of the classes provided by the
  library. Indentation shows class inheritance.
  
   LWP::MemberMixin   -- Access to member variables of Perl5 classes
     LWP::UserAgent   -- WWW user agent class
       LWP::RobotUA   -- When developing a robot applications
     LWP::Protocol          -- Interface to various protocol schemes
       LWP::Protocol::http  -- http:// access
       LWP::Protocol::file  -- file:// access
       LWP::Protocol::ftp   -- ftp:// access
       ...
  
   LWP::Authen::Basic -- Handle 401 and 407 responses
   LWP::Authen::Digest
  
   HTTP::Headers      -- MIME/RFC822 style header (used by HTTP::Message)
   HTTP::Message      -- HTTP style message
     HTTP::Request    -- HTTP request
     HTTP::Response   -- HTTP response
   HTTP::Daemon       -- A HTTP server class
  
   WWW::RobotRules    -- Parse robots.txt files
     WWW::RobotRules::AnyDBM_File -- Persistent RobotRules
  
   Net::HTTP          -- Low level HTTP client
  
  The following modules provide various functions and definitions.
  
   LWP                -- This file.  Library version number and documentation.
   LWP::MediaTypes    -- MIME types configuration (text/html etc.)
   LWP::Simple        -- Simplified procedural interface for common functions
   HTTP::Status       -- HTTP status code (200 OK etc)
   HTTP::Date         -- Date parsing module for HTTP date formats
   HTTP::Negotiate    -- HTTP content negotiation calculation
   File::Listing      -- Parse directory listings
   HTML::Form         -- Processing for <form>s in HTML documents
  
  
  =head1 MORE DOCUMENTATION
  
  All modules contain detailed information on the interfaces they
  provide.  The L<lwpcook> manpage is the libwww-perl cookbook that contain
  examples of typical usage of the library.  You might want to take a
  look at how the scripts L<lwp-request>, L<lwp-download>, L<lwp-dump>
  and L<lwp-mirror> are implemented.
  
  =head1 ENVIRONMENT
  
  The following environment variables are used by LWP:
  
  =over
  
  =item HOME
  
  The C<LWP::MediaTypes> functions will look for the F<.media.types> and
  F<.mime.types> files relative to you home directory.
  
  =item http_proxy
  
  =item ftp_proxy
  
  =item xxx_proxy
  
  =item no_proxy
  
  These environment variables can be set to enable communication through
  a proxy server.  See the description of the C<env_proxy> method in
  L<LWP::UserAgent>.
  
  =item PERL_LWP_ENV_PROXY
  
  If set to a TRUE value, then the C<LWP::UserAgent> will by default call
  C<env_proxy> during initialization.  This makes LWP honor the proxy variables
  described above.
  
  =item PERL_LWP_SSL_VERIFY_HOSTNAME
  
  The default C<verify_hostname> setting for C<LWP::UserAgent>.  If
  not set the default will be 1.  Set it as 0 to disable hostname
  verification (the default prior to libwww-perl 5.840.
  
  =item PERL_LWP_SSL_CA_FILE
  
  =item PERL_LWP_SSL_CA_PATH
  
  The file and/or directory
  where the trusted Certificate Authority certificates
  is located.  See L<LWP::UserAgent> for details.
  
  =item PERL_HTTP_URI_CLASS
  
  Used to decide what URI objects to instantiate.  The default is C<URI>.
  You might want to set it to C<URI::URL> for compatibility with old times.
  
  =back
  
  =head1 AUTHORS
  
  LWP was made possible by contributions from Adam Newby, Albert
  Dvornik, Alexandre Duret-Lutz, Andreas Gustafsson, Andreas König,
  Andrew Pimlott, Andy Lester, Ben Coleman, Benjamin Low, Ben Low, Ben
  Tilly, Blair Zajac, Bob Dalgleish, BooK, Brad Hughes, Brian
  J. Murrell, Brian McCauley, Charles C. Fu, Charles Lane, Chris Nandor,
  Christian Gilmore, Chris W. Unger, Craig Macdonald, Dale Couch, Dan
  Kubb, Dave Dunkin, Dave W. Smith, David Coppit, David Dick, David
  D. Kilzer, Doug MacEachern, Edward Avis, erik, Gary Shea, Gisle Aas,
  Graham Barr, Gurusamy Sarathy, Hans de Graaff, Harald Joerg, Harry
  Bochner, Hugo, Ilya Zakharevich, INOUE Yoshinari, Ivan Panchenko, Jack
  Shirazi, James Tillman, Jan Dubois, Jared Rhine, Jim Stern, Joao
  Lopes, John Klar, Johnny Lee, Josh Kronengold, Josh Rai, Joshua
  Chamas, Joshua Hoblitt, Kartik Subbarao, Keiichiro Nagano, Ken
  Williams, KONISHI Katsuhiro, Lee T Lindley, Liam Quinn, Marc Hedlund,
  Marc Langheinrich, Mark D. Anderson, Marko Asplund, Mark Stosberg,
  Markus B Krüger, Markus Laker, Martijn Koster, Martin Thurn, Matthew
  Eldridge, Matthew.van.Eerde, Matt Sergeant, Michael A. Chase, Michael
  Quaranta, Michael Thompson, Mike Schilli, Moshe Kaminsky, Nathan
  Torkington, Nicolai Langfeldt, Norton Allen, Olly Betts, Paul
  J. Schinder, peterm, Philip GuentherDaniel Buenzli, Pon Hwa Lin,
  Radoslaw Zielinski, Radu Greab, Randal L. Schwartz, Richard Chen,
  Robin Barker, Roy Fielding, Sander van Zoest, Sean M. Burke,
  shildreth, Slaven Rezic, Steve A Fink, Steve Hay, Steven Butler,
  Steve_Kilbane, Takanori Ugai, Thomas Lotterer, Tim Bunce, Tom Hughes,
  Tony Finch, Ville Skyttä, Ward Vandewege, William York, Yale Huang,
  and Yitzchak Scott-Thoennes.
  
  LWP owes a lot in motivation, design, and code, to the libwww-perl
  library for Perl4 by Roy Fielding, which included work from Alberto
  Accomazzi, James Casey, Brooks Cutter, Martijn Koster, Oscar
  Nierstrasz, Mel Melchner, Gertjan van Oosten, Jared Rhine, Jack
  Shirazi, Gene Spafford, Marc VanHeyningen, Steven E. Brenner, Marion
  Hakanson, Waldemar Kebsch, Tony Sanders, and Larry Wall; see the
  libwww-perl-0.40 library for details.
  
  =head1 COPYRIGHT
  
    Copyright 1995-2009, Gisle Aas
    Copyright 1995, Martijn Koster
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 AVAILABILITY
  
  The latest version of this library is likely to be available from CPAN
  as well as:
  
    http://github.com/libwww-perl/libwww-perl
  
  The best place to discuss this code is on the <libwww@perl.org>
  mailing list.
  
  =cut
LWP

$fatpacked{"LWP/Authen/Basic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_BASIC';
  package LWP::Authen::Basic;
  use strict;
  
  require MIME::Base64;
  
  sub auth_header {
      my($class, $user, $pass) = @_;
      return "Basic " . MIME::Base64::encode("$user:$pass", "");
  }
  
  sub authenticate
  {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my $realm = $auth_param->{realm} || "";
      my $url = $proxy ? $request->{proxy} : $request->uri_canonical;
      return $response unless $url;
      my $host_port = $url->host_port;
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
      my @m = $proxy ? (m_proxy => $url) : (m_host_port => $host_port);
      push(@m, realm => $realm);
  
      my $h = $ua->get_my_handler("request_prepare", @m, sub {
          $_[0]{callback} = sub {
              my($req, $ua, $h) = @_;
              my($user, $pass) = $ua->credentials($host_port, $h->{realm});
  	    if (defined $user) {
  		my $auth_value = $class->auth_header($user, $pass, $req, $ua, $h);
  		$req->header($auth_header => $auth_value);
  	    }
          };
      });
      $h->{auth_param} = $auth_param;
  
      if (!$proxy && !$request->header($auth_header) && $ua->credentials($host_port, $realm)) {
  	# we can make sure this handler applies and retry
          add_path($h, $url->path);
          return $ua->request($request->clone, $arg, $size, $response);
      }
  
      my($user, $pass) = $ua->get_basic_credentials($realm, $url, $proxy);
      unless (defined $user and defined $pass) {
  	$ua->set_my_handler("request_prepare", undef, @m);  # delete handler
  	return $response;
      }
  
      # check that the password has changed
      my ($olduser, $oldpass) = $ua->credentials($host_port, $realm);
      return $response if (defined $olduser and defined $oldpass and
                           $user eq $olduser and $pass eq $oldpass);
  
      $ua->credentials($host_port, $realm, $user, $pass);
      add_path($h, $url->path) unless $proxy;
      return $ua->request($request->clone, $arg, $size, $response);
  }
  
  sub add_path {
      my($h, $path) = @_;
      $path =~ s,[^/]+\z,,;
      push(@{$h->{m_path_prefix}}, $path);
  }
  
  1;
LWP_AUTHEN_BASIC

$fatpacked{"LWP/Authen/Digest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_DIGEST';
  package LWP::Authen::Digest;
  
  use strict;
  use base 'LWP::Authen::Basic';
  
  require Digest::MD5;
  
  sub auth_header {
      my($class, $user, $pass, $request, $ua, $h) = @_;
  
      my $auth_param = $h->{auth_param};
  
      my $nc = sprintf "%08X", ++$ua->{authen_md5_nonce_count}{$auth_param->{nonce}};
      my $cnonce = sprintf "%8x", time;
  
      my $uri = $request->uri->path_query;
      $uri = "/" unless length $uri;
  
      my $md5 = Digest::MD5->new;
  
      my(@digest);
      $md5->add(join(":", $user, $auth_param->{realm}, $pass));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      push(@digest, $auth_param->{nonce});
  
      if ($auth_param->{qop}) {
  	push(@digest, $nc, $cnonce, ($auth_param->{qop} =~ m|^auth[,;]auth-int$|) ? 'auth' : $auth_param->{qop});
      }
  
      $md5->add(join(":", $request->method, $uri));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      $md5->add(join(":", @digest));
      my($digest) = $md5->hexdigest;
      $md5->reset;
  
      my %resp = map { $_ => $auth_param->{$_} } qw(realm nonce opaque);
      @resp{qw(username uri response algorithm)} = ($user, $uri, $digest, "MD5");
  
      if (($auth_param->{qop} || "") =~ m|^auth([,;]auth-int)?$|) {
  	@resp{qw(qop cnonce nc)} = ("auth", $cnonce, $nc);
      }
  
      my(@order) = qw(username realm qop algorithm uri nonce nc cnonce response);
      if($request->method =~ /^(?:POST|PUT)$/) {
  	$md5->add($request->content);
  	my $content = $md5->hexdigest;
  	$md5->reset;
  	$md5->add(join(":", @digest[0..1], $content));
  	$md5->reset;
  	$resp{"message-digest"} = $md5->hexdigest;
  	push(@order, "message-digest");
      }
      push(@order, "opaque");
      my @pairs;
      for (@order) {
  	next unless defined $resp{$_};
  
  	# RFC2617 sais that qop-value and nc-value should be unquoted.
  	if ( $_ eq 'qop' || $_ eq 'nc' ) {
  		push(@pairs, "$_=" . $resp{$_});
  	}
  	else {
  		push(@pairs, "$_=" . qq("$resp{$_}"));
  	}
      }
  
      my $auth_value  = "Digest " . join(", ", @pairs);
      return $auth_value;
  }
  
  1;
LWP_AUTHEN_DIGEST

$fatpacked{"LWP/Authen/Ntlm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_NTLM';
  package LWP::Authen::Ntlm;
  
  use strict;
  use vars qw/$VERSION/;
  
  $VERSION = "6.00";
  
  use Authen::NTLM "1.02";
  use MIME::Base64 "2.12";
  
  sub authenticate {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my($user, $pass) = $ua->get_basic_credentials($auth_param->{realm},
                                                    $request->uri, $proxy);
  
      unless(defined $user and defined $pass) {
  		return $response;
  	}
  
  	if (!$ua->conn_cache()) {
  		warn "The keep_alive option must be enabled for NTLM authentication to work.  NTLM authentication aborted.\n";
  		return $response;
  	}
  
  	my($domain, $username) = split(/\\/, $user);
  
  	ntlm_domain($domain);
  	ntlm_user($username);
  	ntlm_password($pass);
  
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
  	# my ($challenge) = $response->header('WWW-Authenticate'); 
  	my $challenge;
  	foreach ($response->header('WWW-Authenticate')) { 
  		last if /^NTLM/ && ($challenge=$_);
  	}
  
  	if ($challenge eq 'NTLM') {
  		# First phase, send handshake
  	    my $auth_value = "NTLM " . ntlm();
  		ntlm_reset();
  
  	    # Need to check this isn't a repeated fail!
  	    my $r = $response;
  		my $retry_count = 0;
  	    while ($r) {
  			my $auth = $r->request->header($auth_header);
  			++$retry_count if ($auth && $auth eq $auth_value);
  			if ($retry_count > 2) {
  				    # here we know this failed before
  				    $response->header("Client-Warning" =>
  						      "Credentials for '$user' failed before");
  				    return $response;
  			}
  			$r = $r->previous;
  	    }
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    return $ua->request($referral, $arg, $size, $response);
  	}
  	
  	else {
  		# Second phase, use the response challenge (unless non-401 code
  		#  was returned, in which case, we just send back the response
  		#  object, as is
  		my $auth_value;
  		if ($response->code ne '401') {
  			return $response;
  		}
  		else {
  			my $challenge;
  			foreach ($response->header('WWW-Authenticate')) { 
  				last if /^NTLM/ && ($challenge=$_);
  			}
  			$challenge =~ s/^NTLM //;
  			ntlm();
  			$auth_value = "NTLM " . ntlm($challenge);
  			ntlm_reset();
  		}
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    my $response2 = $ua->request($referral, $arg, $size, $response);
  		return $response2;
  	}
  }
  
  1;
  
  
  =head1 NAME
  
  LWP::Authen::Ntlm - Library for enabling NTLM authentication (Microsoft) in LWP
  
  =head1 SYNOPSIS
  
   use LWP::UserAgent;
   use HTTP::Request::Common;
   my $url = 'http://www.company.com/protected_page.html';
  
   # Set up the ntlm client and then the base64 encoded ntlm handshake message
   my $ua = LWP::UserAgent->new(keep_alive=>1);
   $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
   $request = GET $url;
   print "--Performing request now...-----------\n";
   $response = $ua->request($request);
   print "--Done with request-------------------\n";
  
   if ($response->is_success) {print "It worked!->" . $response->code . "\n"}
   else {print "It didn't work!->" . $response->code . "\n"}
  
  =head1 DESCRIPTION
  
  C<LWP::Authen::Ntlm> allows LWP to authenticate against servers that are using the 
  NTLM authentication scheme popularized by Microsoft.  This type of authentication is 
  common on intranets of Microsoft-centric organizations.
  
  The module takes advantage of the Authen::NTLM module by Mark Bush.  Since there 
  is also another Authen::NTLM module available from CPAN by Yee Man Chan with an 
  entirely different interface, it is necessary to ensure that you have the correct 
  NTLM module.
  
  In addition, there have been problems with incompatibilities between different 
  versions of Mime::Base64, which Bush's Authen::NTLM makes use of.  Therefore, it is 
  necessary to ensure that your Mime::Base64 module supports exporting of the 
  encode_base64 and decode_base64 functions.
  
  =head1 USAGE
  
  The module is used indirectly through LWP, rather than including it directly in your 
  code.  The LWP system will invoke the NTLM authentication when it encounters the 
  authentication scheme while attempting to retrieve a URL from a server.  In order 
  for the NTLM authentication to work, you must have a few things set up in your 
  code prior to attempting to retrieve the URL:
  
  =over 4
  
  =item *
  
  Enable persistent HTTP connections
  
  To do this, pass the "keep_alive=>1" option to the LWP::UserAgent when creating it, like this:
  
      my $ua = LWP::UserAgent->new(keep_alive=>1);
  
  =item *
  
  Set the credentials on the UserAgent object
  
  The credentials must be set like this:
  
     $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
  Note that you cannot use the HTTP::Request object's authorization_basic() method to set 
  the credentials.  Note, too, that the 'www.company.com:80' portion only sets credentials 
  on the specified port AND it is case-sensitive (this is due to the way LWP is coded, and 
  has nothing to do with LWP::Authen::Ntlm)
  
  =back
  
  =head1 AVAILABILITY
  
  General queries regarding LWP should be made to the LWP Mailing List.
  
  Questions specific to LWP::Authen::Ntlm can be forwarded to jtillman@bigfoot.com
  
  =head1 COPYRIGHT
  
  Copyright (c) 2002 James Tillman. All rights reserved. This
  program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<LWP>, L<LWP::UserAgent>, L<lwpcook>.
LWP_AUTHEN_NTLM

$fatpacked{"LWP/ConnCache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_CONNCACHE';
  package LWP::ConnCache;
  
  use strict;
  use vars qw($VERSION $DEBUG);
  
  $VERSION = "6.02";
  
  
  sub new {
      my($class, %cnf) = @_;
  
      my $total_capacity = 1;
      if (exists $cnf{total_capacity}) {
          $total_capacity = delete $cnf{total_capacity};
      }
      if (%cnf && $^W) {
  	require Carp;
  	Carp::carp("Unrecognised options: @{[sort keys %cnf]}")
      }
      my $self = bless { cc_conns => [] }, $class;
      $self->total_capacity($total_capacity);
      $self;
  }
  
  
  sub deposit {
      my($self, $type, $key, $conn) = @_;
      push(@{$self->{cc_conns}}, [$conn, $type, $key, time]);
      $self->enforce_limits($type);
      return;
  }
  
  
  sub withdraw {
      my($self, $type, $key) = @_;
      my $conns = $self->{cc_conns};
      for my $i (0 .. @$conns - 1) {
  	my $c = $conns->[$i];
  	next unless $c->[1] eq $type && $c->[2] eq $key;
  	splice(@$conns, $i, 1);  # remove it
  	return $c->[0];
      }
      return undef;
  }
  
  
  sub total_capacity {
      my $self = shift;
      my $old = $self->{cc_limit_total};
      if (@_) {
  	$self->{cc_limit_total} = shift;
  	$self->enforce_limits;
      }
      $old;
  }
  
  
  sub capacity {
      my $self = shift;
      my $type = shift;
      my $old = $self->{cc_limit}{$type};
      if (@_) {
  	$self->{cc_limit}{$type} = shift;
  	$self->enforce_limits($type);
      }
      $old;
  }
  
  
  sub enforce_limits {
      my($self, $type) = @_;
      my $conns = $self->{cc_conns};
  
      my @types = $type ? ($type) : ($self->get_types);
      for $type (@types) {
  	next unless $self->{cc_limit};
  	my $limit = $self->{cc_limit}{$type};
  	next unless defined $limit;
  	for my $i (reverse 0 .. @$conns - 1) {
  	    next unless $conns->[$i][1] eq $type;
  	    if (--$limit < 0) {
  		$self->dropping(splice(@$conns, $i, 1), "$type capacity exceeded");
  	    }
  	}
      }
  
      if (defined(my $total = $self->{cc_limit_total})) {
  	while (@$conns > $total) {
  	    $self->dropping(shift(@$conns), "Total capacity exceeded");
  	}
      }
  }
  
  
  sub dropping {
      my($self, $c, $reason) = @_;
      print "DROPPING @$c [$reason]\n" if $DEBUG;
  }
  
  
  sub drop {
      my($self, $checker, $reason) = @_;
      if (ref($checker) ne "CODE") {
  	# make it so
  	if (!defined $checker) {
  	    $checker = sub { 1 };  # drop all of them
  	}
  	elsif (_looks_like_number($checker)) {
  	    my $age_limit = $checker;
  	    my $time_limit = time - $age_limit;
  	    $reason ||= "older than $age_limit";
  	    $checker = sub { $_[3] < $time_limit };
  	}
  	else {
  	    my $type = $checker;
  	    $reason ||= "drop $type";
  	    $checker = sub { $_[1] eq $type };  # match on type
  	}
      }
      $reason ||= "drop";
  
      local $SIG{__DIE__};  # don't interfere with eval below
      local $@;
      my @c;
      for (@{$self->{cc_conns}}) {
  	my $drop;
  	eval {
  	    if (&$checker(@$_)) {
  		$self->dropping($_, $reason);
  		$drop++;
  	    }
  	};
  	push(@c, $_) unless $drop;
      }
      @{$self->{cc_conns}} = @c;
  }
  
  
  sub prune {
      my $self = shift;
      $self->drop(sub { !shift->ping }, "ping");
  }
  
  
  sub get_types {
      my $self = shift;
      my %t;
      $t{$_->[1]}++ for @{$self->{cc_conns}};
      return keys %t;
  }
  
  
  sub get_connections {
      my($self, $type) = @_;
      my @c;
      for (@{$self->{cc_conns}}) {
  	push(@c, $_->[0]) if !$type || ($type && $type eq $_->[1]);
      }
      @c;
  }
  
  
  sub _looks_like_number {
      $_[0] =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::ConnCache - Connection cache manager
  
  =head1 NOTE
  
  This module is experimental.  Details of its interface is likely to
  change in the future.
  
  =head1 SYNOPSIS
  
   use LWP::ConnCache;
   my $cache = LWP::ConnCache->new;
   $cache->deposit($type, $key, $sock);
   $sock = $cache->withdraw($type, $key);
  
  =head1 DESCRIPTION
  
  The C<LWP::ConnCache> class is the standard connection cache manager
  for LWP::UserAgent.
  
  The following basic methods are provided:
  
  =over
  
  =item $cache = LWP::ConnCache->new( %options )
  
  This method constructs a new C<LWP::ConnCache> object.  The only
  option currently accepted is 'total_capacity'.  If specified it
  initialize the total_capacity option.  It defaults to the value 1.
  
  =item $cache->total_capacity( [$num_connections] )
  
  Get/sets the number of connection that will be cached.  Connections
  will start to be dropped when this limit is reached.  If set to C<0>,
  then all connections are immediately dropped.  If set to C<undef>,
  then there is no limit.
  
  =item $cache->capacity($type, [$num_connections] )
  
  Get/set a limit for the number of connections of the specified type
  that can be cached.  The $type will typically be a short string like
  "http" or "ftp".
  
  =item $cache->drop( [$checker, [$reason]] )
  
  Drop connections by some criteria.  The $checker argument is a
  subroutine that is called for each connection.  If the routine returns
  a TRUE value then the connection is dropped.  The routine is called
  with ($conn, $type, $key, $deposit_time) as arguments.
  
  Shortcuts: If the $checker argument is absent (or C<undef>) all cached
  connections are dropped.  If the $checker is a number then all
  connections untouched that the given number of seconds or more are
  dropped.  If $checker is a string then all connections of the given
  type are dropped.
  
  The $reason argument is passed on to the dropped() method.
  
  =item $cache->prune
  
  Calling this method will drop all connections that are dead.  This is
  tested by calling the ping() method on the connections.  If the ping()
  method exists and returns a FALSE value, then the connection is
  dropped.
  
  =item $cache->get_types
  
  This returns all the 'type' fields used for the currently cached
  connections.
  
  =item $cache->get_connections( [$type] )
  
  This returns all connection objects of the specified type.  If no type
  is specified then all connections are returned.  In scalar context the
  number of cached connections of the specified type is returned.
  
  =back
  
  
  The following methods are called by low-level protocol modules to
  try to save away connections and to get them back.
  
  =over
  
  =item $cache->deposit($type, $key, $conn)
  
  This method adds a new connection to the cache.  As a result other
  already cached connections might be dropped.  Multiple connections with
  the same $type/$key might added.
  
  =item $conn = $cache->withdraw($type, $key)
  
  This method tries to fetch back a connection that was previously
  deposited.  If no cached connection with the specified $type/$key is
  found, then C<undef> is returned.  There is not guarantee that a
  deposited connection can be withdrawn, as the cache manger is free to
  drop connections at any time.
  
  =back
  
  The following methods are called internally.  Subclasses might want to
  override them.
  
  =over
  
  =item $conn->enforce_limits([$type])
  
  This method is called with after a new connection is added (deposited)
  in the cache or capacity limits are adjusted.  The default
  implementation drops connections until the specified capacity limits
  are not exceeded.
  
  =item $conn->dropping($conn_record, $reason)
  
  This method is called when a connection is dropped.  The record
  belonging to the dropped connection is passed as the first argument
  and a string describing the reason for the drop is passed as the
  second argument.  The default implementation makes some noise if the
  $LWP::ConnCache::DEBUG variable is set and nothing more.
  
  =back
  
  =head1 SUBCLASSING
  
  For specialized cache policy it makes sense to subclass
  C<LWP::ConnCache> and perhaps override the deposit(), enforce_limits()
  and dropping() methods.
  
  The object itself is a hash.  Keys prefixed with C<cc_> are reserved
  for the base class.
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_CONNCACHE

$fatpacked{"LWP/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_DEBUG';
  package LWP::Debug;  # legacy
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(level trace debug conns);
  
  use Carp ();
  
  my @levels = qw(trace debug conns);
  %current_level = ();
  
  
  sub import
  {
      my $pack = shift;
      my $callpkg = caller(0);
      my @symbols = ();
      my @levels = ();
      for (@_) {
  	if (/^[-+]/) {
  	    push(@levels, $_);
  	}
  	else {
  	    push(@symbols, $_);
  	}
      }
      Exporter::export($pack, $callpkg, @symbols);
      level(@levels);
  }
  
  
  sub level
  {
      for (@_) {
  	if ($_ eq '+') {              # all on
  	    # switch on all levels
  	    %current_level = map { $_ => 1 } @levels;
  	}
  	elsif ($_ eq '-') {           # all off
  	    %current_level = ();
  	}
  	elsif (/^([-+])(\w+)$/) {
  	    $current_level{$2} = $1 eq '+';
  	}
  	else {
  	    Carp::croak("Illegal level format $_");
  	}
      }
  }
  
  
  sub trace  { _log(@_) if $current_level{'trace'}; }
  sub debug  { _log(@_) if $current_level{'debug'}; }
  sub conns  { _log(@_) if $current_level{'conns'}; }
  
  
  sub _log
  {
      my $msg = shift;
      $msg .= "\n" unless $msg =~ /\n$/;  # ensure trailing "\n"
  
      my($package,$filename,$line,$sub) = caller(2);
      print STDERR "$sub: $msg";
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::Debug - deprecated
  
  =head1 DESCRIPTION
  
  LWP::Debug is used to provide tracing facilities, but these are not used
  by LWP any more.  The code in this module is kept around
  (undocumented) so that 3rd party code that happens to use the old
  interfaces continue to run.
  
  One useful feature that LWP::Debug provided (in an imprecise and
  troublesome way) was network traffic monitoring.  The following
  section provides some hints about recommended replacements.
  
  =head2 Network traffic monitoring
  
  The best way to monitor the network traffic that LWP generates is to
  use an external TCP monitoring program.  The Wireshark program
  (L<http://www.wireshark.org/>) is highly recommended for this.
  
  Another approach it to use a debugging HTTP proxy server and make
  LWP direct all its traffic via this one.  Call C<< $ua->proxy >> to
  set it up and then just use LWP as before.
  
  For less precise monitoring needs just setting up a few simple
  handlers might do.  The following example sets up handlers to dump the
  request and response objects that pass through LWP:
  
    use LWP::UserAgent;
    $ua = LWP::UserAgent->new;
    $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
  
    $ua->add_handler("request_send",  sub { shift->dump; return });
    $ua->add_handler("response_done", sub { shift->dump; return });
  
    $ua->get("http://www.example.com");
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
LWP_DEBUG

$fatpacked{"LWP/DebugFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_DEBUGFILE';
  package LWP::DebugFile;
  
  # legacy stub
  
  1;
LWP_DEBUGFILE

$fatpacked{"LWP/MemberMixin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_MEMBERMIXIN';
  package LWP::MemberMixin;
  
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = shift if @_;
      return $old;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::MemberMixin - Member access mixin class
  
  =head1 SYNOPSIS
  
   package Foo;
   require LWP::MemberMixin;
   @ISA=qw(LWP::MemberMixin);
  
  =head1 DESCRIPTION
  
  A mixin class to get methods that provide easy access to member
  variables in the %$self.
  Ideally there should be better Perl language support for this.
  
  There is only one method provided:
  
  =over 4
  
  =item _elem($elem [, $val])
  
  Internal method to get/set the value of member variable
  C<$elem>. If C<$val> is present it is used as the new value
  for the member variable.  If it is not present the current
  value is not touched. In both cases the previous value of
  the member variable is returned.
  
  =back
LWP_MEMBERMIXIN

$fatpacked{"LWP/Protocol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL';
  package LWP::Protocol;
  
  require LWP::MemberMixin;
  @ISA = qw(LWP::MemberMixin);
  $VERSION = "6.06";
  
  use strict;
  use Carp ();
  use HTTP::Status ();
  use HTTP::Response;
  
  my %ImplementedBy = (); # scheme => classname
  
  
  
  sub new
  {
      my($class, $scheme, $ua) = @_;
  
      my $self = bless {
  	scheme => $scheme,
  	ua => $ua,
  
  	# historical/redundant
          max_size => $ua->{max_size},
      }, $class;
  
      $self;
  }
  
  
  sub create
  {
      my($scheme, $ua) = @_;
      my $impclass = LWP::Protocol::implementor($scheme) or
  	Carp::croak("Protocol scheme '$scheme' is not supported");
  
      # hand-off to scheme specific implementation sub-class
      my $protocol = $impclass->new($scheme, $ua);
  
      return $protocol;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
  
      if ($impclass) {
  	$ImplementedBy{$scheme} = $impclass;
      }
      my $ic = $ImplementedBy{$scheme};
      return $ic if $ic;
  
      return '' unless $scheme =~ /^([.+\-\w]+)$/;  # check valid URL schemes
      $scheme = $1; # untaint
      $scheme =~ s/[.+\-]/_/g;  # make it a legal module name
  
      # scheme not yet known, look for a 'use'd implementation
      $ic = "LWP::Protocol::$scheme";  # default location
      $ic = "LWP::Protocol::nntp" if $scheme eq 'news'; #XXX ugly hack
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
  	# try to autoload it
  	eval "require $ic";
  	if ($@) {
  	    if ($@ =~ /Can't locate/) { #' #emacs get confused by '
  		$ic = '';
  	    }
  	    else {
  		die "$@\n";
  	    }
  	}
      }
      $ImplementedBy{$scheme} = $ic if $ic;
      $ic;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
      Carp::croak('LWP::Protocol::request() needs to be overridden in subclasses');
  }
  
  
  # legacy
  sub timeout    { shift->_elem('timeout',    @_); }
  sub max_size   { shift->_elem('max_size',   @_); }
  
  
  sub collect
  {
      my ($self, $arg, $response, $collector) = @_;
      my $content;
      my($ua, $max_size) = @{$self}{qw(ua max_size)};
  
      eval {
  	local $\; # protect the print below from surprises
          if (!defined($arg) || !$response->is_success) {
              $response->{default_add_content} = 1;
          }
          elsif (!ref($arg) && length($arg)) {
              open(my $fh, ">", $arg) or die "Can't write to '$arg': $!";
  	    binmode($fh);
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
                      print $fh $_[3] or die "Can't write to '$arg': $!";
                      1;
                  },
              });
              push(@{$response->{handlers}{response_done}}, {
                  callback => sub {
  		    close($fh) or die "Can't write to '$arg': $!";
  		    undef($fh);
  		},
  	    });
          }
          elsif (ref($arg) eq 'CODE') {
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
  		    &$arg($_[3], $_[0], $self);
  		    1;
                  },
              });
          }
          else {
              die "Unexpected collect argument '$arg'";
          }
  
          $ua->run_handlers("response_header", $response);
  
          if (delete $response->{default_add_content}) {
              push(@{$response->{handlers}{response_data}}, {
  		callback => sub {
  		    $_[0]->add_content($_[3]);
  		    1;
  		},
  	    });
          }
  
  
          my $content_size = 0;
          my $length = $response->content_length;
          my %skip_h;
  
          while ($content = &$collector, length $$content) {
              for my $h ($ua->handlers("response_data", $response)) {
                  next if $skip_h{$h};
                  unless ($h->{callback}->($response, $ua, $h, $$content)) {
                      # XXX remove from $response->{handlers}{response_data} if present
                      $skip_h{$h}++;
                  }
              }
              $content_size += length($$content);
              $ua->progress(($length ? ($content_size / $length) : "tick"), $response);
              if (defined($max_size) && $content_size > $max_size) {
                  $response->push_header("Client-Aborted", "max_size");
                  last;
              }
          }
      };
      my $err = $@;
      delete $response->{handlers}{response_data};
      delete $response->{handlers} unless %{$response->{handlers}};
      if ($err) {
          chomp($err);
          $response->push_header('X-Died' => $err);
          $response->push_header("Client-Aborted", "die");
          return $response;
      }
  
      return $response;
  }
  
  
  sub collect_once
  {
      my($self, $arg, $response) = @_;
      my $content = \ $_[3];
      my $first = 1;
      $self->collect($arg, $response, sub {
  	return $content if $first--;
  	return \ "";
      });
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::Protocol - Base class for LWP protocols
  
  =head1 SYNOPSIS
  
   package LWP::Protocol::foo;
   require LWP::Protocol;
   @ISA=qw(LWP::Protocol);
  
  =head1 DESCRIPTION
  
  This class is used a the base class for all protocol implementations
  supported by the LWP library.
  
  When creating an instance of this class using
  C<LWP::Protocol::create($url)>, and you get an initialized subclass
  appropriate for that access method. In other words, the
  LWP::Protocol::create() function calls the constructor for one of its
  subclasses.
  
  All derived LWP::Protocol classes need to override the request()
  method which is used to service a request. The overridden method can
  make use of the collect() function to collect together chunks of data
  as it is received.
  
  The following methods and functions are provided:
  
  =over 4
  
  =item $prot = LWP::Protocol->new()
  
  The LWP::Protocol constructor is inherited by subclasses. As this is a
  virtual base class this method should B<not> be called directly.
  
  =item $prot = LWP::Protocol::create($scheme)
  
  Create an object of the class implementing the protocol to handle the
  given scheme. This is a function, not a method. It is more an object
  factory than a constructor. This is the function user agents should
  use to access protocols.
  
  =item $class = LWP::Protocol::implementor($scheme, [$class])
  
  Get and/or set implementor class for a scheme.  Returns '' if the
  specified scheme is not supported.
  
  =item $prot->request(...)
  
   $response = $protocol->request($request, $proxy, undef);
   $response = $protocol->request($request, $proxy, '/tmp/sss');
   $response = $protocol->request($request, $proxy, \&callback, 1024);
  
  Dispatches a request over the protocol, and returns a response
  object. This method needs to be overridden in subclasses.  Refer to
  L<LWP::UserAgent> for description of the arguments.
  
  =item $prot->collect($arg, $response, $collector)
  
  Called to collect the content of a request, and process it
  appropriately into a scalar, file, or by calling a callback.  If $arg
  is undefined, then the content is stored within the $response.  If
  $arg is a simple scalar, then $arg is interpreted as a file name and
  the content is written to this file.  If $arg is a reference to a
  routine, then content is passed to this routine.
  
  The $collector is a routine that will be called and which is
  responsible for returning pieces (as ref to scalar) of the content to
  process.  The $collector signals EOF by returning a reference to an
  empty string.
  
  The return value from collect() is the $response object reference.
  
  B<Note:> We will only use the callback or file argument if
  $response->is_success().  This avoids sending content data for
  redirects and authentication responses to the callback which would be
  confusing.
  
  =item $prot->collect_once($arg, $response, $content)
  
  Can be called when the whole response content is available as
  $content.  This will invoke collect() with a collector callback that
  returns a reference to $content the first time and an empty string the
  next.
  
  =back
  
  =head1 SEE ALSO
  
  Inspect the F<LWP/Protocol/file.pm> and F<LWP/Protocol/http.pm> files
  for examples of usage.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_PROTOCOL

$fatpacked{"LWP/Protocol/GHTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_GHTTP';
  package LWP::Protocol::GHTTP;
  
  # You can tell LWP to use this module for 'http' requests by running
  # code like this before you make requests:
  #
  #    require LWP::Protocol::GHTTP;
  #    LWP::Protocol::implementor('http', 'LWP::Protocol::GHTTP');
  #
  
  use strict;
  use vars qw(@ISA);
  
  require LWP::Protocol;
  @ISA=qw(LWP::Protocol);
  
  require HTTP::Response;
  require HTTP::Status;
  
  use HTTP::GHTTP qw(METHOD_GET METHOD_HEAD METHOD_POST);
  
  my %METHOD =
  (
   GET  => METHOD_GET,
   HEAD => METHOD_HEAD,
   POST => METHOD_POST,
  );
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      my $method = $request->method;
      unless (exists $METHOD{$method}) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Bad method '$method'");
      }
  
      my $r = HTTP::GHTTP->new($request->uri);
  
      # XXX what headers for repeated headers here?
      $request->headers->scan(sub { $r->set_header(@_)});
  
      $r->set_type($METHOD{$method});
  
      # XXX should also deal with subroutine content.
      my $cref = $request->content_ref;
      $r->set_body($$cref) if length($$cref);
  
      # XXX is this right
      $r->set_proxy($proxy->as_string) if $proxy;
  
      $r->process_request;
  
      my $response = HTTP::Response->new($r->get_status);
  
      # XXX How can get the headers out of $r??  This way is too stupid.
      my @headers;
      eval {
  	# Wrapped in eval because this method is not always available
  	@headers = $r->get_headers;
      };
      @headers = qw(Date Connection Server Content-type
                    Accept-Ranges Server
                    Content-Length Last-Modified ETag) if $@;
      for (@headers) {
  	my $v = $r->get_header($_);
  	$response->header($_ => $v) if defined $v;
      }
  
      return $self->collect_once($arg, $response, $r->get_body);
  }
  
  1;
LWP_PROTOCOL_GHTTP

$fatpacked{"LWP/Protocol/cpan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_CPAN';
  package LWP::Protocol::cpan;
  
  use strict;
  use vars qw(@ISA);
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  require URI;
  require HTTP::Status;
  require HTTP::Response;
  
  our $CPAN;
  
  unless ($CPAN) {
      # Try to find local CPAN mirror via $CPAN::Config
      eval {
  	require CPAN::Config;
  	if($CPAN::Config) {
  	    my $urls = $CPAN::Config->{urllist};
  	    if (ref($urls) eq "ARRAY") {
  		my $file;
  		for (@$urls) {
  		    if (/^file:/) {
  			$file = $_;
  			last;
  		    }
  		}
  
  		if ($file) {
  		    $CPAN = $file;
  		}
  		else {
  		    $CPAN = $urls->[0];
  		}
  	    }
  	}
      };
  
      $CPAN ||= "http://cpan.org/";  # last resort
  }
  
  # ensure that we don't chop of last part
  $CPAN .= "/" unless $CPAN =~ m,/$,;
  
  
  sub request {
      my($self, $request, $proxy, $arg, $size) = @_;
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy with cpan');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'cpan:' URLs");
      }
  
      my $path = $request->uri->path;
      $path =~ s,^/,,;
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_FOUND);
      $response->header("Location" => URI->new_abs($path, $CPAN));
      $response;
  }
  
  1;
LWP_PROTOCOL_CPAN

$fatpacked{"LWP/Protocol/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_DATA';
  package LWP::Protocol::data;
  
  # Implements access to data:-URLs as specified in RFC 2397
  
  use strict;
  use vars qw(@ISA);
  
  require HTTP::Response;
  require HTTP::Status;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use HTTP::Date qw(time2str);
  require LWP;  # needs version number
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with data');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'data:' URLs");
      }
  
      my $url = $request->uri;
      my $response = HTTP::Response->new( &HTTP::Status::RC_OK, "Document follows");
  
      my $media_type = $url->media_type;
  
      my $data = $url->data;
      $response->header('Content-Type'   => $media_type,
  		      'Content-Length' => length($data),
  		      'Date'           => time2str(time),
  		      'Server'         => "libwww-perl-internal/$LWP::VERSION"
  		     );
  
      $data = "" if $method eq "HEAD";
      return $self->collect_once($arg, $response, $data);
  }
  
  1;
LWP_PROTOCOL_DATA

$fatpacked{"LWP/Protocol/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_FILE';
  package LWP::Protocol::file;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use strict;
  
  require LWP::MediaTypes;
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  require HTTP::Date;
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      $size = 4096 unless defined $size and $size > 0;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy through the filesystem');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'file:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'file') {
  	return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "LWP::Protocol::file::request called for '$scheme'");
      }
  
      # URL OK, look at file
      my $path  = $url->file;
  
      # test file exists and is readable
      unless (-e $path) {
  	return HTTP::Response->new( &HTTP::Status::RC_NOT_FOUND,
  				  "File `$path' does not exist");
      }
      unless (-r _) {
  	return HTTP::Response->new( &HTTP::Status::RC_FORBIDDEN,
  				  'User does not have read permission');
      }
  
      # looks like file exists
      my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$filesize,
         $atime,$mtime,$ctime,$blksize,$blocks)
  	    = stat(_);
  
      # XXX should check Accept headers?
  
      # check if-modified-since
      my $ims = $request->header('If-Modified-Since');
      if (defined $ims) {
  	my $time = HTTP::Date::str2time($ims);
  	if (defined $time and $time >= $mtime) {
  	    return HTTP::Response->new( &HTTP::Status::RC_NOT_MODIFIED,
  				      "$method $path");
  	}
      }
  
      # Ok, should be an OK response by now...
      my $response = HTTP::Response->new( &HTTP::Status::RC_OK );
  
      # fill in response headers
      $response->header('Last-Modified', HTTP::Date::time2str($mtime));
  
      if (-d _) {         # If the path is a directory, process it
  	# generate the HTML for directory
  	opendir(D, $path) or
  	   return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				     "Cannot read directory '$path': $!");
  	my(@files) = sort readdir(D);
  	closedir(D);
  
  	# Make directory listing
  	require URI::Escape;
  	require HTML::Entities;
          my $pathe = $path . ( $^O eq 'MacOS' ? ':' : '/');
  	for (@files) {
  	    my $furl = URI::Escape::uri_escape($_);
              if ( -d "$pathe$_" ) {
                  $furl .= '/';
                  $_ .= '/';
              }
  	    my $desc = HTML::Entities::encode($_);
  	    $_ = qq{<LI><A HREF="$furl">$desc</A>};
  	}
  	# Ensure that the base URL is "/" terminated
  	my $base = $url->clone;
  	unless ($base->path =~ m|/$|) {
  	    $base->path($base->path . "/");
  	}
  	my $html = join("\n",
  			"<HTML>\n<HEAD>",
  			"<TITLE>Directory $path</TITLE>",
  			"<BASE HREF=\"$base\">",
  			"</HEAD>\n<BODY>",
  			"<H1>Directory listing of $path</H1>",
  			"<UL>", @files, "</UL>",
  			"</BODY>\n</HTML>\n");
  
  	$response->header('Content-Type',   'text/html');
  	$response->header('Content-Length', length $html);
  	$html = "" if $method eq "HEAD";
  
  	return $self->collect_once($arg, $response, $html);
  
      }
  
      # path is a regular file
      $response->header('Content-Length', $filesize);
      LWP::MediaTypes::guess_media_type($path, $response);
  
      # read the file
      if ($method ne "HEAD") {
  	open(F, $path) or return new
  	    HTTP::Response(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "Cannot read file '$path': $!");
  	binmode(F);
  	$response =  $self->collect($arg, $response, sub {
  	    my $content = "";
  	    my $bytes = sysread(F, $content, $size);
  	    return \$content if $bytes > 0;
  	    return \ "";
  	});
  	close(F);
      }
  
      $response;
  }
  
  1;
LWP_PROTOCOL_FILE

$fatpacked{"LWP/Protocol/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_FTP';
  package LWP::Protocol::ftp;
  
  # Implementation of the ftp protocol (RFC 959). We let the Net::FTP
  # package do all the dirty work.
  
  use Carp ();
  
  use HTTP::Status ();
  use HTTP::Negotiate ();
  use HTTP::Response ();
  use LWP::MediaTypes ();
  use File::Listing ();
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use strict;
  eval {
      package LWP::Protocol::MyFTP;
  
      require Net::FTP;
      Net::FTP->require_version(2.00);
  
      use vars qw(@ISA);
      @ISA=qw(Net::FTP);
  
      sub new {
  	my $class = shift;
  
  	my $self = $class->SUPER::new(@_) || return undef;
  
  	my $mess = $self->message;  # welcome message
  	$mess =~ s|\n.*||s; # only first line left
  	$mess =~ s|\s*ready\.?$||;
  	# Make the version number more HTTP like
  	$mess =~ s|\s*\(Version\s*|/| and $mess =~ s|\)$||;
  	${*$self}{myftp_server} = $mess;
  	#$response->header("Server", $mess);
  
  	$self;
      }
  
      sub http_server {
  	my $self = shift;
  	${*$self}{myftp_server};
      }
  
      sub home {
  	my $self = shift;
  	my $old = ${*$self}{myftp_home};
  	if (@_) {
  	    ${*$self}{myftp_home} = shift;
  	}
  	$old;
      }
  
      sub go_home {
  	my $self = shift;
  	$self->cwd(${*$self}{myftp_home});
      }
  
      sub request_count {
  	my $self = shift;
  	++${*$self}{myftp_reqcount};
      }
  
      sub ping {
  	my $self = shift;
  	return $self->go_home;
      }
  
  };
  my $init_failed = $@;
  
  
  sub _connect {
      my($self, $host, $port, $user, $account, $password, $timeout) = @_;
  
      my $key;
      my $conn_cache = $self->{ua}{conn_cache};
      if ($conn_cache) {
  	$key = "$host:$port:$user";
  	$key .= ":$account" if defined($account);
  	if (my $ftp = $conn_cache->withdraw("ftp", $key)) {
  	    if ($ftp->ping) {
  		# save it again
  		$conn_cache->deposit("ftp", $key, $ftp);
  		return $ftp;
  	    }
  	}
      }
  
      # try to make a connection
      my $ftp = LWP::Protocol::MyFTP->new($host,
  					Port => $port,
  					Timeout => $timeout,
  					LocalAddr => $self->{ua}{local_address},
  				       );
      # XXX Should be some what to pass on 'Passive' (header??)
      unless ($ftp) {
  	$@ =~ s/^Net::FTP: //;
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR, $@);
      }
  
      unless ($ftp->login($user, $password, $account)) {
  	# Unauthorized.  Let's fake a RC_UNAUTHORIZED response
  	my $mess = scalar($ftp->message);
  	$mess =~ s/\n$//;
  	my $res =  HTTP::Response->new(&HTTP::Status::RC_UNAUTHORIZED, $mess);
  	$res->header("Server", $ftp->http_server);
  	$res->header("WWW-Authenticate", qq(Basic Realm="FTP login"));
  	return $res;
      }
  
      my $home = $ftp->pwd;
      $ftp->home($home);
  
      $conn_cache->deposit("ftp", $key, $ftp) if $conn_cache;
  
      return $ftp;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the ftp');
      }
  
      my $url = $request->uri;
      if ($url->scheme ne 'ftp') {
  	my $scheme = $url->scheme;
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  		       "LWP::Protocol::ftp::request called for '$scheme'");
      }
  
      # check method
      my $method = $request->method;
  
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'PUT') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'ftp:' URLs");
      }
  
      if ($init_failed) {
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				   $init_failed);
      }
  
      my $host     = $url->host;
      my $port     = $url->port;
      my $user     = $url->user;
      my $password = $url->password;
  
      # If a basic authorization header is present than we prefer these over
      # the username/password specified in the URL.
      {
  	my($u,$p) = $request->authorization_basic;
  	if (defined $u) {
  	    $user = $u;
  	    $password = $p;
  	}
      }
  
      # We allow the account to be specified in the "Account" header
      my $account = $request->header('Account');
  
      my $ftp = $self->_connect($host, $port, $user, $account, $password, $timeout);
      return $ftp if ref($ftp) eq "HTTP::Response"; # ugh!
  
      # Create an initial response object
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
      $response->header(Server => $ftp->http_server);
      $response->header('Client-Request-Num' => $ftp->request_count);
      $response->request($request);
  
      # Get & fix the path
      my @path =  grep { length } $url->path_segments;
      my $remote_file = pop(@path);
      $remote_file = '' unless defined $remote_file;
  
      my $type;
      if (ref $remote_file) {
  	my @params;
  	($remote_file, @params) = @$remote_file;
  	for (@params) {
  	    $type = $_ if s/^type=//;
  	}
      }
  
      if ($type && $type eq 'a') {
  	$ftp->ascii;
      }
      else {
  	$ftp->binary;
      }
  
      for (@path) {
  	unless ($ftp->cwd($_)) {
  	    return HTTP::Response->new(&HTTP::Status::RC_NOT_FOUND,
  				       "Can't chdir to $_");
  	}
      }
  
      if ($method eq 'GET' || $method eq 'HEAD') {
  	if (my $mod_time = $ftp->mdtm($remote_file)) {
  	    $response->last_modified($mod_time);
  	    if (my $ims = $request->if_modified_since) {
  		if ($mod_time <= $ims) {
  		    $response->code(&HTTP::Status::RC_NOT_MODIFIED);
  		    $response->message("Not modified");
  		    return $response;
  		}
  	    }
  	}
  
  	# We'll use this later to abort the transfer if necessary. 
  	# if $max_size is defined, we need to abort early. Otherwise, it's
        # a normal transfer
  	my $max_size = undef;
  
  	# Set resume location, if the client requested it
  	if ($request->header('Range') && $ftp->supported('REST'))
  	{
  		my $range_info = $request->header('Range');
  
  		# Change bytes=2772992-6781209 to just 2772992
  		my ($start_byte,$end_byte) = $range_info =~ /.*=\s*(\d+)-(\d+)?/;
  		if ( defined $start_byte && !defined $end_byte ) {
  
  		  # open range -- only the start is specified
  
  		  $ftp->restart( $start_byte );
  		  # don't define $max_size, we don't want to abort early
  		}
  		elsif ( defined $start_byte && defined $end_byte &&
  			$start_byte >= 0 && $end_byte >= $start_byte ) {
  
  		  $ftp->restart( $start_byte );
  		  $max_size = $end_byte - $start_byte;
  		}
  		else {
  
  		  return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  		     'Incorrect syntax for Range request');
  		}
  	}
  	elsif ($request->header('Range') && !$ftp->supported('REST'))
  	{
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_IMPLEMENTED,
  	         "Server does not support resume.");
  	}
  
  	my $data;  # the data handle
  	if (length($remote_file) and $data = $ftp->retr($remote_file)) {
  	    my($type, @enc) = LWP::MediaTypes::guess_media_type($remote_file);
  	    $response->header('Content-Type',   $type) if $type;
  	    for (@enc) {
  		$response->push_header('Content-Encoding', $_);
  	    }
  	    my $mess = $ftp->message;
  	    if ($mess =~ /\((\d+)\s+bytes\)/) {
  		$response->header('Content-Length', "$1");
  	    }
  
  	    if ($method ne 'HEAD') {
  		# Read data from server
  		$response = $self->collect($arg, $response, sub {
  		    my $content = '';
  		    my $result = $data->read($content, $size);
  
                      # Stop early if we need to.
                      if (defined $max_size)
                      {
                        # We need an interface to Net::FTP::dataconn for getting
                        # the number of bytes already read
                        my $bytes_received = $data->bytes_read();
  
                        # We were already over the limit. (Should only happen
                        # once at the end.)
                        if ($bytes_received - length($content) > $max_size)
                        {
                          $content = '';
                        }
                        # We just went over the limit
                        elsif ($bytes_received  > $max_size)
                        {
                          # Trim content
                          $content = substr($content, 0,
                            $max_size - ($bytes_received - length($content)) );
                        }
                        # We're under the limit
                        else
                        {
                        }
                      }
  
  		    return \$content;
  		} );
  	    }
  	    # abort is needed for HEAD, it's == close if the transfer has
  	    # already completed.
  	    unless ($data->abort) {
  		# Something did not work too well.  Note that we treat
  		# responses to abort() with code 0 in case of HEAD as ok
  		# (at least wu-ftpd 2.6.1(1) does that).
  		if ($method ne 'HEAD' || $ftp->code != 0) {
  		    $response->code(&HTTP::Status::RC_INTERNAL_SERVER_ERROR);
  		    $response->message("FTP close response: " . $ftp->code .
  				       " " . $ftp->message);
  		}
  	    }
  	}
  	elsif (!length($remote_file) || ( $ftp->code >= 400 && $ftp->code < 600 )) {
  	    # not a plain file, try to list instead
  	    if (length($remote_file) && !$ftp->cwd($remote_file)) {
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_FOUND,
  					   "File '$remote_file' not found");
  	    }
  
  	    # It should now be safe to try to list the directory
  	    my @lsl = $ftp->dir;
  
  	    # Try to figure out if the user want us to convert the
  	    # directory listing to HTML.
  	    my @variants =
  	      (
  	       ['html',  0.60, 'text/html'            ],
  	       ['dir',   1.00, 'text/ftp-dir-listing' ]
  	      );
  	    #$HTTP::Negotiate::DEBUG=1;
  	    my $prefer = HTTP::Negotiate::choose(\@variants, $request);
  
  	    my $content = '';
  
  	    if (!defined($prefer)) {
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_ACCEPTABLE,
  			       "Neither HTML nor directory listing wanted");
  	    }
  	    elsif ($prefer eq 'html') {
  		$response->header('Content-Type' => 'text/html');
  		$content = "<HEAD><TITLE>File Listing</TITLE>\n";
  		my $base = $request->uri->clone;
  		my $path = $base->path;
  		$base->path("$path/") unless $path =~ m|/$|;
  		$content .= qq(<BASE HREF="$base">\n</HEAD>\n);
  		$content .= "<BODY>\n<UL>\n";
  		for (File::Listing::parse_dir(\@lsl, 'GMT')) {
  		    my($name, $type, $size, $mtime, $mode) = @$_;
  		    $content .= qq(  <LI> <a href="$name">$name</a>);
  		    $content .= " $size bytes" if $type eq 'f';
  		    $content .= "\n";
  		}
  		$content .= "</UL></body>\n";
  	    }
  	    else {
  		$response->header('Content-Type', 'text/ftp-dir-listing');
  		$content = join("\n", @lsl, '');
  	    }
  
  	    $response->header('Content-Length', length($content));
  
  	    if ($method ne 'HEAD') {
  		$response = $self->collect_once($arg, $response, $content);
  	    }
  	}
  	else {
  	    my $res = HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  			  "FTP return code " . $ftp->code);
  	    $res->content_type("text/plain");
  	    $res->content($ftp->message);
  	    return $res;
  	}
      }
      elsif ($method eq 'PUT') {
  	# method must be PUT
  	unless (length($remote_file)) {
  	    return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				       "Must have a file name to PUT to");
  	}
  	my $data;
  	if ($data = $ftp->stor($remote_file)) {
  	    my $content = $request->content;
  	    my $bytes = 0;
  	    if (defined $content) {
  		if (ref($content) eq 'SCALAR') {
  		    $bytes = $data->write($$content, length($$content));
  		}
  		elsif (ref($content) eq 'CODE') {
  		    my($buf, $n);
  		    while (length($buf = &$content)) {
  			$n = $data->write($buf, length($buf));
  			last unless $n;
  			$bytes += $n;
  		    }
  		}
  		elsif (!ref($content)) {
  		    if (defined $content && length($content)) {
  			$bytes = $data->write($content, length($content));
  		    }
  		}
  		else {
  		    die "Bad content";
  		}
  	    }
  	    $data->close;
  
  	    $response->code(&HTTP::Status::RC_CREATED);
  	    $response->header('Content-Type', 'text/plain');
  	    $response->content("$bytes bytes stored as $remote_file on $host\n")
  
  	}
  	else {
  	    my $res = HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  					  "FTP return code " . $ftp->code);
  	    $res->content_type("text/plain");
  	    $res->content($ftp->message);
  	    return $res;
  	}
      }
      else {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Illegal method $method");
      }
  
      $response;
  }
  
  1;
  
  __END__
  
  # This is what RFC 1738 has to say about FTP access:
  # --------------------------------------------------
  #
  # 3.2. FTP
  #
  #    The FTP URL scheme is used to designate files and directories on
  #    Internet hosts accessible using the FTP protocol (RFC959).
  #
  #    A FTP URL follow the syntax described in Section 3.1.  If :<port> is
  #    omitted, the port defaults to 21.
  #
  # 3.2.1. FTP Name and Password
  #
  #    A user name and password may be supplied; they are used in the ftp
  #    "USER" and "PASS" commands after first making the connection to the
  #    FTP server.  If no user name or password is supplied and one is
  #    requested by the FTP server, the conventions for "anonymous" FTP are
  #    to be used, as follows:
  #
  #         The user name "anonymous" is supplied.
  #
  #         The password is supplied as the Internet e-mail address
  #         of the end user accessing the resource.
  #
  #    If the URL supplies a user name but no password, and the remote
  #    server requests a password, the program interpreting the FTP URL
  #    should request one from the user.
  #
  # 3.2.2. FTP url-path
  #
  #    The url-path of a FTP URL has the following syntax:
  #
  #         <cwd1>/<cwd2>/.../<cwdN>/<name>;type=<typecode>
  #
  #    Where <cwd1> through <cwdN> and <name> are (possibly encoded) strings
  #    and <typecode> is one of the characters "a", "i", or "d".  The part
  #    ";type=<typecode>" may be omitted. The <cwdx> and <name> parts may be
  #    empty. The whole url-path may be omitted, including the "/"
  #    delimiting it from the prefix containing user, password, host, and
  #    port.
  #
  #    The url-path is interpreted as a series of FTP commands as follows:
  #
  #       Each of the <cwd> elements is to be supplied, sequentially, as the
  #       argument to a CWD (change working directory) command.
  #
  #       If the typecode is "d", perform a NLST (name list) command with
  #       <name> as the argument, and interpret the results as a file
  #       directory listing.
  #
  #       Otherwise, perform a TYPE command with <typecode> as the argument,
  #       and then access the file whose name is <name> (for example, using
  #       the RETR command.)
  #
  #    Within a name or CWD component, the characters "/" and ";" are
  #    reserved and must be encoded. The components are decoded prior to
  #    their use in the FTP protocol.  In particular, if the appropriate FTP
  #    sequence to access a particular file requires supplying a string
  #    containing a "/" as an argument to a CWD or RETR command, it is
  #    necessary to encode each "/".
  #
  #    For example, the URL <URL:ftp://myname@host.dom/%2Fetc/motd> is
  #    interpreted by FTP-ing to "host.dom", logging in as "myname"
  #    (prompting for a password if it is asked for), and then executing
  #    "CWD /etc" and then "RETR motd". This has a different meaning from
  #    <URL:ftp://myname@host.dom/etc/motd> which would "CWD etc" and then
  #    "RETR motd"; the initial "CWD" might be executed relative to the
  #    default directory for "myname". On the other hand,
  #    <URL:ftp://myname@host.dom//etc/motd>, would "CWD " with a null
  #    argument, then "CWD etc", and then "RETR motd".
  #
  #    FTP URLs may also be used for other operations; for example, it is
  #    possible to update a file on a remote file server, or infer
  #    information about it from the directory listings. The mechanism for
  #    doing so is not spelled out here.
  #
  # 3.2.3. FTP Typecode is Optional
  #
  #    The entire ;type=<typecode> part of a FTP URL is optional. If it is
  #    omitted, the client program interpreting the URL must guess the
  #    appropriate mode to use. In general, the data content type of a file
  #    can only be guessed from the name, e.g., from the suffix of the name;
  #    the appropriate type code to be used for transfer of the file can
  #    then be deduced from the data content of the file.
  #
  # 3.2.4 Hierarchy
  #
  #    For some file systems, the "/" used to denote the hierarchical
  #    structure of the URL corresponds to the delimiter used to construct a
  #    file name hierarchy, and thus, the filename will look similar to the
  #    URL path. This does NOT mean that the URL is a Unix filename.
  #
  # 3.2.5. Optimization
  #
  #    Clients accessing resources via FTP may employ additional heuristics
  #    to optimize the interaction. For some FTP servers, for example, it
  #    may be reasonable to keep the control connection open while accessing
  #    multiple URLs from the same server. However, there is no common
  #    hierarchical model to the FTP protocol, so if a directory change
  #    command has been given, it is impossible in general to deduce what
  #    sequence should be given to navigate to another directory for a
  #    second retrieval, if the paths are different.  The only reliable
  #    algorithm is to disconnect and reestablish the control connection.
LWP_PROTOCOL_FTP

$fatpacked{"LWP/Protocol/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_GOPHER';
  package LWP::Protocol::gopher;
  
  # Implementation of the gopher protocol (RFC 1436)
  #
  # This code is based on 'wwwgopher.pl,v 0.10 1994/10/17 18:12:34 shelden'
  # which in turn is a vastly modified version of Oscar's http'get()
  # dated 28/3/94 in <ftp://cui.unige.ch/PUBLIC/oscar/scripts/http.pl>
  # including contributions from Marc van Heyningen and Martijn Koster.
  
  use strict;
  use vars qw(@ISA);
  
  require HTTP::Response;
  require HTTP::Status;
  require IO::Socket;
  require IO::Select;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  
  my %gopher2mimetype = (
      '0' => 'text/plain',                # 0 file
      '1' => 'text/html',                 # 1 menu
  					# 2 CSO phone-book server
  					# 3 Error
      '4' => 'application/mac-binhex40',  # 4 BinHexed Macintosh file
      '5' => 'application/zip',           # 5 DOS binary archive of some sort
      '6' => 'application/octet-stream',  # 6 UNIX uuencoded file.
      '7' => 'text/html',                 # 7 Index-Search server
  					# 8 telnet session
      '9' => 'application/octet-stream',  # 9 binary file
      'h' => 'text/html',                 # html
      'g' => 'image/gif',                 # gif
      'I' => 'image/*',                   # some kind of image
  );
  
  my %gopher2encoding = (
      '6' => 'x_uuencode',                # 6 UNIX uuencoded file.
  );
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the gopher');
      }
  
      my $url = $request->uri;
      die "bad scheme" if $url->scheme ne 'gopher';
  
  
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'gopher:' URLs");
      }
  
      my $gophertype = $url->gopher_type;
      unless (exists $gopher2mimetype{$gophertype}) {
  	return HTTP::Response->new(&HTTP::Status::RC_NOT_IMPLEMENTED,
  				   'Library does not support gophertype ' .
  				   $gophertype);
      }
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
      $response->header('Content-type' => $gopher2mimetype{$gophertype}
  					|| 'text/plain');
      $response->header('Content-Encoding' => $gopher2encoding{$gophertype})
  	if exists $gopher2encoding{$gophertype};
  
      if ($method eq 'HEAD') {
  	# XXX: don't even try it so we set this header
  	$response->header('Client-Warning' => 'Client answer only');
  	return $response;
      }
      
      if ($gophertype eq '7' && ! $url->search) {
        # the url is the prompt for a gopher search; supply boiler-plate
        return $self->collect_once($arg, $response, <<"EOT");
  <HEAD>
  <TITLE>Gopher Index</TITLE>
  <ISINDEX>
  </HEAD>
  <BODY>
  <H1>$url<BR>Gopher Search</H1>
  This is a searchable Gopher index.
  Use the search function of your browser to enter search terms.
  </BODY>
  EOT
      }
  
      my $host = $url->host;
      my $port = $url->port;
  
      my $requestLine = "";
  
      my $selector = $url->selector;
      if (defined $selector) {
  	$requestLine .= $selector;
  	my $search = $url->search;
  	if (defined $search) {
  	    $requestLine .= "\t$search";
  	    my $string = $url->string;
  	    if (defined $string) {
  		$requestLine .= "\t$string";
  	    }
  	}
      }
      $requestLine .= "\015\012";
  
      # potential request headers are just ignored
  
      # Ok, lets make the request
      my $socket = IO::Socket::INET->new(PeerAddr => $host,
  				       PeerPort => $port,
  				       LocalAddr => $self->{ua}{local_address},
  				       Proto    => 'tcp',
  				       Timeout  => $timeout);
      die "Can't connect to $host:$port" unless $socket;
      my $sel = IO::Select->new($socket);
  
      {
  	die "write timeout" if $timeout && !$sel->can_write($timeout);
  	my $n = syswrite($socket, $requestLine, length($requestLine));
  	die $! unless defined($n);
  	die "short write" if $n != length($requestLine);
      }
  
      my $user_arg = $arg;
  
      # must handle menus in a special way since they are to be
      # converted to HTML.  Undefing $arg ensures that the user does
      # not see the data before we get a change to convert it.
      $arg = undef if $gophertype eq '1' || $gophertype eq '7';
  
      # collect response
      my $buf = '';
      $response = $self->collect($arg, $response, sub {
  	die "read timeout" if $timeout && !$sel->can_read($timeout);
          my $n = sysread($socket, $buf, $size);
  	die $! unless defined($n);
  	return \$buf;
        } );
  
      # Convert menu to HTML and return data to user.
      if ($gophertype eq '1' || $gophertype eq '7') {
  	my $content = menu2html($response->content);
  	if (defined $user_arg) {
  	    $response = $self->collect_once($user_arg, $response, $content);
  	}
  	else {
  	    $response->content($content);
  	}
      }
  
      $response;
  }
  
  
  sub gopher2url
  {
      my($gophertype, $path, $host, $port) = @_;
  
      my $url;
  
      if ($gophertype eq '8' || $gophertype eq 'T') {
  	# telnet session
  	$url = $HTTP::URI_CLASS->new($gophertype eq '8' ? 'telnet:':'tn3270:');
  	$url->user($path) if defined $path;
      }
      else {
  	$path = URI::Escape::uri_escape($path);
  	$url = $HTTP::URI_CLASS->new("gopher:/$gophertype$path");
      }
      $url->host($host);
      $url->port($port);
      $url;
  }
  
  sub menu2html {
      my($menu) = @_;
  
      $menu =~ s/\015//g;  # remove carriage return
      my $tmp = <<"EOT";
  <HTML>
  <HEAD>
     <TITLE>Gopher menu</TITLE>
  </HEAD>
  <BODY>
  <H1>Gopher menu</H1>
  EOT
      for (split("\n", $menu)) {
  	last if /^\./;
  	my($pretty, $path, $host, $port) = split("\t");
  
  	$pretty =~ s/^(.)//;
  	my $type = $1;
  
  	my $url = gopher2url($type, $path, $host, $port)->as_string;
  	$tmp .= qq{<A HREF="$url">$pretty</A><BR>\n};
      }
      $tmp .= "</BODY>\n</HTML>\n";
      $tmp;
  }
  
  1;
LWP_PROTOCOL_GOPHER

$fatpacked{"LWP/Protocol/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_HTTP';
  package LWP::Protocol::http;
  
  use strict;
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::HTTP;
  
  use vars qw(@ISA @EXTRA_SOCK_OPTS);
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  my $CRLF = "\015\012";
  
  sub _new_socket
  {
      my($self, $host, $port, $timeout) = @_;
  
      local($^W) = 0;  # IO::Socket::INET can be noisy
      my $sock = $self->socket_class->new(PeerAddr => $host,
  					PeerPort => $port,
  					LocalAddr => $self->{ua}{local_address},
  					Proto    => 'tcp',
  					Timeout  => $timeout,
  					KeepAlive => !!$self->{ua}{conn_cache},
  					SendTE    => 1,
  					$self->_extra_sock_opts($host, $port),
  				       );
  
      unless ($sock) {
  	# IO::Socket::INET leaves additional error messages in $@
  	my $status = "Can't connect to $host:$port";
  	if ($@ =~ /\bconnect: (.*)/ ||
  	    $@ =~ /\b(Bad hostname)\b/ ||
  	    $@ =~ /\b(certificate verify failed)\b/ ||
  	    $@ =~ /\b(Crypt-SSLeay can't verify hostnames)\b/
  	) {
  	    $status .= " ($1)";
  	}
  	die "$status\n\n$@";
      }
  
      # perl 5.005's IO::Socket does not have the blocking method.
      eval { $sock->blocking(0); };
  
      $sock;
  }
  
  sub socket_type
  {
      return "http";
  }
  
  sub socket_class
  {
      my $self = shift;
      (ref($self) || $self) . "::Socket";
  }
  
  sub _extra_sock_opts  # to be overridden by subclass
  {
      return @EXTRA_SOCK_OPTS;
  }
  
  sub _check_sock
  {
      #my($self, $req, $sock) = @_;
  }
  
  sub _get_sock_info
  {
      my($self, $res, $sock) = @_;
      if (defined(my $peerhost = $sock->peerhost)) {
          $res->header("Client-Peer" => "$peerhost:" . $sock->peerport);
      }
  }
  
  sub _fixup_header
  {
      my($self, $h, $url, $proxy) = @_;
  
      # Extract 'Host' header
      my $hhost = $url->authority;
      if ($hhost =~ s/^([^\@]*)\@//) {  # get rid of potential "user:pass@"
  	# add authorization header if we need them.  HTTP URLs do
  	# not really support specification of user and password, but
  	# we allow it.
  	if (defined($1) && not $h->header('Authorization')) {
  	    require URI::Escape;
  	    $h->authorization_basic(map URI::Escape::uri_unescape($_),
  				    split(":", $1, 2));
  	}
      }
      $h->init_header('Host' => $hhost);
  
      if ($proxy && $url->scheme ne 'https') {
  	# Check the proxy URI's userinfo() for proxy credentials
  	# export http_proxy="http://proxyuser:proxypass@proxyhost:port".
  	# For https only the initial CONNECT requests needs authorization.
  	my $p_auth = $proxy->userinfo();
  	if(defined $p_auth) {
  	    require URI::Escape;
  	    $h->proxy_authorization_basic(map URI::Escape::uri_unescape($_),
  					  split(":", $p_auth, 2))
  	}
      }
  }
  
  sub hlist_remove {
      my($hlist, $k) = @_;
      $k = lc $k;
      for (my $i = @$hlist - 2; $i >= 0; $i -= 2) {
  	next unless lc($hlist->[$i]) eq $k;
  	splice(@$hlist, $i, 2);
      }
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size ||= 4096;
  
      # check method
      my $method = $request->method;
      unless ($method =~ /^[A-Za-z0-9_!\#\$%&\'*+\-.^\`|~]+$/) {  # HTTP token
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'http:' URLs");
      }
  
      my $url = $request->uri;
  
      # Proxying SSL with a http proxy needs issues a CONNECT request to build a
      # tunnel and then upgrades the tunnel to SSL. But when doing keep-alive the
      # https request does not need to be the first request in the connection, so
      # we need to distinguish between
      # - not yet connected (create socket and ssl upgrade)
      # - connected but not inside ssl tunnel (ssl upgrade)
      # - inside ssl tunnel to the target - once we are in the tunnel to the
      #   target we cannot only reuse the tunnel for more https requests with the
      #   same target
  
      my $ssl_tunnel = $proxy && $url->scheme eq 'https'
  	&& $url->host.":".$url->port;
  
      my ($host,$port) = $proxy
  	? ($proxy->host,$proxy->port)
  	: ($url->host,$url->port);
      my $fullpath =
  	$method eq 'CONNECT' ? $url->host . ":" . $url->port :
  	$proxy && ! $ssl_tunnel ? $url->as_string :
  	do {
  	    my $path = $url->path_query;
  	    $path = "/$path" if $path !~m{^/};
  	    $path
  	};
  
      my $socket;
      my $conn_cache = $self->{ua}{conn_cache};
      my $cache_key;
      if ( $conn_cache ) {
  	$cache_key = "$host:$port";
  	# For https we reuse the socket immediatly only if it has an established
  	# tunnel to the target. Otherwise a CONNECT request followed by an SSL
  	# upgrade need to be done first. The request itself might reuse an
  	# existing non-ssl connection to the proxy
  	$cache_key .= "!".$ssl_tunnel if $ssl_tunnel;
  	if ( $socket = $conn_cache->withdraw($self->socket_type,$cache_key)) {
  	    if ($socket->can_read(0)) {
  		# if the socket is readable, then either the peer has closed the
  		# connection or there are some garbage bytes on it.  In either
  		# case we abandon it.
  		$socket->close;
  		$socket = undef;
  	    } # else use $socket
  	}
      }
  
      if ( ! $socket && $ssl_tunnel ) {
  	my $proto_https = LWP::Protocol::create('https',$self->{ua})
  	    or die "no support for scheme https found";
  
  	# only if ssl socket class is IO::Socket::SSL we can upgrade
  	# a plain socket to SSL. In case of Net::SSL we fall back to
  	# the old version
  	if ( my $upgrade_sub = $proto_https->can('_upgrade_sock')) {
  	    my $response = $self->request(
  		HTTP::Request->new('CONNECT',"http://$ssl_tunnel"),
  		$proxy,
  		undef,$size,$timeout
  	    );
  	    $response->is_success or die
  		"establishing SSL tunnel failed: ".$response->status_line;
  	    $socket = $upgrade_sub->($proto_https,
  		$response->{client_socket},$url)
  		or die "SSL upgrade failed: $@";
  	} else {
  	    $socket = $proto_https->_new_socket($url->host,$url->port,$timeout);
  	}
      }
  
      if ( ! $socket ) {
  	# connect to remote site w/o reusing established socket
  	$socket = $self->_new_socket($host, $port, $timeout );
      }
  
      my $http_version = "";
      if (my $proto = $request->protocol) {
  	if ($proto =~ /^(?:HTTP\/)?(1.\d+)$/) {
  	    $http_version = $1;
  	    $socket->http_version($http_version);
  	    $socket->send_te(0) if $http_version eq "1.0";
  	}
      }
  
      $self->_check_sock($request, $socket);
  
      my @h;
      my $request_headers = $request->headers->clone;
      $self->_fixup_header($request_headers, $url, $proxy);
  
      $request_headers->scan(sub {
  			       my($k, $v) = @_;
  			       $k =~ s/^://;
  			       $v =~ s/\n/ /g;
  			       push(@h, $k, $v);
  			   });
  
      my $content_ref = $request->content_ref;
      $content_ref = $$content_ref if ref($$content_ref);
      my $chunked;
      my $has_content;
  
      if (ref($content_ref) eq 'CODE') {
  	my $clen = $request_headers->header('Content-Length');
  	$has_content++ if $clen;
  	unless (defined $clen) {
  	    push(@h, "Transfer-Encoding" => "chunked");
  	    $has_content++;
  	    $chunked++;
  	}
      }
      else {
  	# Set (or override) Content-Length header
  	my $clen = $request_headers->header('Content-Length');
  	if (defined($$content_ref) && length($$content_ref)) {
  	    $has_content = length($$content_ref);
  	    if (!defined($clen) || $clen ne $has_content) {
  		if (defined $clen) {
  		    warn "Content-Length header value was wrong, fixed";
  		    hlist_remove(\@h, 'Content-Length');
  		}
  		push(@h, 'Content-Length' => $has_content);
  	    }
  	}
  	elsif ($clen) {
  	    warn "Content-Length set when there is no content, fixed";
  	    hlist_remove(\@h, 'Content-Length');
  	}
      }
  
      my $write_wait = 0;
      $write_wait = 2
  	if ($request_headers->header("Expect") || "") =~ /100-continue/;
  
      my $req_buf = $socket->format_request($method, $fullpath, @h);
      #print "------\n$req_buf\n------\n";
  
      if (!$has_content || $write_wait || $has_content > 8*1024) {
        WRITE:
          {
              # Since this just writes out the header block it should almost
              # always succeed to send the whole buffer in a single write call.
              my $n = $socket->syswrite($req_buf, length($req_buf));
              unless (defined $n) {
                  redo WRITE if $!{EINTR};
                  if ($!{EAGAIN}) {
                      select(undef, undef, undef, 0.1);
                      redo WRITE;
                  }
                  die "write failed: $!";
              }
              if ($n) {
                  substr($req_buf, 0, $n, "");
              }
              else {
                  select(undef, undef, undef, 0.5);
              }
              redo WRITE if length $req_buf;
          }
      }
  
      my($code, $mess, @junk);
      my $drop_connection;
  
      if ($has_content) {
  	my $eof;
  	my $wbuf;
  	my $woffset = 0;
        INITIAL_READ:
  	if ($write_wait) {
  	    # skip filling $wbuf when waiting for 100-continue
  	    # because if the response is a redirect or auth required
  	    # the request will be cloned and there is no way
  	    # to reset the input stream
  	    # return here via the label after the 100-continue is read
  	}
  	elsif (ref($content_ref) eq 'CODE') {
  	    my $buf = &$content_ref();
  	    $buf = "" unless defined($buf);
  	    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  		if $chunked;
  	    substr($buf, 0, 0) = $req_buf if $req_buf;
  	    $wbuf = \$buf;
  	}
  	else {
  	    if ($req_buf) {
  		my $buf = $req_buf . $$content_ref;
  		$wbuf = \$buf;
  	    }
  	    else {
  		$wbuf = $content_ref;
  	    }
  	    $eof = 1;
  	}
  
  	my $fbits = '';
  	vec($fbits, fileno($socket), 1) = 1;
  
        WRITE:
  	while ($write_wait || $woffset < length($$wbuf)) {
  
  	    my $sel_timeout = $timeout;
  	    if ($write_wait) {
  		$sel_timeout = $write_wait if $write_wait < $sel_timeout;
  	    }
  	    my $time_before;
              $time_before = time if $sel_timeout;
  
  	    my $rbits = $fbits;
  	    my $wbits = $write_wait ? undef : $fbits;
              my $sel_timeout_before = $sel_timeout;
            SELECT:
              {
                  my $nfound = select($rbits, $wbits, undef, $sel_timeout);
                  if ($nfound < 0) {
                      if ($!{EINTR} || $!{EAGAIN}) {
                          if ($time_before) {
                              $sel_timeout = $sel_timeout_before - (time - $time_before);
                              $sel_timeout = 0 if $sel_timeout < 0;
                          }
                          redo SELECT;
                      }
                      die "select failed: $!";
                  }
  	    }
  
  	    if ($write_wait) {
  		$write_wait -= time - $time_before;
  		$write_wait = 0 if $write_wait < 0;
  	    }
  
  	    if (defined($rbits) && $rbits =~ /[^\0]/) {
  		# readable
  		my $buf = $socket->_rbuf;
  		my $n = $socket->sysread($buf, 1024, length($buf));
                  unless (defined $n) {
                      die "read failed: $!" unless  $!{EINTR} || $!{EAGAIN};
                      # if we get here the rest of the block will do nothing
                      # and we will retry the read on the next round
                  }
  		elsif ($n == 0) {
                      # the server closed the connection before we finished
                      # writing all the request content.  No need to write any more.
                      $drop_connection++;
                      last WRITE;
  		}
  		$socket->_rbuf($buf);
  		if (!$code && $buf =~ /\015?\012\015?\012/) {
  		    # a whole response header is present, so we can read it without blocking
  		    ($code, $mess, @h) = $socket->read_response_headers(laxed => 1,
  									junk_out => \@junk,
  								       );
  		    if ($code eq "100") {
  			$write_wait = 0;
  			undef($code);
  			goto INITIAL_READ;
  		    }
  		    else {
  			$drop_connection++;
  			last WRITE;
  			# XXX should perhaps try to abort write in a nice way too
  		    }
  		}
  	    }
  	    if (defined($wbits) && $wbits =~ /[^\0]/) {
  		my $n = $socket->syswrite($$wbuf, length($$wbuf), $woffset);
                  unless (defined $n) {
                      die "write failed: $!" unless $!{EINTR} || $!{EAGAIN};
                      $n = 0;  # will retry write on the next round
                  }
                  elsif ($n == 0) {
  		    die "write failed: no bytes written";
  		}
  		$woffset += $n;
  
  		if (!$eof && $woffset >= length($$wbuf)) {
  		    # need to refill buffer from $content_ref code
  		    my $buf = &$content_ref();
  		    $buf = "" unless defined($buf);
  		    $eof++ unless length($buf);
  		    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  			if $chunked;
  		    $wbuf = \$buf;
  		    $woffset = 0;
  		}
  	    }
  	} # WRITE
      }
  
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	unless $code;
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	if $code eq "100";
  
      my $response = HTTP::Response->new($code, $mess);
      my $peer_http_version = $socket->peer_http_version;
      $response->protocol("HTTP/$peer_http_version");
      {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
      $response->push_header("Client-Junk" => \@junk) if @junk;
  
      $response->request($request);
      $self->_get_sock_info($response, $socket);
  
      if ($method eq "CONNECT") {
  	$response->{client_socket} = $socket;  # so it can be picked up
  	return $response;
      }
  
      if (my @te = $response->remove_header('Transfer-Encoding')) {
  	$response->push_header('Client-Transfer-Encoding', \@te);
      }
      $response->push_header('Client-Response-Num', scalar $socket->increment_response_count);
  
      my $complete;
      $response = $self->collect($arg, $response, sub {
  	my $buf = ""; #prevent use of uninitialized value in SSLeay.xs
  	my $n;
        READ:
  	{
  	    $n = $socket->read_entity_body($buf, $size);
              unless (defined $n) {
                  redo READ if $!{EINTR} || $!{EAGAIN} || $!{ENOTTY};
                  die "read failed: $!";
              }
  	    redo READ if $n == -1;
  	}
  	$complete++ if !$n;
          return \$buf;
      } );
      $drop_connection++ unless $complete;
  
      @h = $socket->get_trailers;
      if (@h) {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
  
      # keep-alive support
      unless ($drop_connection) {
  	if ($cache_key) {
  	    my %connection = map { (lc($_) => 1) }
  		             split(/\s*,\s*/, ($response->header("Connection") || ""));
  	    if (($peer_http_version eq "1.1" && !$connection{close}) ||
  		$connection{"keep-alive"})
  	    {
  		$conn_cache->deposit($self->socket_type, $cache_key, $socket);
  	    }
  	}
      }
  
      $response;
  }
  
  
  #-----------------------------------------------------------
  package LWP::Protocol::http::SocketMethods;
  
  sub ping {
      my $self = shift;
      !$self->can_read(0);
  }
  
  sub increment_response_count {
      my $self = shift;
      return ++${*$self}{'myhttp_response_count'};
  }
  
  #-----------------------------------------------------------
  package LWP::Protocol::http::Socket;
  use vars qw(@ISA);
  @ISA = qw(LWP::Protocol::http::SocketMethods Net::HTTP);
  
  1;
LWP_PROTOCOL_HTTP

$fatpacked{"LWP/Protocol/loopback.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_LOOPBACK';
  package LWP::Protocol::loopback;
  
  use strict;
  use vars qw(@ISA);
  require HTTP::Response;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  sub request {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      my $response = HTTP::Response->new(200, "OK");
      $response->content_type("message/http; msgtype=request");
  
      $response->header("Via", "loopback/1.0 $proxy")
  	if $proxy;
  
      $response->header("X-Arg", $arg);
      $response->header("X-Read-Size", $size);
      $response->header("X-Timeout", $timeout);
  
      return $self->collect_once($arg, $response, $request->as_string);
  }
  
  1;
LWP_PROTOCOL_LOOPBACK

$fatpacked{"LWP/Protocol/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_MAILTO';
  package LWP::Protocol::mailto;
  
  # This module implements the mailto protocol.  It is just a simple
  # frontend to the Unix sendmail program except on MacOS, where it uses
  # Mail::Internet.
  
  require LWP::Protocol;
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  
  use Carp;
  use strict;
  use vars qw(@ISA $SENDMAIL);
  
  @ISA = qw(LWP::Protocol);
  
  unless ($SENDMAIL = $ENV{SENDMAIL}) {
      for my $sm (qw(/usr/sbin/sendmail
  		   /usr/lib/sendmail
  		   /usr/ucblib/sendmail
  		  ))
      {
  	if (-x $sm) {
  	    $SENDMAIL = $sm;
  	    last;
  	}
      }
      die "Can't find the 'sendmail' program" unless $SENDMAIL;
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      my ($mail, $addr) if $^O eq "MacOS";
      my @text = () if $^O eq "MacOS";
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with mail');
      }
  
      # check method
      my $method = $request->method;
  
      if ($method ne 'POST') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'mailto:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'mailto') {
  	return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			 "LWP::Protocol::mailto::request called for '$scheme'");
      }
      if ($^O eq "MacOS") {
  	eval {
  	    require Mail::Internet;
  	};
  	if($@) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have MailTools installed");
  	}
  	unless ($ENV{SMTPHOSTS}) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have SMTPHOSTS defined");
  	}
      }
      else {
  	unless (-x $SENDMAIL) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have $SENDMAIL");
      }
      }
      if ($^O eq "MacOS") {
  	    $mail = Mail::Internet->new or
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	    "Can't get a Mail::Internet object");
      }
      else {
  	open(SENDMAIL, "| $SENDMAIL -oi -t") or
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "Can't run $SENDMAIL: $!");
      }
      if ($^O eq "MacOS") {
  	$addr = $url->encoded822addr;
      }
      else {
  	$request = $request->clone;  # we modify a copy
  	my @h = $url->headers;  # URL headers override those in the request
  	while (@h) {
  	    my $k = shift @h;
  	    my $v = shift @h;
  	    next unless defined $v;
  	    if (lc($k) eq "body") {
  		$request->content($v);
  	    }
  	    else {
  		$request->push_header($k => $v);
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->add(To => $addr);
  	$mail->add(split(/[:\n]/,$request->headers_as_string));
      }
      else {
  	print SENDMAIL $request->headers_as_string;
  	print SENDMAIL "\n";
      }
      my $content = $request->content;
      if (defined $content) {
  	my $contRef = ref($content) ? $content : \$content;
  	if (ref($contRef) eq 'SCALAR') {
  	    if ($^O eq "MacOS") {
  		@text = split("\n",$$contRef);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  	    print SENDMAIL $$contRef;
  	    }
  
  	}
  	elsif (ref($contRef) eq 'CODE') {
  	    # Callback provides data
  	    my $d;
  	    if ($^O eq "MacOS") {
  		my $stuff = "";
  		while (length($d = &$contRef)) {
  		    $stuff .= $d;
  		}
  		@text = split("\n",$stuff);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  		print SENDMAIL $d;
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->body(\@text);
  	unless ($mail->smtpsend) {
  	    return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "Mail::Internet->smtpsend unable to send message to <$addr>");
  	}
      }
      else {
  	unless (close(SENDMAIL)) {
  	    my $err = $! ? "$!" : "Exit status $?";
  	    return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "$SENDMAIL: $err");
  	}
      }
  
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_ACCEPTED,
  				       "Mail accepted");
      $response->header('Content-Type', 'text/plain');
      if ($^O eq "MacOS") {
  	$response->header('Server' => "Mail::Internet $Mail::Internet::VERSION");
  	$response->content("Message sent to <$addr>\n");
      }
      else {
  	$response->header('Server' => $SENDMAIL);
  	my $to = $request->header("To");
  	$response->content("Message sent to <$to>\n");
      }
  
      return $response;
  }
  
  1;
LWP_PROTOCOL_MAILTO

$fatpacked{"LWP/Protocol/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_NNTP';
  package LWP::Protocol::nntp;
  
  # Implementation of the Network News Transfer Protocol (RFC 977)
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::NNTP;
  
  use strict;
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # Check for proxy
      if (defined $proxy) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through NNTP');
      }
  
      # Check that the scheme is as expected
      my $url = $request->uri;
      my $scheme = $url->scheme;
      unless ($scheme eq 'news' || $scheme eq 'nntp') {
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				   "LWP::Protocol::nntp::request called for '$scheme'");
      }
  
      # check for a valid method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'POST') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for '$scheme:' URLs");
      }
  
      # extract the identifier and check against posting to an article
      my $groupart = $url->_group;
      my $is_art = $groupart =~ /@/;
  
      if ($is_art && $method eq 'POST') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Can't post to an article <$groupart>");
      }
  
      my $nntp = Net::NNTP->new($url->host,
  			      #Port    => 18574,
  			      Timeout => $timeout,
  			      #Debug   => 1,
  			     );
      die "Can't connect to nntp server" unless $nntp;
  
      # Check the initial welcome message from the NNTP server
      if ($nntp->status != 2) {
  	return HTTP::Response->new(&HTTP::Status::RC_SERVICE_UNAVAILABLE,
  				   $nntp->message);
      }
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
  
      my $mess = $nntp->message;
  
      # Try to extract server name from greeting message.
      # Don't know if this works well for a large class of servers, but
      # this works for our server.
      $mess =~ s/\s+ready\b.*//;
      $mess =~ s/^\S+\s+//;
      $response->header(Server => $mess);
  
      # First we handle posting of articles
      if ($method eq 'POST') {
  	$nntp->quit; $nntp = undef;
  	$response->code(&HTTP::Status::RC_NOT_IMPLEMENTED);
  	$response->message("POST not implemented yet");
  	return $response;
      }
  
      # The method must be "GET" or "HEAD" by now
      if (!$is_art) {
  	if (!$nntp->group($groupart)) {
  	    $response->code(&HTTP::Status::RC_NOT_FOUND);
  	    $response->message($nntp->message);
  	}
  	$nntp->quit; $nntp = undef;
  	# HEAD: just check if the group exists
  	if ($method eq 'GET' && $response->is_success) {
  	    $response->code(&HTTP::Status::RC_NOT_IMPLEMENTED);
  	    $response->message("GET newsgroup not implemented yet");
  	}
  	return $response;
      }
  
      # Send command to server to retrieve an article (or just the headers)
      my $get = $method eq 'HEAD' ? "head" : "article";
      my $art = $nntp->$get("<$groupart>");
      unless ($art) {
  	$nntp->quit; $nntp = undef;
  	$response->code(&HTTP::Status::RC_NOT_FOUND);
  	$response->message($nntp->message);
  	return $response;
      }
  
      # Parse headers
      my($key, $val);
      local $_;
      while ($_ = shift @$art) {
  	if (/^\s+$/) {
  	    last;  # end of headers
  	}
  	elsif (/^(\S+):\s*(.*)/) {
  	    $response->push_header($key, $val) if $key;
  	    ($key, $val) = ($1, $2);
  	}
  	elsif (/^\s+(.*)/) {
  	    next unless $key;
  	    $val .= $1;
  	}
  	else {
  	    unshift(@$art, $_);
  	    last;
  	}
      }
      $response->push_header($key, $val) if $key;
  
      # Ensure that there is a Content-Type header
      $response->header("Content-Type", "text/plain")
  	unless $response->header("Content-Type");
  
      # Collect the body
      $response = $self->collect_once($arg, $response, join("", @$art))
        if @$art;
  
      # Say goodbye to the server
      $nntp->quit;
      $nntp = undef;
  
      $response;
  }
  
  1;
LWP_PROTOCOL_NNTP

$fatpacked{"LWP/Protocol/nogo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_NOGO';
  package LWP::Protocol::nogo;
  # If you want to disable access to a particular scheme, use this
  # class and then call
  #   LWP::Protocol::implementor(that_scheme, 'LWP::Protocol::nogo');
  # For then on, attempts to access URLs with that scheme will generate
  # a 500 error.
  
  use strict;
  use vars qw(@ISA);
  require HTTP::Response;
  require HTTP::Status;
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  sub request {
      my($self, $request) = @_;
      my $scheme = $request->uri->scheme;
      
      return HTTP::Response->new(
        &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
        "Access to \'$scheme\' URIs has been disabled"
      );
  }
  1;
LWP_PROTOCOL_NOGO

$fatpacked{"LWP/RobotUA.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_ROBOTUA';
  package LWP::RobotUA;
  
  require LWP::UserAgent;
  @ISA = qw(LWP::UserAgent);
  $VERSION = "6.06";
  
  require WWW::RobotRules;
  require HTTP::Request;
  require HTTP::Response;
  
  use Carp ();
  use HTTP::Status ();
  use HTTP::Date qw(time2str);
  use strict;
  
  
  #
  # Additional attributes in addition to those found in LWP::UserAgent:
  #
  # $self->{'delay'}    Required delay between request to the same
  #                     server in minutes.
  #
  # $self->{'rules'}     A WWW::RobotRules object
  #
  
  sub new
  {
      my $class = shift;
      my %cnf;
      if (@_ < 4) {
  	# legacy args
  	@cnf{qw(agent from rules)} = @_;
      }
      else {
  	%cnf = @_;
      }
  
      Carp::croak('LWP::RobotUA agent required') unless $cnf{agent};
      Carp::croak('LWP::RobotUA from address required')
  	unless $cnf{from} && $cnf{from} =~ m/\@/;
  
      my $delay = delete $cnf{delay} || 1;
      my $use_sleep = delete $cnf{use_sleep};
      $use_sleep = 1 unless defined($use_sleep);
      my $rules = delete $cnf{rules};
  
      my $self = LWP::UserAgent->new(%cnf);
      $self = bless $self, $class;
  
      $self->{'delay'} = $delay;   # minutes
      $self->{'use_sleep'} = $use_sleep;
  
      if ($rules) {
  	$rules->agent($cnf{agent});
  	$self->{'rules'} = $rules;
      }
      else {
  	$self->{'rules'} = WWW::RobotRules->new($cnf{agent});
      }
  
      $self;
  }
  
  
  sub delay     { shift->_elem('delay',     @_); }
  sub use_sleep { shift->_elem('use_sleep', @_); }
  
  
  sub agent
  {
      my $self = shift;
      my $old = $self->SUPER::agent(@_);
      if (@_) {
  	# Changing our name means to start fresh
  	$self->{'rules'}->agent($self->{'agent'}); 
      }
      $old;
  }
  
  
  sub rules {
      my $self = shift;
      my $old = $self->_elem('rules', @_);
      $self->{'rules'}->agent($self->{'agent'}) if @_;
      $old;
  }
  
  
  sub no_visits
  {
      my($self, $netloc) = @_;
      $self->{'rules'}->no_visits($netloc) || 0;
  }
  
  *host_count = \&no_visits;  # backwards compatibility with LWP-5.02
  
  
  sub host_wait
  {
      my($self, $netloc) = @_;
      return undef unless defined $netloc;
      my $last = $self->{'rules'}->last_visit($netloc);
      if ($last) {
  	my $wait = int($self->{'delay'} * 60 - (time - $last));
  	$wait = 0 if $wait < 0;
  	return $wait;
      }
      return 0;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # Do we try to access a new server?
      my $allowed = $self->{'rules'}->allowed($request->uri);
  
      if ($allowed < 0) {
  	# Host is not visited before, or robots.txt expired; fetch "robots.txt"
  	my $robot_url = $request->uri->clone;
  	$robot_url->path("robots.txt");
  	$robot_url->query(undef);
  
  	# make access to robot.txt legal since this will be a recursive call
  	$self->{'rules'}->parse($robot_url, ""); 
  
  	my $robot_req = HTTP::Request->new('GET', $robot_url);
  	my $parse_head = $self->parse_head(0);
  	my $robot_res = $self->request($robot_req);
  	$self->parse_head($parse_head);
  	my $fresh_until = $robot_res->fresh_until;
  	my $content = "";
  	if ($robot_res->is_success && $robot_res->content_is_text) {
  	    $content = $robot_res->decoded_content;
  	    $content = "" unless $content && $content =~ /^\s*Disallow\s*:/mi;
  	}
  	$self->{'rules'}->parse($robot_url, $content, $fresh_until);
  
  	# recalculate allowed...
  	$allowed = $self->{'rules'}->allowed($request->uri);
      }
  
      # Check rules
      unless ($allowed) {
  	my $res = HTTP::Response->new(
  	  &HTTP::Status::RC_FORBIDDEN, 'Forbidden by robots.txt');
  	$res->request( $request ); # bind it to that request
  	return $res;
      }
  
      my $netloc = eval { local $SIG{__DIE__}; $request->uri->host_port; };
      my $wait = $self->host_wait($netloc);
  
      if ($wait) {
  	if ($self->{'use_sleep'}) {
  	    sleep($wait)
  	}
  	else {
  	    my $res = HTTP::Response->new(
  	      &HTTP::Status::RC_SERVICE_UNAVAILABLE, 'Please, slow down');
  	    $res->header('Retry-After', time2str(time + $wait));
  	    $res->request( $request ); # bind it to that request
  	    return $res;
  	}
      }
  
      # Perform the request
      my $res = $self->SUPER::simple_request($request, $arg, $size);
  
      $self->{'rules'}->visit($netloc);
  
      $res;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my @s;
      push(@s, "Robot: $self->{'agent'} operated by $self->{'from'}  [$self]");
      push(@s, "    Minimum delay: " . int($self->{'delay'}*60) . "s");
      push(@s, "    Will sleep if too early") if $self->{'use_sleep'};
      push(@s, "    Rules = $self->{'rules'}");
      join("\n", @s, '');
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::RobotUA - a class for well-behaved Web robots
  
  =head1 SYNOPSIS
  
    use LWP::RobotUA;
    my $ua = LWP::RobotUA->new('my-robot/0.1', 'me@foo.com');
    $ua->delay(10);  # be very nice -- max one hit every ten minutes!
    ...
  
    # Then just use it just like a normal LWP::UserAgent:
    my $response = $ua->get('http://whatever.int/...');
    ...
  
  =head1 DESCRIPTION
  
  This class implements a user agent that is suitable for robot
  applications.  Robots should be nice to the servers they visit.  They
  should consult the F</robots.txt> file to ensure that they are welcomed
  and they should not make requests too frequently.
  
  But before you consider writing a robot, take a look at
  <URL:http://www.robotstxt.org/>.
  
  When you use an I<LWP::RobotUA> object as your user agent, then you do not
  really have to think about these things yourself; C<robots.txt> files
  are automatically consulted and obeyed, the server isn't queried
  too rapidly, and so on.  Just send requests
  as you do when you are using a normal I<LWP::UserAgent>
  object (using C<< $ua->get(...) >>, C<< $ua->head(...) >>,
  C<< $ua->request(...) >>, etc.), and this
  special agent will make sure you are nice.
  
  =head1 METHODS
  
  The LWP::RobotUA is a sub-class of LWP::UserAgent and implements the
  same methods. In addition the following methods are provided:
  
  =over 4
  
  =item $ua = LWP::RobotUA->new( %options )
  
  =item $ua = LWP::RobotUA->new( $agent, $from )
  
  =item $ua = LWP::RobotUA->new( $agent, $from, $rules )
  
  The LWP::UserAgent options C<agent> and C<from> are mandatory.  The
  options C<delay>, C<use_sleep> and C<rules> initialize attributes
  private to the RobotUA.  If C<rules> are not provided, then
  C<WWW::RobotRules> is instantiated providing an internal database of
  F<robots.txt>.
  
  It is also possible to just pass the value of C<agent>, C<from> and
  optionally C<rules> as plain positional arguments.
  
  =item $ua->delay
  
  =item $ua->delay( $minutes )
  
  Get/set the minimum delay between requests to the same server, in
  I<minutes>.  The default is 1 minute.  Note that this number doesn't
  have to be an integer; for example, this sets the delay to 10 seconds:
  
      $ua->delay(10/60);
  
  =item $ua->use_sleep
  
  =item $ua->use_sleep( $boolean )
  
  Get/set a value indicating whether the UA should sleep() if requests
  arrive too fast, defined as $ua->delay minutes not passed since
  last request to the given server.  The default is TRUE.  If this value is
  FALSE then an internal SERVICE_UNAVAILABLE response will be generated.
  It will have a Retry-After header that indicates when it is OK to
  send another request to this server.
  
  =item $ua->rules
  
  =item $ua->rules( $rules )
  
  Set/get which I<WWW::RobotRules> object to use.
  
  =item $ua->no_visits( $netloc )
  
  Returns the number of documents fetched from this server host. Yeah I
  know, this method should probably have been named num_visits() or
  something like that. :-(
  
  =item $ua->host_wait( $netloc )
  
  Returns the number of I<seconds> (from now) you must wait before you can
  make a new request to this host.
  
  =item $ua->as_string
  
  Returns a string that describes the state of the UA.
  Mainly useful for debugging.
  
  =back
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>, L<WWW::RobotRules>
  
  =head1 COPYRIGHT
  
  Copyright 1996-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_ROBOTUA

$fatpacked{"LWP/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_SIMPLE';
  package LWP::Simple;
  
  use strict;
  use vars qw($ua %loop_check $FULL_LWP @EXPORT @EXPORT_OK $VERSION);
  
  require Exporter;
  
  @EXPORT = qw(get head getprint getstore mirror);
  @EXPORT_OK = qw($ua);
  
  # I really hate this.  I was a bad idea to do it in the first place.
  # Wonder how to get rid of it???  (It even makes LWP::Simple 7% slower
  # for trivial tests)
  use HTTP::Status;
  push(@EXPORT, @HTTP::Status::EXPORT);
  
  $VERSION = "6.00";
  
  sub import
  {
      my $pkg = shift;
      my $callpkg = caller;
      Exporter::export($pkg, $callpkg, @_);
  }
  
  use LWP::UserAgent ();
  use HTTP::Status ();
  use HTTP::Date ();
  $ua = LWP::UserAgent->new;  # we create a global UserAgent object
  $ua->agent("LWP::Simple/$VERSION ");
  $ua->env_proxy;
  
  
  sub get ($)
  {
      my $response = $ua->get(shift);
      return $response->decoded_content if $response->is_success;
      return undef;
  }
  
  
  sub head ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(HEAD => $url);
      my $response = $ua->request($request);
  
      if ($response->is_success) {
  	return $response unless wantarray;
  	return (scalar $response->header('Content-Type'),
  		scalar $response->header('Content-Length'),
  		HTTP::Date::str2time($response->header('Last-Modified')),
  		HTTP::Date::str2time($response->header('Expires')),
  		scalar $response->header('Server'),
  	       );
      }
      return;
  }
  
  
  sub getprint ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(GET => $url);
      local($\) = ""; # ensure standard $OUTPUT_RECORD_SEPARATOR
      my $callback = sub { print $_[0] };
      if ($^O eq "MacOS") {
  	$callback = sub { $_[0] =~ s/\015?\012/\n/g; print $_[0] }
      }
      my $response = $ua->request($request, $callback);
      unless ($response->is_success) {
  	print STDERR $response->status_line, " <URL:$url>\n";
      }
      $response->code;
  }
  
  
  sub getstore ($$)
  {
      my($url, $file) = @_;
      my $request = HTTP::Request->new(GET => $url);
      my $response = $ua->request($request, $file);
  
      $response->code;
  }
  
  
  sub mirror ($$)
  {
      my($url, $file) = @_;
      my $response = $ua->mirror($url, $file);
      $response->code;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::Simple - simple procedural interface to LWP
  
  =head1 SYNOPSIS
  
   perl -MLWP::Simple -e 'getprint "http://www.sn.no"'
  
   use LWP::Simple;
   $content = get("http://www.sn.no/");
   die "Couldn't get it!" unless defined $content;
  
   if (mirror("http://www.sn.no/", "foo") == RC_NOT_MODIFIED) {
       ...
   }
  
   if (is_success(getprint("http://www.sn.no/"))) {
       ...
   }
  
  =head1 DESCRIPTION
  
  This module is meant for people who want a simplified view of the
  libwww-perl library.  It should also be suitable for one-liners.  If
  you need more control or access to the header fields in the requests
  sent and responses received, then you should use the full object-oriented
  interface provided by the C<LWP::UserAgent> module.
  
  The following functions are provided (and exported) by this module:
  
  =over 3
  
  =item get($url)
  
  The get() function will fetch the document identified by the given URL
  and return it.  It returns C<undef> if it fails.  The $url argument can
  be either a string or a reference to a URI object.
  
  You will not be able to examine the response code or response headers
  (like 'Content-Type') when you are accessing the web using this
  function.  If you need that information you should use the full OO
  interface (see L<LWP::UserAgent>).
  
  =item head($url)
  
  Get document headers. Returns the following 5 values if successful:
  ($content_type, $document_length, $modified_time, $expires, $server)
  
  Returns an empty list if it fails.  In scalar context returns TRUE if
  successful.
  
  =item getprint($url)
  
  Get and print a document identified by a URL. The document is printed
  to the selected default filehandle for output (normally STDOUT) as
  data is received from the network.  If the request fails, then the
  status code and message are printed on STDERR.  The return value is
  the HTTP response code.
  
  =item getstore($url, $file)
  
  Gets a document identified by a URL and stores it in the file. The
  return value is the HTTP response code.
  
  =item mirror($url, $file)
  
  Get and store a document identified by a URL, using
  I<If-modified-since>, and checking the I<Content-Length>.  Returns
  the HTTP response code.
  
  =back
  
  This module also exports the HTTP::Status constants and procedures.
  You can use them when you check the response code from getprint(),
  getstore() or mirror().  The constants are:
  
     RC_CONTINUE
     RC_SWITCHING_PROTOCOLS
     RC_OK
     RC_CREATED
     RC_ACCEPTED
     RC_NON_AUTHORITATIVE_INFORMATION
     RC_NO_CONTENT
     RC_RESET_CONTENT
     RC_PARTIAL_CONTENT
     RC_MULTIPLE_CHOICES
     RC_MOVED_PERMANENTLY
     RC_MOVED_TEMPORARILY
     RC_SEE_OTHER
     RC_NOT_MODIFIED
     RC_USE_PROXY
     RC_BAD_REQUEST
     RC_UNAUTHORIZED
     RC_PAYMENT_REQUIRED
     RC_FORBIDDEN
     RC_NOT_FOUND
     RC_METHOD_NOT_ALLOWED
     RC_NOT_ACCEPTABLE
     RC_PROXY_AUTHENTICATION_REQUIRED
     RC_REQUEST_TIMEOUT
     RC_CONFLICT
     RC_GONE
     RC_LENGTH_REQUIRED
     RC_PRECONDITION_FAILED
     RC_REQUEST_ENTITY_TOO_LARGE
     RC_REQUEST_URI_TOO_LARGE
     RC_UNSUPPORTED_MEDIA_TYPE
     RC_INTERNAL_SERVER_ERROR
     RC_NOT_IMPLEMENTED
     RC_BAD_GATEWAY
     RC_SERVICE_UNAVAILABLE
     RC_GATEWAY_TIMEOUT
     RC_HTTP_VERSION_NOT_SUPPORTED
  
  The HTTP::Status classification functions are:
  
  =over 3
  
  =item is_success($rc)
  
  True if response code indicated a successful request.
  
  =item is_error($rc)
  
  True if response code indicated that an error occurred.
  
  =back
  
  The module will also export the LWP::UserAgent object as C<$ua> if you
  ask for it explicitly.
  
  The user agent created by this module will identify itself as
  "LWP::Simple/#.##"
  and will initialize its proxy defaults from the environment (by
  calling $ua->env_proxy).
  
  =head1 CAVEAT
  
  Note that if you are using both LWP::Simple and the very popular CGI.pm
  module, you may be importing a C<head> function from each module,
  producing a warning like "Prototype mismatch: sub main::head ($) vs
  none". Get around this problem by just not importing LWP::Simple's
  C<head> function, like so:
  
          use LWP::Simple qw(!head);
          use CGI qw(:standard);  # then only CGI.pm defines a head()
  
  Then if you do need LWP::Simple's C<head> function, you can just call
  it as C<LWP::Simple::head($url)>.
  
  =head1 SEE ALSO
  
  L<LWP>, L<lwpcook>, L<LWP::UserAgent>, L<HTTP::Status>, L<lwp-request>,
  L<lwp-mirror>
LWP_SIMPLE

$fatpacked{"LWP/UserAgent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_USERAGENT';
  package LWP::UserAgent;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  require LWP::MemberMixin;
  @ISA = qw(LWP::MemberMixin);
  $VERSION = "6.06";
  
  use HTTP::Request ();
  use HTTP::Response ();
  use HTTP::Date ();
  
  use LWP ();
  use LWP::Protocol ();
  
  use Carp ();
  
  
  sub new
  {
      # Check for common user mistake
      Carp::croak("Options to LWP::UserAgent should be key/value pairs, not hash reference") 
          if ref($_[1]) eq 'HASH'; 
  
      my($class, %cnf) = @_;
  
      my $agent = delete $cnf{agent};
      my $from  = delete $cnf{from};
      my $def_headers = delete $cnf{default_headers};
      my $timeout = delete $cnf{timeout};
      $timeout = 3*60 unless defined $timeout;
      my $local_address = delete $cnf{local_address};
      my $ssl_opts = delete $cnf{ssl_opts} || {};
      unless (exists $ssl_opts->{verify_hostname}) {
  	# The processing of HTTPS_CA_* below is for compatibility with Crypt::SSLeay
  	if (exists $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME}) {
  	    $ssl_opts->{verify_hostname} = $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME};
  	}
  	elsif ($ENV{HTTPS_CA_FILE} || $ENV{HTTPS_CA_DIR}) {
  	    # Crypt-SSLeay compatibility (verify peer certificate; but not the hostname)
  	    $ssl_opts->{verify_hostname} = 0;
  	    $ssl_opts->{SSL_verify_mode} = 1;
  	}
  	else {
  	    $ssl_opts->{verify_hostname} = 1;
  	}
      }
      unless (exists $ssl_opts->{SSL_ca_file}) {
  	if (my $ca_file = $ENV{PERL_LWP_SSL_CA_FILE} || $ENV{HTTPS_CA_FILE}) {
  	    $ssl_opts->{SSL_ca_file} = $ca_file;
  	}
      }
      unless (exists $ssl_opts->{SSL_ca_path}) {
  	if (my $ca_path = $ENV{PERL_LWP_SSL_CA_PATH} || $ENV{HTTPS_CA_DIR}) {
  	    $ssl_opts->{SSL_ca_path} = $ca_path;
  	}
      }
      my $use_eval = delete $cnf{use_eval};
      $use_eval = 1 unless defined $use_eval;
      my $parse_head = delete $cnf{parse_head};
      $parse_head = 1 unless defined $parse_head;
      my $show_progress = delete $cnf{show_progress};
      my $max_size = delete $cnf{max_size};
      my $max_redirect = delete $cnf{max_redirect};
      $max_redirect = 7 unless defined $max_redirect;
      my $env_proxy = exists $cnf{env_proxy} ? delete $cnf{env_proxy} : $ENV{PERL_LWP_ENV_PROXY};
  
      my $cookie_jar = delete $cnf{cookie_jar};
      my $conn_cache = delete $cnf{conn_cache};
      my $keep_alive = delete $cnf{keep_alive};
      
      Carp::croak("Can't mix conn_cache and keep_alive")
  	  if $conn_cache && $keep_alive;
  
      my $protocols_allowed   = delete $cnf{protocols_allowed};
      my $protocols_forbidden = delete $cnf{protocols_forbidden};
      
      my $requests_redirectable = delete $cnf{requests_redirectable};
      $requests_redirectable = ['GET', 'HEAD']
        unless defined $requests_redirectable;
  
      # Actually ""s are just as good as 0's, but for concision we'll just say:
      Carp::croak("protocols_allowed has to be an arrayref or 0, not \"$protocols_allowed\"!")
        if $protocols_allowed and ref($protocols_allowed) ne 'ARRAY';
      Carp::croak("protocols_forbidden has to be an arrayref or 0, not \"$protocols_forbidden\"!")
        if $protocols_forbidden and ref($protocols_forbidden) ne 'ARRAY';
      Carp::croak("requests_redirectable has to be an arrayref or 0, not \"$requests_redirectable\"!")
        if $requests_redirectable and ref($requests_redirectable) ne 'ARRAY';
  
  
      if (%cnf && $^W) {
  	Carp::carp("Unrecognized LWP::UserAgent options: @{[sort keys %cnf]}");
      }
  
      my $self = bless {
  		      def_headers  => $def_headers,
  		      timeout      => $timeout,
  		      local_address => $local_address,
  		      ssl_opts     => $ssl_opts,
  		      use_eval     => $use_eval,
                        show_progress=> $show_progress,
  		      max_size     => $max_size,
  		      max_redirect => $max_redirect,
                        proxy        => {},
  		      no_proxy     => [],
                        protocols_allowed     => $protocols_allowed,
                        protocols_forbidden   => $protocols_forbidden,
                        requests_redirectable => $requests_redirectable,
  		     }, $class;
  
      $self->agent(defined($agent) ? $agent : $class->_agent)
  	if defined($agent) || !$def_headers || !$def_headers->header("User-Agent");
      $self->from($from) if $from;
      $self->cookie_jar($cookie_jar) if $cookie_jar;
      $self->parse_head($parse_head);
      $self->env_proxy if $env_proxy;
  
      $self->protocols_allowed(  $protocols_allowed  ) if $protocols_allowed;
      $self->protocols_forbidden($protocols_forbidden) if $protocols_forbidden;
  
      if ($keep_alive) {
  	$conn_cache ||= { total_capacity => $keep_alive };
      }
      $self->conn_cache($conn_cache) if $conn_cache;
  
      return $self;
  }
  
  
  sub send_request
  {
      my($self, $request, $arg, $size) = @_;
      my($method, $url) = ($request->method, $request->uri);
      my $scheme = $url->scheme;
  
      local($SIG{__DIE__});  # protect against user defined die handlers
  
      $self->progress("begin", $request);
  
      my $response = $self->run_handlers("request_send", $request);
  
      unless ($response) {
          my $protocol;
  
          {
              # Honor object-specific restrictions by forcing protocol objects
              #  into class LWP::Protocol::nogo.
              my $x;
              if($x = $self->protocols_allowed) {
                  if (grep lc($_) eq $scheme, @$x) {
                  }
                  else {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              elsif ($x = $self->protocols_forbidden) {
                  if(grep lc($_) eq $scheme, @$x) {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              # else fall thru and create the protocol object normally
          }
  
          # Locate protocol to use
          my $proxy = $request->{proxy};
          if ($proxy) {
              $scheme = $proxy->scheme;
          }
  
          unless ($protocol) {
              $protocol = eval { LWP::Protocol::create($scheme, $self) };
              if ($@) {
                  $@ =~ s/ at .* line \d+.*//s;  # remove file/line number
                  $response =  _new_response($request, &HTTP::Status::RC_NOT_IMPLEMENTED, $@);
                  if ($scheme eq "https") {
                      $response->message($response->message . " (LWP::Protocol::https not installed)");
                      $response->content_type("text/plain");
                      $response->content(<<EOT);
  LWP will support https URLs if the LWP::Protocol::https module
  is installed.
  EOT
                  }
              }
          }
  
          if (!$response && $self->{use_eval}) {
              # we eval, and turn dies into responses below
              eval {
                  $response = $protocol->request($request, $proxy, $arg, $size, $self->{timeout}) ||
  		    die "No response returned by $protocol";
              };
              if ($@) {
                  if (UNIVERSAL::isa($@, "HTTP::Response")) {
                      $response = $@;
                      $response->request($request);
                  }
                  else {
                      my $full = $@;
                      (my $status = $@) =~ s/\n.*//s;
                      $status =~ s/ at .* line \d+.*//s;  # remove file/line number
                      my $code = ($status =~ s/^(\d\d\d)\s+//) ? $1 : &HTTP::Status::RC_INTERNAL_SERVER_ERROR;
                      $response = _new_response($request, $code, $status, $full);
                  }
              }
          }
          elsif (!$response) {
              $response = $protocol->request($request, $proxy,
                                             $arg, $size, $self->{timeout});
              # XXX: Should we die unless $response->is_success ???
          }
      }
  
      $response->request($request);  # record request for reference
      $response->header("Client-Date" => HTTP::Date::time2str(time));
  
      $self->run_handlers("response_done", $response);
  
      $self->progress("end", $response);
      return $response;
  }
  
  
  sub prepare_request
  {
      my($self, $request) = @_;
      die "Method missing" unless $request->method;
      my $url = $request->uri;
      die "URL missing" unless $url;
      die "URL must be absolute" unless $url->scheme;
  
      $self->run_handlers("request_preprepare", $request);
  
      if (my $def_headers = $self->{def_headers}) {
  	for my $h ($def_headers->header_field_names) {
  	    $request->init_header($h => [$def_headers->header($h)]);
  	}
      }
  
      $self->run_handlers("request_prepare", $request);
  
      return $request;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # sanity check the request passed in
      if (defined $request) {
  	if (ref $request) {
  	    Carp::croak("You need a request object, not a " . ref($request) . " object")
  	      if ref($request) eq 'ARRAY' or ref($request) eq 'HASH' or
  		 !$request->can('method') or !$request->can('uri');
  	}
  	else {
  	    Carp::croak("You need a request object, not '$request'");
  	}
      }
      else {
          Carp::croak("No request object passed in");
      }
  
      eval {
  	$request = $self->prepare_request($request);
      };
      if ($@) {
  	$@ =~ s/ at .* line \d+.*//s;  # remove file/line number
  	return _new_response($request, &HTTP::Status::RC_BAD_REQUEST, $@);
      }
      return $self->send_request($request, $arg, $size);
  }
  
  
  sub request
  {
      my($self, $request, $arg, $size, $previous) = @_;
  
      my $response = $self->simple_request($request, $arg, $size);
      $response->previous($previous) if $previous;
  
      if ($response->redirects >= $self->{max_redirect}) {
          $response->header("Client-Warning" =>
                            "Redirect loop detected (max_redirect = $self->{max_redirect})");
          return $response;
      }
  
      if (my $req = $self->run_handlers("response_redirect", $response)) {
          return $self->request($req, $arg, $size, $response);
      }
  
      my $code = $response->code;
  
      if ($code == &HTTP::Status::RC_MOVED_PERMANENTLY or
  	$code == &HTTP::Status::RC_FOUND or
  	$code == &HTTP::Status::RC_SEE_OTHER or
  	$code == &HTTP::Status::RC_TEMPORARY_REDIRECT)
      {
  	my $referral = $request->clone;
  
  	# These headers should never be forwarded
  	$referral->remove_header('Host', 'Cookie');
  	
  	if ($referral->header('Referer') &&
  	    $request->uri->scheme eq 'https' &&
  	    $referral->uri->scheme eq 'http')
  	{
  	    # RFC 2616, section 15.1.3.
  	    # https -> http redirect, suppressing Referer
  	    $referral->remove_header('Referer');
  	}
  
  	if ($code == &HTTP::Status::RC_SEE_OTHER ||
  	    $code == &HTTP::Status::RC_FOUND) 
          {
  	    my $method = uc($referral->method);
  	    unless ($method eq "GET" || $method eq "HEAD") {
  		$referral->method("GET");
  		$referral->content("");
  		$referral->remove_content_headers;
  	    }
  	}
  
  	# And then we update the URL based on the Location:-header.
  	my $referral_uri = $response->header('Location');
  	{
  	    # Some servers erroneously return a relative URL for redirects,
  	    # so make it absolute if it not already is.
  	    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
  	    my $base = $response->base;
  	    $referral_uri = "" unless defined $referral_uri;
  	    $referral_uri = $HTTP::URI_CLASS->new($referral_uri, $base)
  		            ->abs($base);
  	}
  	$referral->uri($referral_uri);
  
  	return $response unless $self->redirect_ok($referral, $response);
  	return $self->request($referral, $arg, $size, $response);
  
      }
      elsif ($code == &HTTP::Status::RC_UNAUTHORIZED ||
  	     $code == &HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED
  	    )
      {
  	my $proxy = ($code == &HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED);
  	my $ch_header = $proxy || $request->method eq 'CONNECT'
  	    ?  "Proxy-Authenticate" : "WWW-Authenticate";
  	my @challenge = $response->header($ch_header);
  	unless (@challenge) {
  	    $response->header("Client-Warning" => 
  			      "Missing Authenticate header");
  	    return $response;
  	}
  
  	require HTTP::Headers::Util;
  	CHALLENGE: for my $challenge (@challenge) {
  	    $challenge =~ tr/,/;/;  # "," is used to separate auth-params!!
  	    ($challenge) = HTTP::Headers::Util::split_header_words($challenge);
  	    my $scheme = shift(@$challenge);
  	    shift(@$challenge); # no value
  	    $challenge = { @$challenge };  # make rest into a hash
  
  	    unless ($scheme =~ /^([a-z]+(?:-[a-z]+)*)$/) {
  		$response->header("Client-Warning" => 
  				  "Bad authentication scheme '$scheme'");
  		return $response;
  	    }
  	    $scheme = $1;  # untainted now
  	    my $class = "LWP::Authen::\u$scheme";
  	    $class =~ s/-/_/g;
  
  	    no strict 'refs';
  	    unless (%{"$class\::"}) {
  		# try to load it
  		eval "require $class";
  		if ($@) {
  		    if ($@ =~ /^Can\'t locate/) {
  			$response->header("Client-Warning" =>
  					  "Unsupported authentication scheme '$scheme'");
  		    }
  		    else {
  			$response->header("Client-Warning" => $@);
  		    }
  		    next CHALLENGE;
  		}
  	    }
  	    unless ($class->can("authenticate")) {
  		$response->header("Client-Warning" =>
  				  "Unsupported authentication scheme '$scheme'");
  		next CHALLENGE;
  	    }
  	    return $class->authenticate($self, $proxy, $challenge, $response,
  					$request, $arg, $size);
  	}
  	return $response;
      }
      return $response;
  }
  
  
  #
  # Now the shortcuts...
  #
  sub get {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::GET( @parameters ), @suff );
  }
  
  
  sub post {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      return $self->request( HTTP::Request::Common::POST( @parameters ), @suff );
  }
  
  
  sub head {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::HEAD( @parameters ), @suff );
  }
  
  
  sub put {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      return $self->request( HTTP::Request::Common::PUT( @parameters ), @suff );
  }
  
  
  sub delete {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::DELETE( @parameters ), @suff );
  }
  
  
  sub _process_colonic_headers {
      # Process :content_cb / :content_file / :read_size_hint headers.
      my($self, $args, $start_index) = @_;
  
      my($arg, $size);
      for(my $i = $start_index; $i < @$args; $i += 2) {
  	next unless defined $args->[$i];
  
  	#printf "Considering %s => %s\n", $args->[$i], $args->[$i + 1];
  
  	if($args->[$i] eq ':content_cb') {
  	    # Some sanity-checking...
  	    $arg = $args->[$i + 1];
  	    Carp::croak("A :content_cb value can't be undef") unless defined $arg;
  	    Carp::croak("A :content_cb value must be a coderef")
  		unless ref $arg and UNIVERSAL::isa($arg, 'CODE');
  	    
  	}
  	elsif ($args->[$i] eq ':content_file') {
  	    $arg = $args->[$i + 1];
  
  	    # Some sanity-checking...
  	    Carp::croak("A :content_file value can't be undef")
  		unless defined $arg;
  	    Carp::croak("A :content_file value can't be a reference")
  		if ref $arg;
  	    Carp::croak("A :content_file value can't be \"\"")
  		unless length $arg;
  
  	}
  	elsif ($args->[$i] eq ':read_size_hint') {
  	    $size = $args->[$i + 1];
  	    # Bother checking it?
  
  	}
  	else {
  	    next;
  	}
  	splice @$args, $i, 2;
  	$i -= 2;
      }
  
      # And return a suitable suffix-list for request(REQ,...)
  
      return             unless defined $arg;
      return $arg, $size if     defined $size;
      return $arg;
  }
  
  
  sub is_online {
      my $self = shift;
      return 1 if $self->get("http://www.msftncsi.com/ncsi.txt")->content eq "Microsoft NCSI";
      return 1 if $self->get("http://www.apple.com")->content =~ m,<title>Apple</title>,;
      return 0;
  }
  
  
  my @ANI = qw(- \ | /);
  
  sub progress {
      my($self, $status, $m) = @_;
      return unless $self->{show_progress};
  
      local($,, $\);
      if ($status eq "begin") {
          print STDERR "** ", $m->method, " ", $m->uri, " ==> ";
          $self->{progress_start} = time;
          $self->{progress_lastp} = "";
          $self->{progress_ani} = 0;
      }
      elsif ($status eq "end") {
          delete $self->{progress_lastp};
          delete $self->{progress_ani};
          print STDERR $m->status_line;
          my $t = time - delete $self->{progress_start};
          print STDERR " (${t}s)" if $t;
          print STDERR "\n";
      }
      elsif ($status eq "tick") {
          print STDERR "$ANI[$self->{progress_ani}++]\b";
          $self->{progress_ani} %= @ANI;
      }
      else {
          my $p = sprintf "%3.0f%%", $status * 100;
          return if $p eq $self->{progress_lastp};
          print STDERR "$p\b\b\b\b";
          $self->{progress_lastp} = $p;
      }
      STDERR->flush;
  }
  
  
  #
  # This whole allow/forbid thing is based on man 1 at's way of doing things.
  #
  sub is_protocol_supported
  {
      my($self, $scheme) = @_;
      if (ref $scheme) {
  	# assume we got a reference to an URI object
  	$scheme = $scheme->scheme;
      }
      else {
  	Carp::croak("Illegal scheme '$scheme' passed to is_protocol_supported")
  	    if $scheme =~ /\W/;
  	$scheme = lc $scheme;
      }
  
      my $x;
      if(ref($self) and $x       = $self->protocols_allowed) {
        return 0 unless grep lc($_) eq $scheme, @$x;
      }
      elsif (ref($self) and $x = $self->protocols_forbidden) {
        return 0 if grep lc($_) eq $scheme, @$x;
      }
  
      local($SIG{__DIE__});  # protect against user defined die handlers
      $x = LWP::Protocol::implementor($scheme);
      return 1 if $x and $x ne 'LWP::Protocol::nogo';
      return 0;
  }
  
  
  sub protocols_allowed      { shift->_elem('protocols_allowed'    , @_) }
  sub protocols_forbidden    { shift->_elem('protocols_forbidden'  , @_) }
  sub requests_redirectable  { shift->_elem('requests_redirectable', @_) }
  
  
  sub redirect_ok
  {
      # RFC 2616, section 10.3.2 and 10.3.3 say:
      #  If the 30[12] status code is received in response to a request other
      #  than GET or HEAD, the user agent MUST NOT automatically redirect the
      #  request unless it can be confirmed by the user, since this might
      #  change the conditions under which the request was issued.
  
      # Note that this routine used to be just:
      #  return 0 if $_[1]->method eq "POST";  return 1;
  
      my($self, $new_request, $response) = @_;
      my $method = $response->request->method;
      return 0 unless grep $_ eq $method,
        @{ $self->requests_redirectable || [] };
      
      if ($new_request->uri->scheme eq 'file') {
        $response->header("Client-Warning" =>
  			"Can't redirect to a file:// URL!");
        return 0;
      }
      
      # Otherwise it's apparently okay...
      return 1;
  }
  
  
  sub credentials
  {
      my $self = shift;
      my $netloc = lc(shift);
      my $realm = shift || "";
      my $old = $self->{basic_authentication}{$netloc}{$realm};
      if (@_) {
          $self->{basic_authentication}{$netloc}{$realm} = [@_];
      }
      return unless $old;
      return @$old if wantarray;
      return join(":", @$old);
  }
  
  
  sub get_basic_credentials
  {
      my($self, $realm, $uri, $proxy) = @_;
      return if $proxy;
      return $self->credentials($uri->host_port, $realm);
  }
  
  
  sub timeout      { shift->_elem('timeout',      @_); }
  sub local_address{ shift->_elem('local_address',@_); }
  sub max_size     { shift->_elem('max_size',     @_); }
  sub max_redirect { shift->_elem('max_redirect', @_); }
  sub show_progress{ shift->_elem('show_progress', @_); }
  
  sub ssl_opts {
      my $self = shift;
      if (@_ == 1) {
  	my $k = shift;
  	return $self->{ssl_opts}{$k};
      }
      if (@_) {
  	my $old;
  	while (@_) {
  	    my($k, $v) = splice(@_, 0, 2);
  	    $old = $self->{ssl_opts}{$k} unless @_;
  	    if (defined $v) {
  		$self->{ssl_opts}{$k} = $v;
  	    }
  	    else {
  		delete $self->{ssl_opts}{$k};
  	    }
  	}
  	%{$self->{ssl_opts}} = (%{$self->{ssl_opts}}, @_);
  	return $old;
      }
  
      return keys %{$self->{ssl_opts}};
  }
  
  sub parse_head {
      my $self = shift;
      if (@_) {
          my $flag = shift;
          my $parser;
          my $old = $self->set_my_handler("response_header", $flag ? sub {
                 my($response, $ua) = @_;
                 require HTML::HeadParser;
                 $parser = HTML::HeadParser->new;
                 $parser->xml_mode(1) if $response->content_is_xhtml;
                 $parser->utf8_mode(1) if $] >= 5.008 && $HTML::Parser::VERSION >= 3.40;
  
                 push(@{$response->{handlers}{response_data}}, {
  		   callback => sub {
  		       return unless $parser;
  		       unless ($parser->parse($_[3])) {
  			   my $h = $parser->header;
  			   my $r = $_[0];
  			   for my $f ($h->header_field_names) {
  			       $r->init_header($f, [$h->header($f)]);
  			   }
  			   undef($parser);
  		       }
  		   },
  	       });
  
              } : undef,
              m_media_type => "html",
          );
          return !!$old;
      }
      else {
          return !!$self->get_my_handler("response_header");
      }
  }
  
  sub cookie_jar {
      my $self = shift;
      my $old = $self->{cookie_jar};
      if (@_) {
  	my $jar = shift;
  	if (ref($jar) eq "HASH") {
  	    require HTTP::Cookies;
  	    $jar = HTTP::Cookies->new(%$jar);
  	}
  	$self->{cookie_jar} = $jar;
          $self->set_my_handler("request_prepare",
              $jar ? sub { $jar->add_cookie_header($_[0]); } : undef,
          );
          $self->set_my_handler("response_done",
              $jar ? sub { $jar->extract_cookies($_[0]); } : undef,
          );
      }
      $old;
  }
  
  sub default_headers {
      my $self = shift;
      my $old = $self->{def_headers} ||= HTTP::Headers->new;
      if (@_) {
  	Carp::croak("default_headers not set to HTTP::Headers compatible object")
  	    unless @_ == 1 && $_[0]->can("header_field_names");
  	$self->{def_headers} = shift;
      }
      return $old;
  }
  
  sub default_header {
      my $self = shift;
      return $self->default_headers->header(@_);
  }
  
  sub _agent       { "libwww-perl/$LWP::VERSION" }
  
  sub agent {
      my $self = shift;
      if (@_) {
  	my $agent = shift;
          if ($agent) {
              $agent .= $self->_agent if $agent =~ /\s+$/;
          }
          else {
              undef($agent)
          }
          return $self->default_header("User-Agent", $agent);
      }
      return $self->default_header("User-Agent");
  }
  
  sub from {  # legacy
      my $self = shift;
      return $self->default_header("From", @_);
  }
  
  
  sub conn_cache {
      my $self = shift;
      my $old = $self->{conn_cache};
      if (@_) {
  	my $cache = shift;
  	if (ref($cache) eq "HASH") {
  	    require LWP::ConnCache;
  	    $cache = LWP::ConnCache->new(%$cache);
  	}
  	$self->{conn_cache} = $cache;
      }
      $old;
  }
  
  
  sub add_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{line} ||= join(":", (caller)[1,2]);
      my $conf = $self->{handlers}{$phase} ||= do {
          require HTTP::Config;
          HTTP::Config->new;
      };
      $conf->add(%spec, callback => $cb);
  }
  
  sub set_my_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      $self->remove_handler($phase, %spec);
      $spec{line} ||= join(":", (caller)[1,2]);
      $self->add_handler($phase, $cb, %spec) if $cb;
  }
  
  sub get_my_handler {
      my $self = shift;
      my $phase = shift;
      my $init = pop if @_ % 2;
      my %spec = @_;
      my $conf = $self->{handlers}{$phase};
      unless ($conf) {
          return unless $init;
          require HTTP::Config;
          $conf = $self->{handlers}{$phase} = HTTP::Config->new;
      }
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      my @h = $conf->find(%spec);
      if (!@h && $init) {
          if (ref($init) eq "CODE") {
              $init->(\%spec);
          }
          elsif (ref($init) eq "HASH") {
              while (my($k, $v) = each %$init) {
                  $spec{$k} = $v;
              }
          }
          $spec{callback} ||= sub {};
          $spec{line} ||= join(":", (caller)[1,2]);
          $conf->add(\%spec);
          return \%spec;
      }
      return wantarray ? @h : $h[0];
  }
  
  sub remove_handler {
      my($self, $phase, %spec) = @_;
      if ($phase) {
          my $conf = $self->{handlers}{$phase} || return;
          my @h = $conf->remove(%spec);
          delete $self->{handlers}{$phase} if $conf->empty;
          return @h;
      }
  
      return unless $self->{handlers};
      return map $self->remove_handler($_), sort keys %{$self->{handlers}};
  }
  
  sub handlers {
      my($self, $phase, $o) = @_;
      my @h;
      if ($o->{handlers} && $o->{handlers}{$phase}) {
          push(@h, @{$o->{handlers}{$phase}});
      }
      if (my $conf = $self->{handlers}{$phase}) {
          push(@h, $conf->matching($o));
      }
      return @h;
  }
  
  sub run_handlers {
      my($self, $phase, $o) = @_;
      if (defined(wantarray)) {
          for my $h ($self->handlers($phase, $o)) {
              my $ret = $h->{callback}->($o, $self, $h);
              return $ret if $ret;
          }
          return undef;
      }
  
      for my $h ($self->handlers($phase, $o)) {
          $h->{callback}->($o, $self, $h);
      }
  }
  
  
  # deprecated
  sub use_eval   { shift->_elem('use_eval',  @_); }
  sub use_alarm
  {
      Carp::carp("LWP::UserAgent->use_alarm(BOOL) is a no-op")
  	if @_ > 1 && $^W;
      "";
  }
  
  
  sub clone
  {
      my $self = shift;
      my $copy = bless { %$self }, ref $self;  # copy most fields
  
      delete $copy->{handlers};
      delete $copy->{conn_cache};
  
      # copy any plain arrays and hashes; known not to need recursive copy
      for my $k (qw(proxy no_proxy requests_redirectable ssl_opts)) {
          next unless $copy->{$k};
          if (ref($copy->{$k}) eq "ARRAY") {
              $copy->{$k} = [ @{$copy->{$k}} ];
          }
          elsif (ref($copy->{$k}) eq "HASH") {
              $copy->{$k} = { %{$copy->{$k}} };
          }
      }
  
      if ($self->{def_headers}) {
          $copy->{def_headers} = $self->{def_headers}->clone;
      }
  
      # re-enable standard handlers
      $copy->parse_head($self->parse_head);
  
      # no easy way to clone the cookie jar; so let's just remove it for now
      $copy->cookie_jar(undef);
  
      $copy;
  }
  
  
  sub mirror
  {
      my($self, $url, $file) = @_;
  
      my $request = HTTP::Request->new('GET', $url);
  
      # If the file exists, add a cache-related header
      if ( -e $file ) {
          my ($mtime) = ( stat($file) )[9];
          if ($mtime) {
              $request->header( 'If-Modified-Since' => HTTP::Date::time2str($mtime) );
          }
      }
      my $tmpfile = "$file-$$";
  
      my $response = $self->request($request, $tmpfile);
      if ( $response->header('X-Died') ) {
  	die $response->header('X-Died');
      }
  
      # Only fetching a fresh copy of the would be considered success.
      # If the file was not modified, "304" would returned, which 
      # is considered by HTTP::Status to be a "redirect", /not/ "success"
      if ( $response->is_success ) {
          my @stat        = stat($tmpfile) or die "Could not stat tmpfile '$tmpfile': $!";
          my $file_length = $stat[7];
          my ($content_length) = $response->header('Content-length');
  
          if ( defined $content_length and $file_length < $content_length ) {
              unlink($tmpfile);
              die "Transfer truncated: " . "only $file_length out of $content_length bytes received\n";
          }
          elsif ( defined $content_length and $file_length > $content_length ) {
              unlink($tmpfile);
              die "Content-length mismatch: " . "expected $content_length bytes, got $file_length\n";
          }
          # The file was the expected length. 
          else {
              # Replace the stale file with a fresh copy
              if ( -e $file ) {
                  # Some DOSish systems fail to rename if the target exists
                  chmod 0777, $file;
                  unlink $file;
              }
              rename( $tmpfile, $file )
                  or die "Cannot rename '$tmpfile' to '$file': $!\n";
  
              # make sure the file has the same last modification time
              if ( my $lm = $response->last_modified ) {
                  utime $lm, $lm, $file;
              }
          }
      }
      # The local copy is fresh enough, so just delete the temp file  
      else {
  	unlink($tmpfile);
      }
      return $response;
  }
  
  
  sub _need_proxy {
      my($req, $ua) = @_;
      return if exists $req->{proxy};
      my $proxy = $ua->{proxy}{$req->uri->scheme} || return;
      if ($ua->{no_proxy}) {
          if (my $host = eval { $req->uri->host }) {
              for my $domain (@{$ua->{no_proxy}}) {
                  if ($host =~ /\Q$domain\E$/) {
                      return;
                  }
              }
          }
      }
      $req->{proxy} = $HTTP::URI_CLASS->new($proxy);
  }
  
  
  sub proxy
  {
      my $self = shift;
      my $key  = shift;
      return map $self->proxy($_, @_), @$key if ref $key;
  
      Carp::croak("'$key' is not a valid URI scheme") unless $key =~ /^$URI::scheme_re\z/;
      my $old = $self->{'proxy'}{$key};
      if (@_) {
          my $url = shift;
          if (defined($url) && length($url)) {
              Carp::croak("Proxy must be specified as absolute URI; '$url' is not") unless $url =~ /^$URI::scheme_re:/;
              Carp::croak("Bad http proxy specification '$url'") if $url =~ /^https?:/ && $url !~ m,^https?://\w,;
          }
          $self->{proxy}{$key} = $url;
          $self->set_my_handler("request_preprepare", \&_need_proxy)
      }
      return $old;
  }
  
  
  sub env_proxy {
      my ($self) = @_;
      require Encode;
      require Encode::Locale;
      my($k,$v);
      while(($k, $v) = each %ENV) {
  	if ($ENV{REQUEST_METHOD}) {
  	    # Need to be careful when called in the CGI environment, as
  	    # the HTTP_PROXY variable is under control of that other guy.
  	    next if $k =~ /^HTTP_/;
  	    $k = "HTTP_PROXY" if $k eq "CGI_HTTP_PROXY";
  	}
  	$k = lc($k);
  	next unless $k =~ /^(.*)_proxy$/;
  	$k = $1;
  	if ($k eq 'no') {
  	    $self->no_proxy(split(/\s*,\s*/, $v));
  	}
  	else {
              # Ignore random _proxy variables, allow only valid schemes
              next unless $k =~ /^$URI::scheme_re\z/;
              # Ignore xxx_proxy variables if xxx isn't a supported protocol
              next unless LWP::Protocol::implementor($k);
  	    $self->proxy($k, Encode::decode(locale => $v));
  	}
      }
  }
  
  
  sub no_proxy {
      my($self, @no) = @_;
      if (@no) {
  	push(@{ $self->{'no_proxy'} }, @no);
      }
      else {
  	$self->{'no_proxy'} = [];
      }
  }
  
  
  sub _new_response {
      my($request, $code, $message, $content) = @_;
      $message ||= HTTP::Status::status_message($code);
      my $response = HTTP::Response->new($code, $message);
      $response->request($request);
      $response->header("Client-Date" => HTTP::Date::time2str(time));
      $response->header("Client-Warning" => "Internal response");
      $response->header("Content-Type" => "text/plain");
      $response->content($content || "$code $message\n");
      return $response;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::UserAgent - Web user agent class
  
  =head1 SYNOPSIS
  
   require LWP::UserAgent;
   
   my $ua = LWP::UserAgent->new;
   $ua->timeout(10);
   $ua->env_proxy;
   
   my $response = $ua->get('http://search.cpan.org/');
   
   if ($response->is_success) {
       print $response->decoded_content;  # or whatever
   }
   else {
       die $response->status_line;
   }
  
  =head1 DESCRIPTION
  
  The C<LWP::UserAgent> is a class implementing a web user agent.
  C<LWP::UserAgent> objects can be used to dispatch web requests.
  
  In normal use the application creates an C<LWP::UserAgent> object, and
  then configures it with values for timeouts, proxies, name, etc. It
  then creates an instance of C<HTTP::Request> for the request that
  needs to be performed. This request is then passed to one of the
  request method the UserAgent, which dispatches it using the relevant
  protocol, and returns a C<HTTP::Response> object.  There are
  convenience methods for sending the most common request types: get(),
  head(), post(), put() and delete().  When using these methods then the
  creation of the request object is hidden as shown in the synopsis above.
  
  The basic approach of the library is to use HTTP style communication
  for all protocol schemes.  This means that you will construct
  C<HTTP::Request> objects and receive C<HTTP::Response> objects even
  for non-HTTP resources like I<gopher> and I<ftp>.  In order to achieve
  even more similarity to HTTP style communications, gopher menus and
  file directories are converted to HTML documents.
  
  =head1 CONSTRUCTOR METHODS
  
  The following constructor methods are available:
  
  =over 4
  
  =item $ua = LWP::UserAgent->new( %options )
  
  This method constructs a new C<LWP::UserAgent> object and returns it.
  Key/value pair arguments may be provided to set up the initial state.
  The following options correspond to attribute methods described below:
  
     KEY                     DEFAULT
     -----------             --------------------
     agent                   "libwww-perl/#.###"
     from                    undef
     conn_cache              undef
     cookie_jar              undef
     default_headers         HTTP::Headers->new
     local_address           undef
     ssl_opts		   { verify_hostname => 1 }
     max_size                undef
     max_redirect            7
     parse_head              1
     protocols_allowed       undef
     protocols_forbidden     undef
     requests_redirectable   ['GET', 'HEAD']
     timeout                 180
  
  The following additional options are also accepted: If the C<env_proxy> option
  is passed in with a TRUE value, then proxy settings are read from environment
  variables (see env_proxy() method below).  If C<env_proxy> isn't provided the
  C<PERL_LWP_ENV_PROXY> environment variable controls if env_proxy() is called
  during initialization.  If the C<keep_alive> option is passed in, then a
  C<LWP::ConnCache> is set up (see conn_cache() method below).  The C<keep_alive>
  value is passed on as the C<total_capacity> for the connection cache.
  
  =item $ua->clone
  
  Returns a copy of the LWP::UserAgent object.
  
  =back
  
  =head1 ATTRIBUTES
  
  The settings of the configuration attributes modify the behaviour of the
  C<LWP::UserAgent> when it dispatches requests.  Most of these can also
  be initialized by options passed to the constructor method.
  
  The following attribute methods are provided.  The attribute value is
  left unchanged if no argument is given.  The return value from each
  method is the old attribute value.
  
  =over
  
  =item $ua->agent
  
  =item $ua->agent( $product_id )
  
  Get/set the product token that is used to identify the user agent on
  the network.  The agent value is sent as the "User-Agent" header in
  the requests.  The default is the string returned by the _agent()
  method (see below).
  
  If the $product_id ends with space then the _agent() string is
  appended to it.
  
  The user agent string should be one or more simple product identifiers
  with an optional version number separated by the "/" character.
  Examples are:
  
    $ua->agent('Checkbot/0.4 ' . $ua->_agent);
    $ua->agent('Checkbot/0.4 ');    # same as above
    $ua->agent('Mozilla/5.0');
    $ua->agent("");                 # don't identify
  
  =item $ua->_agent
  
  Returns the default agent identifier.  This is a string of the form
  "libwww-perl/#.###", where "#.###" is substituted with the version number
  of this library.
  
  =item $ua->from
  
  =item $ua->from( $email_address )
  
  Get/set the e-mail address for the human user who controls
  the requesting user agent.  The address should be machine-usable, as
  defined in RFC 822.  The C<from> value is send as the "From" header in
  the requests.  Example:
  
    $ua->from('gaas@cpan.org');
  
  The default is to not send a "From" header.  See the default_headers()
  method for the more general interface that allow any header to be defaulted.
  
  =item $ua->cookie_jar
  
  =item $ua->cookie_jar( $cookie_jar_obj )
  
  Get/set the cookie jar object to use.  The only requirement is that
  the cookie jar object must implement the extract_cookies($request) and
  add_cookie_header($response) methods.  These methods will then be
  invoked by the user agent as requests are sent and responses are
  received.  Normally this will be a C<HTTP::Cookies> object or some
  subclass.
  
  The default is to have no cookie_jar, i.e. never automatically add
  "Cookie" headers to the requests.
  
  Shortcut: If a reference to a plain hash is passed in as the
  $cookie_jar_object, then it is replaced with an instance of
  C<HTTP::Cookies> that is initialized based on the hash.  This form also
  automatically loads the C<HTTP::Cookies> module.  It means that:
  
    $ua->cookie_jar({ file => "$ENV{HOME}/.cookies.txt" });
  
  is really just a shortcut for:
  
    require HTTP::Cookies;
    $ua->cookie_jar(HTTP::Cookies->new(file => "$ENV{HOME}/.cookies.txt"));
  
  =item $ua->default_headers
  
  =item $ua->default_headers( $headers_obj )
  
  Get/set the headers object that will provide default header values for
  any requests sent.  By default this will be an empty C<HTTP::Headers>
  object.
  
  =item $ua->default_header( $field )
  
  =item $ua->default_header( $field => $value )
  
  This is just a short-cut for $ua->default_headers->header( $field =>
  $value ). Example:
  
    $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
    $ua->default_header('Accept-Language' => "no, en");
  
  =item $ua->conn_cache
  
  =item $ua->conn_cache( $cache_obj )
  
  Get/set the C<LWP::ConnCache> object to use.  See L<LWP::ConnCache>
  for details.
  
  =item $ua->credentials( $netloc, $realm )
  
  =item $ua->credentials( $netloc, $realm, $uname, $pass )
  
  Get/set the user name and password to be used for a realm.
  
  The $netloc is a string of the form "<host>:<port>".  The username and
  password will only be passed to this server.  Example:
  
    $ua->credentials("www.example.com:80", "Some Realm", "foo", "secret");
  
  =item $ua->local_address
  
  =item $ua->local_address( $address )
  
  Get/set the local interface to bind to for network connections.  The interface
  can be specified as a hostname or an IP address.  This value is passed as the
  C<LocalAddr> argument to L<IO::Socket::INET>.
  
  =item $ua->max_size
  
  =item $ua->max_size( $bytes )
  
  Get/set the size limit for response content.  The default is C<undef>,
  which means that there is no limit.  If the returned response content
  is only partial, because the size limit was exceeded, then a
  "Client-Aborted" header will be added to the response.  The content
  might end up longer than C<max_size> as we abort once appending a
  chunk of data makes the length exceed the limit.  The "Content-Length"
  header, if present, will indicate the length of the full content and
  will normally not be the same as C<< length($res->content) >>.
  
  =item $ua->max_redirect
  
  =item $ua->max_redirect( $n )
  
  This reads or sets the object's limit of how many times it will obey
  redirection responses in a given request cycle.
  
  By default, the value is 7. This means that if you call request()
  method and the response is a redirect elsewhere which is in turn a
  redirect, and so on seven times, then LWP gives up after that seventh
  request.
  
  =item $ua->parse_head
  
  =item $ua->parse_head( $boolean )
  
  Get/set a value indicating whether we should initialize response
  headers from the E<lt>head> section of HTML documents. The default is
  TRUE.  Do not turn this off, unless you know what you are doing.
  
  =item $ua->protocols_allowed
  
  =item $ua->protocols_allowed( \@protocols )
  
  This reads (or sets) this user agent's list of protocols that the
  request methods will exclusively allow.  The protocol names are case
  insensitive.
  
  For example: C<$ua-E<gt>protocols_allowed( [ 'http', 'https'] );>
  means that this user agent will I<allow only> those protocols,
  and attempts to use this user agent to access URLs with any other
  schemes (like "ftp://...") will result in a 500 error.
  
  To delete the list, call: C<$ua-E<gt>protocols_allowed(undef)>
  
  By default, an object has neither a C<protocols_allowed> list, nor a
  C<protocols_forbidden> list.
  
  Note that having a C<protocols_allowed> list causes any
  C<protocols_forbidden> list to be ignored.
  
  =item $ua->protocols_forbidden
  
  =item $ua->protocols_forbidden( \@protocols )
  
  This reads (or sets) this user agent's list of protocols that the
  request method will I<not> allow. The protocol names are case
  insensitive.
  
  For example: C<$ua-E<gt>protocols_forbidden( [ 'file', 'mailto'] );>
  means that this user agent will I<not> allow those protocols, and
  attempts to use this user agent to access URLs with those schemes
  will result in a 500 error.
  
  To delete the list, call: C<$ua-E<gt>protocols_forbidden(undef)>
  
  =item $ua->requests_redirectable
  
  =item $ua->requests_redirectable( \@requests )
  
  This reads or sets the object's list of request names that
  C<$ua-E<gt>redirect_ok(...)> will allow redirection for.  By
  default, this is C<['GET', 'HEAD']>, as per RFC 2616.  To
  change to include 'POST', consider:
  
     push @{ $ua->requests_redirectable }, 'POST';
  
  =item $ua->show_progress
  
  =item $ua->show_progress( $boolean )
  
  Get/set a value indicating whether a progress bar should be displayed
  on the terminal as requests are processed. The default is FALSE.
  
  =item $ua->timeout
  
  =item $ua->timeout( $secs )
  
  Get/set the timeout value in seconds. The default timeout() value is
  180 seconds, i.e. 3 minutes.
  
  The requests is aborted if no activity on the connection to the server
  is observed for C<timeout> seconds.  This means that the time it takes
  for the complete transaction and the request() method to actually
  return might be longer.
  
  =item $ua->ssl_opts
  
  =item $ua->ssl_opts( $key )
  
  =item $ua->ssl_opts( $key => $value )
  
  Get/set the options for SSL connections.  Without argument return the list
  of options keys currently set.  With a single argument return the current
  value for the given option.  With 2 arguments set the option value and return
  the old.  Setting an option to the value C<undef> removes this option.
  
  The options that LWP relates to are:
  
  =over
  
  =item C<verify_hostname> => $bool
  
  When TRUE LWP will for secure protocol schemes ensure it connects to servers
  that have a valid certificate matching the expected hostname.  If FALSE no
  checks are made and you can't be sure that you communicate with the expected peer.
  The no checks behaviour was the default for libwww-perl-5.837 and earlier releases.
  
  This option is initialized from the L<PERL_LWP_SSL_VERIFY_HOSTNAME> environment
  variable.  If this environment variable isn't set; then C<verify_hostname>
  defaults to 1.
  
  =item C<SSL_ca_file> => $path
  
  The path to a file containing Certificate Authority certificates.
  A default setting for this option is provided by checking the environment
  variables C<PERL_LWP_SSL_CA_FILE> and C<HTTPS_CA_FILE> in order.
  
  =item C<SSL_ca_path> => $path
  
  The path to a directory containing files containing Certificate Authority
  certificates.
  A default setting for this option is provided by checking the environment
  variables C<PERL_LWP_SSL_CA_PATH> and C<HTTPS_CA_DIR> in order.
  
  =back
  
  Other options can be set and are processed directly by the SSL Socket implementation
  in use.  See L<IO::Socket::SSL> or L<Net::SSL> for details.
  
  The libwww-perl core no longer bundles protocol plugins for SSL.  You will need
  to install L<LWP::Protocol::https> separately to enable support for processing
  https-URLs.
  
  =back
  
  =head2 Proxy attributes
  
  The following methods set up when requests should be passed via a
  proxy server.
  
  =over
  
  =item $ua->proxy(\@schemes, $proxy_url)
  
  =item $ua->proxy($scheme, $proxy_url)
  
  Set/retrieve proxy URL for a scheme:
  
   $ua->proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');
   $ua->proxy('gopher', 'http://proxy.sn.no:8001/');
  
  The first form specifies that the URL is to be used for proxying of
  access methods listed in the list in the first method argument,
  i.e. 'http' and 'ftp'.
  
  The second form shows a shorthand form for specifying
  proxy URL for a single access scheme.
  
  =item $ua->no_proxy( $domain, ... )
  
  Do not proxy requests to the given domains.  Calling no_proxy without
  any domains clears the list of domains. Eg:
  
   $ua->no_proxy('localhost', 'example.com');
  
  =item $ua->env_proxy
  
  Load proxy settings from *_proxy environment variables.  You might
  specify proxies like this (sh-syntax):
  
    gopher_proxy=http://proxy.my.place/
    wais_proxy=http://proxy.my.place/
    no_proxy="localhost,example.com"
    export gopher_proxy wais_proxy no_proxy
  
  csh or tcsh users should use the C<setenv> command to define these
  environment variables.
  
  On systems with case insensitive environment variables there exists a
  name clash between the CGI environment variables and the C<HTTP_PROXY>
  environment variable normally picked up by env_proxy().  Because of
  this C<HTTP_PROXY> is not honored for CGI scripts.  The
  C<CGI_HTTP_PROXY> environment variable can be used instead.
  
  =back
  
  =head2 Handlers
  
  Handlers are code that injected at various phases during the
  processing of requests.  The following methods are provided to manage
  the active handlers:
  
  =over
  
  =item $ua->add_handler( $phase => \&cb, %matchspec )
  
  Add handler to be invoked in the given processing phase.  For how to
  specify %matchspec see L<HTTP::Config/"Matching">.
  
  The possible values $phase and the corresponding callback signatures are:
  
  =over
  
  =item request_preprepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the C<request_prepare> and other standard
  initialization of the request.  This can be used to set up headers
  and attributes that the C<request_prepare> handler depends on.  Proxy
  initialization should take place here; but in general don't register
  handlers for this phase.
  
  =item request_prepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the request is sent and can modify the
  request any way it see fit.  This can for instance be used to add
  certain headers to specific requests.
  
  The method can assign a new request object to $_[0] to replace the
  request that is sent fully.
  
  The return value from the callback is ignored.  If an exception is
  raised it will abort the request and make the request method return a
  "400 Bad request" response.
  
  =item request_send => sub { my($request, $ua, $h) = @_; ... }
  
  This handler gets a chance of handling requests before they're sent to the
  protocol handlers.  It should return an HTTP::Response object if it
  wishes to terminate the processing; otherwise it should return nothing.
  
  The C<response_header> and C<response_data> handlers will not be
  invoked for this response, but the C<response_done> will be.
  
  =item response_header => sub { my($response, $ua, $h) = @_; ... }
  
  This handler is called right after the response headers have been
  received, but before any content data.  The handler might set up
  handlers for data and might croak to abort the request.
  
  The handler might set the $response->{default_add_content} value to
  control if any received data should be added to the response object
  directly.  This will initially be false if the $ua->request() method
  was called with a $content_file or $content_cb argument; otherwise true.
  
  =item response_data => sub { my($response, $ua, $h, $data) = @_; ... }
  
  This handler is called for each chunk of data received for the
  response.  The handler might croak to abort the request.
  
  This handler needs to return a TRUE value to be called again for
  subsequent chunks for the same request.
  
  =item response_done => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called after the response has been fully received, but
  before any redirect handling is attempted.  The handler can be used to
  extract information or modify the response.
  
  =item response_redirect => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called in $ua->request after C<response_done>.  If the
  handler returns an HTTP::Request object we'll start over with processing
  this request instead.
  
  =back
  
  =item $ua->remove_handler( undef, %matchspec )
  
  =item $ua->remove_handler( $phase, %matchspec )
  
  Remove handlers that match the given %matchspec.  If $phase is not
  provided remove handlers from all phases.
  
  Be careful as calling this function with %matchspec that is not
  specific enough can remove handlers not owned by you.  It's probably
  better to use the set_my_handler() method instead.
  
  The removed handlers are returned.
  
  =item $ua->set_my_handler( $phase, $cb, %matchspec )
  
  Set handlers private to the executing subroutine.  Works by defaulting
  an C<owner> field to the %matchspec that holds the name of the called
  subroutine.  You might pass an explicit C<owner> to override this.
  
  If $cb is passed as C<undef>, remove the handler.
  
  =item $ua->get_my_handler( $phase, %matchspec )
  
  =item $ua->get_my_handler( $phase, %matchspec, $init )
  
  Will retrieve the matching handler as hash ref.
  
  If C<$init> is passed as a TRUE value, create and add the
  handler if it's not found.  If $init is a subroutine reference, then
  it's called with the created handler hash as argument.  This sub might
  populate the hash with extra fields; especially the callback.  If
  $init is a hash reference, merge the hashes.
  
  =item $ua->handlers( $phase, $request )
  
  =item $ua->handlers( $phase, $response )
  
  Returns the handlers that apply to the given request or response at
  the given processing phase.
  
  =back
  
  =head1 REQUEST METHODS
  
  The methods described in this section are used to dispatch requests
  via the user agent.  The following request methods are provided:
  
  =over
  
  =item $ua->get( $url )
  
  =item $ua->get( $url , $field_name => $value, ... )
  
  This method will dispatch a C<GET> request on the given $url.  Further
  arguments can be given to initialize the headers of the request. These
  are given as separate name/value pairs.  The return value is a
  response object.  See L<HTTP::Response> for a description of the
  interface it provides.
  
  There will still be a response object returned when LWP can't connect to the
  server specified in the URL or when other failures in protocol handlers occur.
  These internal responses use the standard HTTP status codes, so the responses
  can't be differentiated by testing the response status code alone.  Error
  responses that LWP generates internally will have the "Client-Warning" header
  set to the value "Internal response".  If you need to differentiate these
  internal responses from responses that a remote server actually generates, you
  need to test this header value.
  
  Fields names that start with ":" are special.  These will not
  initialize headers of the request but will determine how the response
  content is treated.  The following special field names are recognized:
  
      :content_file   => $filename
      :content_cb     => \&callback
      :read_size_hint => $bytes
  
  If a $filename is provided with the C<:content_file> option, then the
  response content will be saved here instead of in the response
  object.  If a callback is provided with the C<:content_cb> option then
  this function will be called for each chunk of the response content as
  it is received from the server.  If neither of these options are
  given, then the response content will accumulate in the response
  object itself.  This might not be suitable for very large response
  bodies.  Only one of C<:content_file> or C<:content_cb> can be
  specified.  The content of unsuccessful responses will always
  accumulate in the response object itself, regardless of the
  C<:content_file> or C<:content_cb> options passed in.
  
  The C<:read_size_hint> option is passed to the protocol module which
  will try to read data from the server in chunks of this size.  A
  smaller value for the C<:read_size_hint> will result in a higher
  number of callback invocations.
  
  The callback function is called with 3 arguments: a chunk of data, a
  reference to the response object, and a reference to the protocol
  object.  The callback can abort the request by invoking die().  The
  exception message will show up as the "X-Died" header field in the
  response returned by the get() function.
  
  =item $ua->head( $url )
  
  =item $ua->head( $url , $field_name => $value, ... )
  
  This method will dispatch a C<HEAD> request on the given $url.
  Otherwise it works like the get() method described above.
  
  =item $ua->post( $url, \%form )
  
  =item $ua->post( $url, \@form )
  
  =item $ua->post( $url, \%form, $field_name => $value, ... )
  
  =item $ua->post( $url, $field_name => $value,... Content => \%form )
  
  =item $ua->post( $url, $field_name => $value,... Content => \@form )
  
  =item $ua->post( $url, $field_name => $value,... Content => $content )
  
  This method will dispatch a C<POST> request on the given $url, with
  %form or @form providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the get() method.
  
  This method will use the POST() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->put( $url, \%form )
  
  =item $ua->put( $url, \@form )
  
  =item $ua->put( $url, \%form, $field_name => $value, ... )
  
  =item $ua->put( $url, $field_name => $value,... Content => \%form )
  
  =item $ua->put( $url, $field_name => $value,... Content => \@form )
  
  =item $ua->put( $url, $field_name => $value,... Content => $content )
  
  This method will dispatch a C<PUT> request on the given $url, with
  %form or @form providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the get() method.
  
  This method will use the PUT() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->delete( $url )
  
  =item $ua->delete( $url, $field_name => $value, ... )
  
  This method will dispatch a C<DELETE> request on the given $url.  Additional
  headers and content options are the same as for the get() method.
  
  This method will use the DELETE() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->mirror( $url, $filename )
  
  This method will get the document identified by $url and store it in
  file called $filename.  If the file already exists, then the request
  will contain an "If-Modified-Since" header matching the modification
  time of the file.  If the document on the server has not changed since
  this time, then nothing happens.  If the document has been updated, it
  will be downloaded again.  The modification time of the file will be
  forced to match that of the server.
  
  The return value is the response object.
  
  =item $ua->request( $request )
  
  =item $ua->request( $request, $content_file )
  
  =item $ua->request( $request, $content_cb )
  
  =item $ua->request( $request, $content_cb, $read_size_hint )
  
  This method will dispatch the given $request object.  Normally this
  will be an instance of the C<HTTP::Request> class, but any object with
  a similar interface will do.  The return value is a response object.
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  interface provided by these classes.
  
  The request() method will process redirects and authentication
  responses transparently.  This means that it may actually send several
  simple requests via the simple_request() method described below.
  
  The request methods described above; get(), head(), post() and
  mirror(), will all dispatch the request they build via this method.
  They are convenience methods that simply hides the creation of the
  request object for you.
  
  The $content_file, $content_cb and $read_size_hint all correspond to
  options described with the get() method above.
  
  You are allowed to use a CODE reference as C<content> in the request
  object passed in.  The C<content> function should return the content
  when called.  The content can be returned in chunks.  The content
  function will be invoked repeatedly until it return an empty string to
  signal that there is no more content.
  
  =item $ua->simple_request( $request )
  
  =item $ua->simple_request( $request, $content_file )
  
  =item $ua->simple_request( $request, $content_cb )
  
  =item $ua->simple_request( $request, $content_cb, $read_size_hint )
  
  This method dispatches a single request and returns the response
  received.  Arguments are the same as for request() described above.
  
  The difference from request() is that simple_request() will not try to
  handle redirects or authentication responses.  The request() method
  will in fact invoke this method for each simple request it sends.
  
  =item $ua->is_online
  
  Tries to determine if you have access to the Internet.  Returns
  TRUE if the built-in heuristics determine that the user agent is
  able to access the Internet (over HTTP).  See also L<LWP::Online>.
  
  =item $ua->is_protocol_supported( $scheme )
  
  You can use this method to test whether this user agent object supports the
  specified C<scheme>.  (The C<scheme> might be a string (like 'http' or
  'ftp') or it might be an URI object reference.)
  
  Whether a scheme is supported, is determined by the user agent's
  C<protocols_allowed> or C<protocols_forbidden> lists (if any), and by
  the capabilities of LWP.  I.e., this will return TRUE only if LWP
  supports this protocol I<and> it's permitted for this particular
  object.
  
  =back
  
  =head2 Callback methods
  
  The following methods will be invoked as requests are processed. These
  methods are documented here because subclasses of C<LWP::UserAgent>
  might want to override their behaviour.
  
  =over
  
  =item $ua->prepare_request( $request )
  
  This method is invoked by simple_request().  Its task is to modify the
  given $request object by setting up various headers based on the
  attributes of the user agent. The return value should normally be the
  $request object passed in.  If a different request object is returned
  it will be the one actually processed.
  
  The headers affected by the base implementation are; "User-Agent",
  "From", "Range" and "Cookie".
  
  =item $ua->redirect_ok( $prospective_request, $response )
  
  This method is called by request() before it tries to follow a
  redirection to the request in $response.  This should return a TRUE
  value if this redirection is permissible.  The $prospective_request
  will be the request to be sent if this method returns TRUE.
  
  The base implementation will return FALSE unless the method
  is in the object's C<requests_redirectable> list,
  FALSE if the proposed redirection is to a "file://..."
  URL, and TRUE otherwise.
  
  =item $ua->get_basic_credentials( $realm, $uri, $isproxy )
  
  This is called by request() to retrieve credentials for documents
  protected by Basic or Digest Authentication.  The arguments passed in
  is the $realm provided by the server, the $uri requested and a boolean
  flag to indicate if this is authentication against a proxy server.
  
  The method should return a username and password.  It should return an
  empty list to abort the authentication resolution attempt.  Subclasses
  can override this method to prompt the user for the information. An
  example of this can be found in C<lwp-request> program distributed
  with this library.
  
  The base implementation simply checks a set of pre-stored member
  variables, set up with the credentials() method.
  
  =item $ua->progress( $status, $request_or_response )
  
  This is called frequently as the response is received regardless of
  how the content is processed.  The method is called with $status
  "begin" at the start of processing the request and with $state "end"
  before the request method returns.  In between these $status will be
  the fraction of the response currently received or the string "tick"
  if the fraction can't be calculated.
  
  When $status is "begin" the second argument is the request object,
  otherwise it is the response object.
  
  =back
  
  =head1 SEE ALSO
  
  See L<LWP> for a complete overview of libwww-perl5.  See L<lwpcook>
  and the scripts F<lwp-request> and F<lwp-download> for examples of
  usage.
  
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  message objects dispatched and received.  See L<HTTP::Request::Common>
  and L<HTML::Form> for other ways to build request objects.
  
  See L<WWW::Mechanize> and L<WWW::Search> for examples of more
  specialized user agents based on C<LWP::UserAgent>.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_USERAGENT

$fatpacked{"Modern/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODERN_PERL';
  package Modern::Perl;
  {
    $Modern::Perl::VERSION = '1.20140107';
  }
  # ABSTRACT: enable all of the features of Modern Perl with one import
  
  use 5.010_000;
  
  use strict;
  use warnings;
  
  use mro     ();
  use feature ();
  
  # enable methods on filehandles; unnecessary when 5.14 autoloads them
  use IO::File   ();
  use IO::Handle ();
  
  our $VERSION;
  
  my $wanted_date;
  sub VERSION
  {
      my ($self, $version) = @_;
  
      return $VERSION unless defined $version;
      return $VERSION if             $version < 2009;
  
      $wanted_date = $version if (caller(1))[3] =~ /::BEGIN/;
      return 2014;
  }
  
  sub import
  {
      my ($class, $date) = @_;
      $date = $wanted_date unless defined $date;
  
      my $feature_tag    = validate_date( $date );
      undef $wanted_date;
  
      warnings->import;
      strict->import;
      feature->import( $feature_tag );
      mro::set_mro( scalar caller(), 'c3' );
  }
  
  sub unimport
  {
      warnings->unimport;
      strict->unimport;
      feature->unimport;
  }
  
  my %dates =
  (
      2009 => ':5.10',
      2010 => ':5.10',
      2011 => ':5.12',
      2012 => ':5.14',
      2013 => ':5.16',
      2014 => ':5.18',
  );
  
  sub validate_date
  {
      my $date = shift;
  
      # always enable unicode_strings when available
      unless ($date)
      {
          return ':5.12' if $] > 5.011003;
          return ':5.10';
      }
  
      my $year = substr $date, 0, 4;
      return $dates{$year} if exists $dates{$year};
  
      die "Unknown date '$date' requested\n";
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Modern::Perl - enable all of the features of Modern Perl with one import
  
  =head1 VERSION
  
  version 1.20140107
  
  =head1 SYNOPSIS
  
  Modern Perl programs use several modules to enable additional features of Perl
  and of the CPAN.  Instead of copying and pasting all of these C<use> lines,
  instead write only one:
  
      use Modern::Perl;
  
  This enables the L<strict> and L<warnings> pragmas, as well as all of the
  features available in Perl 5.10. It also enables C3 method resolution order as
  documented in C<perldoc mro> and loads L<IO::File> and L<IO::Handle> so that
  you may call methods on filehandles. In the future, it may include additional
  core modules and pragmas.
  
  Because so much of this module's behavior uses lexically scoped pragmas, you
  may disable these pragmas within an inner scope with:
  
      no Modern::Perl;
  
  See L<http://www.modernperlbooks.com/mt/2009/01/toward-a-modernperl.html> for
  more information, L<http://www.modernperlbooks.com/> for further discussion of
  Modern Perl and its implications, and
  L<http://onyxneon.com/books/modern_perl/index.html> for a freely-downloadable
  Modern Perl tutorial.
  
  =head2 Forward Compatibility
  
  For forward compatibility, I recommend you specify a I<year> as the single
  optional import tag. For example:
  
      use Modern::Perl '2009';
      use Modern::Perl '2010';
  
  ... both enable 5.10 features, while:
  
      use Modern::Perl '2011';
  
  ... enables 5.12 features:
  
      use Modern::Perl '2012';
  
  ... enables 5.14 features:
  
      use Modern::Perl '2013';
  
  ... enables 5.16 features, and:
  
      use Modern::Perl '2014';
  
  ... enables 5.18 features. Obviously you cannot use newer features on earlier
  versions. Perl will throw the appropriate exception if you try.
  
  By mid-2014, this module will drop support for 5.10 and 5.12 and will complain
  (once per process) if you use a year too old. As of January 2014, Perl 5.14 is
  unsupported by the Perl 5 Porters, so please consider upgrading.
  
  =head1 AUTHOR
  
  chromatic, C<< <chromatic at wgz.org> >>
  
  =head1 BUGS
  
  None reported.
  
  Please report any bugs or feature requests to C<bug-modern-perl at
  rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Modern-Perl>.  I will be
  notified, and then you'll automatically be notified of progress on your bug as
  I make changes.
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc Modern::Perl
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Modern-Perl>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Modern-Perl>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Modern-Perl>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Modern-Perl/>
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  Damian Conway (inspiration from L<Toolkit>), Florian Ragwitz
  (L<B::Hooks::Parser>, so I didn't have to write it myself), chocolateboy (for
  suggesting that I don't even need L<B::Hooks::Parser>), Damien Learns Perl,
  David Moreno, Evan Carroll, Elliot Shank, Andreas König, Father Chrysostomos,
  and Norbert E. Grüner for reporting bugs, filing patches, and requesting
  features.
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2009-2014 chromatic, all rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl 5.18 itself.
  
  =head1 AUTHOR
  
  chromatic
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by chromatic@wgz.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
MODERN_PERL

$fatpacked{"Object/Pluggable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OBJECT_PLUGGABLE';
  package Object::Pluggable;
  BEGIN {
    $Object::Pluggable::AUTHORITY = 'cpan:HINRIK';
  }
  BEGIN {
    $Object::Pluggable::VERSION = '1.29';
  }
  
  use strict;
  use warnings;
  use Carp;
  use Object::Pluggable::Pipeline;
  use Object::Pluggable::Constants qw(:ALL);
  
  sub _pluggable_init {
      my ($self, %opts) = @_;
    
      $self->{'_pluggable_' . lc $_} = delete $opts{$_} for keys %opts;
      $self->{_pluggable_reg_prefix} = 'plugin_' if !$self->{_pluggable_reg_prefix};
      $self->{_pluggable_prefix} = 'pluggable_' if !$self->{_pluggable_prefix};
    
      if (ref $self->{_pluggable_types} eq 'ARRAY') {
          $self->{_pluggable_types} = { map { $_ => $_ } @{ $self->{_pluggable_types} } };
      }
      elsif (ref $self->{_pluggable_types} ne 'HASH') {
          croak "Argument 'types' must be supplied";
      }
    
      return 1;
  }
  
  sub _pluggable_destroy {
      my ($self) = @_;
      $self->plugin_del( $_ ) for keys %{ $self->plugin_list() };
      return;
  }
  
  sub _pluggable_event {
      return;
  }
  
  sub _pluggable_process {
      my ($self, $type, $event, $args) = @_;
  
      if (!defined $type || !defined $event) {
          carp 'Please supply an event type and name!';
          return;
      }
  
      $event = lc $event;
      my $pipeline = $self->pipeline;
      my $prefix = $self->{_pluggable_prefix};
      $event =~ s/^\Q$prefix\E//;
      my $sub = join '_', $self->{_pluggable_types}{$type}, $event;
      my $return = PLUGIN_EAT_NONE;
      my $self_ret = $return;
      my @extra_args;
  
      local $@;
      if ($self->can($sub)) {
          eval { $self_ret = $self->$sub($self, \(@$args), \@extra_args ) };
          $self->_handle_error($self, $sub, $self_ret);
      }
      elsif ( $self->can('_default') ) {
          eval { $self_ret = $self->_default($self, $sub, \(@$args), \@extra_args) };
          $self->_handle_error($self, '_default', $self_ret);
      }
  
      $self_ret = PLUGIN_EAT_NONE unless defined $self_ret;
      return $return if $self_ret == PLUGIN_EAT_PLUGIN;
      $return = PLUGIN_EAT_ALL if $self_ret == PLUGIN_EAT_CLIENT;
      return PLUGIN_EAT_ALL if $self_ret == PLUGIN_EAT_ALL;
  
      if (@extra_args) {
          push @$args, @extra_args;
          @extra_args = ();
      }
  
      for my $plugin (@{ $pipeline->{PIPELINE} }) {
          if ($self eq $plugin
            || !$pipeline->{HANDLES}{$plugin}{$type}{$event}
            && !$pipeline->{HANDLES}{$plugin}{$type}{all}) {
              next;
          }
  
          my $ret = PLUGIN_EAT_NONE;
  
          my $alias = ($pipeline->get($plugin))[1];
          if ($plugin->can($sub)) {
              eval { $ret = $plugin->$sub($self, \(@$args), \@extra_args) };
              $self->_handle_error($plugin, $sub, $ret, $alias);
          }
          elsif ( $plugin->can('_default') ) {
              eval { $ret = $plugin->_default($self, $sub, \(@$args), \@extra_args) };
              $self->_handle_error($plugin, '_default', $ret, $alias);
          }
  
  	$ret = PLUGIN_EAT_NONE unless defined $ret;
          return $return if $ret == PLUGIN_EAT_PLUGIN;
          $return = PLUGIN_EAT_ALL if $ret == PLUGIN_EAT_CLIENT;
          return PLUGIN_EAT_ALL if $ret == PLUGIN_EAT_ALL;
  
          if (@extra_args) {
              push @$args, @extra_args;
              @extra_args = ();
          }
      }
  
      return $return;
  }
  
  sub _handle_error {
      my ($self, $object, $sub, $return, $source) = @_;
      $source = defined $source ? "plugin '$source'" : 'self';
  
      if ($@) {
          chomp $@;
          my $error = "$sub call on $source failed: $@";
          warn "$error\n" if $self->{_pluggable_debug};
  
          $self->_pluggable_event(
              "$self->{_pluggable_prefix}plugin_error",
              $error, ($object == $self ? ($object, $source) : ()),
          );
      }
      elsif ( !defined $return || 
        ($return != PLUGIN_EAT_NONE
        && $return != PLUGIN_EAT_PLUGIN
        && $return != PLUGIN_EAT_CLIENT
        && $return != PLUGIN_EAT_ALL) ) {
          my $error = "$sub call on $source did not return a valid EAT constant";
          warn "$error\n" if $self->{_pluggable_debug};
  
          $self->_pluggable_event(
              "$self->{_pluggable_prefix}plugin_error",
              $error, ($object == $self ? ($object, $source) : ()),
          );
      }
  
      return;
  }
  
  # accesses the plugin pipeline
  sub pipeline {
      my ($self) = @_;
      local $@;
      eval { $self->{_PLUGINS}->isa('Object::Pluggble::Pipeline') };
      $self->{_PLUGINS} = Object::Pluggable::Pipeline->new($self) if $@;
      return $self->{_PLUGINS};
  }
  
  # Adds a new plugin object
  sub plugin_add {
      my ($self, $name, $plugin, @args) = @_;
  
      if (!defined $name || !defined $plugin) {
          carp 'Please supply a name and the plugin object to be added!';
          return;
      }
  
      return $self->pipeline->push($name, $plugin, @args);
  }
  
  # Removes a plugin object
  sub plugin_del {
      my ($self, $name, @args) = @_;
  
      if (!defined $name) {
          carp 'Please supply a name/object for the plugin to be removed!';
          return;
      }
  
      my $return = scalar $self->pipeline->remove($name, @args);
      return $return;
  }
  
  # Gets the plugin object
  sub plugin_get {
      my ($self, $name) = @_;  
  
      if (!defined $name) {
          carp 'Please supply a name/object for the plugin to be removed!';
          return;
      }
  
      return scalar $self->pipeline->get($name);
  }
  
  # Lists loaded plugins
  sub plugin_list {
      my ($self) = @_;
      my $pipeline = $self->pipeline;
    
      my %return = map {$pipeline->{PLUGS}{$_} => $_} @{ $pipeline->{PIPELINE} };
      return \%return;
  }
  
  # Lists loaded plugins in order!
  sub plugin_order {
      my ($self) = @_;
      return $self->pipeline->{PIPELINE};
  }
  
  sub plugin_register {
      my ($self, $plugin, $type, @events) = @_;
      my $pipeline = $self->pipeline;
  
      if (!grep { $_ eq $type } keys %{ $self->{_pluggable_types} }) {
          carp "The event type '$type' is not supported!";
          return;
      }
  
      if (!defined $plugin) {
          carp 'Please supply the plugin object to register events for!';
          return;
      }
  
      if (!@events) {
          carp 'Please supply at least one event to register!';
          return;
      }
  
      for my $ev (@events) {
          if (ref $ev and ref $ev eq 'ARRAY') {
              $pipeline->{HANDLES}{$plugin}{$type}{lc $_} = 1 for @$ev;
          }
          else {
              $pipeline->{HANDLES}{$plugin}{$type}{lc $ev} = 1;
          }
      }
  
      return 1;
  }
  
  sub plugin_unregister {
      my ($self, $plugin, $type, @events) = @_;
      my $pipeline = $self->pipeline;
  
      if (!grep { $_ eq $type } keys %{ $self->{_pluggable_types} }) {
          carp "The event type '$type' is not supported!";
          return;
      }
  
      if (!defined $plugin) {
          carp 'Please supply the plugin object to register!';
          return;
      }
  
      if (!@events) {
          carp 'Please supply at least one event to unregister!';
          return;
      }
  
      for my $ev (@events) {
          if (ref $ev and ref $ev eq "ARRAY") {
              for my $e (map { lc } @$ev) {
                  if (!delete $pipeline->{HANDLES}{$plugin}{$type}{$e}) {
                      carp "The event '$e' does not exist!";
                      next;
                  }
              }
          }
          else {
              $ev = lc $ev;
              if (!delete $pipeline->{HANDLES}{$plugin}{$type}{$ev}) {
                  carp "The event '$ev' does not exist!";
                  next;
              }
          }
      }
  
      return 1;
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Object::Pluggable - A base class for creating plugin-enabled objects
  
  =head1 SYNOPSIS
  
   # A simple POE Component that sends ping events to registered sessions
   # and plugins every second.
  
   {
       package SimplePoCo;
  
       use strict;
       use warnings;
       use base qw(Object::Pluggable);
       use POE;
       use Object::Pluggable::Constants qw(:ALL);
  
       sub spawn {
           my ($package, %opts) = @_;
           my $self = bless \%opts, $package;
  
           $self->_pluggable_init(
               prefix => 'simplepoco_',
               types  => [qw(EXAMPLE)],
               debug  => 1,
           );
  
           POE::Session->create(
               object_states => [
                   $self => { shutdown => '_shutdown' },
                   $self => [qw(_send_ping _start register unregister __send_event)],
               ],
           );
  
           return $self;
       }
  
       sub shutdown {
           my ($self) = @_;
           $poe_kernel->post($self->{session_id}, 'shutdown');
       }
  
       sub _pluggable_event {
           my ($self) = @_;
           $poe_kernel->post($self->{session_id}, '__send_event', @_);
       }
  
       sub _start {
           my ($kernel, $self) = @_[KERNEL, OBJECT];
           $self->{session_id} = $_[SESSION]->ID();
  
           if ($self->{alias}) {
               $kernel->alias_set($self->{alias});
           }
           else {
               $kernel->refcount_increment($self->{session_id}, __PACKAGE__);
           }
  
           $kernel->delay(_send_ping => $self->{time} || 300);
           return;
       }
  
       sub _shutdown {
            my ($kernel, $self) = @_[KERNEL, OBJECT];
  
            $self->_pluggable_destroy();
            $kernel->alarm_remove_all();
            $kernel->alias_remove($_) for $kernel->alias_list();
            $kernel->refcount_decrement($self->{session_id}, __PACKAGE__) if !$self->{alias};
            $kernel->refcount_decrement($_, __PACKAGE__) for keys %{ $self->{sessions} };
  
            return;
       }
  
       sub register {
           my ($kernel, $sender, $self) = @_[KERNEL, SENDER, OBJECT];
           my $sender_id = $sender->ID();
           $self->{sessions}->{$sender_id}++;
  
           if ($self->{sessions}->{$sender_id} == 1) { 
               $kernel->refcount_increment($sender_id, __PACKAGE__);
               $kernel->yield(__send_event => 'simplepoco_registered', $sender_id);
           }
  
           return;
       }
  
       sub unregister {
           my ($kernel, $sender, $self) = @_[KERNEL, SENDER, OBJECT];
           my $sender_id = $sender->ID();
           my $record = delete $self->{sessions}->{$sender_id};
  
           if ($record) {
               $kernel->refcount_decrement($sender_id, __PACKAGE__);
               $kernel->yield(__send_event => 'simplepoco_unregistered', $sender_id);
           }
  
           return;
       }
    
       sub __send_event {
           my ($kernel, $self, $event, @args) = @_[KERNEL, OBJECT, ARG0..$#_];
  
           return 1 if $self->_pluggable_process(EXAMPLE => $event, \@args) == PLUGIN_EAT_ALL;
           $kernel->post($_, $event, @args) for keys %{ $self->{sessions} };
       }
  
       sub _send_ping {
           my ($kernel, $self) = @_[KERNEL, OBJECT];
  
           $kernel->yield(__send_event => 'simplepoco_ping', 'Wake up sleepy');
           $kernel->delay(_send_ping => $self->{time} || 1);
           return;
       }
   }
  
   {
       package SimplePoCo::Plugin;
       use strict;
       use warnings;
       use Object::Pluggable::Constants qw(:ALL);
  
       sub new {
           my $package = shift;
           return bless { @_ }, $package;
       }
  
       sub plugin_register {
           my ($self, $pluggable) = splice @_, 0, 2;
           print "Plugin added\n";
           $pluggable->plugin_register($self, 'EXAMPLE', 'all');
           return 1;
       }
  
       sub plugin_unregister {
           print "Plugin removed\n";
           return 1;
       }
  
       sub EXAMPLE_ping {
           my ($self, $pluggable) = splice @_, 0, 2;
           my $text = ${ $_[0] };
           print "Plugin got '$text'\n";
           return PLUGIN_EAT_NONE;
       }
   }
  
   use strict;
   use warnings;
   use POE;
  
   my $pluggable = SimplePoCo->spawn(
       alias => 'pluggable',
       time  => 1,
   );
  
   POE::Session->create(
       package_states => [
           main => [qw(_start simplepoco_registered simplepoco_ping)],
       ],
   );
  
   $poe_kernel->run();
  
   sub _start {
       my $kernel = $_[KERNEL];
       $kernel->post(pluggable => 'register');
       return;
   }
  
   sub simplepoco_registered {
       print "Main program registered for events\n";
       my $plugin = SimplePoCo::Plugin->new();
       $pluggable->plugin_add('TestPlugin', $plugin);
       return;
   }
  
   sub simplepoco_ping {
       my ($heap, $text) = @_[HEAP, ARG0];
       print "Main program got '$text'\n";
       $heap->{got_ping}++;
       $pluggable->shutdown() if $heap->{got_ping} == 3;
       return;
   }
  
  =head1 DESCRIPTION
  
  Object::Pluggable is a base class for creating plugin enabled objects. It is
  a generic port of L<POE::Component::IRC|POE::Component::IRC>'s plugin system.
  
  If your object dispatches events to listeners, then Object::Pluggable may be
  a good fit for you.
  
  Basic use would involve subclassing Object::Pluggable, then overriding
  C<_pluggable_event()> and inserting C<_pluggable_process()> wherever you
  dispatch events from.
  
  Users of your object can then load plugins using the plugin methods provided
  to handle events generated by the object.
  
  You may also use plugin style handlers within your object as
  C<_pluggable_process()> will attempt to process any events with local method
  calls first. The return value of these handlers has the same significance as
  the return value of 'normal' plugin handlers.
  
  =head1 PRIVATE METHODS
  
  Subclassing Object::Pluggable gives your object the following 'private'
  methods:
  
  =head2 C<_pluggable_init>
  
  This should be called on your object after initialisation, but before you want
  to start processing plugins. It accepts a number of argument/value pairs:
  
   'types', an arrayref of the types of events that your poco will support,
            OR a hashref with the event types as keys and their abbrevations
            (used as plugin event method prefixes) as values. This argument is
            mandatory.
  
   'prefix', the prefix for your events (default: 'pluggable_');
   'reg_prefix', the prefix for the register()/unregister() plugin methods 
                 (default: 'plugin_');
   'debug', a boolean, if true, will cause a warning to be printed every time a
            plugin call fails.
  
  Notes: 'prefix' should probably end with a '_'. The types specify the prefixes
  for plugin handlers. You can specify as many different types as you require. 
  
  =head2 C<_pluggable_destroy>
  
  This should be called from any shutdown handler that your poco has. The method
  unloads any loaded plugins.
  
  =head2 C<_pluggable_process>
  
  This should be called before events are dispatched to interested sessions.
  This gives pluggable a chance to discard events if requested to by a plugin.
  
  The first argument is a type, as specified to C<_pluggable_init()>.
  
   sub _dispatch {
       my ($self, $event, $type, @args) = @_;
  
       # stuff
  
       my $type = ...
  
       return 1 if $self->_pluggable_process($type, $event, \@args)) == PLUGIN_EAT_ALL;
  
       # dispatch event to interested sessions.
   }
  
  A reference to the argument array is passed. This allows the plugin system
  to mangle the arguments or even add new ones.
  
  =head2 C<_pluggable_event>
  
  This method should be overridden in your class so that pipeline can dispatch
  events through your event dispatcher. Pipeline sends a prefixed 'plugin_add'
  and 'plugin_del' event whenever plugins are added or removed, respectively.
  A prefixed 'plugin_error' event will be sent if a plugin a) raises an
  exception, b) fails to return a true value from its register/unregister
  methods, or c) fails to return a valid EAT constant from a handler.
  
   sub _pluggable_event {
       my $self = shift;
       $poe_kernel->post($self->{session_id}, '__send_event', @_);
   }
  
  There is an example of this in the SYNOPSIS.
  
  =head1 PUBLIC METHODS
  
  Subclassing Object::Pluggable gives your object the following public
  methods:
  
  =head2 C<pipeline>
  
  Returns the L<Object::Pluggable::Pipeline|Object::Pluggable::Pipeline>
  object.
  
  =head2 C<plugin_add>
  
  Accepts two arguments:
  
   The alias for the plugin
   The actual plugin object
   Any number of extra arguments
  
  The alias is there for the user to refer to it, as it is possible to have
  multiple plugins of the same kind active in one Object::Pluggable object.
  
  This method goes through the pipeline's C<push()> method, which will call
  C<< $plugin->plugin_register($pluggable, @args) >>.
  
  Returns the number of plugins now in the pipeline if plugin was initialized,
  C<undef>/an empty list if not.
  
  =head2 C<plugin_del>
  
  Accepts the following arguments:
  
   The alias for the plugin or the plugin object itself
   Any number of extra arguments
  
  This method goes through the pipeline's C<remove()> method, which will call
  C<< $plugin->plugin_unregister($pluggable, @args) >>.
  
  Returns the plugin object if the plugin was removed, C<undef>/an empty list
  if not.
  
  =head2 C<plugin_get>
  
  Accepts the following arguments:
  
   The alias for the plugin
  
  This method goes through the pipeline's C<get()> method.
  
  Returns the plugin object if it was found, C<undef>/an empty list if not.
  
  =head2 C<plugin_list>
  
  Takes no arguments.
  
  Returns a hashref of plugin objects, keyed on alias, or an empty list if
  there are no plugins loaded.
  
  =head2 C<plugin_order>
  
  Takes no arguments.
  
  Returns an arrayref of plugin objects, in the order which they are
  encountered in the pipeline.
  
  =head2 C<plugin_register>
  
  Accepts the following arguments:
  
   The plugin object
   The type of the hook (the hook types are specified with _pluggable_init()'s 'types')
   The event name[s] to watch
  
  The event names can be as many as possible, or an arrayref. They correspond
  to the prefixed events and naturally, arbitrary events too.
  
  You do not need to supply events with the prefix in front of them, just the
  names.
  
  It is possible to register for all events by specifying 'all' as an event.
  
  Returns 1 if everything checked out fine, C<undef>/an empty list if something
  is seriously wrong.
  
  =head2 C<plugin_unregister>
  
  Accepts the following arguments:
  
   The plugin object
   The type of the hook (the hook types are specified with _pluggable_init()'s 'types')
   The event name[s] to unwatch
  
  The event names can be as many as possible, or an arrayref. They correspond
  to the prefixed events and naturally, arbitrary events too.
  
  You do not need to supply events with the prefix in front of them, just the
  names.
  
  It is possible to register for all events by specifying 'all' as an event.
  
  Returns 1 if all the event name[s] was unregistered, undef if some was not
  found.
  
  =head1 PLUGINS
  
  The basic anatomy of a pluggable plugin is:
  
   # Import the constants, of course you could provide your own 
   # constants as long as they map correctly.
   use Object::Pluggable::Constants qw( :ALL );
  
   # Our constructor
   sub new {
       ...
   }
  
   # Required entry point for pluggable plugins
   sub plugin_register {
       my($self, $pluggable) = @_;
  
       # Register events we are interested in
       $pluggable->plugin_register($self, 'SERVER', qw(something whatever));
  
       # Return success
       return 1;
   }
  
   # Required exit point for pluggable
   sub plugin_unregister {
       my($self, $pluggable) = @_;
  
       # Pluggable will automatically unregister events for the plugin
  
       # Do some cleanup...
  
       # Return success
       return 1;
   }
  
   sub _default {
       my($self, $pluggable, $event) = splice @_, 0, 3;
  
       print "Default called for $event\n";
  
       # Return an exit code
       return PLUGIN_EAT_NONE;
   }
  
  As shown in the example above, a plugin's C<_default> subroutine (if present)
  is called if the plugin receives an event for which it has no handler.
  
  The special exit code CONSTANTS are documented in
  L<Object::Pluggable::Constants|Object::Pluggable::Constants>. You could
  provide your own as long as the values match up, though.
  
  =head1 TODO
  
  Better documentation >:]
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams <chris@bingosnet.co.uk>
  
  =head1 LICENSE
  
  Copyright C<(c)> Chris Williams, Apocalypse, Hinrik Örn Sigurðsson and Jeff Pinyan
  
  This module may be used, modified, and distributed under the same terms as
  Perl itself. Please see the license that came with your Perl distribution for
  details.
  
  =head1 KUDOS
  
  APOCAL for writing the original L<POE::Component::IRC|POE::Component::IRC>
  plugin system.
  
  japhy for writing L<POE::Component::IRC::Pipeline|POE::Component::IRC::Pipeline>
  which improved on it.
  
  All the happy chappies who have contributed to POE::Component::IRC over the 
  years (yes, it has been years) refining and tweaking the plugin system.
  
  The initial idea was heavily borrowed from X-Chat, BIG thanks go out to the
  genius that came up with the EAT_* system :)
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  L<Object::Pluggable::Pipeline|Object::Pluggable::Pipeline>
  
  Both L<POE::Component::Client::NNTP|POE::Component::Client::NNTP> and
  L<POE::Component::Server::NNTP|POE::Component::Server::NNTP> use this module
  as a base, examination of their source may yield further understanding.
  
  =cut
OBJECT_PLUGGABLE

$fatpacked{"Object/Pluggable/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OBJECT_PLUGGABLE_CONSTANTS';
  package Object::Pluggable::Constants;
  BEGIN {
    $Object::Pluggable::Constants::AUTHORITY = 'cpan:HINRIK';
  }
  BEGIN {
    $Object::Pluggable::Constants::VERSION = '1.29';
  }
  
  use strict;
  use warnings;
  
  require Exporter;
  use base qw(Exporter);
  our @EXPORT_OK = qw(
      PLUGIN_EAT_NONE PLUGIN_EAT_CLIENT PLUGIN_EAT_PLUGIN PLUGIN_EAT_ALL
  );
  our %EXPORT_TAGS = ( ALL => [@EXPORT_OK] );
  
  use constant {
      PLUGIN_EAT_NONE   => 1,
      PLUGIN_EAT_CLIENT => 2,
      PLUGIN_EAT_PLUGIN => 3,
      PLUGIN_EAT_ALL    => 4,
  };
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Object::Pluggable::Constants - Importable constants for Object::Pluggable
  
  =head1 SYNOPSIS
  
   use Object::Pluggable::Constants qw(:ALL);
  
  =head1 DESCRIPTION
  
  Object::Pluggable::Constants defines a number of constants that are
  required by the plugin system.
  
  =head1 EXPORTS
  
  =head2 C<PLUGIN_EAT_NONE>
  
  Value: 1
  
  This means the event will continue to be processed by remaining plugins and
  finally, sent to interested sessions that registered for it.
  
  =head2 C<PLUGIN_EAT_CLIENT>
  
  Value: 2
  
  This means the event will continue to be processed by remaining plugins but
  it will not be sent to any sessions that registered for it.
  
  =head2 C<PLUGIN_EAT_PLUGIN>
  
  Value: 3
  
  This means the event will not be processed by remaining plugins, it will go
  straight to interested sessions.
  
  =head2 C<PLUGIN_EAT_ALL>
  
  Value: 4
  
  This means the event will be completely discarded, no plugin or session will
  see it.
  
  =head1 MAINTAINER
  
  Chris 'BinGOs' Williams <chris@bingosnet.co.uk>
  
  =head1 SEE ALSO
  
  L<Object::Pluggable|Object::Pluggable>
  
  =cut
OBJECT_PLUGGABLE_CONSTANTS

$fatpacked{"Object/Pluggable/Pipeline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OBJECT_PLUGGABLE_PIPELINE';
  package Object::Pluggable::Pipeline;
  BEGIN {
    $Object::Pluggable::Pipeline::AUTHORITY = 'cpan:HINRIK';
  }
  BEGIN {
    $Object::Pluggable::Pipeline::VERSION = '1.29';
  }
  
  use strict;
  use warnings;
  use Carp;
  use Scalar::Util qw(weaken);
  
  sub new {
      my ($package, $pluggable) = @_;
  
      my $self = bless {
          PLUGS    => {},
          PIPELINE => [],
          HANDLES  => {},
          OBJECT   => $pluggable,
      }, $package;
  
      weaken($self->{OBJECT});
  
      return $self;
  }
  
  sub push {
      my ($self, $alias, $plug, @register_args) = @_;
  
      if ($self->{PLUGS}{$alias}) {
          $@ = "Plugin named '$alias' already exists ($self->{PLUGS}{$alias})";
          return;
      }
  
      my $return = $self->_register($alias, $plug, @register_args);
      return if !$return;
  
      push @{ $self->{PIPELINE} }, $plug;
      return scalar @{ $self->{PIPELINE} };
  }
  
  sub pop {
      my ($self, @unregister_args) = @_;
  
      return if !@{ $self->{PIPELINE} };
  
      my $plug = pop @{ $self->{PIPELINE} };
      my $alias = $self->{PLUGS}{$plug};
      $self->_unregister($alias, $plug, @unregister_args);
  
      return wantarray ? ($plug, $alias) : $plug;
  }
  
  sub unshift {
      my ($self, $alias, $plug, @register_args) = @_;
  
      if ($self->{PLUGS}{$alias}) {
          $@ = "Plugin named '$alias' already exists ($self->{PLUGS}{$alias}";
          return;
      }
  
      my $return = $self->_register($alias, $plug, @register_args);
      return if !$return;
  
      unshift @{ $self->{PIPELINE} }, $plug;
      return scalar @{ $self->{PIPELINE} };
  }
  
  sub shift {
      my ($self, @unregister_args) = @_;
  
      return if !@{ $self->{PIPELINE} };
  
      my $plug = shift @{ $self->{PIPELINE} };
      my $alias = $self->{PLUGS}{$plug};
      $self->_unregister($alias, $plug, @unregister_args);
  
      return wantarray ? ($plug, $alias) : $plug;
  }
  
  sub replace {
      my ($self, $old, $new_a, $new_p, $unregister_args, $register_args) = @_;
      
      my ($old_a, $old_p) = ref $old
          ? ($self->{PLUGS}{$old}, $old)
          : ($old, $self->{PLUGS}{$old})
      ;
  
      if (!$old_p) {
          $@ = "Plugin '$old_a' does not exist";
          return;
      }
  
      $self->_unregister(
          $old_a,
          $old_p,
          (ref $unregister_args eq 'ARRAY'
              ? @$unregister_args
              : ()
          )
      );
  
      if ($self->{PLUGS}{$new_a}) {
          $@ = "Plugin named '$new_a' already exists ($self->{PLUGS}{$new_a}";
          return;
      }
  
      my $return = $self->_register(
          $new_a,
          $new_p,
          (ref $register_args eq 'ARRAY'
              ? @$register_args
              : ()
          )
      );
      return if !$return;
  
      for my $plugin (@{ $self->{PIPELINE} }) {
          if ($plugin == $old_p) {
              $plugin = $new_p;
              last;
          }
      }
  
      return 1;
  }
  
  sub remove {
      my ($self, $old, @unregister_args) = @_;
      my ($old_a, $old_p) = ref $old
          ? ($self->{PLUGS}{$old}, $old)
          : ($old, $self->{PLUGS}{$old})
      ;
  
      if (!$old_p) {
          $@ = "Plugin '$old_a' does not exist";
          return;
      }
  
      my $i = 0;
      for my $plugin (@{ $self->{PIPELINE} }) {
          if ($plugin == $old_p) {
              splice(@{ $self->{PIPELINE} }, $i, 1);
              last;
          }
          $i++;
      }
  
      $self->_unregister($old_a, $old_p, @unregister_args);
  
      return wantarray ? ($old_p, $old_a) : $old_p;
  }
  
  sub get {
      my ($self, $old) = @_;
      
      my ($old_a, $old_p) = ref $old
          ? ($self->{PLUGS}{$old}, $old)
          : ($old, $self->{PLUGS}{$old})
      ;
  
  
      if (!$old_p) {
          $@ = "Plugin '$old_a' does not exist";
          return;
      }
  
      return wantarray ? ($old_p, $old_a) : $old_p;
  }
  
  sub get_index {
      my ($self, $old) = @_;
      
      my ($old_a, $old_p) = ref $old
          ? ($self->{PLUGS}{$old}, $old)
          : ($old, $self->{PLUGS}{$old})
      ;
  
      if (!$old_p) {
          $@ = "Plugin '$old_a' does not exist";
          return -1;
      }
  
      my $i = 0;
      for my $plugin (@{ $self->{PIPELINE} }) {
          return $i if $plugin == $old_p;
          $i++;
      }
  
      return -1;
  }
  
  sub insert_before {
      my ($self, $old, $new_a, $new_p, @register_args) = @_;
      
      my ($old_a, $old_p) = ref $old
          ? ($self->{PLUGS}{$old}, $old)
          : ($old, $self->{PLUGS}{$old})
      ;
  
      if (!$old_p) {
          $@ = "Plugin '$old_a' does not exist";
          return;
      }
  
      if ($self->{PLUGS}{$new_a}) {
          $@ = "Plugin named '$new_a' already exists ($self->{PLUGS}{$new_a}";
          return;
      }
  
      my $return = $self->_register($new_a, $new_p, @register_args);
      return if !$return;
  
      my $i = 0;
      for my $plugin (@{ $self->{PIPELINE} }) {
          if ($plugin == $old_p) {
              splice(@{ $self->{PIPELINE} }, $i, 0, $new_p);
              last;
          }
          $i++;
      }
  
      return 1;
  }
  
  sub insert_after {
      my ($self, $old, $new_a, $new_p, @register_args) = @_;
      my ($old_a, $old_p) = ref $old
          ? ($self->{PLUGS}{$old}, $old)
          : ($old, $self->{PLUGS}{$old})
      ;
  
      if (!$old_p) {
          $@ = "Plugin '$old_a' does not exist";
          return;
      }
  
      if ($self->{PLUGS}{$new_a}) {
          $@ = "Plugin named '$new_a' already exists ($self->{PLUGS}{$new_a}";
          return;
      }
  
      my $return = $self->_register($new_a, $new_p, @register_args);
      return if !$return;
  
      my $i = 0;
      for my $plugin (@{ $self->{PIPELINE} }) {
          if ($plugin == $old_p) {
              splice(@{ $self->{PIPELINE} }, $i+1, 0, $new_p);
              last;
          }
          $i++;
      }
  
      return 1;
  }
  
  sub bump_up {
      my ($self, $old, $diff) = @_;
      my $idx = $self->get_index($old);
  
      return -1 if $idx < 0;
  
      my $pipeline = $self->{PIPELINE};
      $diff ||= 1;
  
      my $pos = $idx - $diff;
  
      if ($pos < 0) {
          carp "$idx - $diff is negative, moving to head of the pipeline";
      }
  
      splice(@$pipeline, $pos, 0, splice(@$pipeline, $idx, 1));
      return $pos;
  }
  
  sub bump_down {
      my ($self, $old, $diff) = @_;
      my $idx = $self->get_index($old);
  
      return -1 if $idx < 0;
  
      my $pipeline = $self->{PIPELINE};
      $diff ||= 1;
  
      my $pos = $idx + $diff;
  
      if ($pos >= @$pipeline) {
          carp "$idx + $diff is too high, moving to back of the pipeline";
      }
  
      splice(@$pipeline, $pos, 0, splice(@$pipeline, $idx, 1));
      return $pos;
  }
  
  sub _register {
      my ($self, $alias, $plug, @register_args) = @_;
      return if !defined $self->{OBJECT};
  
      my $return;
      my $sub = "$self->{OBJECT}{_pluggable_reg_prefix}register";
      local $@;
      eval { $return = $plug->$sub($self->{OBJECT}, @register_args) };
  
      if ($@) {
          chomp $@;
          my $error = "$sub call on plugin '$alias' failed: $@";
          $self->_handle_error($error, $plug, $alias);
      }
      elsif (!$return) {
          my $error = "$sub call on plugin '$alias' did not return a true value";
          $self->_handle_error($error, $plug, $alias);
      }
  
      $self->{PLUGS}{$plug} = $alias;
      $self->{PLUGS}{$alias} = $plug;
      
      $self->{OBJECT}->_pluggable_event(
          "$self->{OBJECT}{_pluggable_prefix}plugin_add",
          $alias, $plug,
      );
  
      return $return;
  }
  
  sub _unregister {
      my ($self, $alias, $plug, @unregister_args) = @_;
      return if !defined $self->{OBJECT};
  
      my $return;
      my $sub = "$self->{OBJECT}{_pluggable_reg_prefix}unregister";
      local $@;
      eval { $return = $plug->$sub($self->{OBJECT}, @unregister_args) };
  
      if ($@) {
          chomp $@;
          my $error = "$sub call on plugin '$alias' failed: $@";
          $self->_handle_error($error, $plug, $alias);
      }
      elsif (!$return) {
          my $error = "$sub call on plugin '$alias' did not return a true value";
          $self->_handle_error($error, $plug, $alias);
      }
  
      delete $self->{PLUGS}{$plug};
      delete $self->{PLUGS}{$alias};
      delete $self->{HANDLES}{$plug};
  
      $self->{OBJECT}->_pluggable_event(
          "$self->{OBJECT}{_pluggable_prefix}plugin_del",
          $alias, $plug,
      );
  
      return $return;
  }
  
  sub _handle_error {
      my ($self, $error, $plugin, $alias) = @_;
  
      warn "$error\n" if $self->{OBJECT}{_pluggable_debug};
      $self->{OBJECT}->_pluggable_event(
          "$self->{OBJECT}{_pluggable_prefix}plugin_error",
          $error, $plugin, $alias,
      );
  
      return;
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Object::Pluggable::Pipeline - The plugin pipeline for Object::Pluggable.
  
  =head1 SYNOPSIS
  
    use Object::Pluggable;
    use Object::Pluggable::Pipeline;
    use My::Plugin;
  
    my $self = Object::Pluggable->new();
  
    # the following operations are presented in pairs
    # the first is the general procedure, the second is
    # the specific way using the pipeline directly
  
    # to install a plugin
    $self->plugin_add(mine => My::Plugin->new);
    $self->pipeline->push(mine => My::Plugin->new);  
  
    # to remove a plugin
    $self->plugin_del('mine');        # or the object
    $self->pipeline->remove('mine');  # or the object
  
    # to get a plugin
    my $plug = $self->plugin_get('mine');
    my $plug = $self->pipeline->get('mine');
  
    # there are other very specific operations that
    # the pipeline offers, demonstrated here:
  
    # to get the pipeline object itself
    my $pipe = $self->pipeline;
  
    # to install a plugin at the front of the pipeline
    $pipe->unshift(mine => My::Plugin->new);
  
    # to remove the plugin at the end of the pipeline
    my $plug = $pipe->pop;
  
    # to remove the plugin at the front of the pipeline
    my $plug = $pipe->shift;
  
    # to replace a plugin with another
    $pipe->replace(mine => newmine => My::Plugin->new);
  
    # to insert a plugin before another
    $pipe->insert_before(mine => newmine => My::Plugin->new);
  
    # to insert a plugin after another
    $pipe->insert_after(mine => newmine => My::Plugin->new);
  
    # to get the location in the pipeline of a plugin
    my $index = $pipe->get_index('mine');
  
    # to move a plugin closer to the front of the pipeline
    $pipe->bump_up('mine');
  
    # to move a plugin closer to the end of the pipeline
    $pipe->bump_down('mine');
  
  =head1 DESCRIPTION
  
  Object::Pluggable::Pipeline defines the Plugin pipeline system for
  L<Object::Pluggable|Object::Pluggable> instances.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Takes one argument, the Object::Pluggable object to attach to.
  
  =head2 C<push>
  
  Takes at least two arguments, an alias for a plugin and the plugin object
  itself. Any extra arguments will be passed to the register method of the
  plugin object. If a plugin with that alias already exists, C<$@> will be set
  and C<undef> will be returned. Otherwise, it adds the plugin to the end of
  the pipeline and registers it. This will yield a C<plugin_add> event. If
  successful, it returns the size of the pipeline.
  
   my $new_size = $pipe->push($name, $plug, @register_args);
  
  =head2 C<unshift>
  
  Takes at least two arguments, an alias for a plugin and the plugin object
  itself. Any extra arguments will be passed to the register method of the
  plugin object. If a plugin with that alias already exists, C<$@> will be set
  and C<undef> will be returned. Otherwise, it adds the plugin to the beginning
  of the pipeline and registers it. This will yield a C<plugin_add> event. If
  successful, it returns the size of the pipeline.
  
   my $new_size = $pipe->push($name, $plug, @register_args);
  
  =head2 C<shift>
  
  Takes any number of arguments. The first plugin in the pipeline is removed.
  Any arguments will be passed to the unregister method of the plugin object.
  This will yield a C<plugin_del> event. In list context, it returns the plugin
  and its alias; in scalar context, it returns only the plugin. If there were
  no elements, an empty list or C<undef> will be returned.
  
   my ($plug, $name) = $pipe->shift(@unregister_args);
   my $plug = $pipe->shift(@unregister_args);
  
  =head2 C<pop>
  
  Takes any number of arguments. The last plugin in the pipeline is removed.
  Any arguments will be passed to the unregister method of the plugin object.
  This will yield an C<plugin_del> event. In list context, it returns the
  plugin and its alias; in scalar context, it returns only the plugin. If
  there were no elements, an empty list or C<undef> will be returned.
  
   my ($plug, $name) = $pipe->pop(@unregister_args);
   my $plug = $pipe->pop(@unregister_args);
  
  =head2 C<replace>
  
  Takes at least three arguments, the old plugin or its alias, an alias for the
  new plugin and the new plugin object itself. You can optionally pass two
  array references of arguments which will be delivered to the unregister method
  of the old plugin and the register method of the new plugin, respectively.
  If you only want to pass the latter, you can put C<undef> in place of the
  former. If the old plugin doesn't exist, or if there is already a plugin with
  the new alias (besides the old plugin), C<$@> will be set and C<undef> will be
  returned. Otherwise, it removes the old plugin (yielding an C<plugin_del>
  event) and replaces it with the new plugin. This will yield an C<plugin_add>
  event. If successful, it returns 1.
  
   my $success = $pipe->replace($name, $new_name, $new_plug, \@unregister_args, \@register_args);
   my $success = $pipe->replace($plug, $new_name, $new_plug, \@unregister_args, \@register_args);
  
  =head2 C<insert_before>
  
  Takes at least three arguments, the plugin that is relative to the operation,
  an alias for the new plugin and the new plugin object itself. Any extra
  arguments will be passed to the register method of the new plugin object. If
  the first plugin doesn't exist, or if there is already a plugin with the new
  alias, C<$@> will be set and C<undef> will be returned. Otherwise, the new
  plugin is placed just prior to the other plugin in the pipeline. If
  successful, it returns 1.
  
   my $success = $pipe->insert_before($name, $new_name, $new_plug, @register_args);
   my $success = $pipe->insert_before($plug, $new_name, $new_plug, @register_args);
  
  =head2 C<insert_after>
  
  Takes at least three arguments, the plugin that is relative to the operation,
  an alias for the new plugin and the new plugin object itself. any extra
  arguments will be passed to the register method of the new plugin object. If
  the first plugin doesn't exist, or if there is already a plugin with the new
  alias, C<$@> will be set and C<undef> will be returned. Otherwise, the new
  plugin is placed just after to the other plugin in the pipeline. If
  successful, it returns 1.
  
   my $success = $pipe->insert_after($name, $new_name, $new_plug, @register_args);
   my $success = $pipe->insert_after($plug, $new_name, $new_plug, @register_args);
  
  =head2 C<bump_up>
  
  Takes one or two arguments, the plugin or its alias, and the distance to
  bump the plugin. The distance defaults to 1. If the plugin doesn't exist,
  C<$@> will be set and B<-1 will be returned, not undef>. Otherwise, the
  plugin will be moved the given distance closer to the front of the
  pipeline. A warning is issued alerting you if it would have been moved
  past the beginning of the pipeline, and the plugin is placed at the
  beginning. If successful, the new index of the plugin in the pipeline is
  returned.
  
   my $pos = $pipe->bump_up($name);
   my $pos = $pipe->bump_up($plug);
   my $pos = $pipe->bump_up($name, $delta);
   my $pos = $pipe->bump_up($plug, $delta);
  
  =head2 C<bump_down>
  
  Takes one or two arguments, the plugin or its alias, and the distance to
  bump the plugin. The distance defaults to 1. If the plugin doesn't exist,
  C<$@> will be set and B<-1 will be returned, not C<undef>>. Otherwise, the
  plugin will be moved the given distance closer to the end of the pipeline.
  A warning is issued alerting you if it would have been moved past the end
  of the pipeline, and the plugin is placed at the end. If successful, the new
  index of the plugin in the pipeline is returned.
  
   my $pos = $pipe->bump_down($name);
   my $pos = $pipe->bump_down($plug);
   my $pos = $pipe->bump_down($name, $delta);
   my $pos = $pipe->bump_down($plug, $delta);
  
  =head2 C<remove>
  
  Takes at least one argument, a plugin or its alias. Any arguments will be
  passed to the unregister method of the plugin object. If the plugin doesn't
  exist, C<$@> will be set and C<undef> will be returned. Otherwise, the plugin
  is removed from the pipeline. This will yield an C<plugin_del> event. In list
  context, it returns the plugin and its alias; in scalar context, it returns
  only the plugin.
  
   my ($plug, $name) = $pipe->remove($the_name, @unregister_args);
   my ($plug, $name) = $pipe->remove($the_plug, @unregister_args);
   my $plug = $pipe->remove($the_name, @unregister_args);
   my $plug = $pipe->remove($the_plug, @unregister_args);
  
  =head2 C<get>
  
  Takes one argument, a plugin or its alias. If no such plugin exists, C<$@>
  will be set and C<undef> will be returned. In list context, it returns the
  plugin and its alias; in scalar context, it returns only the plugin.
  
   my ($plug, $name) = $pipe->get($the_name);
   my ($plug, $name) = $pipe->get($the_plug);
   my $plug = $pipe->get($the_name);
   my $plug = $pipe->get($the_plug);
  
  =head2 C<get_index>
  
  Takes one argument, a plugin or its alias. If no such plugin exists, C<$@>
  will be set and B<-1 will be returned, not C<undef>>. Otherwise, the index
  in the pipeline is returned.
  
   my $pos = $pipe->get_index($name);
   my $pos = $pipe->get_index($plug);
  
  =head1 BUGS
  
  None known so far.
  
  =head1 AUTHOR
  
  Jeff C<japhy> Pinyan, F<japhy@perlmonk.org>.
  
  =head1 MAINTAINER
  
  Chris C<BinGOs> Williams, F<chris@bingosnet.co.uk>.
  
  =head1 SEE ALSO
  
  L<Object::Pluggable|Object::Pluggable>.
  
  L<POE::Component::IRC|POE::Component::IRC>, 
  
  =cut
OBJECT_PLUGGABLE_PIPELINE

$fatpacked{"POE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE';
  # Copyrights and documentation are after __END__.
  
  package POE;
  
  use strict;
  use Carp qw( croak );
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use POE::Resource::Clock qw( monotime time walltime sleep mono2wall wall2mono );
  
  sub import {
    my $self = shift;
  
    my @loops    = grep(/^(?:XS::)?Loop::/, @_);
    my @sessions = grep(/^(Session|NFA)$/, @_);
    my @modules  = grep(!/^(Kernel|Session|NFA|(?:XS::)?Loop::[\w:]+)$/, @_);
  
    croak "can't use multiple event loops at once"
      if (@loops > 1);
    croak "POE::Session and POE::NFA export conflicting constants"
      if scalar @sessions > 1;
  
    # If a session was specified, use that.  Otherwise use Session.
    if (@sessions) {
      unshift @modules, @sessions;
    }
    else {
      unshift @modules, 'Session';
    }
  
    my $package = caller();
    my @failed;
  
    # Load POE::Kernel in the caller's package.  This is separate
    # because we need to push POE::Loop classes through POE::Kernel's
    # import().
  
    {
      my $loop = "";
      if (@loops) {
        $loop = "{ loop => '" . shift (@loops) . "' }";
      }
      my $code = "package $package; use POE::Kernel $loop;";
      # warn $code;
      eval $code;
      if ($@) {
        warn $@;
        push @failed, "Kernel"
      }
    }
  
    # Load all the others.
  
    foreach my $module (@modules) {
      my $code = "package $package; use POE::$module;";
      # warn $code;
      eval($code);
      if ($@) {
        warn $@;
        push(@failed, $module);
      }
    }
  
    @failed and croak "could not import qw(" . join(' ', @failed) . ")";
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE - portable multitasking and networking framework for any event loop
  
  =head1 SYNOPSIS
  
    #!/usr/bin/perl -w
    use strict;
  
    use POE;  # Auto-includes POE::Kernel and POE::Session.
  
    sub handler_start {
      my ($kernel, $heap, $session) = @_[KERNEL, HEAP, SESSION];
      print "Session ", $session->ID, " has started.\n";
      $heap->{count} = 0;
      $kernel->yield('increment');
    }
  
    sub handler_increment {
      my ($kernel, $heap, $session) = @_[KERNEL, HEAP, SESSION];
      print "Session ", $session->ID, " counted to ", ++$heap->{count}, ".\n";
      $kernel->yield('increment') if $heap->{count} < 10;
    }
  
    sub handler_stop {
      print "Session ", $_[SESSION]->ID, " has stopped.\n";
    }
  
    for (1..10) {
      POE::Session->create(
        inline_states => {
          _start    => \&handler_start,
          increment => \&handler_increment,
          _stop     => \&handler_stop,
        }
      );
    }
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE is a framework for cooperative, event driven multitasking and
  networking in Perl.  Other languages have similar frameworks.  Python
  has Twisted.  TCL has "the event loop".
  
  POE provides a unified interface for several other event loops,
  including select(), L<IO::Poll|IO::Poll>, L<Glib>, L<Gtk>, L<Tk>,
  L<Wx>, and L<Gtk2>.  Many of these event loop interfaces were written
  by others, with the help of POE::Test::Loops.  They may be found on
  the CPAN.
  
  POE achieves its high degree of portability to different operating
  systems and Perl versions by being written entirely in Perl.  CPAN
  hosts optional XS modules for POE if speed is more desirable than
  portability.
  
  POE is designed in layers.  Each layer builds atop the lower level
  ones.  Programs are free to use POE at any level of abstraction, and
  different levels can be mixed and matched seamlessly within a single
  program.  Remember, though, that higher-level abstractions often
  require more resources than lower-level ones.  The conveniences they
  provide are not free.
  
  POE's bundled abstraction layers are the tip of a growing iceberg.
  L<Sprocket>, L<POE::Stage|POE::Stage>, and other CPAN distributions
  build upon this work.  You're encouraged to look around.
  
  No matter how high you go, though, it all boils down to calls to
  L<POE::Kernel|POE::Kernel>.  So your down-to-earth code can easily
  cooperate with stratospheric systems.
  
  =head2 Layer 1: Kernel and Sessions
  
  The lowest public layer is comprised of L<POE::Kernel|POE::Kernel>,
  L<POE::Session|POE::Session>, and other session types.
  
  L<POE::Kernel|POE::Kernel> does most of the heavy lifting.  It provides a portable
  interface for filehandle activity detection, multiple alarms and other
  timers, signal handling, and other less-common features.
  
  L<POE::Session|POE::Session> and derived classes encapsulate the notion of an event
  driven task.  They also customize event dispatch to a particular
  calling convention.  L<POE::NFA|POE::NFA>, for example, is more of a proper state
  machine.  The CPAN has several other kinds of sessions.
  
  Everything ultimately builds on these classes or the concepts they
  implement.  If you're short on time, the things to read besides this
  are L<POE::Kernel|POE::Kernel> and L<POE::Session|POE::Session>.
  
  =head2 Layer 2: Wheels, Filters, and Drivers
  
  POE::Wheel objects are dynamic mix-ins for POE::Session instances. These
  "wheels" perform very common, generic tasks in a highly reusable and
  customizable way.  L<POE::Wheel::ReadWrite|POE::Wheel::ReadWrite>, for
  example, implements non-blocking buffered I/O.  Nearly everybody needs this,
  so why require people to reinvent it all the time?
  
  L<POE::Filter|POE::Filter> objects customize wheels in a modular way.  Filters act as
  I/O layers, turning raw streams into structured data, and serializing
  structures into something suitable for streams.  The CPAN also has several
  of these.
  
  Drivers are where the wheels meet the road.  In this case, the road is
  some type of file handle.  Drivers do the actual reading and writing
  in a standard way so wheels don't need to know the difference between
  send() and syswrite().
  
  L<POE::Driver|POE::Driver> objects get relatively short shrift because very few are
  needed.  The most common driver, L<POE::Driver::SysRW|POE::Driver::SysRW> is ubiquitous and
  also the default, so most people will never need to specify one.
  
  =head2 Layer 3: Components
  
  L<POE::Component|POE::Component> classes are essentially Perl classes that use POE to
  perform tasks in a non-blocking or cooperative way.  This is a very
  broad definition, and POE components are all over the abstraction map.
  
  Many components, such as L<POE::Component::Server::SMTP|POE::Component::Server::SMTP>, encapsulate the
  generic details of an entire application.  Others perform rather
  narrow tasks, such as L<POE::Component::DirWatch::Object|POE::Component::DirWatch::Object>.
  
  POE components are often just plain Perl objects.  The previously
  mentioned L<POE::Component::DirWatch::Object|POE::Component::DirWatch::Object> uses L<Moose|Moose>.  Other object
  and meta-object frameworks are compatible.
  
  Also of interest is L<POE::Component::Generic|POE::Component::Generic>, which allows you to create
  a POE component from nearly any blocking module.
  
  There are quite a lot of components on the CPAN.  
  L<http://search.cpan.org/search?query=poe+component&mode=all>
  
  =head2 Layer 4 and Beyond: Frameworks and Object Metaphors
  
  It's possible to abstract POE entirely behind a different framework.
  In fact we encourage people to write domain-specific abstractions that
  entirely hide POE if necessary.  The nice thing here is that even at
  these high levels of abstraction, things will continue to interoperate
  all the way down to layer 1.
  
  Two examples of ultra-high level abstraction are L<Sprocket>, a networking
  framework that does its own thing, and L<POE::Stage|POE::Stage>, which is POE's
  creator's attempt to formalize and standardize POE components.
  
  It is also possible to communicate between POE processes.  This is called
  IKC, for I<Inter-Kernel Communication>.  There are a few IKC components on
  the CPAN (L<http://search.cpan.org/search?query=IKC&mode=all>), notably
  L<POE::Component::IKC|POE::Component::IKC> and L<POE::TIKC|POE::TIKC>.
  
  =head2 Layer 0: POE's Internals
  
  POE's layered architecture continues below the surface.  POE's guts
  are broken into specific L<POE::Loop|POE::Loop> classes for each event
  loop it supports.  Internals are divided up by type, giving
  L<POE::Resource|POE::Resource> classes for Aliases, Controls, Events,
  Extrefs, FileHandles, SIDs, Sessions and Signals.
  
  POE::Kernel's APIs are extensible through POE::API mix-in classes.
  Some brave souls have even published new APIs on CPAN, such as
  L<POE::API::Peek|POE::API::Peek> (which gives you access to some of the internal
  L<POE::Resource|POE::Resource> methods).
  
  By design, it's possible to implement new L<POE::Kernel|POE::Kernel> guts by creating
  another L<POE::Resource|POE::Resource> class.  One can then expose the functionality with
  a new POE::API mix-in.
  
  =head1 DOCUMENTATION ROADMAP
  
  You're reading the main POE documentation.  It's the general entry
  point to the world of POE.  You already know this, however, so let's
  talk about something more interesting.
  
  =head2 Basic Features
  
  POE's basic features are documented mainly in L<POE::Kernel|POE::Kernel> and
  L<POE::Session|POE::Session>.  Methods are documented in the classes that implement
  them.  Broader concepts are covered in the most appropriate class, and
  sometimes they are divided among classes that share in their
  implementation.
  
  =head2 Basic Usage
  
  Basic usage, even for POE.pm, is documented in L<POE::Kernel|POE::Kernel>.  That's
  where most of POE's work is done, and POE.pm is little more than a
  class loader.
  
  =head2 @_[KERNEL, HEAP, etc.]
  
  Event handler calling conventions, that weird C<@_[KERNEL, HEAP]>
  stuff, is documented in L<POE::Session|POE::Session>.  That's because POE::Session
  implements the calling convention, and other session types often do it
  differently.
  
  =head2 Base Classes Document Common Features
  
  The L<POE::Wheel|POE::Wheel>, L<POE::Driver|POE::Driver>,
  L<POE::Filter|POE::Filter>, and L<POE::Component|POE::Component> base
  classes describe what's common among each class.  It's a good idea to at
  least skim the base class documentation since the subclasses tend not to
  rehash the common things.
  
  L<POE::Queue|POE::Queue>, L<POE::Resource|POE::Resource>, and L<POE::Loop|POE::Loop> document the
  concepts and sometimes the standard interfaces behind multiple
  subclasses.  You're encouraged to have a look.
  
  =head2 Helper Classes
  
  POE includes some helper classes for portability.  L<POE::Pipe|POE::Pipe>, and its
  subclasses L<POE::Pipe::OneWay|POE::Pipe::OneWay> and L<POE::Pipe::TwoWay|POE::Pipe::TwoWay> are portable pipes.
  
  =head2 Event Loop Bridges
  
  L<POE::Loop|POE::Loop> documents and specifies the interface for all of POE's event
  loop bridges.  The individual classes may document specific details,
  but generally they adhere to the spec strongly enough that they don't
  need to.
  
  Many of the existing L<POE::Loop|POE::Loop> bridges provided in POE's base
  distribution will move out to separate distributions shortly.  The
  documentation will probably remain the same, however.
  
  =head2 POE::Queue and POE::Queue::Array
  
  POE's event queue is basically a priority heap implemented as an
  ordered array.  L<POE::Queue|POE::Queue> documents the standard interface for POE
  event queues, and L<POE::Queue::Array|POE::Queue::Array> implements the ordered array
  queue.  Tony Cook has released L<POE::XS::Queue::Array|POE::XS::Queue::Array>, which is a
  drop-in C replacement for L<POE::Queue::Array|POE::Queue::Array>.  You might give it a try
  if you need more performance.  POE's event queue is some of the
  hottest code in the system.
  
  =head2 This Section Isn't Complete
  
  Help organize the documentation.  Obviously we can't think of
  everything.  We're well aware of this and welcome audience
  participation.
  
  =head2 See SEE ALSO
  
  Wherever possible, the SEE ALSO section will cross-reference one
  module to related ones.
  
  =head2 Don't Forget the Web
  
  Finally, there are many POE resources on the web.  The CPAN contains a
  growing number of POE modules.  L<http://poe.perl.org/> hosts POE's
  wiki, which includes tutorials, an extensive set of examples,
  documentation, and more.  Plus it's a wiki, so you can trivially pitch
  in your two cents.
  
  =head1 SYSTEM REQUIREMENTS
  
  POE's basic requirements are rather light.  Most are included with
  modern versions of Perl, and the rest (if any) should be generally
  portable by now.
  
  L<Time::HiRes|Time::HiRes> is highly recommended, even for older Perls that don't
  include it.  POE will work without it, but alarms and other features will be
  much more accurate if it's included. L<POE::Kernel|POE::Kernel> will use Time::HiRes
  automatically if it's available.
  
  L<POE::Filter::Reference|POE::Filter::Reference> needs a module to serialize data for transporting
  it across a network.  It will use L<Storable|Storable>, L<FreezeThaw|FreezeThaw>, L<YAML|YAML>, or
  some other package with freeze() and thaw() methods.  It can also use
  L<Compress::Zlib|Compress::Zlib> to conserve bandwidth and reduce latency over slow links, but
  it's not required.
  
  If you want to write web servers, you'll need to install libwww-perl, which
  requires libnet.  This is a small world of modules that includes
  L<HTTP::Status|HTTP::Status>, L<HTTP::Request|HTTP::Request>,
  L<HTTP::Date|HTTP::Date>, and L<HTTP::Response|HTTP::Response>.  They are
  generally good to have, and modern versions of Perl even include them.
  
  Programs that use L<POE::Wheel::Curses|POE::Wheel::Curses> will of course
  require the L<Curses> module, which in turn requires some sort of
  curses library.
  
  If you're using POE with Tk, you'll need L<Tk> installed.
  
  And other obvious things.  Let us know if we've overlooked a
  non-obvious detail.
  
  =head1 COMPATIBILITY ISSUES
  
  One of POE's design goals is to be as portable as possible.  That's
  why it's written in "Plain Perl".  XS versions of POE modules are
  available as third-party distributions.  Parts of POE that require
  nonstandard libraries are optional, and not having those libraries
  should not prevent POE from installing.
  
  Despite Chris Williams' efforts, we can't test POE everywhere.  Please
  see the GETTING HELP section if you run into a problem.
  
  POE is expected to work on most forms of UNIX, including FreeBSD,
  MacOS X, Linux, Solaris.  Maybe even AIX and QNX, but we're not sure.
  
  POE is also tested on Windows XP, using the latest version of
  ActiveState, Strawberry and Cygwin Perl.  POE is fully supported with
  Strawberry Perl, as it's included in the Strawberry distribution.
  
  OS/2 and MacOS 9 have been reported to work in the past, but nobody
  seems to be testing there anymore.  Reports and patches are still
  welcome.
  
  Past versions of POE have been tested with Perl versions as far back
  as 5.6.2 and as recent as "blead", today's development build.  We
  can no longer guarantee each release will work everywhere, but we will
  be happy to work with you if you need special support for a really old
  system. You can always use older POE releases that works on your version,
  please check L<BackPAN|http://backpan.perl.org/authors/id/R/RC/RCAPUTO/>.
  
  POE's quality is due in large part to the fine work of Chris Williams
  and the other CPAN testers.  They have dedicated resources towards
  ensuring CPAN distributions pass their own tests, and we watch their
  reports religiously.  You can, too.  The latest POE test reports can
  be found at L<http://cpantesters.org/distro/P/POE.html>.
  
  Thanks also go out to Benjamin Smith and the 2006 Google Summer of
  Code.  Ben was awarded a grant to improve POE's test suite, which he
  did admirably.
  
  =head2 Windows Issues
  
  POE seems to work very nicely with Perl compiled for Cygwin.  If you
  must use ActiveState Perl, please use the absolute latest version.
  ActiveState Perl's compatibility fluctuates from one build to another,
  so we tend not to support older releases.
  
  Windows and ActiveState Perl are considered an esoteric platform due
  to the complex interactions between various versions.  POE therefore
  relies on user feedback and support here.
  
  A number of people have helped bring POE's Windows support this far,
  through contributions of time, patches, and other resources.  Some of
  them are: Sean Puckett, Douglas Couch, Andrew Chen, Uhlarik Ondoej,
  Nick Williams, and Chris Williams (no relation).
  
  =head2 Linux/Unix Issues
  
  =head3 pty woes
  
  Some distributions chose to not completely setup the pseudo-tty
  support. This is needed for L<POE::Wheel::Run> to interact with the
  subprocess. If you see something like this while running C<make test>
  please look at your distribution's documentation on how to fix it. For
  example, on Debian-based systems the solution was to execute 
  "sudo apt-get install udev".
  
    t/30_loops/io_poll/wheel_run.t ..................... 1/99
    pty_allocate(nonfatal): posix_openpt(): No such file or directory at /usr/local/lib/perl/5.10.0/IO/Pty.pm line 24.
    ...
    Cannot open a pty at /home/apoc/poe/blib/lib/POE/Wheel/Run.pm line 251
    Compilation failed in require at t/30_loops/io_poll/wheel_run.t line 24.
    # Looks like you planned 99 tests but ran 5.
    # Looks like your test exited with 22 just after 5.
    t/30_loops/io_poll/wheel_run.t ..................... Dubious, test returned 22 (wstat 5632, 0x1600)
  
  =head2 Other Compatibility Issues
  
  None currently known.  See GETTING HELP below if you've run into
  something.
  
  =head1 GETTING HELP
  
  POE's developers take pride in its quality.  If you encounter a
  problem, please let us know.
  
  =head2 POE's Request Tracker
  
  You're welcome to e-mail questions and bug reports to
  <bug-POE@rt.cpan.org>.  This is not a realtime support channel,
  though.  If you need a more immediate response, try one of the methods
  below.
  
  =head2 POE's Mailing List
  
  POE has a dedicated mailing list where developers and users discuss
  the software and its use.  You're welcome to join us.  Send an e-mail
  to <poe-help@perl.org> for subscription instructions.  The subject and
  message body are ignored.
  
  =head2 POE's Web Site
  
  <http://poe.perl.org> contains recent information, tutorials, and
  examples.  It's also a wiki, so people are invited to share tips and
  code snippets there as well.
  
  =head2 POE's Source Code
  
  The following command will fetch the most current version of POE into
  the "poe" subdirectory:
  
    svn co https://poe.svn.sourceforge.net/svnroot/poe poe
  
  =head2 SourceForge
  
  http://sourceforge.net/projects/poe/ is POE's project page.
  
  =head2 Internet Relay Chat (IRC)
  
  irc.perl.org channel #poe is an informal place to waste some time and
  maybe even discuss Perl and POE.  Consider an SSH relay if your
  workplace frowns on IRC.  But only if they won't fire you if you're
  caught.
  
  =head2 Personal Support
  
  Unfortunately we don't have resources to provide free one-on-one
  personal support anymore.  We'll do it for a fee, though.  Send Rocco
  an e-mail via his CPAN address.
  
  =head1 SEE ALSO
  
  Broken down by abstraction layer.
  
  =head2 Layer 1
  
  L<POE::Kernel>, L<POE::Session>, L<POE::NFA>
  
  =head2 Layer 2
  
  L<POE::Wheel>, L<POE::Wheel::Curses>, L<POE::Wheel::FollowTail>,
  L<POE::Wheel::ListenAccept>, L<POE::Wheel::ReadLine>, L<POE::Wheel::ReadWrite>,
  L<POE::Wheel::Run>, L<POE::Wheel::SocketFactory>
  
  L<POE::Driver>, L<POE::Driver::SysRW>
  
  L<POE::Filter>, L<POE::Filter::Block>, L<POE::Filter::Grep>,
  L<POE::Filter::HTTPD>, L<POE::Filter::Line>, L<POE::Filter::Map>,
  L<POE::Filter::RecordBlock>, L<POE::Filter::Reference>,
  L<POE::Filter::Stackable>, L<POE::Filter::Stream>
  
  =head2 Layer 3
  
  L<POE::Component>, L<POE::Component::Client::TCP>,
  L<POE::Component::Server::TCP>
  
  =head2 Layer 0
  
  L<POE::Loop>, L<POE::Loop::Event>, L<POE::Loop::Gtk>, L<POE::Loop::IO_Poll>,
  L<POE::Loop::Select>, L<POE::Loop::Tk>
  
  L<POE::Queue>, L<POE::Queue::Array>
  
  L<POE::Resource>, L<POE::Resource::Aliases>, L<POE::Resource::Events>,
  L<POE::Resource::Extrefs>, L<POE::Resource::FileHandles>,
  L<POE::Resource::SIDs>, L<POE::Resource::Sessions>, L<POE::Resource::Signals>
  
  =head2 Helpers
  
  L<POE::Pipe>, L<POE::Pipe::OneWay>, L<POE::Pipe::TwoWay>
  
  =head2 Home Page
  
  http://poe.perl.org/
  
  =head2 Bug Tracker
  
  https://rt.cpan.org/Dist/Display.html?Status=Active&Queue=POE
  
  =head2 Repositories and Changes
  
  Thanks to the magic of distributed version control, POE is hosted at
  three locations for redundancy.  You can browse the source at any one
  of:
  
  https://github.com/rcaputo/poe
  
  https://gitorious.org/poe
  
  http://poe.git.sourceforge.net/git/gitweb-index.cgi
  
  Complete change logs can also be browsed at those sites.  They all
  provide RSS news feeds for those who want to follow development in
  near-realtime.
  
  =head2 Other Resources
  
  https://metacpan.org/module/POE
  
  http://search.cpan.org/dist/POE
  
  =head1 AUTHORS & COPYRIGHT
  
  POE is the combined effort of quite a lot of people.  This is an
  incomplete list of some early contributors.  A more complete list can
  be found in POE's change log.
  
  =over 2
  
  =item Ann Barcomb
  
  Ann Barcomb is <kudra@domaintje.com>, aka C<kudra>.  Ann contributed
  large portions of POE::Simple and the code that became the ReadWrite
  support in POE::Component::Server::TCP.  Her ideas also inspired
  Client::TCP component, introduced in version 0.1702.
  
  =item Artur Bergman
  
  Artur Bergman is <sky@cpan.org>.  He contributed many hours' work into
  POE and quite a lot of ideas.  Years later, I decide he's right and
  actually implement them.
  
  Artur is the author of Filter::HTTPD and Filter::Reference, as well as
  bits and pieces throughout POE.  His feedback, testing, design and
  inspiration have been instrumental in making POE what it is today.
  
  Artur is investing his time heavily into perl 5's iThreads and PONIE
  at the moment.  This project has far-reaching implications for POE's
  future.
  
  =item Jos Boumans
  
  Jos Boumans is <kane@cpan.org>, aka C<kane>.  Jos is a major driving
  force behind the POE::Simple movement and has helped inspire the
  POE::Components for TCP clients and servers.
  
  =item Matt Cashner
  
  Matt Cashner is <sungo@pobox.com>, aka C<sungo>.  Matt is one of POE's
  core developers.  He's spearheaded the movement to simplify POE for
  new users, flattening the learning curve and making the system more
  accessible to everyone.  He uses the system in mission critical
  applications, folding feedback and features back into the distribution
  for everyone's enjoyment.
  
  =item Andrew Chen
  
  Andrew Chen is <achen-poe@micropixel.com>.  Andrew is the resident
  POE/Windows guru.  He contributes much needed testing for Solaris on
  the SPARC and Windows on various Intel platforms.
  
  =item Douglas Couch
  
  Douglas Couch is <dscouch@purdue.edu>.  Douglas helped port and
  maintain POE for Windows early on.
  
  =item Jeffrey Goff
  
  Jeffrey Goff is <jgoff@blackboard.com>.  Jeffrey is the author of
  several POE modules, including a tokenizing filter and a component for
  managing user information, PoCo::UserBase.  He's also co-author of "A
  Beginner's Introduction to POE" at www.perl.com.
  
  =item Philip Gwyn
  
  Philip Gwyn is <gwynp@artware.qc.ca>.  He extended the Wheels I/O
  abstraction to support hot-swappable filters, and he eventually
  convinced Rocco that unique session and kernel IDs were a good thing.
  
  Philip also enhanced L<POE::Filter::Reference|POE::Filter::Reference> to
  support different serialization methods.  He has also improved POE's quality
  by finding and fixing several bugs.  He provided POE a much needed code
  review around version 0.06.
  
  Lately, Philip tracked down the race condition in signal handling and
  fixed it with the signal pipe.
  
  =item Arnar M. Hrafnkelsson
  
  Arnar is <addi@umich.edu>.  Addi tested POE and L<POE::Component::IRC|POE::Component::IRC> on
  Windows, finding bugs and testing fixes.  He appears throughout the Changes
  file.  He has also written "cpoe", which is a POE-like library for C.
  
  =item Dave Paris
  
  Dave Paris is <dparis@w3works.com>.  Dave tested and benchmarked POE
  around version 0.05, discovering some subtle (and not so subtle)
  timing problems.  The pre-forking server sample was his idea.
  Versions 0.06 and later scaled to higher loads because of his work.
  He has contributed a lot of testing and feedback, much of which is
  tagged in the Changes file as a-mused.  The man is scarily good at
  testing and troubleshooting.
  
  =item Dieter Pearcey
  
  Dieter Pearcey is <dieter@bullfrog.perlhacker.org>.  He goes by several
  Japanese nicknames.  Dieter's current area of expertise is in Wheels and
  Filters.  He greatly improved L<POE::Wheel::FollowTail|POE::Wheel::FollowTail>, and his Filter
  contributions include the basic Block filter, as well as Stackable,
  RecordBlock, Grep and Map.
  
  =item Plixer International
  
  Plixer International is at L<http://plixer.com/>.  Their sponsorship
  has helped POE 1.300 and beyond be significantly more robust using
  iThreads, especially when using fork() in Windows.
  
  =item Robert Seifer
  
  Robert Seifer is <e-mail unknown>.  He rotates IRC nicknames
  regularly.
  
  Robert contributed entirely too much time, both his own and his
  computers, towards the detection and eradication of a memory
  corruption bug that POE tickled in earlier Perl versions.  In the end,
  his work produced a simple compile-time hack that worked around a
  problem relating to anonymous subs, scope and @{} processing.
  
  =item Matt Sergeant
  
  Matt contributed C<POE::Kernel::Poll>, a more efficient way to watch
  multiple files than select().  It's since been moved to
  L<POE::Loop::IO_Poll|POE::Loop::IO_Poll>.
  
  =item Richard Soderberg
  
  Richard Soderberg is <poe@crystalflame.net>, aka C<coral>.  Richard is
  a collaborator on several side projects involving POE.  His work
  provides valuable testing and feedback from a user's point of view.
  
  =item Dennis Taylor
  
  Dennis Taylor is <dennis@funkplanet.com>.  Dennis has been testing,
  debugging and patching bits here and there, such as Filter::Line which
  he improved by leaps in 0.1102.  He's also the author of
  L<POE::Component::IRC|POE::Component::IRC>, the widely popular POE-based successor to his
  wildly popular L<Net::IRC|Net::IRC> library.
  
  =item David Davis
  
  David Davis, aka Xantus is <xantus@cpan.org>.  David contributed patches
  to the HTTPD filter, and added CALLER_STATE to L<POE::Session|POE::Session>.  He is the
  author of L<Sprocket>, a networking framework built on POE.
  
  =item Others?
  
  Please contact the author if you've been forgotten and would like to
  be included here.
  
  =for comment
  TODO - This section has fallen into disrepair.  A POE historian needs
  to cull the CHANGES for the names of major contributors.
  
  =back
  
  =head2 Author
  
  =over 2
  
  =item Rocco Caputo
  
  Rocco Caputo is <rcaputo@cpan.org>.  POE is his brainchild.  He wishes
  to thank you for your interest, and he has more thanks than he can
  count for all the people who have contributed.  POE would not be
  nearly as cool without you.
  
  Except where otherwise noted, POE is Copyright 1998-2013 Rocco Caputo.
  All rights reserved.  POE is free software; you may redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =back
  
  Thank you for reading!
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE

$fatpacked{"POE/Component.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT';
  # Copyrights and documentation are after __END__.
  
  package POE::Component;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Component - event driven objects or subsystems
  
  =head1 SYNOPSIS
  
  See specific components.
  
  =head1 DESCRIPTION
  
  POE "components" are event-driven modules that generally encapsulate
  mid- to high-level program features.  For example,
  POE::Component::Client::DNS performs message-based asynchronous
  resolver lookups.  POE::Component::Server::TCP is a basic asynchronous
  network server.
  
  The POE::Component namespace was started as place for contributors to
  publish their POE-based modules without requiring coordination with
  the main POE distribution.  The namespace predates the -X convention,
  otherwise you'd be reading about POEx instead.
  
  As with many things in Perl, there is more than one way to implement
  component interfaces.  Newer components sport OO interfaces, and some
  even use Moose, but older ones are solely message driven.
  
  =head1 OBJECT ORIENTED COMPONENTS
  
  One way to create object-oriented components is to embed a
  POE::Session instance within an object.  This is done by creating the
  session during the object's constructor, setting the session's alias
  to something unique, and saving a copy of the alias in the object.
  
    package Asynchrotron;
  
    my $alias_index = 0;
  
    sub new {
      my $class = shift;
      my $self = bless {
        alias => __PACKAGE__ . " " . ++$alias_index;
      }, $class;
  
      POE::Session->create(
        object_states => [
          $self => {
            _start       => "_poe_start",
            do_something => "_poe_do_something",
          },
        ],
      );
      return $self;
    }
  
    sub _poe_start {
      $_[KERNEL]->alias_set($_[OBJECT]->{alias});
    }
  
  The alias allows object methods to pass events into the session
  without having to store something about the session.  The POE::Kernel
  call() transfers execution from the caller session's context into the
  component's session.
  
    sub do_something {
      my $self = shift;
      print "Inside the caller's session right now: @_\n";
      $poe_kernel->call($self->{alias}, "do_something", @_);
    }
  
    sub _poe_do_something {
      my @args = @_[ARG0..$#_];
      print "Inside the component's session now: @args\n";
      $_[OBJECT]{count}++;
    }
  
  Both $_[HEAP] and $_[OBJECT] are visible within the component's
  session.  $_[HEAP] can be used for ultra-private encapsulation, while
  $_[OBJECT] may be used for data visible by accessors.
  
    sub get_count {
      my $self = shift;
      return $self->{count}; # $_[OBJECT]{count} above
    }
  
  Too many sessions may bog down object creation and destruction, so
  avoid creating them for every object.
  
  =head1 SEE ALSO
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  L<POE::Stage> is a nascent project to formalize POE components, make
  POE::Kernel more object-oriented, and provide syntactic and semantic
  sugar for many common aspects of POE::Component development.  It's
  also easier to type.  Please investigate the project.  Ideas and I<tuits>
  are badly needed to help get the project off the ground.
  
  =head1 TO DO
  
  Document the customary (but not mandatory!) process of creating and
  publishing a component.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Each component is written and copyrighted separately.
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_COMPONENT

$fatpacked{"POE/Component/Client/TCP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_CLIENT_TCP';
  package POE::Component::Client::TCP;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw(carp croak);
  use Errno qw(ETIMEDOUT ECONNRESET);
  
  # Explicit use to import the parameter constants;
  use POE::Session;
  use POE::Driver::SysRW;
  use POE::Filter::Line;
  use POE::Wheel::ReadWrite;
  use POE::Wheel::SocketFactory;
  
  # Create the client.  This is just a handy way to encapsulate
  # POE::Session->create().  Because the states are so small, it uses
  # real inline coderefs.
  
  sub new {
    my $type = shift;
  
    # Helper so we don't have to type it all day.  $mi is a name I call
    # myself.
    my $mi = $type . '->new()';
  
    # If they give us lemons, tell them to make their own damn
    # lemonade.
    croak "$mi requires an even number of parameters" if (@_ & 1);
    my %param = @_;
  
    # Validate what we're given.
    croak "$mi needs a RemoteAddress parameter"
      unless exists $param{RemoteAddress};
    croak "$mi needs a RemotePort parameter"
      unless exists $param{RemotePort};
  
    # Extract parameters.
    my $alias           = delete $param{Alias};
    my $address         = delete $param{RemoteAddress};
    my $port            = delete $param{RemotePort};
    my $domain          = delete $param{Domain};
    my $bind_address    = delete $param{BindAddress};
    my $bind_port       = delete $param{BindPort};
    my $ctimeout        = delete $param{ConnectTimeout};
    my $args            = delete $param{Args};
    my $session_type    = delete $param{SessionType};
    my $session_params  = delete $param{SessionParams};
  
    $args = [] unless defined $args;
    croak "Args must be an array reference" unless ref($args) eq "ARRAY";
  
    foreach (
      qw(
        PreConnect Connected ConnectError Disconnected ServerInput
        ServerError ServerFlushed Started
        ServerHigh ServerLow
      )
    ) {
      croak "$_ must be a coderef" if(
        defined($param{$_}) and ref($param{$_}) ne 'CODE'
      );
    }
  
    my $high_mark_level = delete $param{HighMark};
    my $low_mark_level  = delete $param{LowMark};
    my $high_event      = delete $param{ServerHigh};
    my $low_event       = delete $param{ServerLow};
  
    # this is ugly, but now its elegant :)  grep++
    my $using_watermarks = grep { defined $_ }
      ($high_mark_level, $low_mark_level, $high_event, $low_event);
    if ($using_watermarks > 0 and $using_watermarks != 4) {
      croak "If you use the Mark settings, you must define all four";
    }
  
    $high_event = sub { } unless defined $high_event;
    $low_event  = sub { } unless defined $low_event;
  
    my $pre_conn_callback   = delete $param{PreConnect};
    my $conn_callback       = delete $param{Connected};
    my $conn_error_callback = delete $param{ConnectError};
    my $disc_callback       = delete $param{Disconnected};
    my $input_callback      = delete $param{ServerInput};
    my $error_callback      = delete $param{ServerError};
    my $flush_callback      = delete $param{ServerFlushed};
    my $start_callback      = delete $param{Started};
    my $filter              = delete $param{Filter};
    # TODO should we have ServerInputFilter/ServerOutputFilter like Server-TCP does?
  
    # Extra states.
  
    my $inline_states = delete $param{InlineStates};
    $inline_states = {} unless defined $inline_states;
  
    my $package_states = delete $param{PackageStates};
    $package_states = [] unless defined $package_states;
  
    my $object_states = delete $param{ObjectStates};
    $object_states = [] unless defined $object_states;
  
    croak "InlineStates must be a hash reference"
      unless ref($inline_states) eq 'HASH';
  
    croak "PackageStates must be a list or array reference"
      unless ref($package_states) eq 'ARRAY';
  
    croak "ObjectStates must be a list or array reference"
      unless ref($object_states) eq 'ARRAY';
  
    # Errors.
  
    croak "$mi requires a ServerInput parameter" unless defined $input_callback;
  
    foreach (sort keys %param) {
      carp "$mi doesn't recognize \"$_\" as a parameter";
    }
  
    # Defaults.
  
    $session_type = 'POE::Session' unless defined $session_type;
    if (defined($session_params) && ref($session_params)) {
      if (ref($session_params) ne 'ARRAY') {
        croak "SessionParams must be an array reference";
      }
    } else {
      $session_params = [ ];
    }
  
    $address = '127.0.0.1' unless defined $address;
  
    $conn_error_callback = \&_default_error unless defined $conn_error_callback;
    $error_callback      = \&_default_io_error unless defined $error_callback;
  
    # Spawn the session that makes the connection and then interacts
    # with what was connected to.
  
    return $session_type->create
      ( @$session_params,
        inline_states =>
        { _start => sub {
            my ($kernel, $heap) = @_[KERNEL, HEAP];
            $heap->{shutdown_on_error} = 1;
            $kernel->alias_set( $alias ) if defined $alias;
            $kernel->yield( 'reconnect' );
            $start_callback and $start_callback->(@_);
          },
  
          # To quiet ASSERT_STATES.
          _stop   => sub { },
          _child  => sub { },
  
          reconnect => sub {
            my ($kernel, $heap) = @_[KERNEL, HEAP];
  
            $heap->{shutdown} = 0;
            $heap->{connected} = 0;
  
            # Tentative patch to re-establish the alias upon reconnect.
            # Necessary because otherwise the alias goes away for good.
            # Unfortunately, there is a gap where the alias may not be
            # set, and any events dispatched then will be dropped.
            $kernel->alias_set( $alias ) if defined $alias;
  
            $heap->{server} = POE::Wheel::SocketFactory->new
              ( RemoteAddress => $address,
                RemotePort    => $port,
                SocketDomain  => $domain,
                BindAddress   => $bind_address,
                BindPort      => $bind_port,
                SuccessEvent  => 'got_connect_success',
                FailureEvent  => 'got_connect_error',
              );
            $_[KERNEL]->alarm_remove( delete $heap->{ctimeout_id} )
              if exists $heap->{ctimeout_id};
            $heap->{ctimeout_id} = $_[KERNEL]->alarm_set
              ( got_connect_timeout => time + $ctimeout
              ) if defined $ctimeout;
          },
  
          connect => sub {
            my ($new_address, $new_port) = @_[ARG0, ARG1];
            $address = $new_address if defined $new_address;
            $port    = $new_port    if defined $new_port;
            $_[KERNEL]->yield("reconnect");
          },
  
          got_connect_success => sub {
            my ($kernel, $heap, $socket) = @_[KERNEL, HEAP, ARG0];
  
            $kernel->alarm_remove( delete $heap->{ctimeout_id} )
              if exists $heap->{ctimeout_id};
  
            # Pre-connected callback.
            if ($pre_conn_callback) {
              unless ($socket = $pre_conn_callback->(@_)) {
                $heap->{connected} = 0;
                # TODO - Error callback?  Disconnected callback?
                return;
              }
            }
  
            # Ok to overwrite like this as of 0.13.
            $_[HEAP]->{server} = POE::Wheel::ReadWrite->new
              ( Handle       => $socket,
                Driver       => POE::Driver::SysRW->new(),
                Filter       => _get_filter($filter),
                InputEvent   => 'got_server_input',
                ErrorEvent   => 'got_server_error',
                FlushedEvent => 'got_server_flush',
                (
                  $using_watermarks
                  ? (
                    HighMark  => $high_mark_level,
                    HighEvent => 'got_high',
                    LowMark   => $low_mark_level,
                    LowEvent  => 'got_low',
                  )
                  : ()
                )
              );
  
            $heap->{connected} = 1;
            $conn_callback and $conn_callback->(@_);
          },
          got_high => $high_event,
          got_low => $low_event,
  
          got_connect_error => sub {
            my $heap = $_[HEAP];
            $_[KERNEL]->alarm_remove( delete $heap->{ctimeout_id} )
              if exists $heap->{ctimeout_id};
            $heap->{connected} = 0;
            $conn_error_callback->(@_);
            delete $heap->{server};
          },
  
          got_connect_timeout => sub {
            my $heap = $_[HEAP];
            $heap->{connected} = 0;
            $_[KERNEL]->alarm_remove( delete $heap->{ctimeout_id} )
              if exists $heap->{ctimeout_id};
            $! = ETIMEDOUT;
            @_[ARG0,ARG1,ARG2] = ('connect', $!+0, $!);
            $conn_error_callback->(@_);
            delete $heap->{server};
          },
  
          got_server_error => sub {
            $error_callback->(@_);
            if ($_[HEAP]->{shutdown_on_error}) {
              $_[KERNEL]->yield("shutdown");
              $_[HEAP]->{got_an_error} = 1;
            }
          },
  
          got_server_input => sub {
            my $heap = $_[HEAP];
            return if $heap->{shutdown};
            $input_callback->(@_);
          },
  
          got_server_flush => sub {
            my $heap = $_[HEAP];
            $flush_callback and $flush_callback->(@_);
            if ($heap->{shutdown}) {
              delete $heap->{server};
              $disc_callback and $disc_callback->(@_);
            }
          },
  
          shutdown => sub {
            my ($kernel, $heap) = @_[KERNEL, HEAP];
            $heap->{shutdown} = 1;
  
            $kernel->alarm_remove( delete $heap->{ctimeout_id} )
              if exists $heap->{ctimeout_id};
  
            if ($heap->{connected}) {
              $heap->{connected} = 0;
              if (defined $heap->{server}) {
                if (
                  $heap->{got_an_error} or
                  not $heap->{server}->get_driver_out_octets()
                ) {
                  delete $heap->{server};
                  $disc_callback and $disc_callback->(@_);
                }
              }
            }
            else {
              delete $heap->{server};
            }
  
            $kernel->alias_remove($alias) if defined $alias;
          },
  
          # User supplied states.
          %$inline_states,
        },
  
        # User arguments.
        args => $args,
  
        # User supplied states.
        package_states => $package_states,
        object_states  => $object_states,
      )->ID;
  }
  
  sub _get_filter {
    my $filter = shift;
    if (ref $filter eq 'ARRAY') {
      my @filter_args = @$filter;
      $filter = shift @filter_args;
      return $filter->new(@filter_args);
    } elsif (ref $filter) {
      return $filter->clone();
    } elsif (!defined($filter)) {
      return POE::Filter::Line->new();
    } else {
      return $filter->new();
    }
  }
  
  # The default error handler logs to STDERR and shuts down the socket.
  
  sub _default_error {
    unless ($_[ARG0] eq "read" and ($_[ARG1] == 0 or $_[ARG1] == ECONNRESET)) {
      warn(
        'Client ', $_[SESSION]->ID, " got $_[ARG0] error $_[ARG1] ($_[ARG2])\n"
      );
    }
    delete $_[HEAP]->{server};
  }
  
  sub _default_io_error {
    my ($syscall, $errno, $error) = @_[ARG0..ARG2];
    $error = "Normal disconnection" unless $errno;
    warn('Client ', $_[SESSION]->ID, " got $syscall error $errno ($error)\n");
    $_[KERNEL]->yield("shutdown");
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Component::Client::TCP - a simplified TCP client
  
  =head1 SYNOPSIS
  
    #!perl
  
    use warnings;
    use strict;
  
    use POE qw(Component::Client::TCP);
  
    POE::Component::Client::TCP->new(
      RemoteAddress => "yahoo.com",
      RemotePort    => 80,
      Connected     => sub {
        $_[HEAP]{server}->put("HEAD /");
      },
      ServerInput   => sub {
        my $input = $_[ARG0];
        print "from server: $input\n";
      },
    );
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Component::Client::TCP implements a generic single-Session
  client.  Internally it uses POE::Wheel::SocketFactory to establish the
  connection and POE::Wheel::ReadWrite to interact with the server.
  
  POE::Component::Client::TCP is customized by providing callbacks for
  common operations.  Most operations have sensible default callbacks,
  so clients may be created with as little work as possible.
  
  =head2 Performance Considerations
  
  POE::Component::Client::TCP's ease of use comes at a price.  The
  component is generic, so it's not tuned to perform well for any
  particular application.
  
  If performance is your primary goal, POE::Kernel's select_read() and
  select_write() perform about the same as IO::Select, but your code
  will be portable across every event loop POE supports.
  
  =head1 PUBLIC METHODS
  
  =head2 new
  
  new() starts a client based on POE::Component::Client::TCP and returns
  the ID of the session that will handle server interaction.
  
  new() returns immediately, which may be before the client has
  established its connection.  It is always reliable to wait for the
  C<Connected> callback to fire before transmitting data to the server.
  
  The client's constructor may seem to take a daunting number of
  parameters.  As with most POE modules, POE::Component::Client::TCP
  tries to do as much work in its constructor so that the run-time code
  path is relatively light.
  
  =head3 Constructor Parameters Affecting the Session
  
  The parameters in this section affect how the client's POE::Session
  object will be created.
  
  =head4 Alias
  
  C<Alias> is an optional symbolic name for the client's Session.  It
  allows other sessions to post events to the client, such as "shutdown"
  and "reconnect".  The client itself may yield() these events, so an
  alias isn't usually needed.
  
    Alias => "client",
  
  =head4 Args
  
  C<Args> is optional.  When specified, it holds an ARRAYREF that will
  be passed to the C<Started> callback via @_[ARG0..$#_].  This allows a
  program to pass extra information into the client session.
  
  =head4 InlineStates
  
  C<InlineStates> is optional.  If specified, it must hold a hashref of
  named callbacks.  Its syntax is that of POE:Session->create()'s
  inline_states parameter.
  
  =head4 ObjectStates
  
  If C<ObjectStates> is specified, it must hold an arrayref of objects
  and the events they will handle.  The arrayref must follow the syntax
  for POE::Session->create()'s object_states parameter.
  
  =head4 PackageStates
  
  When the optional C<PackageStates> is set, it must hold an arrayref of
  package names and the events they will handle  The arrayref must
  follow the syntax for POE::Session->create()'s package_states
  parameter.
  
  =head4 PreConnect
  
  C<PreConnect> is called before C<Connected>, and it has different
  parameters: $_[ARG0] contains a copy of the socket before it's given
  to POE::Wheel::ReadWrite for management.  Most HEAP members are set,
  except of course $_[HEAP]{server}, because the POE::Wheel::ReadWrite
  object has not been created yet.  C<PreConnect> may enable SSL on the
  socket using POE::Component::SSLify.  C<PreConnect> must return a
  valid socket to complete the connection; the client will disconnect if
  anything else is returned.
  
    PreConnect => {
      # Convert the socket into an SSL socket.
      my $socket = eval { Client_SSLify($_[ARG0]) };
  
      # Disconnect if SSL failed.
      return if $@;
  
      # Return the SSL-ified socket.
      return $socket;
    }
  
  =head4 SessionType
  
  Each client is created within its own Session.  C<SessionType> names
  the class that will be used to create the session.
  
    SessionType => "POE::Session::MultiDispatch",
  
  C<SessionType> is optional.  The component will use "POE::Session" by
  default.
  
  =head4 SessionParams
  
  C<SessionParams> specifies additional parameters that will be passed
  to the C<SessionType> constructor at creation time.  It must be an
  array reference.
  
    SessionParams => [ options => { debug => 1, trace => 1 } ],
  
  Note: POE::Component::Client::TCP supplies its own POE::Session
  constructor parameters.  Conflicts between them and C<SessionParams>
  may cause the component to behave erratically.  To avoid such
  problems, please limit SessionParams to the C<options> hash.  See
  L<POE::Session> for an known options.
  
  We may enable other options later.  Please let us know if you need
  something.
  
  =head4 Started
  
  C<Started> sets an optional callback that will be invoked within the
  client session has been started.  The callback's parameters are the
  usual for the session's _start handler.
  
  C<Args> may be used to pass additional parameters to C<Started>.  This
  can be used to bypass issues introduced by closures.  The values from
  C<Args> will be included in the @_[ARG0..$#_] parameters.
  
    sub handle_started {
      my @args = @_[ARG0..$#_];
      # ...
    }
  
  =head3 POE::Wheel::SocketFactory Constructor Parameters
  
  The constructor parameters in this section affect how the client's
  POE::Wheel::SocketFactory object will be created.
  
  =head4 BindAddress
  
  C<BindAddress> specifies the local interface address to bind to before
  starting to connect.  This allows the client to connect from a
  specific address when multiple interfaces are available.
  
  C<BindAddress> is optional.  If specified, its value will be passed
  directly to POE::Wheel::SocketFactory's BindAddress constructor
  parameter.
  
  =head4 BindPort
  
  C<BindPort> sets the local socket port that the client will be bound
  to before starting to connect.  This allows the client to connect from
  a specific port.
  
  It's not usually necessary to bind to a particular port, so
  C<BindPort> is optional and disabled by default.
  
  If specified, the value in C<BindPort> is passed directly to
  POE::Wheel::SocketFactory's own BindPort constructor parameter.
  
  =head4 ConnectError
  
  C<ConnectError> is an optional callback to handle errors from
  POE::Wheel::SocketFactory.  These errors happen when a socket can't be
  created or has trouble connecting to the remote host.
  
  The following parameters will be passed to the callback along with the
  usual POE event parameters:  $_[ARG0] will describe what was happening
  at the time of failure.  $_[ARG1] and $_[ARG2] will contain the
  numeric and string versions of $!, respectively.
  
  Depending on the nature of the error and the type of client, it may be
  useful to reconnect from the ConnectError callback.
  
    ConnectError => sub {
      my ($operation, $error_number, $error_string) = @_[ARG0..ARG2];
      warn "$operation error $error_number occurred: $error_string";
      if (error_is_recoverable($error_number)) {
        $_[KERNEL]->delay( reconnect => 60 );
      }
      else {
        $_[KERNEL]->yield("shutdown");
      }
    },
  
  POE::Component::Client::TCP will shut down after ConnectError if a
  reconnect isn't requested.
  
  =head4 Connected
  
  Connections are asynchronously set up and may take some time to
  complete.  C<Connected> is an optional callback that notifies a
  program when the connection has finally been made.
  
  This is an advisory callback that occurs after a POE::Wheel::ReadWrite
  object has already been created.  Programs should not need to create
  their own.
  
  C<Connected> is called in response to POE::Wheel::SocketFactory's
  SuccessEvent.  In addition to the usual POE event parameters, it
  includes a copy of the established socket handle in  $_[ARG0].
  POE::Component::Client::TCP will manage the socket, so an application
  should rarely need to save a copy of it.  $_[ARG1] and $_[ARG2]
  contain the remote address and port as returned from getpeername().
  
    Connected => {
      my ($socket, $peer_addr, $peer_port) = @_[ARG0, ARG1, ARG2];
      # ...
    }
  
  See L</PreConnect> to modify the socket before it's given to
  POE::Wheel::ReadWrite.
  
  =head4 ConnectTimeout
  
  C<ConnectTimeout> is the maximum number of seconds to wait for a
  connection to be established.  If it is omitted, Client::TCP relies on
  the operating system to abort stalled connect() calls.
  
  The application will be notified of a timeout via the ConnectError
  callback.  In the case of a timeout, $_[ARG0] will contain "connect",
  and $_[ARG1] and $_[ARG2] will contain the numeric and string
  representations of the ETIMEDOUT error.
  
  =head4 Domain
  
  C<Domain> sets the address or protocol family within which to operate.
  The C<Domain> may be any value that POE::Wheel::SocketFactory
  supports.  AF_INET (Internet address space) is used by default.
  
  Use AF_INET6 for IPv6 support.  This constant is exported by Socket.
  Also be sure to have Socket::GetAddrInfo installed, which is required
  by POE::Wheel::SocketFactory for IPv6 support.
  
  =head4 RemoteAddress
  
  C<RemoteAddress> contains the address of the server to connect to.  It
  is required and may contain a host name ("poe.perl.org"), a dot- or
  colon-separated numeric address (depending on the Domain), or a packed
  socket address.  Pretty much anything POE::Wheel::SocketFactory's
  RemoteAddress parameter does.
  
  =head4 RemotePort
  
  C<RemotePort> contains the port of the server to connect to.  It is
  required and may be a service name ("echo") or number (7).
  
  
  =head3 POE::Wheel::ReadWrite Constructor Parameters
  
  Parameters in this section control configuration of the client's
  POE::Wheel::ReadWrite object.
  
  =head4 Disconnected
  
  C<Disconnected> is an optional callback to notify a program that an
  established socket has been disconnected.  It includes no special
  parameters.
  
  It may be useful to reconnect from the Disconnected callback, in the
  case of MUD bots or long-running services.  For example:
  
    Disconnected => sub {
      $_[KERNEL]->delay( reconnect => 60 );
    },
  
  The component will shut down if the connection ceases without being
  reconnected.
  
  =head4 Filter
  
  C<Filter> specifies the type of POE::Filter object that will parse
  input from and serialize output to a server.  It may either be a
  scalar, an array reference, or a POE::Filter object.
  
  If C<Filter> is a scalar, it will be expected to contain a POE::Filter
  class name:
  
    Filter => "POE::Filter::Line",
  
  C<Filter> is optional.  In most cases, the default "POE::Filter::Line"
  is fine.
  
  If C<Filter> is an array reference, the first item in the array will
  be treated as a POE::Filter class name.  The remaining items will be
  passed to the filter's constructor.  In this example, the vertical bar
  will be used as POE::Filter::Line's record terminator:
  
    Filter => [ "POE::Filter::Line", Literal => "|" ],
  
  If it is an object, it will be cloned every time the client connects:
  
    Filter => POE::Filter::Line->new(Literal => "|"),
  
  Be sure to C<use> the appropriate POE::Filter subclass when specifying
  a C<Filter> other than the default.
  
  =head4 ServerError
  
  C<ServerError> is an optional callback that will be invoked when an
  established server connection has encountered some kind of error.  It
  is triggered by POE::Wheel::ReadWrite's ErrorEvent.  By default, the
  component will log any errors to STDERR.  This may be suppressed by
  defining a quieter ServerError callback.
  
  As with C<ConnectError>, it is invoked with the customary error
  parameters:  $_[ARG0] will contain the name of the operation that
  failed.  $_[ARG1] and $_[ARG2] will hold the numeric and string forms
  of $!, respectively.
  
  Components usually disconnect on error.  POE::Component::Client::TCP
  will shut down if the socket disconnects without being reconnected.
  
  =head4 ServerFlushed
  
  C<ServerFlushed> is an optional callback to notify a program that
  ReadWrite's output buffers have completely flushed.  It has no special
  parameters.
  
  The component will shut down after a server flush if $heap->{shutdown}
  is set.
  
  =head4 ServerInput
  
  C<ServerInput> is a required callback.  It is called for each fully
  parsed input record received by POE::Wheel::ReadWrite.  $_[ARG0]
  contains the input record, the format of which is determined by the
  C<Filter> constructor parameter.
  
  C<SeverInput> will stop being called when $_[HEAP]{shutdown} is true.
  The most reliable way to set the "shutdown" member is to call
  $_[KERNEL]->yield("shutdown").
  
  =head1 Public Events
  
  POE::Component::Client::TCP handles a small number of public "command"
  messages.  These may be posted into the client from an external
  session, or yielded from within the client.
  
  =head2 connect
  
  The C<connect> event causes POE::Component::Client::TCP to begin
  connecting to a server.  It optionally includes a new RemoteHost and
  RemotePort, both of which will be used for subsequent reconnections.
  
    $_[KERNEL]->post(alias => connect => "127.0.0.1", 80);
  
  If the client is already connected to a server, it will disconnect
  immediately before beginning the new connection procedure.  Buffered
  input and output will be lost.
  
  =head2 reconnect
  
  The C<reconnect> command causes POE::Component::Client::TCP to
  immediately disconnect its current connection and begin reconnecting
  to its most recently set RemoteHost and RemotePort.  Any buffered
  input and output will be lost.
  
  =head2 shutdown
  
  The C<shutdown> command tells POE::Component::Client::TCP to flush its
  buffers, disconnect, and begin DESTROY procedures.
  
  All input will be discarded after receipt of "shutdown".  All pending
  output will be written to the server socket before disconnecting and
  destructing.
  
  =head1 Reserved Heap Members
  
  POE::Component::Client::TCP requires some heap space for its own
  bookkeeping.  The following members are used and should be used as
  directed, or with care.
  
  This sample input handler is an example of most reserved heap members:
  
    sub handle_input {
      # Pending input from when we were connected.
      return unless $_[HEAP]{connected};
  
      # We've been shut down.
      return if $_[HEAP]{shutdown};
  
      my $input = $_[ARG0];
      $_[HEAP]{server}->put("you sent: $input");
    }
  
  =head2 server
  
  The read-only C<server> heap member contains the POE::Wheel object
  used to connect to or talk with the server.  While the component is
  connecting, C<server> will be a L<POE::Wheel::SocketFactory> object.  After
  the connection has been made, C<server> is replaced with a
  L<POE::Wheel::ReadWrite> object.
  
  The most reliable way to avoid prematurely using C<server> is to first
  check the C<connected> reserved heap member.  See the example above.
  
  =head2 shutdown
  
  C<shutdown> is a read-only flag that tells the component it's shutting
  down.  It should only be by the C<shutdown> event, which does other
  cleanup.
  
  C<shutdown> may be checked to avoid starting new work during a
  client's shutting-down procedure.  See the example above.
  
  =head2 connected
  
  C<connected> is a read-only flag that indicates whether the component
  is currently connected.
  
  =head2 shutdown_on_error
  
  C<shutdown_on_error> is a read-only flag that governs the component's
  shutdown-on-error behavior.  When true, POE::Component::Client::TCP
  will automatically shutdown when it encounters an error.
  
  =head1 SEE ALSO
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  L<POE::Component::Server::TCP> is the server-side counterpart to this
  module.
  
  This component uses and exposes features from L<POE::Filter>,
  L<POE::Wheel::SocketFactory>, and L<POE::Wheel::ReadWrite>.
  
  See L<POE::Wheel::SocketFactory/SYNOPSIS> for a more efficient but
  lower-level way to create clients and servers.
  
  =head1 CAVEATS
  
  This looks nothing like what Ann envisioned.
  
  POE::Component::Client::TCP is a generic client.  As such, it's not
  tuned for any particular task.  While it handles the common cases well
  and with a minimum of code, it may not be suitable for everything.
  
  =head1 AUTHORS & COPYRIGHTS
  
  POE::Component::Client::TCP is Copyright 2001-2013 by Rocco Caputo.
  All rights are reserved.  POE::Component::Client::TCP is free
  software, and it may be redistributed and/or modified under the same
  terms as Perl itself.
  
  POE::Component::Client::TCP is based on code, used with permission,
  from Ann Barcomb E<lt>kudra@domaintje.comE<gt>.
  
  POE::Component::Client::TCP is based on code, used with permission,
  from Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_COMPONENT_CLIENT_TCP

$fatpacked{"POE/Component/IRC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC';
  package POE::Component::IRC;
  BEGIN {
    $POE::Component::IRC::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use POE qw(Wheel::SocketFactory Wheel::ReadWrite Driver::SysRW
             Filter::Line Filter::Stream Filter::Stackable);
  use POE::Filter::IRCD;
  use POE::Filter::IRC::Compat;
  use POE::Component::IRC::Constants qw(:ALL);
  use POE::Component::IRC::Plugin qw(:ALL);
  use POE::Component::IRC::Plugin::DCC;
  use POE::Component::IRC::Plugin::ISupport;
  use POE::Component::IRC::Plugin::Whois;
  use Socket qw(AF_INET SOCK_STREAM unpack_sockaddr_in inet_ntoa inet_aton);
  use base qw(POE::Component::Syndicator);
  
  our ($GOT_SSL, $GOT_CLIENT_DNS, $GOT_SOCKET6, $GOT_ZLIB);
  
  BEGIN {
      eval {
          require POE::Component::SSLify;
          import POE::Component::SSLify qw( Client_SSLify SSLify_ContextCreate );
          $GOT_SSL = 1;
      };
      eval {
          require POE::Component::Client::DNS;
          $GOT_CLIENT_DNS = 1 if $POE::Component::Client::DNS::VERSION >= 0.99;
      };
      eval {
          require POE::Filter::Zlib::Stream;
          $GOT_ZLIB = 1 if $POE::Filter::Zlib::Stream::VERSION >= 1.96;
      };
      # Socket6 provides AF_INET6 where earlier Perls' Socket don't.
      eval {
          Socket->import(qw(AF_INET6 unpack_sockaddr_in6 inet_ntop));
          $GOT_SOCKET6 = 1;
      };
      if (!$GOT_SOCKET6) {
          eval {
              require Socket6;
              Socket6->import(qw(AF_INET6 unpack_sockaddr_in6 inet_ntop));
              $GOT_SOCKET6 = 1;
          };
          if (!$GOT_SOCKET6) {
              # provide a dummy sub so code compiles
              *AF_INET6 = sub { ~0 };
          }
      }
  }
  
  # BINGOS: I have bundled up all the stuff that needs changing
  # for inherited classes into _create. This gets called from 'spawn'.
  # $self->{OBJECT_STATES_ARRAYREF} contains event mappings to methods that have
  # the same name, gets passed to POE::Session->create as $self => [ ];
  # $self->{OBJECT_STATES_HASHREF} contains event mappings to methods, where the
  # event and the method have diferent names.
  # $self->{IRC_CMDS} contains the traditional %irc_commands, mapping commands
  # to events and the priority that the command has.
  sub _create {
      my ($self) = @_;
  
      $self->{IRC_CMDS} = {
          rehash    => [ PRI_HIGH,     'noargs',        ],
          die       => [ PRI_HIGH,     'noargs',        ],
          restart   => [ PRI_HIGH,     'noargs',        ],
          quit      => [ PRI_NORMAL,   'oneoptarg',     ],
          version   => [ PRI_HIGH,     'oneoptarg',     ],
          time      => [ PRI_HIGH,     'oneoptarg',     ],
          trace     => [ PRI_HIGH,     'oneoptarg',     ],
          admin     => [ PRI_HIGH,     'oneoptarg',     ],
          info      => [ PRI_HIGH,     'oneoptarg',     ],
          away      => [ PRI_HIGH,     'oneoptarg',     ],
          users     => [ PRI_HIGH,     'oneoptarg',     ],
          lusers    => [ PRI_HIGH,     'oneoptarg',     ],
          locops    => [ PRI_HIGH,     'oneoptarg',     ],
          operwall  => [ PRI_HIGH,     'oneoptarg',     ],
          wallops   => [ PRI_HIGH,     'oneoptarg',     ],
          motd      => [ PRI_HIGH,     'oneoptarg',     ],
          who       => [ PRI_HIGH,     'oneoptarg',     ],
          nick      => [ PRI_HIGH,     'onlyonearg',    ],
          oper      => [ PRI_HIGH,     'onlytwoargs',   ],
          invite    => [ PRI_HIGH,     'onlytwoargs',   ],
          squit     => [ PRI_HIGH,     'onlytwoargs',   ],
          kill      => [ PRI_HIGH,     'onlytwoargs',   ],
          privmsg   => [ PRI_NORMAL,   'privandnotice', ],
          privmsglo => [ PRI_NORMAL+1, 'privandnotice', ],
          privmsghi => [ PRI_NORMAL-1, 'privandnotice', ],
          notice    => [ PRI_NORMAL,   'privandnotice', ],
          noticelo  => [ PRI_NORMAL+1, 'privandnotice', ],
          noticehi  => [ PRI_NORMAL-1, 'privandnotice', ],
          squery    => [ PRI_NORMAL,   'privandnotice', ],
          join      => [ PRI_HIGH,     'oneortwo',      ],
          summon    => [ PRI_HIGH,     'oneortwo',      ],
          sconnect  => [ PRI_HIGH,     'oneandtwoopt',  ],
          whowas    => [ PRI_HIGH,     'oneandtwoopt',  ],
          stats     => [ PRI_HIGH,     'spacesep',      ],
          links     => [ PRI_HIGH,     'spacesep',      ],
          mode      => [ PRI_HIGH,     'spacesep',      ],
          servlist  => [ PRI_HIGH,     'spacesep',      ],
          cap       => [ PRI_HIGH,     'spacesep',      ],
          part      => [ PRI_HIGH,     'commasep',      ],
          names     => [ PRI_HIGH,     'commasep',      ],
          list      => [ PRI_HIGH,     'commasep',      ],
          whois     => [ PRI_HIGH,     'commasep',      ],
          ctcp      => [ PRI_HIGH,     'ctcp',          ],
          ctcpreply => [ PRI_HIGH,     'ctcp',          ],
          ping      => [ PRI_HIGH,     'oneortwo',      ],
          pong      => [ PRI_HIGH,     'oneortwo',      ],
      };
  
      my %event_map = map {($_ => $self->{IRC_CMDS}->{$_}->[CMD_SUB])}
          keys %{ $self->{IRC_CMDS} };
  
      $self->{OBJECT_STATES_HASHREF} = {
          %event_map,
          quote => 'sl',
      };
  
      $self->{OBJECT_STATES_ARRAYREF} = [qw(
          syndicator_started
          _parseline
          _sock_down
          _sock_failed
          _sock_up
          _socks_proxy_connect
          _socks_proxy_response
          debug
          connect
          _resolve_addresses
          _do_connect
          _quit_timeout
          _send_login
          _got_dns_response
          ison
          kick
          remove
          nickserv
          shutdown
          sl
          sl_login
          sl_high
          sl_delayed
          sl_prioritized
          topic
          userhost
      )];
  
      return;
  }
  
  # BINGOS: the component can now configure itself via _configure() from
  # either spawn() or connect()
  ## no critic (Subroutines::ProhibitExcessComplexity)
  sub _configure {
      my ($self, $args) = @_;
      my $spawned = 0;
  
      if (ref $args eq 'HASH' && keys %{ $args }) {
          $spawned = delete $args->{spawned};
          $self->{use_localaddr} = delete $args->{localaddr};
          @{ $self }{ keys %{ $args } } = values %{ $args };
      }
  
      if ($ENV{POCOIRC_DEBUG}) {
          $self->{debug} = 1;
          $self->{plugin_debug} = 1;
      }
  
      if ($self->{debug}) {
          $self->{ircd_filter}->debug(1);
          $self->{ircd_compat}->debug(1);
      }
  
      if ($self->{useipv6} && !$GOT_SOCKET6) {
          warn "'useipv6' option specified, but Socket6 was not found\n";
      }
  
      if ($self->{usessl} && !$GOT_SSL) {
          warn "'usessl' option specified, but POE::Component::SSLify was not found\n";
      }
  
      $self->{dcc}->nataddr($self->{nataddr}) if exists $self->{nataddr};
      $self->{dcc}->dccports($self->{dccports}) if exists $self->{dccports};
  
      $self->{port} = 6667 if !$self->{port};
      $self->{msg_length} = 450 if !defined $self->{msg_length};
  
      if ($self->{use_localaddr}) {
          $self->{localaddr} = $self->{use_localaddr}
              . ($self->{localport} ? (':'.$self->{localport}) : '');
      }
  
      # Make sure that we have reasonable defaults for all the attributes.
      # The "IRC*" variables are ircII environment variables.
      if (!defined $self->{nick}) {
          $self->{nick} = $ENV{IRCNICK} || eval { scalar getpwuid($>) }
              || $ENV{USER} || $ENV{LOGNAME} || 'WankerBot';
      }
  
      if (!defined $self->{username}) {
          $self->{username} = eval { scalar getpwuid($>) } || $ENV{USER}
              || $ENV{LOGNAME} || 'foolio';
      }
  
      if (!defined $self->{ircname}) {
          $self->{ircname} = $ENV{IRCNAME} || eval { (getpwuid $>)[6] }
              || 'Just Another Perl Hacker';
      }
  
      if (!defined $self->{server} && !$spawned) {
          die "No IRC server specified\n" if !$ENV{IRCSERVER};
          $self->{server} = $ENV{IRCSERVER};
      }
  
      return;
  }
  
  sub debug {
      my ($self, $switch) = @_[OBJECT, ARG0];
  
      $self->{debug} = $switch;
      $self->{ircd_filter}->debug( $switch );
      $self->{ircd_compat}->debug( $switch );
      return;
  }
  
  # Parse a message from the IRC server and generate the appropriate
  # event(s) for listening sessions.
  sub _parseline {
      my ($session, $self, $ev) = @_[SESSION, OBJECT, ARG0];
  
      return if !$ev->{name};
      $self->send_event(irc_raw => $ev->{raw_line} ) if $self->{raw};
  
      # record our nickname
      if ( $ev->{name} eq '001' ) {
          $self->{INFO}{RealNick} = ( split / /, $ev->{raw_line} )[2];
      }
  
      $ev->{name} = 'irc_' . $ev->{name};
      $self->send_event( $ev->{name}, @{$ev->{args}} );
  
      if ($ev->{name} =~ /^irc_ctcp_(.+)$/) {
          $self->send_event(irc_ctcp => $1 => @{$ev->{args}});
      }
  
      return;
  }
  
  # Internal function called when a socket is closed.
  sub _sock_down {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
  
      # Destroy the RW wheel for the socket.
      delete $self->{socket};
      delete $self->{localaddr};
      $self->{connected} = 0;
  
      # Stop any delayed sends.
      $self->{send_queue} = [ ];
      $self->{send_time}  = 0;
      $kernel->delay( sl_delayed => undef );
  
      # Reset the filters if necessary
      $self->_compress_uplink( 0 );
      $self->_compress_downlink( 0 );
      $self->{ircd_compat}->chantypes( [ '#', '&' ] );
      $self->{ircd_compat}->identifymsg(0);
  
      # post a 'irc_disconnected' to each session that cares
      $self->send_event(irc_disconnected => $self->{server} );
      return;
  }
  
  sub disconnect {
      my ($self) = @_;
      $self->yield('_sock_down');
      return;
  }
  
  # Internal function called when a socket fails to be properly opened.
  sub _sock_failed {
      my ($self, $op, $errno, $errstr) = @_[OBJECT, ARG0..ARG2];
  
      delete $self->{socketfactory};
      $self->send_event(irc_socketerr => "$op error $errno: $errstr" );
      return;
  }
  
  # Internal function called when a connection is established.
  sub _sock_up {
      my ($kernel, $self, $session, $socket) = @_[KERNEL, OBJECT, SESSION, ARG0];
  
      # We no longer need the SocketFactory wheel. Scrap it.
      delete $self->{socketfactory};
  
      # Remember what IP address we're connected through, for multihomed boxes.
      my $localaddr;
      if ($GOT_SOCKET6) {
          eval {
                  $localaddr = (unpack_sockaddr_in6( getsockname $socket ))[1];
                  $localaddr = inet_ntop( AF_INET6, $localaddr );
          };
      }
  
      if ( !$localaddr ) {
          $localaddr = (unpack_sockaddr_in( getsockname $socket ))[1];
          $localaddr = inet_ntoa($localaddr);
      }
  
      $self->{localaddr} = $localaddr;
  
      if ( $self->{socks_proxy} ) {
          $self->{socket} = POE::Wheel::ReadWrite->new(
              Handle       => $socket,
              Driver       => POE::Driver::SysRW->new(),
              Filter       => POE::Filter::Stream->new(),
              InputEvent   => '_socks_proxy_response',
              ErrorEvent   => '_sock_down',
          );
  
          if ( !$self->{socket} ) {
              $self->send_event(irc_socketerr =>
                  "Couldn't create ReadWrite wheel for SOCKS socket" );
              return;
          }
  
          my $packet;
          if ( _ip_is_ipv4( $self->{server} ) ) {
              # SOCKS 4
              $packet = pack ('CCn', 4, 1, $self->{port}) .
              inet_aton($self->{server}) . ($self->{socks_id} || '') . (pack 'x');
          }
          else {
              # SOCKS 4a
              $packet = pack ('CCn', 4, 1, $self->{port}) .
              inet_aton('0.0.0.1') . ($self->{socks_id} || '') . (pack 'x') .
              $self->{server} . (pack 'x');
          }
  
          $self->{socket}->put( $packet );
          return;
      }
  
      # ssl!
      if ($GOT_SSL and $self->{usessl}) {
          eval {
              my ($ctx);
  
              if( $self->{sslctx} )
              {
                  $ctx = $self->{sslctx};
              }
              elsif( $self->{sslkey} && $self->{sslcert} )
              {
                  $ctx = SSLify_ContextCreate( $self->{sslkey}, $self->{sslcert} );
              }
              else
              {
                  $ctx = undef;
              }
  
              $socket = Client_SSLify($socket, undef, undef, $ctx);
          };
  
          if ($@) {
           	chomp $@;
              warn "Couldn't use an SSL socket: $@\n";
              $self->{usessl} = 0;
          }
      }
  
      if ( $self->{compress} ) {
          $self->_compress_uplink(1);
          $self->_compress_downlink(1);
      }
  
      # Create a new ReadWrite wheel for the connected socket.
      $self->{socket} = POE::Wheel::ReadWrite->new(
          Handle       => $socket,
          Driver       => POE::Driver::SysRW->new(),
          InputFilter  => $self->{srv_filter},
          OutputFilter => $self->{out_filter},
          InputEvent   => '_parseline',
          ErrorEvent   => '_sock_down',
      );
  
      if ($self->{socket}) {
          $self->{connected} = 1;
      }
      else {
          $self->send_event(irc_socketerr => "Couldn't create ReadWrite wheel for IRC socket");
          return;
      }
  
      # Post a 'irc_connected' event to each session that cares
      $self->send_event(irc_connected => $self->{server} );
  
      # CONNECT if we're using a proxy
      if ($self->{proxy}) {
          # The original proxy code, AFAIK, did not actually work
          # with an HTTP proxy.
          $self->call(
              'sl_login',
              'CONNECT ' . $self->{server} . ':' . $self->{port} . " HTTP/1.0\n\n",
          );
  
          # KLUDGE: Also, the original proxy code assumes the connection
          # is instantaneous Since this is not always the case, mess with
          # the queueing so that the sent text is delayed...
          $self->{send_time} = time() + 10;
      }
  
      $kernel->yield('_send_login');
      return;
  }
  
  sub _socks_proxy_response {
      my ($kernel, $self, $session, $input) = @_[KERNEL, OBJECT, SESSION, ARG0];
  
      if (length $input != 8) {
          $self->send_event(
              'irc_socks_failed',
              'Mangled response from SOCKS proxy',
              $input,
          );
          $self->disconnect();
          return;
      }
  
      my @resp = unpack 'CCnN', $input;
      if (@resp != 4 || $resp[0] ne '0' || $resp[1] !~ /^(?:90|91|92|93)$/) {
          $self->send_event(
              'irc_socks_failed',
              'Mangled response from SOCKS proxy',
              $input,
          );
          $self->disconnect();
          return;
      }
  
      if ( $resp[1] eq '90' ) {
          $kernel->call($session => '_socks_proxy_connect');
          $self->{connected} = 1;
          $self->send_event( 'irc_connected', $self->{server} );
          $kernel->yield('_send_login');
      }
      else {
          $self->send_event(
              'irc_socks_rejected',
              $resp[1],
              $self->{socks_proxy},
              $self->{socks_port},
              $self->{socks_id},
          );
          $self->disconnect();
      }
  
      return;
  }
  
  sub _socks_proxy_connect {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      $self->{socket}->event( InputEvent => '_parseline' );
      $self->{socket}->set_input_filter( $self->{srv_filter} );
      $self->{socket}->set_output_filter( $self->{out_filter} );
      return;
  }
  
  sub _send_login {
      my ($kernel, $self, $session) = @_[KERNEL, OBJECT, SESSION];
  
      # Now that we're connected, attempt to log into the server.
  
      # for servers which support CAP, it's customary to start with that
      $kernel->call($session, 'sl_login', 'CAP REQ :identify-msg');
      $kernel->call($session, 'sl_login', 'CAP REQ :multi-prefix');
      $kernel->call($session, 'sl_login', 'CAP LS');
      $kernel->call($session, 'sl_login', 'CAP END');
  
      if (defined $self->{password}) {
          $kernel->call($session => sl_login => 'PASS ' . $self->{password});
      }
      $kernel->call($session => sl_login => 'NICK ' . $self->{nick});
      $kernel->call(
          $session,
          'sl_login',
          'USER ' .
          join(' ', $self->{username},
              (defined $self->{bitmode} ? $self->{bitmode} : 8),
              '*',
              ':' . $self->{ircname}
          ),
      );
  
      # If we have queued data waiting, its flush loop has stopped
      # while we were disconnected.  Start that up again.
      $kernel->delay(sl_delayed => 0);
  
      return;
  }
  
  # Set up the component's IRC session.
  sub syndicator_started {
      my ($kernel, $session, $sender, $self, $alias)
          = @_[KERNEL, SESSION, SENDER, OBJECT, ARG0, ARG1 .. $#_];
  
      # Send queue is used to hold pending lines so we don't flood off.
      # The count is used to track the number of lines sent at any time.
      $self->{send_queue} = [ ];
      $self->{send_time}  = 0;
  
      $self->{ircd_filter} = POE::Filter::IRCD->new(debug => $self->{debug});
      $self->{ircd_compat} = POE::Filter::IRC::Compat->new(debug => $self->{debug});
  
      my $srv_filters = [
          POE::Filter::Line->new(
              InputRegexp => '\015?\012',
              OutputLiteral => '\015\012',
          ),
          $self->{ircd_filter},
          $self->{ircd_compat},
      ];
  
      $self->{srv_filter} = POE::Filter::Stackable->new(Filters => $srv_filters);
      $self->{out_filter} = POE::Filter::Stackable->new(Filters => [
          POE::Filter::Line->new( OutputLiteral => "\015\012" ),
      ]);
  
      # Plugin 'irc_whois' and 'irc_whowas' support
      $self->plugin_add('Whois_' . $self->session_id(),
          POE::Component::IRC::Plugin::Whois->new()
      );
  
      $self->{isupport} = POE::Component::IRC::Plugin::ISupport->new();
      $self->plugin_add('ISupport_' . $self->session_id(), $self->{isupport});
      $self->{dcc} = POE::Component::IRC::Plugin::DCC->new();
      $self->plugin_add('DCC_' . $self->session_id(), $self->{dcc});
  
      return 1;
  }
  
  # The handler for commands which have N arguments, separated by commas.
  sub commasep {
      my ($kernel, $self, $state, @args) = @_[KERNEL, OBJECT, STATE, ARG0 .. $#_];
      my $args;
  
      if ($state eq 'whois' and @args > 1 ) {
          $args = shift @args;
          $args .= ' ' . join ',', @args;
      }
      elsif ( $state eq 'part' and @args > 1 ) {
          my $chantypes = join('', @{ $self->isupport('CHANTYPES') || ['#', '&']});
          my $message;
          if ($args[-1] =~ / +/ || $args[-1] !~ /^[$chantypes]/) {
              $message = pop @args;
          }
          $args = join(',', @args);
          $args .= " :$message" if defined $message;
      }
      else {
          $args = join ',', @args;
      }
  
      my $pri = $self->{IRC_CMDS}->{$state}->[CMD_PRI];
      $state = uc $state;
      $state .= " $args" if defined $args;
      $kernel->yield(sl_prioritized => $pri, $state );
  
      return;
  }
  
  # Get variables in order for openning a connection
  sub connect {
      my ($kernel, $self, $session, $sender, $args)
          = @_[KERNEL, OBJECT, SESSION, SENDER, ARG0];
  
      if ($args) {
          my %arg;
          %arg = @{ $args } if ref $args eq 'ARRAY';
          %arg = %{ $args } if ref $args eq 'HASH';
          $arg{ lc $_ } = delete $arg{$_} for keys %arg;
          $self->_configure( \%arg );
      }
  
      if ( $self->{resolver} && $self->{res_addresses}
          && @{ $self->{res_addresses} } ) {
          push @{ $self->{res_addresses} }, $self->{server};
          $self->{resolved_server} = shift @{ $self->{res_addresses} };
      }
  
      # try and use non-blocking resolver if needed
      if ( $self->{resolver} && !_ip_get_version( $self->{server} )
          && !$self->{nodns} ) {
          $kernel->yield(
              '_resolve_addresses',
               $self->{server},
               ( $self->{useipv6} && $GOT_SOCKET6 ? 'AAAA' : 'A' ),
          );
      }
      else {
          $kernel->yield('_do_connect');
      }
  
      $self->{INFO}{RealNick} = $self->{nick};
      return;
  }
  
  sub _resolve_addresses {
      my ($kernel, $self, $hostname, $type) = @_[KERNEL, OBJECT, ARG0 .. ARG1];
  
      my $response = $self->{resolver}->resolve(
          event => '_got_dns_response',
          host => $hostname,
          type => $type,
          context => { },
      );
  
      $kernel->yield(_got_dns_response => $response) if $response;
      return;
  }
  
  # open the connection
  sub _do_connect {
      my ($kernel, $self, $session) = @_[KERNEL, OBJECT, SESSION];
      my $domain = AF_INET;
  
      # Disconnect if we're already logged into a server.
      $kernel->call($session => 'quit') if $self->{socket};
  
      if ($self->{socks_proxy} && !$self->{socks_port}) {
          $self->{socks_port} = 1080;
      }
  
      for my $address (qw(socks_proxy proxy server resolved_server use_localaddr)) {
          next if !$self->{$address} || !_ip_is_ipv6( $self->{$address} );
          if (!$GOT_SOCKET6) {
              warn "IPv6 address specified for '$address' but Socket6 not found\n";
              return;
          }
          $domain = AF_INET6;
      }
  
      $self->{socketfactory} = POE::Wheel::SocketFactory->new(
          SocketDomain   => $domain,
          SocketType     => SOCK_STREAM,
          SocketProtocol => 'tcp',
          RemoteAddress  => $self->{socks_proxy} || $self->{proxy} || $self->{resolved_server} || $self->{server},
          RemotePort     => $self->{socks_port} || $self->{proxyport} || $self->{port},
          SuccessEvent   => '_sock_up',
          FailureEvent   => '_sock_failed',
          ($self->{use_localaddr} ? (BindAddress => $self->{use_localaddr}) : ()),
      );
  
      return;
  }
  
  # got response from POE::Component::Client::DNS
  sub _got_dns_response {
      my ($kernel, $self, $response) = @_[KERNEL, OBJECT, ARG0];
  
      my $type = uc $response->{type};
      my $net_dns_packet = $response->{response};
      my $net_dns_errorstring = $response->{error};
      $self->{res_addresses} = [ ];
  
      if (!defined $net_dns_packet) {
          $self->send_event(irc_socketerr => $net_dns_errorstring );
          return;
      }
  
      my @net_dns_answers = $net_dns_packet->answer;
  
      for my $net_dns_answer (@net_dns_answers) {
          next if $net_dns_answer->type !~ /^A/;
          push @{ $self->{res_addresses} }, $net_dns_answer->rdatastr;
      }
  
      if ( !@{ $self->{res_addresses} } && $type eq 'AAAA') {
          $kernel->yield(_resolve_addresses => $self->{server}, 'A');
          return;
      }
  
      if ( !@{ $self->{res_addresses} } ) {
          $self->send_event(irc_socketerr => 'Unable to resolve ' . $self->{server});
          return;
        }
  
      if ( my $address = shift @{ $self->{res_addresses} } ) {
          $self->{resolved_server} = $address;
          $kernel->yield('_do_connect');
          return;
      }
  
      $self->send_event(irc_socketerr => 'Unable to resolve ' . $self->{server});
      return;
  }
  
  # Send a CTCP query or reply, with the same syntax as a PRIVMSG event.
  sub ctcp {
      my ($kernel, $state, $self, $to) = @_[KERNEL, STATE, OBJECT, ARG0];
      my $message = join ' ', @_[ARG1 .. $#_];
  
      if (!defined $to || !defined $message) {
          warn "The '$state' event requires two arguments\n";
          return;
      }
  
      # CTCP-quote the message text.
      ($message) = @{$self->{ircd_compat}->put([ $message ])};
  
      # Should we send this as a CTCP request or reply?
      $state = $state eq 'ctcpreply' ? 'notice' : 'privmsg';
  
      $kernel->yield($state, $to, $message);
      return;
  }
  
  # The way /notify is implemented in IRC clients.
  sub ison {
      my ($kernel, @nicks) = @_[KERNEL, ARG0 .. $#_];
      my $tmp = 'ISON';
  
      if (!@nicks) {
          warn "The 'ison' event requires one or more nicknames\n";
          return;
      }
  
      # We can pass as many nicks as we want, as long as it's shorter than
      # the maximum command length (510). If the list we get is too long,
      # w'll break it into multiple ISON commands.
      while (@nicks) {
          my $nick = shift @nicks;
          if (length($tmp) + length($nick) >= 509) {
              $kernel->yield(sl_high => $tmp);
              $tmp = 'ISON';
          }
          $tmp .= " $nick";
      }
  
      $kernel->yield(sl_high => $tmp);
      return;
  }
  
  # Tell the IRC server to forcibly remove a user from a channel.
  sub kick {
      my ($kernel, $chan, $nick) = @_[KERNEL, ARG0, ARG1];
      my $message = join '', @_[ARG2 .. $#_];
  
      if (!defined $chan || !defined $nick) {
          warn "The 'kick' event requires at least two arguments\n";
          return;
      }
  
      $nick .= " :$message" if defined $message;
      $kernel->yield(sl_high => "KICK $chan $nick");
      return;
  }
  
  # Tell the IRC server to forcibly remove a user from a channel. Freenode extension
  sub remove {
      my ($kernel, $chan, $nick) = @_[KERNEL, ARG0, ARG1];
      my $message = join '', @_[ARG2 .. $#_];
  
      if (!defined $chan || !defined $nick) {
          warn "The 'remove' event requires at least two arguments\n";
          return;
      }
  
      $nick .= " :$message" if defined $message;
      $kernel->yield(sl_high => "REMOVE $chan $nick");
      return;
  }
  
  # Interact with NickServ
  sub nickserv {
      my ($kernel, $self, $state) = @_[KERNEL, OBJECT, STATE];
      my $args = join ' ', @_[ARG0 .. $#_];
  
      my $command = 'NICKSERV';
      my $version = $self->server_version();
      $command = 'NS' if defined $version && $version =~ /ratbox/i;
      $command .= " $args" if defined $args;
  
      $kernel->yield(sl_high => $command);
      return;
  }
  
  # Set up a new IRC component. Deprecated.
  sub new {
      my ($package, $alias) = splice @_, 0, 2;
      croak "$package options should be an even-sized list" if @_ & 1;
      my %options = @_;
  
      if (!defined $alias) {
          croak 'Not enough arguments to POE::Component::IRC::new()';
      }
  
      carp "Use of ${package}->new() is deprecated, please use spawn()";
  
      my $self = $package->spawn ( alias => $alias, options => \%options );
      return $self;
  }
  
  # Set up a new IRC component. New interface.
  sub spawn {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %params = @_;
  
      $params{ lc $_ } = delete $params{$_} for keys %params;
      delete $params{options} if ref $params{options} ne 'HASH';
  
      my $self = bless { }, $package;
      $self->_create();
  
      if ($ENV{POCOIRC_DEBUG}) {
          $params{debug} = 1;
          $params{plugin_debug} = 1;
      }
  
      my $options      = delete $params{options};
      my $alias        = delete $params{alias};
      my $plugin_debug = delete $params{plugin_debug};
  
      $self->_syndicator_init(
          prefix          => 'irc_',
          reg_prefix      => 'PCI_',
          types           => [SERVER => 'S', USER => 'U'],
          alias           => $alias,
          register_signal => 'POCOIRC_REGISTER',
          shutdown_signal => 'POCOIRC_SHUTDOWN',
          object_states   => [
              $self => delete $self->{OBJECT_STATES_HASHREF},
              $self => delete $self->{OBJECT_STATES_ARRAYREF},
          ],
          ($plugin_debug ? (debug => 1) : () ),
          (ref $options eq 'HASH' ? ( options => $options ) : ()),
      );
  
      $params{spawned} = 1;
      $self->_configure(\%params);
  
      if (!$params{nodns} && $GOT_CLIENT_DNS && !$self->{resolver}) {
          $self->{resolver} = POE::Component::Client::DNS->spawn(
              Alias => 'resolver' . $self->session_id()
          );
          $self->{mydns} = 1;
      }
  
      return $self;
  }
  
  # The handler for all IRC commands that take no arguments.
  sub noargs {
      my ($kernel, $state, $arg) = @_[KERNEL, STATE, ARG0];
      my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
  
      if (defined $arg) {
          warn "The '$state' event takes no arguments\n";
          return;
      }
  
      $state = uc $state;
      $kernel->yield(sl_prioritized => $pri, $state);
      return;
  }
  
  # The handler for commands that take one required and two optional arguments.
  sub oneandtwoopt {
      my ($kernel, $state) = @_[KERNEL, STATE];
      my $arg = join '', @_[ARG0 .. $#_];
      my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
  
      $state = 'connect' if $state eq 'sconnect';
      $state = uc $state;
      if (defined $arg) {
          $arg = ':' . $arg if $arg =~ /\x20/;
          $state .= " $arg";
      }
  
      $kernel->yield(sl_prioritized => $pri, $state);
      return;
  }
  
  # The handler for commands that take at least one optional argument.
  sub oneoptarg {
      my ($kernel, $state) = @_[KERNEL, STATE];
      my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
      $state = uc $state;
  
      if (defined $_[ARG0]) {
          my $arg = join '', @_[ARG0 .. $#_];
          $arg = ':' . $arg if $arg =~ /\x20/;
          $state .= " $arg";
      }
  
      $kernel->yield(sl_prioritized => $pri, $state);
      return;
  }
  
  # The handler for commands which take one required and one optional argument.
  sub oneortwo {
      my ($kernel, $state, $one) = @_[KERNEL, STATE, ARG0];
      my $two = join '', @_[ARG1 .. $#_];
      my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
  
      if (!defined $one) {
          warn "The '$state' event requires at least one argument\n";
          return;
      }
  
      $state = uc( $state ) . " $one";
      $state .= " $two" if defined $two;
      $kernel->yield(sl_prioritized => $pri, $state);
      return;
  }
  
  # Handler for commands that take exactly one argument.
  sub onlyonearg {
      my ($kernel, $state) = @_[KERNEL, STATE];
      my $arg = join '', @_[ARG0 .. $#_];
      my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
  
      if (!defined $arg) {
          warn "The '$state' event requires one argument\n";
          return;
      }
  
      $state = uc $state;
      $arg = ':' . $arg if $arg =~ /\x20/;
      $state .= " $arg";
      $kernel->yield(sl_prioritized => $pri, $state);
      return;
  }
  
  # Handler for commands that take exactly two arguments.
  sub onlytwoargs {
      my ($kernel, $state, $one) = @_[KERNEL, STATE, ARG0];
      my ($two) = join '', @_[ARG1 .. $#_];
      my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
  
      if (!defined $one || !defined $two) {
          warn "The '$state' event requires two arguments\n";
          return;
      }
  
      $state = uc $state;
      $two = ':' . $two if $two =~ /\x20/;
      $state .= " $one $two";
      $kernel->yield(sl_prioritized => $pri, $state);
      return;
  }
  
  # Handler for privmsg or notice events.
  sub privandnotice {
      my ($kernel, $state, $to, $msg) = @_[KERNEL, STATE, ARG0, ARG1];
      my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
  
      $state =~ s/privmsglo/privmsg/;
      $state =~ s/privmsghi/privmsg/;
      $state =~ s/noticelo/notice/;
      $state =~ s/noticehi/notice/;
  
      if (!defined $to || !defined $msg) {
          warn "The '$state' event requires two arguments\n";
          return;
      }
  
      $to = join ',', @$to if ref $to eq 'ARRAY';
      $state = uc $state;
  
      $kernel->yield(sl_prioritized => $pri, "$state $to :$msg");
      return;
  }
  
  # Tell the IRC session to go away.
  sub shutdown {
      my ($kernel, $self, $sender, $session) = @_[KERNEL, OBJECT, SENDER, SESSION];
      return if $self->{_shutdown};
      $self->{_shutdown} = $sender->ID();
  
      if ($self->logged_in()) {
          my ($msg, $timeout) = @_[ARG0, ARG1];
          $msg = '' if !defined $msg;
          $timeout = 5 if !defined $timeout;
          $msg = ":$msg" if $msg =~ /\x20/;
          my $cmd = "QUIT $msg";
          $kernel->call($session => sl_high => $cmd);
          $kernel->delay('_quit_timeout', $timeout);
          $self->{_waiting} = 1;
      }
      elsif ($self->connected()) {
          $self->disconnect();
      }
      else {
          $self->_shutdown();
      }
  
      return;
  }
  
  sub _quit_timeout {
      my ($self) = $_[OBJECT];
      $self->disconnect();
      return;
  }
  
  sub _shutdown {
      my ($self) = @_;
  
      $self->_syndicator_destroy($self->{_shutdown});
      delete $self->{$_} for qw(socketfactory dcc wheelmap);
      $self->{resolver}->shutdown() if $self->{resolver} && $self->{mydns};
      return;
  }
  
  # Send a line of login-priority IRC output.  These are things which
  # must go first.
  sub sl_login {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      my $arg = join ' ', @_[ARG0 .. $#_];
      $kernel->yield(sl_prioritized => PRI_LOGIN, $arg );
      return;
  }
  
  # Send a line of high-priority IRC output.  Things like channel/user
  # modes, kick messages, and whatever.
  sub sl_high {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      my $arg = join ' ', @_[ARG0 .. $#_];
      $kernel->yield(sl_prioritized => PRI_HIGH, $arg );
      return;
  }
  
  # Send a line of normal-priority IRC output to the server.  PRIVMSG
  # and other random chatter.  Uses sl() for compatibility with existing
  # code.
  sub sl {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      my $arg = join ' ', @_[ARG0 .. $#_];
      $kernel->yield(sl_prioritized => PRI_NORMAL, $arg );
      return;
  }
  
  # Prioritized sl().  This keeps the queue ordered by priority, low to
  # high in the UNIX tradition.  It also throttles transmission
  # following the hybrid ircd's algorithm, so you can't accidentally
  # flood yourself off.  Thanks to Raistlin for explaining how ircd
  # throttles messages.
  sub sl_prioritized {
      my ($kernel, $self, $priority, @args) = @_[KERNEL, OBJECT, ARG0, ARG1];
  
      if (my ($event) = $args[0] =~ /^(\w+)/ ) {
          # Let the plugin system process this
          return 1 if $self->send_user_event($event, \@args) == PCI_EAT_ALL;
      }
      else {
          warn "Unable to extract the event name from '$args[0]'\n";
      }
  
      my $msg = $args[0];
      my $now = time();
      $self->{send_time} = $now if $self->{send_time} < $now;
  
      # if we find a newline in the message, take that to be the end of it
      $msg =~ s/[\015\012].*//s;
  
      if (bytes::length($msg) > $self->{msg_length} - bytes::length($self->nick_name())) {
          $msg = bytes::substr($msg, 0, $self->{msg_length} - bytes::length($self->nick_name()));
      }
  
      if (@{ $self->{send_queue} }) {
          my $i = @{ $self->{send_queue} };
          $i-- while ($i && $priority < $self->{send_queue}->[$i-1]->[MSG_PRI]);
          splice( @{ $self->{send_queue} }, $i, 0, [ $priority, $msg ] );
      }
      elsif ( !$self->{flood} && $self->{send_time} - $now >= 10
          || !defined $self->{socket} ) {
          push( @{$self->{send_queue}}, [ $priority, $msg ] );
          $kernel->delay( sl_delayed => $self->{send_time} - $now - 10 );
      }
      else {
          warn ">>> $msg\n" if $self->{debug};
          $self->send_event(irc_raw_out => $msg) if $self->{raw};
          $self->{send_time} += 2 + length($msg) / 120;
          $self->{socket}->put($msg);
      }
  
      return;
  }
  
  # Send delayed lines to the ircd.  We manage a virtual "send time"
  # that progresses into the future based on hybrid ircd's rules every
  # time a message is sent.  Once we find it ten or more seconds into
  # the future, we wait for the realtime clock to catch up.
  sub sl_delayed {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
  
      return if !defined $self->{socket};
  
      my $now = time();
      $self->{send_time} = $now if $self->{send_time} < $now;
  
      while (@{ $self->{send_queue} } && ($self->{send_time} - $now < 10)) {
          my $arg = (shift @{$self->{send_queue}})->[MSG_TEXT];
          warn ">>> $arg\n" if $self->{debug};
          $self->send_event(irc_raw_out => $arg) if $self->{raw};
          $self->{send_time} += 2 + length($arg) / 120;
          $self->{socket}->put($arg);
      }
  
      if (@{ $self->{send_queue} }) {
          $kernel->delay( sl_delayed => $self->{send_time} - $now - 10 );
      }
  
      return;
  }
  
  # The handler for commands which have N arguments, separated by spaces.
  sub spacesep {
      my ($kernel, $state) = @_[KERNEL, STATE];
      my $args = join ' ', @_[ARG0 .. $#_];
      my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
  
      $state = uc $state;
      $state .= " $args" if defined $args;
      $kernel->yield(sl_prioritized => $pri, $state );
      return;
  }
  
  # Set or query the current topic on a channel.
  sub topic {
      my ($kernel, $chan, @args) = @_[KERNEL, ARG0..$#_];
      my $topic;
      $topic = join '', @args if @args;
  
      if (defined $topic) {
          $chan .= " :";
          $chan .= $topic if length $topic;
      }
  
      $kernel->yield(sl_prioritized => PRI_NORMAL, "TOPIC $chan");
      return;
  }
  
  # Asks the IRC server for some random information about particular nicks.
  sub userhost {
      my ($kernel, @nicks) = @_[KERNEL, ARG0 .. $#_];
  
      if (!@nicks) {
          warn "The 'userhost' event requires at least one nickname\n";
          return;
      }
  
      # According to the RFC, you can only send 5 nicks at a time.
      while (@nicks) {
          $kernel->yield(
              'sl_prioritized',
              PRI_HIGH,
              'USERHOST ' . join(' ', splice(@nicks, 0, 5)),
          );
      }
  
      return;
  }
  
  # Non-event methods
  
  sub server {
      my ($self) = @_;
      return $self->{server};
  }
  
  sub port {
      my ($self) = @_;
      return $self->{port};
  }
  
  sub server_name {
      my ($self) = @_;
      return $self->{INFO}{ServerName};
  }
  
  sub server_version {
      my ($self) = @_;
      return $self->{INFO}{ServerVersion};
  }
  
  sub localaddr {
      my ($self) = @_;
      return $self->{localaddr};
  }
  
  sub nick_name {
      my ($self) = @_;
      return $self->{INFO}{RealNick};
  }
  
  sub send_queue {
      my ($self) = @_;
  
      if (defined $self->{send_queue} && ref $self->{send_queue} eq 'ARRAY' ) {
          return scalar @{ $self->{send_queue} };
      }
      return;
  }
  
  sub raw_events {
      my ($self, $value) = @_;
      return $self->{raw} if !defined $value;
      $self->{raw} = $value;
      return;
  }
  
  sub connected {
      my ($self) = @_;
      return $self->{connected};
  }
  
  sub logged_in {
      my ($self) = @_;
      return 1 if $self->{INFO}{LoggedIn};
      return;
  }
  
  sub _compress_uplink {
      my ($self, $value) = @_;
  
      return if !$GOT_ZLIB;
      return $self->{uplink} if !defined $value;
  
      if ($value) {
          $self->{out_filter}->unshift( POE::Filter::Zlib::Stream->new() ) if !$self->{uplink};
          $self->{uplink} = 1;
      }
      else {
          $self->{out_filter}->shift() if $self->{uplink};
          $self->{uplink} = 0;
      }
  
      return $self->{uplink};
  }
  
  sub _compress_downlink {
      my ($self, $value) = @_;
  
      return if !$GOT_ZLIB;
      return $self->{downlink} if !defined $value;
  
      if ($value) {
          $self->{srv_filter}->unshift( POE::Filter::Zlib::Stream->new() ) if !$self->{downlink};
          $self->{downlink} = 1;
      }
      else {
          $self->{srv_filter}->shift() if $self->{uplink};
          $self->{downlink} = 0;
      }
  
      return $self->{downlink};
  }
  
  sub S_001 {
      my ($self, $irc) = splice @_, 0, 2;
      $self->{INFO}{ServerName} = ${ $_[0] };
      $self->{INFO}{LoggedIn}   = 1;
      return PCI_EAT_NONE;
  }
  
  sub S_004 {
      my ($self, $irc) = splice @_, 0, 2;
      my $args = ${ $_[2] };
      $self->{INFO}{ServerVersion} = $args->[1];
      return PCI_EAT_NONE;
  }
  
  sub S_error {
      my ($self, $irc) = splice @_, 0, 2;
      $self->{INFO}{LoggedIn} = 0;
      return PCI_EAT_NONE;
  }
  
  sub S_disconnected {
      my ($self, $irc) = splice @_, 0, 2;
      $self->{INFO}{LoggedIn} = 0;
  
      if ($self->{_waiting}) {
          $poe_kernel->delay('_quit_timeout');
          delete $self->{_waiting};
      }
  
      $self->_shutdown() if $self->{_shutdown};
      return PCI_EAT_NONE;
  }
  
  sub S_shutdown {
      my ($self, $irc) = splice @_, 0, 2;
      $self->{INFO}{LoggedIn} = 0;
      return PCI_EAT_NONE;
  }
  
  # Automatically replies to a PING from the server. Do not confuse this
  # with CTCP PINGs, which are a wholly different animal that evolved
  # much later on the technological timeline.
  sub S_ping {
      my ($self, $irc) = splice @_, 0, 2;
      my $arg = ${ $_[0] };
      $irc->yield(sl_login => "PONG :$arg");
      return PCI_EAT_NONE;
  }
  
  # NICK messages for the purposes of determining our current nickname
  sub S_nick {
      my ($self, $irc) = splice @_, 0, 2;
      my $nick = ( split /!/, ${ $_[0] } )[0];
      my $new = ${ $_[1] };
      $self->{INFO}{RealNick} = $new if ( $nick eq $self->{INFO}{RealNick} );
      return PCI_EAT_NONE;
  }
  
  # tell POE::Filter::IRC::Compat to handle IDENTIFY-MSG
  sub S_290 {
      my ($self, $irc) = splice @_, 0, 2;
      my $text = ${ $_[1] };
      $self->{ircd_compat}->identifymsg(1) if $text eq 'IDENTIFY-MSG';
      return PCI_EAT_NONE;
  }
  
  sub S_cap {
      my ($self, $irc) = splice @_, 0, 2;
      my $cmd = ${ $_[0] };
  
      if ($cmd eq 'ACK') {
          my $list = ${ $_[1] } eq '*' ? ${ $_[2] } : ${ $_[1] };
          my @enabled = split / /, $list;
  
          if (grep { $_ =~ /^=?identify-msg$/ } @enabled) {
              $self->{ircd_compat}->identifymsg(1);
          }
          if (grep { $_ =~ /^-identify-msg$/ } @enabled) {
              $self->{ircd_compat}->identifymsg(0);
          }
      }
      return PCI_EAT_NONE;
  }
  
  sub S_isupport {
      my ($self, $irc) = splice @_, 0, 2;
      my $isupport = ${ $_[0] };
      $self->{ircd_compat}->chantypes( $isupport->isupport('CHANTYPES') || [ '#', '&' ] );
      $irc->yield(sl_login => 'CAPAB IDENTIFY-MSG') if $isupport->isupport('CAPAB');
      $irc->yield(sl_login => 'PROTOCTL NAMESX') if $isupport->isupport('NAMESX');
      $irc->yield(sl_login => 'PROTOCTL UHNAMES') if $isupport->isupport('UHNAMES');
      return PCI_EAT_NONE;
  }
  
  # accesses the ISupport plugin
  sub isupport {
      my ($self, @args) = @_;
      return $self->{isupport}->isupport(@args);
  }
  
  sub isupport_dump_keys {
      return $_[0]->{isupport}->isupport_dump_keys();
  }
  
  sub resolver {
      return $_[0]->{resolver};
  }
  
  sub _ip_get_version {
      my ($ip) = @_;
      return if !defined $ip;
  
      # If the address does not contain any ':', maybe it's IPv4
      return 4 if $ip !~ /:/ && _ip_is_ipv4($ip);
  
      # Is it IPv6 ?
      return 6 if _ip_is_ipv6($ip);
  
      return;
  }
  
  sub _ip_is_ipv4 {
      my ($ip) = @_;
      return if !defined $ip;
  
      # Check for invalid chars
      return if $ip !~ /^[\d\.]+$/;
      return if $ip =~ /^\./;
      return if $ip =~ /\.$/;
  
      # Single Numbers are considered to be IPv4
      return 1 if $ip =~ /^(\d+)$/ && $1 < 256;
  
      # Count quads
      my $n = ($ip =~ tr/\./\./);
  
      # IPv4 must have from 1 to 4 quads
      return if $n <= 0 || $n > 4;
  
      # Check for empty quads
      return if $ip =~ /\.\./;
  
      for my $quad (split /\./, $ip) {
          # Check for invalid quads
          return if $quad < 0 || $quad >= 256;
      }
      return 1;
  }
  
  sub _ip_is_ipv6 {
      my ($ip) = @_;
      return if !defined $ip;
  
      # Count octets
      my $n = ($ip =~ tr/:/:/);
      return if ($n <= 0 || $n >= 8);
  
      # $k is a counter
      my $k;
  
      for my $octet (split /:/, $ip) {
          $k++;
  
          # Empty octet ?
          next if $octet eq '';
  
          # Normal v6 octet ?
          next if $octet =~ /^[a-f\d]{1,4}$/i;
  
          # Last octet - is it IPv4 ?
          if ($k == $n + 1) {
              next if (ip_is_ipv4($octet));
          }
  
          return;
      }
  
      # Does the IP address start with : ?
      return if $ip =~ m/^:[^:]/;
  
      # Does the IP address finish with : ?
      return if $ip =~ m/[^:]:$/;
  
      # Does the IP address have more than one '::' pattern ?
      return if $ip =~ s/:(?=:)//g > 1;
  
      return 1;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC - A fully event-driven IRC client module
  
  =head1 SYNOPSIS
  
   # A simple Rot13 'encryption' bot
  
   use strict;
   use warnings;
   use POE qw(Component::IRC);
  
   my $nickname = 'Flibble' . $$;
   my $ircname  = 'Flibble the Sailor Bot';
   my $server   = 'irc.perl.org';
  
   my @channels = ('#Blah', '#Foo', '#Bar');
  
   # We create a new PoCo-IRC object
   my $irc = POE::Component::IRC->spawn(
      nick => $nickname,
      ircname => $ircname,
      server  => $server,
   ) or die "Oh noooo! $!";
  
   POE::Session->create(
       package_states => [
           main => [ qw(_default _start irc_001 irc_public) ],
       ],
       heap => { irc => $irc },
   );
  
   $poe_kernel->run();
  
   sub _start {
       my $heap = $_[HEAP];
  
       # retrieve our component's object from the heap where we stashed it
       my $irc = $heap->{irc};
  
       $irc->yield( register => 'all' );
       $irc->yield( connect => { } );
       return;
   }
  
   sub irc_001 {
       my $sender = $_[SENDER];
  
       # Since this is an irc_* event, we can get the component's object by
       # accessing the heap of the sender. Then we register and connect to the
       # specified server.
       my $irc = $sender->get_heap();
  
       print "Connected to ", $irc->server_name(), "\n";
  
       # we join our channels
       $irc->yield( join => $_ ) for @channels;
       return;
   }
  
   sub irc_public {
       my ($sender, $who, $where, $what) = @_[SENDER, ARG0 .. ARG2];
       my $nick = ( split /!/, $who )[0];
       my $channel = $where->[0];
  
       if ( my ($rot13) = $what =~ /^rot13 (.+)/ ) {
           $rot13 =~ tr[a-zA-Z][n-za-mN-ZA-M];
           $irc->yield( privmsg => $channel => "$nick: $rot13" );
       }
       return;
   }
  
   # We registered for all events, this will produce some debug info.
   sub _default {
       my ($event, $args) = @_[ARG0 .. $#_];
       my @output = ( "$event: " );
  
       for my $arg (@$args) {
           if ( ref $arg eq 'ARRAY' ) {
               push( @output, '[' . join(', ', @$arg ) . ']' );
           }
           else {
               push ( @output, "'$arg'" );
           }
       }
       print join ' ', @output, "\n";
       return;
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC is a POE component (who'd have guessed?) which
  acts as an easily controllable IRC client for your other POE
  components and sessions. You create an IRC component and tell it what
  events your session cares about and where to connect to, and it sends
  back interesting IRC events when they happen. You make the client do
  things by sending it events. That's all there is to it. Cool, no?
  
  [Note that using this module requires some familiarity with the
  details of the IRC protocol. I'd advise you to read up on the gory
  details of RFC 1459 (L<http://www.faqs.org/rfcs/rfc1459.html>) before you
  get started. Keep the list of server numeric codes handy while you
  program. Needless to say, you'll also need a good working knowledge of
  POE, or this document will be of very little use to you.]
  
  The POE::Component::IRC distribution has a F<docs/> folder with a collection of
  salient documentation including the pertinent RFCs.
  
  POE::Component::IRC consists of a POE::Session that manages the IRC connection
  and dispatches C<irc_> prefixed events to interested sessions and
  an object that can be used to access additional information using methods.
  
  Sessions register their interest in receiving C<irc_> events by sending
  L<C<register>|/register> to the component. One would usually do this in
  your C<_start> handler. Your session will continue to receive events until
  you L<C<unregister>|/unregister>. The component will continue to stay
  around until you tell it not to with L<C<shutdown>|/shutdown>.
  
  The L<SYNOPSIS|/SYNOPSIS> demonstrates a fairly basic bot.
  
  See L<POE::Component::IRC::Cookbook|POE::Component::IRC::Cookbook> for more
  examples.
  
  =head2 Useful subclasses
  
  Included with POE::Component::IRC are a number of useful subclasses. As they
  are subclasses they support all the methods, etc. documented here and have
  additional methods and quirks which are documented separately:
  
  =over 4
  
  =item * L<POE::Component::IRC::State|POE::Component::IRC::State>
  
  POE::Component::IRC::State provides all the functionality of POE::Component::IRC
  but also tracks IRC state entities such as nicks and channels.
  
  =item * L<POE::Component::IRC::Qnet|POE::Component::IRC::Qnet>
  
  POE::Component::IRC::Qnet is POE::Component::IRC tweaked for use on Quakenet IRC
  network.
  
  =item * L<POE::Component::IRC::Qnet::State|POE::Component::IRC::Qnet::State>
  
  POE::Component::IRC::Qnet::State is a tweaked version of POE::Component::IRC::State
  for use on the Quakenet IRC network.
  
  =back
  
  =head2 The Plugin system
  
  As of 3.7, PoCo-IRC sports a plugin system. The documentation for it can be
  read by looking at L<POE::Component::IRC::Plugin|POE::Component::IRC::Plugin>.
  That is not a subclass, just a placeholder for documentation!
  
  A number of useful plugins have made their way into the core distribution:
  
  =over 4
  
  =item * L<POE::Component::IRC::Plugin::DCC|POE::Component::IRC::Plugin::DCC>
  
  Provides DCC support. Loaded by default.
  
  =item * L<POE::Component::IRC::Plugin::AutoJoin|POE::Component::IRC::Plugin::AutoJoin>
  
  Keeps you on your favorite channels throughout reconnects and even kicks.
  
  =item * L<POE::Component::IRC::Plugin::Connector|POE::Component::IRC::Plugin::Connector>
  
  Glues an irc bot to an IRC network, i.e. deals with maintaining ircd connections.
  
  =item * L<POE::Component::IRC::Plugin::BotTraffic|POE::Component::IRC::Plugin::BotTraffic>
  
  Under normal circumstances irc bots do not normal the msgs and public msgs that
  they generate themselves. This plugin enables you to handle those events.
  
  =item * L<POE::Component::IRC::Plugin::BotAddressed|POE::Component::IRC::Plugin::BotAddressed>
  
  Generates C<irc_bot_addressed> / C<irc_bot_mentioned> / C<irc_bot_mentioned_action>
  events whenever your bot's name comes up in channel discussion.
  
  =item * L<POE::Component::IRC::Plugin::BotCommand|POE::Component::IRC::Plugin::BotCommand>
  
  Provides an easy way to handle commands issued to your bot.
  
  =item * L<POE::Component::IRC::Plugin::Console|POE::Component::IRC::Plugin::Console>
  
  See inside the component. See what events are being sent. Generate irc commands
  manually. A TCP based console.
  
  =item * L<POE::Component::IRC::Plugin::FollowTail|POE::Component::IRC::Plugin::FollowTail>
  
  Follow the tail of an ever-growing file.
  
  =item * L<POE::Component::IRC::Plugin::Logger|POE::Component::IRC::Plugin::Logger>
  
  Log public and private messages to disk.
  
  =item * L<POE::Component::IRC::Plugin::NickServID|POE::Component::IRC::Plugin::NickServID>
  
  Identify with NickServ when needed.
  
  =item * L<POE::Component::IRC::Plugin::Proxy|POE::Component::IRC::Plugin::Proxy>
  
  A lightweight IRC proxy/bouncer.
  
  =item * L<POE::Component::IRC::Plugin::CTCP|POE::Component::IRC::Plugin::CTCP>
  
  Automagically generates replies to ctcp version, time and userinfo queries.
  
  =item * L<POE::Component::IRC::Plugin::PlugMan|POE::Component::IRC::Plugin::PlugMan>
  
  An experimental Plugin Manager plugin.
  
  =item * L<POE::Component::IRC::Plugin::NickReclaim|POE::Component::IRC::Plugin::NickReclaim>
  
  Automagically deals with your nickname being in use and reclaiming it.
  
  =item * L<POE::Component::IRC::Plugin::CycleEmpty|POE::Component::IRC::Plugin::CycleEmpty>
  
  Cycles (parts and rejoins) channels if they become empty and opless, in order
  to gain ops.
  
  =back
  
  =head1 CONSTRUCTORS
  
  Both constructors return an object. The object is also available within 'irc_'
  event handlers by using C<< $_[SENDER]->get_heap() >>. See also
  L<C<register>|/register> and L<C<irc_registered>|/irc_registered>.
  
  =head2 C<spawn>
  
  Takes a number of arguments, all of which are optional. All the options
  below may be supplied to the L<C<connect>|/connect> input event as well,
  except for B<'alias'>, B<'options'>, B<'NoDNS'>, B<'debug'>, and
  B<'plugin_debug'>.
  
  =over 4
  
  =item * B<'alias'>, a name (kernel alias) that this instance will be known
  by;
  
  =item * B<'options'>, a hashref containing L<POE::Session|POE::Session>
  options;
  
  =item * B<'Server'>, the server name;
  
  =item * B<'Port'>, the remote port number;
  
  =item * B<'Password'>, an optional password for restricted servers;
  
  =item * B<'Nick'>, your client's IRC nickname;
  
  =item * B<'Username'>, your client's username;
  
  =item * B<'Ircname'>, some cute comment or something.
  
  =item * B<'Bitmode'>, an integer representing your initial user modes set
  in the USER command. See RFC 2812. If you do not set this, C<8> (+i) will
  be used.
  
  =item *  B<'UseSSL'>, set to some true value if you want to connect using
  SSL.
  
  =item *  B<'SSLCert'>, set to a SSL Certificate(PAM encoded) to connect using a client cert
  
  =item *  B<'SSLKey'>, set to a SSL Key(PAM encoded) to connect using a client cert
  
  =item *  B<'SSLCtx'>, set to a SSL Context to configure the SSL Connection
  
  The B<'SSLCert'> and B<'SSLKey'> both need to be specified. The B<'SSLCtx'> takes precedence specified.
  
  =item * B<'Raw'>, set to some true value to enable the component to send
  L<C<irc_raw>|/irc_raw> and L<C<irc_raw_out>|/irc_raw_out> events.
  
  =item * B<'LocalAddr'>, which local IP address on a multihomed box to
  connect as;
  
  =item * B<'LocalPort'>, the local TCP port to open your socket on;
  
  =item * B<'NoDNS'>, set this to 1 to disable DNS lookups using
  PoCo-Client-DNS. (See note below).
  
  =item * B<'Flood'>, when true, it disables the component's flood
  protection algorithms, allowing it to send messages to an IRC server at
  full speed. Disconnects and k-lines are some common side effects of
  flooding IRC servers, so care should be used when enabling this option.
  Default is false.
  
  Two new attributes are B<'Proxy'> and B<'ProxyPort'> for sending your
  =item * B<'Proxy'>, IP address or server name of a proxy server to use.
  
  =item * B<'ProxyPort'>, which tcp port on the proxy to connect to.
  
  =item * B<'NATAddr'>, what other clients see as your IP address.
  
  =item * B<'DCCPorts'>, an arrayref containing tcp ports that can be used
  for DCC sends.
  
  =item * B<'Resolver'>, provide a L<POE::Component::Client::DNS|POE::Component::Client::DNS> object for the component to use.
  
  =item * B<'msg_length'>, the maximum length of IRC messages, in bytes.
  Default is 450. The IRC component shortens all messages longer than this
  value minus the length of your current nickname. IRC only allows raw
  protocol lines messages that are 512 bytes or shorter, including the
  trailing "\r\n". This is most relevant to long PRIVMSGs. The IRC component
  can't be sure how long your user@host mask will be every time you send a
  message, considering that most networks mangle the 'user' part and some
  even replace the whole string (think FreeNode cloaks). If you have an
  unusually long user@host mask you might want to decrease this value if
  you're prone to sending long messages. Conversely, if you have an
  unusually short one, you can increase this value if you want to be able to
  send as long a message as possible. Be careful though, increase it too
  much and the IRC server might disconnect you with a "Request too long"
  message when you try to send a message that's too long.
  
  =item * B<'debug'>, if set to a true value causes the IRC component to
  print every message sent to and from the server, as well as print some
  warnings when it receives malformed messages. This option will be enabled
  if the C<POCOIRC_DEBUG> environment variable is set to a true value.
  
  =item * B<'plugin_debug'>, set to some true value to print plugin debug
  info, default 0. Plugins are processed inside an eval. When you enable
  this option, you will be notified when (and why) a plugin raises an
  exception. This option will be enabled if the C<POCOIRC_DEBUG> environment
  variable is set to a true value.
  
  =item * B<'socks_proxy'>, specify a SOCKS4/SOCKS4a proxy to use.
  
  =item * B<'socks_port'>, the SOCKS port to use, defaults to 1080 if not
  specified.
  
  =item * B<'socks_id'>, specify a SOCKS user_id. Default is none.
  
  =item * B<'useipv6'>, enable the use of IPv6 for connections.
  
  =back
  
  C<spawn> will supply reasonable defaults for any of these attributes
  which are missing, so don't feel obliged to write them all out.
  
  If the component finds that L<POE::Component::Client::DNS|POE::Component::Client::DNS>
  is installed it will use that to resolve the server name passed. Disable
  this behaviour if you like, by passing: C<< NoDNS => 1 >>.
  
  IRC traffic through a proxy server. B<'Proxy'>'s value should be the IP
  address or server name of the proxy. B<'ProxyPort'>'s value should be the
  port on the proxy to connect to. L<C<connect>|/connect> will default
  to using the I<actual> IRC server's port if you provide a proxy but omit
  the proxy's port. These are for HTTP Proxies. See B<'socks_proxy'> for
  SOCKS4 and SOCKS4a support.
  
  For those people who run bots behind firewalls and/or Network Address
  Translation there are two additional attributes for DCC. B<'DCCPorts'>,
  is an arrayref of ports to use when initiating DCC connections.
  B<'NATAddr'>, is the NAT'ed IP address that your bot is hidden behind,
  this is sent whenever you do DCC.
  
  SSL support requires L<POE::Component::SSLify|POE::Component::SSLify>, as
  well as an IRC server that supports SSL connections. If you're missing
  POE::Component::SSLify, specifying B<'UseSSL'> will do nothing. The
  default is to not try to use SSL.
  
  B<'Resolver'>, requires a L<POE::Component::Client::DNS|POE::Component::Client::DNS>
  object. Useful when spawning multiple poco-irc sessions, saves the
  overhead of multiple dns sessions.
  
  B<'NoDNS'> has different results depending on whether it is set with
  L<C<spawn>|/spawn> or L<C<connect>|/connect>. Setting it with
  C<spawn>, disables the creation of the POE::Component::Client::DNS
  completely. Setting it with L<C<connect>|/connect> on the other hand
  allows the PoCo-Client-DNS session to be spawned, but will disable
  any dns lookups using it.
  
  SOCKS4 proxy support is provided by B<'socks_proxy'>, B<'socks_port'> and
  B<'socks_id'> parameters. If something goes wrong with the SOCKS connection
  you should get a warning on STDERR. This is fairly experimental currently.
  
  IPv6 support is available for connecting to IPv6 enabled ircds (it won't
  work for DCC though). To enable it, specify B<'useipv6'>. Perl >=5.14 or
  L<Socket6|Socket6> (for older Perls) is required. If you that and
  L<POE::Component::Client::DNS|POE::Component::Client::DNS> installed and
  specify a hostname that resolves to an IPv6 address then IPv6 will be used.
  If you specify an ipv6 B<'localaddr'> then IPv6 will be used.
  
  =head2 C<new>
  
  This method is deprecated. See the L<C<spawn>|/spawn> method instead.
  The first argument should be a name (kernel alias) which this new
  connection will be known by. Optionally takes more arguments (see
  L<C<spawn>|/spawn> as name/value pairs. Returns a POE::Component::IRC
  object. :)
  
  B<Note:> Use of this method will generate a warning. There are currently no
  plans to make it die() >;]
  
  =head1 METHODS
  
  =head2 Information
  
  =head3 C<server>
  
  Takes no arguments. Returns the server host we are currently connected to
  (or trying to connect to).
  
  =head3 C<port>
  
  Takes no arguments. Returns the server port we are currently connected to
  (or trying to connect to).
  
  =head3 C<server_name>
  
  Takes no arguments. Returns the name of the IRC server that the component
  is currently connected to.
  
  =head3 C<server_version>
  
  Takes no arguments. Returns the IRC server version.
  
  =head3 C<nick_name>
  
  Takes no arguments. Returns a scalar containing the current nickname that the
  bot is using.
  
  =head3 C<localaddr>
  
  Takes no arguments. Returns the IP address being used.
  
  =head3 C<send_queue>
  
  The component provides anti-flood throttling. This method takes no arguments
  and returns a scalar representing the number of messages that are queued up
  waiting for dispatch to the irc server.
  
  =head3 C<logged_in>
  
  Takes no arguments. Returns true or false depending on whether the IRC
  component is logged into an IRC network.
  
  =head3 C<connected>
  
  Takes no arguments. Returns true or false depending on whether the component's
  socket is currently connected.
  
  =head3 C<disconnect>
  
  Takes no arguments. Terminates the socket connection disgracefully >;o]
  
  =head3 C<isupport>
  
  Takes one argument, a server capability to query. Returns C<undef> on failure
  or a value representing the applicable capability. A full list of capabilities
  is available at L<http://www.irc.org/tech_docs/005.html>.
  
  =head3 C<isupport_dump_keys>
  
  Takes no arguments, returns a list of the available server capabilities keys,
  which can be used with L<C<isupport>|/isupport>.
  
  =head3 C<resolver>
  
  Returns a reference to the L<POE::Component::Client::DNS|POE::Component::Client::DNS>
  object that is internally created by the component.
  
  =head2 Events
  
  =head3 C<session_id>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/session_id>>
  
  Takes no arguments. Returns the ID of the component's session. Ideal for posting
  events to the component.
  
   $kernel->post($irc->session_id() => 'mode' => $channel => '+o' => $dude);
  
  =head3 C<session_alias>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/session_alias>>
  
  Takes no arguments. Returns the session alias that has been set through
  L<C<spawn>|/spawn>'s B<'alias'> argument.
  
  =head3 C<raw_events>
  
  With no arguments, returns true or false depending on whether
  L<C<irc_raw>|/irc_raw> and L<C<irc_raw_out>|/irc_raw_out> events are being generated
  or not. Provide a true or false argument to enable or disable this feature
  accordingly.
  
  =head3 C<yield>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/yield>>
  
  This method provides an alternative object based means of posting events to the
  component. First argument is the event to post, following arguments are sent as
  arguments to the resultant post.
  
   $irc->yield(mode => $channel => '+o' => $dude);
  
  =head3 C<call>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/call>>
  
  This method provides an alternative object based means of calling events to the
  component. First argument is the event to call, following arguments are sent as
  arguments to the resultant
  call.
  
   $irc->call(mode => $channel => '+o' => $dude);
  
  =head3 C<delay>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/delay>>
  
  This method provides a way of posting delayed events to the component. The
  first argument is an arrayref consisting of the delayed command to post and
  any command arguments. The second argument is the time in seconds that one
  wishes to delay the command being posted.
  
   my $alarm_id = $irc->delay( [ mode => $channel => '+o' => $dude ], 60 );
  
  Returns an alarm ID that can be used with L<C<delay_remove>|/delay_remove>
  to cancel the delayed event. This will be undefined if something went wrong.
  
  =head3 C<delay_remove>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/delay_remove>>
  
  This method removes a previously scheduled delayed event from the component.
  Takes one argument, the C<alarm_id> that was returned by a
  L<C<delay>|/delay> method call.
  
   my $arrayref = $irc->delay_remove( $alarm_id );
  
  Returns an arrayref that was originally requested to be delayed.
  
  =head3 C<send_event>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/send_event>>
  
  Sends an event through the component's event handling system. These will get
  processed by plugins then by registered sessions. First argument is the event
  name, followed by any parameters for that event.
  
  =head3 C<send_event_next>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/send_event_next>>
  
  This sends an event right after the one that's currently being processed.
  Useful if you want to generate some event which is directly related to
  another event so you want them to appear together. This method can only be
  called when POE::Component::IRC is processing an event, e.g. from one of your
  event handlers. Takes the same arguments as L<C<send_event>|/send_event>.
  
  =head3 C<send_event_now>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/send_event_now>>
  
  This will send an event to be processed immediately. This means that if an
  event is currently being processed and there are plugins or sessions which
  will receive it after you do, then an event sent with C<send_event_now> will
  be received by those plugins/sessions I<before> the current event. Takes the
  same arguments as L<C<send_event>|/send_event>.
  
  =head2 Plugins
  
  =head3 C<pipeline>
  
  I<Inherited from L<Object::Pluggable|Object::Pluggable/pipeline>>
  
  Returns the L<Object::Pluggable::Pipeline|Object::Pluggable::Pipeline>
  object.
  
  =head3 C<plugin_add>
  
  I<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_add>>
  
  Accepts two arguments:
  
   The alias for the plugin
   The actual plugin object
   Any number of extra arguments
  
  The alias is there for the user to refer to it, as it is possible to have
  multiple plugins of the same kind active in one Object::Pluggable object.
  
  This method goes through the pipeline's C<push()> method, which will call
  C<< $plugin->plugin_register($pluggable, @args) >>.
  
  Returns the number of plugins now in the pipeline if plugin was initialized,
  C<undef>/an empty list if not.
  
  =head3 C<plugin_del>
  
  I<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_del>>
  
  Accepts the following arguments:
  
   The alias for the plugin or the plugin object itself
   Any number of extra arguments
  
  This method goes through the pipeline's C<remove()> method, which will call
  C<< $plugin->plugin_unregister($pluggable, @args) >>.
  
  Returns the plugin object if the plugin was removed, C<undef>/an empty list
  if not.
  
  =head3 C<plugin_get>
  
  I<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_get>>
  
  Accepts the following arguments:
  
   The alias for the plugin
  
  This method goes through the pipeline's C<get()> method.
  
  Returns the plugin object if it was found, C<undef>/an empty list if not.
  
  =head3 C<plugin_list>
  
  I<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_list>>
  
  Takes no arguments.
  
  Returns a hashref of plugin objects, keyed on alias, or an empty list if
  there are no plugins loaded.
  
  =head3 C<plugin_order>
  
  I<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_order>>
  
  Takes no arguments.
  
  Returns an arrayref of plugin objects, in the order which they are
  encountered in the pipeline.
  
  =head3 C<plugin_register>
  
  I<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_register>>
  
  Accepts the following arguments:
  
   The plugin object
   The type of the hook (the hook types are specified with _pluggable_init()'s 'types')
   The event name[s] to watch
  
  The event names can be as many as possible, or an arrayref. They correspond
  to the prefixed events and naturally, arbitrary events too.
  
  You do not need to supply events with the prefix in front of them, just the
  names.
  
  It is possible to register for all events by specifying 'all' as an event.
  
  Returns 1 if everything checked out fine, C<undef>/an empty list if something
  is seriously wrong.
  
  =head3 C<plugin_unregister>
  
  I<Inherited from L<Object::Pluggable|Object::Pluggable/plugin_unregister>>
  
  Accepts the following arguments:
  
   The plugin object
   The type of the hook (the hook types are specified with _pluggable_init()'s 'types')
   The event name[s] to unwatch
  
  The event names can be as many as possible, or an arrayref. They correspond
  to the prefixed events and naturally, arbitrary events too.
  
  You do not need to supply events with the prefix in front of them, just the
  names.
  
  It is possible to register for all events by specifying 'all' as an event.
  
  Returns 1 if all the event name[s] was unregistered, undef if some was not
  found.
  
  =head1 INPUT EVENTS
  
  How to talk to your new IRC component... here's the events we'll accept.
  These are events that are posted to the component, either via
  C<< $poe_kernel->post() >> or via the object method L<C<yield>|/yield>.
  
  So the following would be functionally equivalent:
  
   sub irc_001 {
       my ($kernel,$sender) = @_[KERNEL,SENDER];
       my $irc = $sender->get_heap(); # obtain the poco's object
  
       $irc->yield( privmsg => 'foo' => 'Howdy!' );
       $kernel->post( $sender => privmsg => 'foo' => 'Howdy!' );
       $kernel->post( $irc->session_id() => privmsg => 'foo' => 'Howdy!' );
       $kernel->post( $irc->session_alias() => privmsg => 'foo' => 'Howdy!' );
  
       return;
   }
  
  =head2 Important Commands
  
  =head3 C<register>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/register>>
  
  Takes N arguments: a list of event names that your session wants to
  listen for, minus the C<irc_> prefix. So, for instance, if you just
  want a bot that keeps track of which people are on a channel, you'll
  need to listen for JOINs, PARTs, QUITs, and KICKs to people on the
  channel you're in. You'd tell POE::Component::IRC that you want those
  events by saying this:
  
   $kernel->post('my client', 'register', qw(join part quit kick));
  
  Then, whenever people enter or leave a channel your bot is on (forcibly
  or not), your session will receive events with names like
  L<C<irc_join>|/irc_join>, L<C<irc_kick>|/irc_kick>, etc.,
  which you can use to update a list of people on the channel.
  
  Registering for B<'all'> will cause it to send all IRC-related events to
  you; this is the easiest way to handle it. See the test script for an
  example.
  
  Registering will generate an L<C<irc_registered>|/irc_registered>
  event that your session can trap. C<ARG0> is the components object. Useful
  if you want to bolt PoCo-IRC's new features such as Plugins into a bot
  coded to the older deprecated API. If you are using the new API, ignore this :)
  
  Registering with multiple component sessions can be tricky, especially if
  one wants to marry up sessions/objects, etc. Check the L<SIGNALS|/SIGNALS>
  section for an alternative method of registering with multiple poco-ircs.
  
  Starting with version 4.96, if you spawn the component from inside another POE
  session, the component will automatically register that session as wanting
  B<'all'> irc events. That session will receive an
  L<C<irc_registered>|/irc_registered> event indicating that the component
  is up and ready to go.
  
  =head3 C<unregister>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/unregister>>
  
  Takes N arguments: a list of event names which you I<don't> want to
  receive. If you've previously done a L<C<register>|/register>
  for a particular event which you no longer care about, this event will
  tell the IRC connection to stop sending them to you. (If you haven't, it just
  ignores you. No big deal.)
  
  If you have registered with 'all', attempting to unregister individual
  events such as 'mode', etc. will not work. This is a 'feature'.
  
  =head3 C<connect>
  
  Takes one argument: a hash reference of attributes for the new connection,
  see L<C<spawn>|/spawn> for details. This event tells the IRC client to
  connect to a new/different server. If it has a connection already open, it'll
  close it gracefully before reconnecting.
  
  =head3 C<ctcp> and C<ctcpreply>
  
  Sends a CTCP query or response to the nick(s) or channel(s) which you
  specify. Takes 2 arguments: the nick or channel to send a message to
  (use an array reference here to specify multiple recipients), and the
  plain text of the message to send (the CTCP quoting will be handled
  for you). The "/me" command in popular IRC clients is actually a CTCP action.
  
   # Doing a /me
   $irc->yield(ctcp => $channel => 'ACTION dances.');
  
  =head3 C<join>
  
  Tells your IRC client to join a single channel of your choice. Takes
  at least one arg: the channel name (required) and the channel key
  (optional, for password-protected channels).
  
  =head3 C<kick>
  
  Tell the IRC server to forcibly evict a user from a particular
  channel. Takes at least 2 arguments: a channel name, the nick of the
  user to boot, and an optional witty message to show them as they sail
  out the door.
  
  =head3 C<remove>
  
  Tell the IRC server to forcibly evict a user from a particular
  channel. Takes at least 2 arguments: a channel name, the nick of the
  user to boot, and an optional witty message to show them as they sail
  out the door. Similar to KICK but does an enforced PART instead. Not
  supported by all servers.
  
  =head3 C<mode>
  
  Request a mode change on a particular channel or user. Takes at least
  one argument: the mode changes to effect, as a single string (e.g.
  "#mychan +sm-p+o"), and any number of optional operands to the mode changes
  (nicks, hostmasks, channel keys, whatever.) Or just pass them all as one
  big string and it'll still work, whatever. I regret that I haven't the
  patience now to write a detailed explanation, but serious IRC users know
  the details anyhow.
  
  =head3 C<nick>
  
  Allows you to change your nickname. Takes exactly one argument: the
  new username that you'd like to be known as.
  
  =head3 C<nickserv>
  
  Talks to NickServ, on networks which have it. Takes any number of
  arguments.
  
  =head3 C<notice>
  
  Sends a NOTICE message to the nick(s) or channel(s) which you
  specify. Takes 2 arguments: the nick or channel to send a notice to
  (use an array reference here to specify multiple recipients), and the
  text of the notice to send.
  
  =head3 C<part>
  
  Tell your IRC client to leave the channels which you pass to it. Takes
  any number of arguments: channel names to depart from. If the last argument
  doesn't begin with a channel name identifier or contains a space character,
  it will be treated as a PART message and dealt with accordingly.
  
  =head3 C<privmsg>
  
  Sends a public or private message to the nick(s) or channel(s) which
  you specify. Takes 2 arguments: the nick or channel to send a message
  to (use an array reference here to specify multiple recipients), and
  the text of the message to send.
  
  Have a look at the constants in L<IRC::Utils|IRC::Utils> if you would
  like to use formatting and color codes in your messages.
  
   $irc->yield('primvsg', '#mychannel', 'Hello there');
  
   # same, but with a green Hello
   use IRC::Utils qw(GREEN NORMAL);
   $irc->yield('primvsg', '#mychannel', GREEN.'Hello'.NORMAL.' there');
  
  =head3 C<quit>
  
  Tells the IRC server to disconnect you. Takes one optional argument:
  some clever, witty string that other users in your channels will see
  as you leave. You can expect to get an
  L<C<irc_disconnected>|/irc_disconnected> event shortly after sending this.
  
  =head3 C<shutdown>
  
  By default, POE::Component::IRC sessions never go away. Even after
  they're disconnected, they're still sitting around in the background,
  waiting for you to call L<C<connect>|/connect> on them again to
  reconnect. (Whether this behavior is the Right Thing is doubtful, but I
  don't want to break backwards compatibility at this point.) You can send
  the IRC session a C<shutdown> event manually to make it delete itself.
  
  If you are logged into an IRC server, C<shutdown> first will send a quit
  message and wait to be disconnected. It will wait for up to 5 seconds before
  forcibly disconnecting from the IRC server. If you provide an argument, that
  will be used as the QUIT message. If you provide two arguments, the second
  one will be used as the timeout (in seconds).
  
  Terminating multiple components can be tricky. Check the L<SIGNALS|/SIGNALS>
  section for a method of shutting down multiple poco-ircs.
  
  =head3 C<topic>
  
  Retrieves or sets the topic for particular channel. If called with just
  the channel name as an argument, it will ask the server to return the
  current topic. If called with the channel name and a string, it will
  set the channel topic to that string. Supply an empty string to unset a
  channel topic.
  
  =head3 C<debug>
  
  Takes one argument: 0 to turn debugging off or 1 to turn debugging on.
  This flips the debugging flag in L<POE::Filter::IRCD|POE::Filter::IRCD>,
  L<POE::Filter::IRC::Compat|POE::Filter::IRC::Compat>, and
  POE::Component::IRC. This has the same effect as setting Debug in
  L<C<spawn>|/spawn> or L<C<connect>|/connect>.
  
  =head2 Not-So-Important Commands
  
  =head3 C<admin>
  
  Asks your server who your friendly neighborhood server administrators
  are. If you prefer, you can pass it a server name to query, instead of
  asking the server you're currently on.
  
  =head3 C<away>
  
  When sent with an argument (a message describig where you went), the
  server will note that you're now away from your machine or otherwise
  preoccupied, and pass your message along to anyone who tries to
  communicate with you. When sent without arguments, it tells the server
  that you're back and paying attention.
  
  =head3 C<cap>
  
  Used to query/enable/disable IRC protocol capabilities. Takes any number of
  arguments.
  
  =head3 C<dcc*>
  
  See the L<DCC plugin|POE::Component::IRC::Plugin/COMMANDS> (loaded by default)
  documentation for DCC-related commands.
  
  =head3 C<info>
  
  Basically the same as the L<C<version>|/version> command, except that the
  server is permitted to return any information about itself that it thinks is
  relevant. There's some nice, specific standards-writing for ya, eh?
  
  =head3 C<invite>
  
  Invites another user onto an invite-only channel. Takes 2 arguments:
  the nick of the user you wish to admit, and the name of the channel to
  invite them to.
  
  =head3 C<ison>
  
  Asks the IRC server which users out of a list of nicknames are
  currently online. Takes any number of arguments: a list of nicknames
  to query the IRC server about.
  
  =head3 C<links>
  
  Asks the server for a list of servers connected to the IRC
  network. Takes two optional arguments, which I'm too lazy to document
  here, so all you would-be linklooker writers should probably go dig up
  the RFC.
  
  =head3 C<list>
  
  Asks the server for a list of visible channels and their topics. Takes
  any number of optional arguments: names of channels to get topic
  information for. If called without any channel names, it'll list every
  visible channel on the IRC network. This is usually a really big list,
  so don't do this often.
  
  =head3 C<motd>
  
  Request the server's "Message of the Day", a document which typically
  contains stuff like the server's acceptable use policy and admin
  contact email addresses, et cetera. Normally you'll automatically
  receive this when you log into a server, but if you want it again,
  here's how to do it. If you'd like to get the MOTD for a server other
  than the one you're logged into, pass it the server's hostname as an
  argument; otherwise, no arguments.
  
  =head3 C<names>
  
  Asks the server for a list of nicknames on particular channels. Takes
  any number of arguments: names of channels to get lists of users
  for. If called without any channel names, it'll tell you the nicks of
  everyone on the IRC network. This is a really big list, so don't do
  this much.
  
  =head3 C<quote>
  
  Sends a raw line of text to the server. Takes one argument: a string
  of a raw IRC command to send to the server. It is more optimal to use
  the events this module supplies instead of writing raw IRC commands
  yourself.
  
  =head3 C<stats>
  
  Returns some information about a server. Kinda complicated and not
  terribly commonly used, so look it up in the RFC if you're
  curious. Takes as many arguments as you please.
  
  =head3 C<time>
  
  Asks the server what time it thinks it is, which it will return in a
  human-readable form. Takes one optional argument: a server name to
  query. If not supplied, defaults to current server.
  
  =head3 C<trace>
  
  If you pass a server name or nick along with this request, it asks the
  server for the list of servers in between you and the thing you
  mentioned. If sent with no arguments, it will show you all the servers
  which are connected to your current server.
  
  =head3 C<users>
  
  Asks the server how many users are logged into it. Defaults to the
  server you're currently logged into; however, you can pass a server
  name as the first argument to query some other machine instead.
  
  =head3 C<version>
  
  Asks the server about the version of ircd that it's running. Takes one
  optional argument: a server name to query. If not supplied, defaults
  to current server.
  
  =head3 C<who>
  
  Lists the logged-on users matching a particular channel name, hostname,
  nickname, or what-have-you. Takes one optional argument: a string for
  it to search for. Wildcards are allowed; in the absence of this
  argument, it will return everyone who's currently logged in (bad
  move). Tack an "o" on the end if you want to list only IRCops, as per
  the RFC.
  
  =head3 C<whois>
  
  Queries the IRC server for detailed information about a particular
  user. Takes any number of arguments: nicknames or hostmasks to ask for
  information about. As of version 3.2, you will receive an
  L<C<irc_whois>|/irc_whois> event in addition to the usual numeric
  responses. See below for details.
  
  =head3 C<whowas>
  
  Asks the server for information about nickname which is no longer
  connected. Takes at least one argument: a nickname to look up (no
  wildcards allowed), the optional maximum number of history entries to
  return, and the optional server hostname to query. As of version 3.2,
  you will receive an L<C<irc_whowas>|/irc_whowas> event in addition
  to the usual numeric responses. See below for details.
  
  =head3 C<ping> and C<pong>
  
  Included for completeness sake. The component will deal with ponging to
  pings automatically. Don't worry about it.
  
  =head2 Purely Esoteric Commands
  
  =head3 C<die>
  
  Tells the IRC server you're connect to, to terminate. Only useful for
  IRCops, thank goodness. Takes no arguments.
  
  =head3 C<locops>
  
  Opers-only command. This one sends a message to all currently
  logged-on local-opers (+l). This option is specific to EFNet.
  
  =head3 C<oper>
  
  In the exceedingly unlikely event that you happen to be an IRC
  operator, you can use this command to authenticate with your IRC
  server. Takes 2 arguments: your username and your password.
  
  =head3 C<operwall>
  
  Opers-only command. This one sends a message to all currently
  logged-on global opers. This option is specific to EFNet.
  
  =head3 C<rehash>
  
  Tells the IRC server you're connected to, to rehash its configuration
  files. Only useful for IRCops. Takes no arguments.
  
  =head3 C<restart>
  
  Tells the IRC server you're connected to, to shut down and restart itself.
  Only useful for IRCops, thank goodness. Takes no arguments.
  
  =head3 C<sconnect>
  
  Tells one IRC server (which you have operator status on) to connect to
  another. This is actually the CONNECT command, but I already had an
  event called L<C<connect>|/connect>, so too bad. Takes the args
  you'd expect: a server to connect to, an optional port to connect on,
  and an optional remote server to connect with, instead of the one you're
  currently on.
  
  =head3 C<squit>
  
  Operator-only command used to disconnect server links. Takes two arguments,
  the server to disconnect and a message explaining your action.
  
  =head3 C<summon>
  
  Don't even ask.
  
  =head3 C<servlist>
  
  Lists the currently connected services on the network that are visible to you.
  Takes two optional arguments, a mask for matching service names against, and
  a service type.
  
  =head3 C<squery>
  
  Sends a message to a service. Takes the same arguments as
  L<C<privmsg>|/privmsg>.
  
  =head3 C<userhost>
  
  Asks the IRC server for information about particular nicknames. (The
  RFC doesn't define exactly what this is supposed to return.) Takes any
  number of arguments: the nicknames to look up.
  
  =head3 C<wallops>
  
  Another opers-only command. This one sends a message to all currently
  logged-on opers (and +w users); sort of a mass PA system for the IRC
  server administrators. Takes one argument: some clever, witty message
  to send.
  
  =head1 OUTPUT EVENTS
  
  The events you will receive (or can ask to receive) from your running
  IRC component. Note that all incoming event names your session will
  receive are prefixed by C<irc_>, to inhibit event namespace pollution.
  
  If you wish, you can ask the client to send you every event it
  generates. Simply register for the event name "all". This is a lot
  easier than writing a huge list of things you specifically want to
  listen for.
  
  FIXME: I'd really like to classify these somewhat ("basic", "oper", "ctcp",
  "dcc", "raw" or some such), and I'd welcome suggestions for ways to make
  this easier on the user, if you can think of some.
  
  In your event handlers, C<$_[SENDER]> is the particular component session that
  sent you the event. C<< $_[SENDER]->get_heap() >> will retrieve the component's
  object. Useful if you want on-the-fly access to the object and its methods.
  
  =head2 Important Events
  
  =head3 C<irc_registered>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/syndicator_registered>>
  
  Sent once to the requesting session on registration (see
  L<C<register>|/register>). C<ARG0> is a reference tothe component's object.
  
  =head3 C<irc_shutdown>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/syndicator_shutdown>>
  
  Sent to all registered sessions when the component has been asked to
  L<C<shutdown>|/shutdown>. C<ARG0> will be the session ID of the requesting
  session.
  
  =head3 C<irc_connected>
  
  The IRC component will send an C<irc_connected> event as soon as it
  establishes a connection to an IRC server, before attempting to log
  in. C<ARG0> is the server name.
  
  B<NOTE:> When you get an C<irc_connected> event, this doesn't mean you
  can start sending commands to the server yet. Wait until you receive
  an L<C<irc_001>|/All numeric events> event (the server welcome message)
  before actually sending anything back to the server.
  
  =head3 C<irc_ctcp>
  
  C<irc_ctcp> events are generated upon receipt of CTCP messages, in addition to
  the C<irc_ctcp_*> events mentioned below. They are identical in every way to
  these, with one difference: instead of the * being in the method name, it
  is prepended to the argument list. For example, if someone types C</ctcp
  Flibble foo bar>, an C<irc_ctcp> event will be sent with B<'foo'> as C<ARG0>,
  and the rest as given below.
  
  It is not recommended that you register for both C<irc_ctcp> and C<irc_ctcp_*>
  events, since they will both be fired and presumably cause duplication.
  
  =head3 C<irc_ctcp_*>
  
  C<irc_ctcp_whatever> events are generated upon receipt of CTCP messages.
  For instance, receiving a CTCP PING request generates an C<irc_ctcp_ping>
  event, CTCP ACTION (produced by typing "/me" in most IRC clients)
  generates an C<irc_ctcp_action> event, blah blah, so on and so forth. C<ARG0>
  is the nick!hostmask of the sender. C<ARG1> is the channel/recipient
  name(s). C<ARG2> is the text of the CTCP message. On servers supporting the
  IDENTIFY-MSG feature (e.g. FreeNode), CTCP ACTIONs will have C<ARG3>, which
  will be C<1> if the sender has identified with NickServ, C<0> otherwise.
  
  Note that DCCs are handled separately -- see the
  L<DCC plugin|POE::Component::IRC::Plugin::DCC>.
  
  =head3 C<irc_ctcpreply_*>
  
  C<irc_ctcpreply_whatever> messages are just like C<irc_ctcp_whatever>
  messages, described above, except that they're generated when a response
  to one of your CTCP queries comes back. They have the same arguments and
  such as C<irc_ctcp_*> events.
  
  =head3 C<irc_disconnected>
  
  The counterpart to L<C<irc_connected>|/irc_connected>, sent whenever
  a socket connection to an IRC server closes down (whether intentionally or
  unintentionally). C<ARG0> is the server name.
  
  =head3 C<irc_error>
  
  You get this whenever the server sends you an ERROR message. Expect
  this to usually be accompanied by the sudden dropping of your
  connection. C<ARG0> is the server's explanation of the error.
  
  =head3 C<irc_join>
  
  Sent whenever someone joins a channel that you're on. C<ARG0> is the
  person's nick!hostmask. C<ARG1> is the channel name.
  
  =head3 C<irc_invite>
  
  Sent whenever someone offers you an invitation to another channel. C<ARG0>
  is the person's nick!hostmask. C<ARG1> is the name of the channel they want
  you to join.
  
  =head3 C<irc_kick>
  
  Sent whenever someone gets booted off a channel that you're on. C<ARG0>
  is the kicker's nick!hostmask. C<ARG1> is the channel name. C<ARG2> is the
  nick of the unfortunate kickee. C<ARG3> is the explanation string for the
  kick.
  
  =head3 C<irc_mode>
  
  Sent whenever someone changes a channel mode in your presence, or when
  you change your own user mode. C<ARG0> is the nick!hostmask of that
  someone. C<ARG1> is the channel it affects (or your nick, if it's a user
  mode change). C<ARG2> is the mode string (i.e., "+o-b"). The rest of the
  args (C<ARG3 .. $#_>) are the operands to the mode string (nicks,
  hostmasks, channel keys, whatever).
  
  =head3 C<irc_msg>
  
  Sent whenever you receive a PRIVMSG command that was addressed to you
  privately. C<ARG0> is the nick!hostmask of the sender. C<ARG1> is an array
  reference containing the nick(s) of the recipients. C<ARG2> is the text
  of the message. On servers supporting the IDENTIFY-MSG feature (e.g.
  FreeNode), there will be an additional argument, C<ARG3>, which will be
  C<1> if the sender has identified with NickServ, C<0> otherwise.
  
  =head3 C<irc_nick>
  
  Sent whenever you, or someone around you, changes nicks. C<ARG0> is the
  nick!hostmask of the changer. C<ARG1> is the new nick that they changed
  to.
  
  =head3 C<irc_notice>
  
  Sent whenever you receive a NOTICE command. C<ARG0> is the nick!hostmask
  of the sender. C<ARG1> is an array reference containing the nick(s) or
  channel name(s) of the recipients. C<ARG2> is the text of the NOTICE
  message.
  
  =head3 C<irc_part>
  
  Sent whenever someone leaves a channel that you're on. C<ARG0> is the
  person's nick!hostmask. C<ARG1> is the channel name. C<ARG2> is the part
  message.
  
  =head3 C<irc_public>
  
  Sent whenever you receive a PRIVMSG command that was sent to a channel.
  C<ARG0> is the nick!hostmask of the sender. C<ARG1> is an array
  reference containing the channel name(s) of the recipients. C<ARG2> is the
  text of the message. On servers supporting the IDENTIFY-MSG feature (e.g.
  FreeNode), there will be an additional argument, C<ARG3>, which will be
  C<1> if the sender has identified with NickServ, C<0> otherwise.
  
  =head3 C<irc_quit>
  
  Sent whenever someone on a channel with you quits IRC (or gets
  KILLed). C<ARG0> is the nick!hostmask of the person in question. C<ARG1> is
  the clever, witty message they left behind on the way out.
  
  =head3 C<irc_socketerr>
  
  Sent when a connection couldn't be established to the IRC server. C<ARG0>
  is probably some vague and/or misleading reason for what failed.
  
  =head3 C<irc_topic>
  
  Sent when a channel topic is set or unset. C<ARG0> is the nick!hostmask of the
  sender. C<ARG1> is the channel affected. C<ARG2> will be either: a string if the
  topic is being set; or a zero-length string (i.e. '') if the topic is being
  unset. Note: replies to queries about what a channel topic *is*
  (i.e. TOPIC #channel), are returned as numerics, not with this event.
  
  =head3 C<irc_whois>
  
  Sent in response to a WHOIS query. C<ARG0> is a hashref, with the following
  keys:
  
  =over 4
  
  =item * B<'nick'>, the users nickname;
  
  =item * B<'user'>, the users username;
  
  =item * B<'host'>, their hostname;
  
  =item * B<'real'>, their real name;
  
  =item * B<'idle'>, their idle time in seconds;
  
  =item * B<'signon'>, the epoch time they signed on (will be undef if ircd
  does not support this);
  
  =item * B<'channels'>, an arrayref listing visible channels they are on,
  the channel is prefixed with '@','+','%' depending on whether they have
  +o +v or +h;
  
  =item * B<'server'>, their server (might not be useful on some networks);
  
  =item * B<'oper'>, whether they are an IRCop, contains the IRC operator
  string if they are, undef if they aren't.
  
  =item * B<'actually'>, some ircds report the user's actual ip address,
  that'll be here;
  
  =item * B<'identified'>. if the user has identified with NICKSERV
  (ircu, seven, Plexus)
  
  =item * B<'modes'>, a string describing the user's modes (Rizon)
  
  =back
  
  =head3 C<irc_whowas>
  
  Similar to the above, except some keys will be missing.
  
  =head3 C<irc_raw>
  
  Enabled by passing C<< Raw => 1 >> to L<C<spawn>|/spawn> or
  L<C<connect>|/connect>, or by calling L<C<raw_events>|/raw_events> with
  a true argument. C<ARG0> is the raw IRC string received by the component from
  the IRC server, before it has been mangled by filters and such like.
  
  =head3 C<irc_raw_out>
  
  Enabled by passing C<< Raw => 1 >> to L<C<spawn>|/spawn> or
  L<C<connect>|/connect>, or by calling L<C<raw_events>|/raw_events> with
  a true argument. C<ARG0> is the raw IRC string sent by the component to the
  the IRC server.
  
  =head3 C<irc_isupport>
  
  Emitted by the first event after an L<C<irc_005>|/All numeric events>, to
  indicate that isupport information has been gathered. C<ARG0> is the
  L<POE::Component::IRC::Plugin::ISupport|POE::Component::IRC::Plugin::ISupport>
  object.
  
  =head3 C<irc_socks_failed>
  
  Emitted whenever we fail to connect successfully to a SOCKS server or the
  SOCKS server is not actually a SOCKS server. C<ARG0> will be some vague reason
  as to what went wrong. Hopefully.
  
  =head3 C<irc_socks_rejected>
  
  Emitted whenever a SOCKS connection is rejected by a SOCKS server. C<ARG0> is
  the SOCKS code, C<ARG1> the SOCKS server address, C<ARG2> the SOCKS port and
  C<ARG3> the SOCKS user id (if defined).
  
  =head3 C<irc_plugin_add>
  
  I<Inherited from L<Object::Pluggable|Object::Pluggable/_pluggable_event>>
  
  Emitted whenever a new plugin is added to the pipeline. C<ARG0> is the
  plugin alias. C<ARG1> is the plugin object.
  
  =head3 C<irc_plugin_del>
  
  I<Inherited from L<Object::Pluggable|Object::Pluggable/_pluggable_event>>
  
  Emitted whenever a plugin is removed from the pipeline. C<ARG0> is the
  plugin alias. C<ARG1> is the plugin object.
  
  =head3 C<irc_plugin_error>
  
  I<Inherited from L<Object::Pluggable|Object::Pluggable/_pluggable_event>>
  
  Emitted when an error occurs while executing a plugin handler. C<ARG0> is
  the error message. C<ARG1> is the plugin alias. C<ARG2> is the plugin object.
  
  =head2 Somewhat Less Important Events
  
  =head3 C<irc_cap>
  
  A reply from the server regarding protocol capabilities. C<ARG0> is the
  CAP subcommand (e.g. 'LS'). C<ARG1> is the result of the subcommand, unless
  this is a multi-part reply, in which case C<ARG1> is '*' and C<ARG2> contains
  the result.
  
  =head3 C<irc_dcc_*>
  
  See the L<DCC plugin|POE::Component::IRC::Plugin/OUTPUT> (loaded by default)
  documentation for DCC-related events.
  
  =head3 C<irc_ping>
  
  An event sent whenever the server sends a PING query to the
  client. (Don't confuse this with a CTCP PING, which is another beast
  entirely. If unclear, read the RFC.) Note that POE::Component::IRC will
  automatically take care of sending the PONG response back to the
  server for you, although you can still register to catch the event for
  informational purposes.
  
  =head3 C<irc_snotice>
  
  A weird, non-RFC-compliant message from an IRC server. Usually sent during
  to you during an authentication phase right after you connect, while the
  server does a hostname lookup or similar tasks. C<ARG0> is the text of the
  server's message. C<ARG1> is the target, which could be B<'*'> or B<'AUTH'>
  or whatever. Servers vary as to whether these notices include a server name
  as the sender, or no sender at all. C<ARG1> is the sender, if any.
  
  =head3 C<irc_delay_set>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/syndicator_delay_set>>
  
  Emitted on a successful addition of a delayed event using the
  L<C<delay>|/delay> method. C<ARG0> will be the alarm_id which can be used
  later with L<C<delay_remove>|/delay_remove>. Subsequent parameters are
  the arguments that were passed to L<C<delay>|/delay>.
  
  =head3 C<irc_delay_removed>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/syndicator_delay_removed>>
  
  Emitted when a delayed command is successfully removed. C<ARG0> will be the
  alarm_id that was removed. Subsequent parameters are the arguments that were
  passed to L<C<delay>|/delay>.
  
  =head2 All numeric events
  
  Most messages from IRC servers are identified only by three-digit
  numeric codes with undescriptive constant names like RPL_UMODEIS and
  ERR_NOTOPLEVEL. (Actually, the list of codes in the RFC is kind of
  out-of-date... the list in the back of Net::IRC::Event.pm is more
  complete, and different IRC networks have different and incompatible
  lists. Ack!) As an example, say you wanted to handle event 376
  (RPL_ENDOFMOTD, which signals the end of the MOTD message). You'd
  register for '376', and listen for C<irc_376> events. Simple, no? C<ARG0>
  is the name of the server which sent the message. C<ARG1> is the text of
  the message. C<ARG2> is an array reference of the parsed message, so there
  is no need to parse C<ARG1> yourself.
  
  =head1 SIGNALS
  
  The component will handle a number of custom signals that you may send using
  L<POE::Kernel|POE::Kernel>'s C<signal> method.
  
  =head2 C<POCOIRC_REGISTER>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/SYNDICATOR_REGISTER>>
  
  Registering with multiple PoCo-IRC components has been a pita. Well, no more,
  using the power of L<POE::Kernel|POE::Kernel> signals.
  
  If the component receives a C<POCOIRC_REGISTER> signal it'll register the
  requesting session and trigger an L<C<irc_registered>|/irc_registered>
  event. From that event one can get all the information necessary such as the
  poco-irc object and the SENDER session to do whatever one needs to build a
  poco-irc dispatch table.
  
  The way the signal handler in PoCo-IRC is written also supports sending the
  C<POCOIRC_REGISTER> to multiple sessions simultaneously, by sending the signal
  to the POE Kernel itself.
  
  Pass the signal your session, session ID or alias, and the IRC events (as
  specified to L<C<register>|/register>).
  
  To register with multiple PoCo-IRCs one can do the following in your session's
  _start handler:
  
   sub _start {
       my ($kernel, $session) = @_[KERNEL, SESSION];
  
       # Registering with multiple pocoircs for 'all' IRC events
       $kernel->signal($kernel, 'POCOIRC_REGISTER', $session->ID(), 'all');
  
       return:
   }
  
  Each poco-irc will send your session an
  L<C<irc_registered>|/irc_registered> event:
  
   sub irc_registered {
       my ($kernel, $sender, $heap, $irc_object) = @_[KERNEL, SENDER, HEAP, ARG0];
  
       # Get the poco-irc session ID
       my $sender_id = $sender->ID();
  
       # Or it's alias
       my $poco_alias = $irc_object->session_alias();
  
       # Store it in our heap maybe
       $heap->{irc_objects}->{ $sender_id } = $irc_object;
  
       # Make the poco connect
       $irc_object->yield(connect => { });
  
       return;
   }
  
  =head2 C<POCOIRC_SHUTDOWN>
  
  I<Inherited from L<POE::Component::Syndicator|POE::Component::Syndicator/SYNDICATOR_SHUTDOWN>>
  
  Telling multiple poco-ircs to shutdown was a pita as well. The same principle as
  with registering applies to shutdown too.
  
  Send a C<POCOIRC_SHUTDOWN> to the POE Kernel to terminate all the active
  poco-ircs simultaneously.
  
   $poe_kernel->signal($poe_kernel, 'POCOIRC_SHUTDOWN');
  
  Any additional parameters passed to the signal will become your quit messages
  on each IRC network.
  
  =head1 ENCODING
  
  This can be an issue. Take a look at L<IRC::Utils' section|IRC::Utils/ENCODING>
  on it.
  
  =head1 BUGS
  
  A few have turned up in the past and they are sure to again. Please use
  L<http://rt.cpan.org/> to report any. Alternatively, email the current
  maintainer.
  
  =head1 DEVELOPMENT
  
  You can find the latest source on github:
  L<http://github.com/bingos/poe-component-irc>
  
  The project's developers usually hang out in the C<#poe> IRC channel on
  irc.perl.org. Do drop us a line.
  
  =head1 MAINTAINERS
  
  Chris C<BinGOs> Williams <chris@bingosnet.co.uk>
  
  Hinrik E<Ouml>rn SigurE<eth>sson <hinrik.sig@gmail.com>
  
  =head1 AUTHOR
  
  Dennis Taylor.
  
  =head1 LICENCE
  
  Copyright (c) Dennis Taylor, Chris Williams and Hinrik E<Ouml>rn SigurE<eth>sson
  
  This module may be used, modified, and distributed under the same
  terms as Perl itself. Please see the license that came with your Perl
  distribution for details.
  
  =head1 MAD PROPS
  
  The maddest of mad props go out to Rocco "dngor" Caputo
  <troc@netrus.net>, for inventing something as mind-bogglingly
  cool as POE, and to Kevin "oznoid" Lenzo E<lt>lenzo@cs.cmu.eduE<gt>,
  for being the attentive parent of our precocious little infobot on
  #perl.
  
  Further props to a few of the studly bughunters who made this module not
  suck: Abys <abys@web1-2-3.com>, Addi <addi@umich.edu>, ResDev
  <ben@reser.org>, and Roderick <roderick@argon.org>. Woohoo!
  
  Kudos to Apocalypse, <apocal@cpan.org>, for the plugin system and to
  Jeff 'japhy' Pinyan, <japhy@perlmonk.org>, for Pipeline.
  
  Thanks to the merry band of POE pixies from #PoE @ irc.perl.org,
  including ( but not limited to ), ketas, ct, dec, integral, webfox,
  immute, perigrin, paulv, alias.
  
  IP functions are shamelessly 'borrowed' from L<Net::IP|Net::IP> by Manuel
  Valente
  
  Check out the Changes file for further contributors.
  
  =head1 SEE ALSO
  
  RFC 1459 L<http://www.faqs.org/rfcs/rfc1459.html>
  
  L<http://www.irchelp.org/>,
  
  L<http://poe.perl.org/>,
  
  L<http://www.infobot.org/>,
  
  Some good examples reside in the POE cookbook which has a whole section
  devoted to IRC programming L<http://poe.perl.org/?POE_Cookbook>.
  
  The examples/ folder of this distribution.
  
  =cut
POE_COMPONENT_IRC

$fatpacked{"POE/Component/IRC/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_COMMON';
  package POE::Component::IRC::Common;
  BEGIN {
    $POE::Component::IRC::Common::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Common::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  
  use IRC::Utils;
  
  require Exporter;
  use base qw(Exporter);
  our @EXPORT_OK = qw(
      u_irc l_irc parse_mode_line parse_ban_mask matches_mask matches_mask_array
      parse_user has_color has_formatting strip_color strip_formatting NORMAL
      BOLD UNDERLINE REVERSE WHITE BLACK DARK_BLUE DARK_GREEN RED BROWN PURPLE
      ORANGE YELLOW LIGHT_GREEN TEAL CYAN LIGHT_BLUE MAGENTA DARK_GREY
      LIGHT_GREY irc_to_utf8
  );
  our %EXPORT_TAGS = ( ALL => [@EXPORT_OK] );
  
  no warnings 'once'; ## no critic (TestingAndDebugging::ProhibitNoWarnings)
  *NORMAL      = *IRC::Utils::NORMAL;
  *BOLD        = *IRC::Utils::BOLD;
  *UNDERLINE   = *IRC::Utils::UNDERLINE;
  *REVERSE     = *IRC::Utils::REVERSE;
  *ITALIC      = *IRC::Utils::ITALIC;
  *FIXED       = *IRC::Utils::FIXED;
  *WHITE       = *IRC::Utils::WHITE;
  *BLACK       = *IRC::Utils::BLACK;
  *DARK_BLUE   = *IRC::Utils::BLUE;
  *DARK_GREEN  = *IRC::Utils::GREEN;
  *RED         = *IRC::Utils::RED;
  *BROWN       = *IRC::Utils::BROWN;
  *PURPLE      = *IRC::Utils::PURPLE;
  *ORANGE      = *IRC::Utils::ORANGE;
  *YELLOW      = *IRC::Utils::YELLOW;
  *LIGHT_GREEN = *IRC::Utils::LIGHT_GREEN;
  *TEAL        = *IRC::Utils::TEAL;
  *CYAN        = *IRC::Utils::LIGHT_CYAN;
  *LIGHT_BLUE  = *IRC::Utils::LIGHT_BLUE;
  *MAGENTA     = *IRC::Utils::PINK;
  *DARK_GREY   = *IRC::Utils::GREY;
  *LIGHT_GREY  = *IRC::Utils::LIGHT_GREY;
  
  *u_irc              = *IRC::Utils::uc_irc;
  *l_irc              = *IRC::Utils::lc_irc;
  *parse_mode_line    = *IRC::Utils::parse_mode_line;
  *parse_ban_mask     = *IRC::Utils::normalize_mask;
  *parse_user         = *IRC::Utils::parse_user;
  *matches_mask       = *IRC::Utils::matches_mask;
  *matches_mask_array = *IRC::Utils::matches_mask_array;
  *has_color          = *IRC::Utils::has_color;
  *has_formatting     = *IRC::Utils::has_formatting;
  *strip_color        = *IRC::Utils::strip_color;
  *strip_formatting   = *IRC::Utils::strip_formatting;
  *irc_to_utf8        = *IRC::Utils::decode_irc;
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Common - Provides a set of common functions for the
  L<POE::Component::IRC|POE::Component::IRC> suite
  
  =head1 SYNOPSIS
  
   use IRC::Utils;
  
  =head1 DESCRIPTION
  
  B<'ATTENTION'>: Most of this module's functionality has been moved into
  L<IRC::Utils|IRC::Utils>. Take a look at it.
  
  This module still exports the old functions (as wrappers around equivalents
  from L<IRC::Utils|IRC::Utils>), but new ones won't be added.
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams
  
  =head1 SEE ALSO
  
  L<IRC::Utils|IRC::Utils>
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  =cut
POE_COMPONENT_IRC_COMMON

$fatpacked{"POE/Component/IRC/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_CONSTANTS';
  package POE::Component::IRC::Constants;
  BEGIN {
    $POE::Component::IRC::Constants::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Constants::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  
  require Exporter;
  use base qw(Exporter);
  our @EXPORT_OK = qw(
      PCI_REFCOUNT_TAG PRI_LOGIN PRI_HIGH PRI_NORMAL MSG_PRI MSG_TEXT
      CMD_PRI CMD_SUB
  );
  our %EXPORT_TAGS = ( ALL => [@EXPORT_OK] );
  
  use constant {
      # The name of the reference count P::C::I keeps in client sessions.
      PCI_REFCOUNT_TAG => 'P::C::I registered',
  
      # Message priorities.
      PRI_LOGIN  => 10, # PASS/NICK/USER messages must go first.
      PRI_HIGH   => 20, # KICK/MODE etc. is more important than chatter.
      PRI_NORMAL => 30, # Random chatter.
  
      MSG_PRI  => 0, # Queued message priority.
      MSG_TEXT => 1, # Queued message text.
  
      # RCC: Since most of the commands are data driven, I have moved their
      # event/handler maps here and added priorities for each data driven
      # command.  The priorities determine message importance when messages
      # are queued up.  Lower ones get sent first.
      CMD_PRI => 0, # Command priority.
      CMD_SUB => 1, # Command handler.
  };
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Constants - Defines constants required by
  L<POE::Component::IRC|POE::Component::IRC>
  
  =head1 SYNOPSIS
  
   use POE::Component::IRC::Constants qw(:ALL);
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Constants defines constants required by
  L<POE::Component::IRC|POE::Component::IRC> and derived sub-classes.
  
  =head1 AUTHOR
  
  Chris Williams <chris@bingosnet.co.uk>
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  =cut
POE_COMPONENT_IRC_CONSTANTS

$fatpacked{"POE/Component/IRC/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN';
  package POE::Component::IRC::Plugin;
  BEGIN {
    $POE::Component::IRC::Plugin::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  
  require Exporter;
  use base qw(Exporter);
  our @EXPORT_OK = qw(PCI_EAT_NONE PCI_EAT_CLIENT PCI_EAT_PLUGIN PCI_EAT_ALL);
  our %EXPORT_TAGS = ( ALL => [@EXPORT_OK] );
  
  use constant {
      PCI_EAT_NONE   => 1,
      PCI_EAT_CLIENT => 2,
      PCI_EAT_PLUGIN => 3,
      PCI_EAT_ALL    => 4,
  };
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin - Provides plugin constants and documentation for
  L<POE::Component::IRC|POE::Component::IRC>
  
  =head1 SYNOPSIS
  
   # A simple ROT13 'encryption' plugin
  
   package Rot13;
  
   use strict;
   use warnings;
   use POE::Component::IRC::Plugin qw( :ALL );
  
   # Plugin object constructor
   sub new {
       my $package = shift;
       return bless {}, $package;
   }
  
   sub PCI_register {
       my ($self, $irc) = splice @_, 0, 2;
  
       $irc->plugin_register( $self, 'SERVER', qw(public) );
       return 1;
   }
  
   # This is method is mandatory but we don't actually have anything to do.
   sub PCI_unregister {
       return 1;
   }
  
   sub S_public {
       my ($self, $irc) = splice @_, 0, 2;
  
       # Parameters are passed as scalar-refs including arrayrefs.
       my $nick    = ( split /!/, ${ $_[0] } )[0];
       my $channel = ${ $_[1] }->[0];
       my $msg     = ${ $_[2] };
  
       if (my ($rot13) = $msg =~ /^rot13 (.+)/) {
           $rot13 =~ tr[a-zA-Z][n-za-mN-ZA-M];
  
           # Send a response back to the server.
           $irc->yield( privmsg => $channel => $rot13 );
           # We don't want other plugins to process this
           return PCI_EAT_PLUGIN;
       }
  
       # Default action is to allow other plugins to process it.
       return PCI_EAT_NONE;
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC's plugin system has been released separately as
  L<Object::Pluggable|Object::Pluggable>. Gleaning at its documentation is
  advised. The rest of this document mostly describes aspects that are
  specific to POE::Component::IRC's use of Object::Pluggable.
  
  =head1 HISTORY
  
  Certain individuals in #PoE on MAGNet said we didn't need to bloat the
  PoCo-IRC code...
  
  BinGOs, the current maintainer of the module, and I heartily agreed that this
  is a wise choice.
  
  One example:
  
  Look at the magnificent new feature in 3.4 -> irc_whois replies! Yes, that is
  a feature I bet most of us have been coveting for a while, as it definitely
  makes our life easier. It was implemented in 30 minutes or so after a request,
  the maintainer said. I replied by saying that it's a wonderful idea, but what
  would happen if somebody else asked for a new feature? Maybe thatfeature is
  something we all would love to have, so should it be put in the core? Plugins
  allow the core to stay lean and mean, while delegating additional functionality
  to outside modules. BinGOs' work with making PoCo-IRC inheritable is wonderful,
  but what if there were 2 modules which have features that you would love to
  have in your bot? Inherit from both? Imagine the mess...
  
  Here comes plugins to the rescue :)
  
  You could say Bot::Pluggable does the job, and so on, but if this feature were
  put into the core, it would allow PoCo-IRC to be extended beyond our wildest
  dreams, and allow the code to be shared amongst us all, giving us superior bug
  smashing abilities.
  
  Yes, there are changes that most of us will moan when we go update our bots to
  use the new C<$irc> object system, but what if we also used this opportunity to
  improve PoCo-IRC even more and give it a lifespan until Perl8 or whatever comes
  along? :)
  
  =head1 DESCRIPTION
  
  The plugin system works by letting coders hook into the two aspects of PoCo-IRC:
  
  =over
  
  =item *
  
  Data received from the server
  
  =item *
  
  User commands about to be sent to the server
  
  =back
  
  The goal of this system is to make PoCo-IRC so easy to extend, enabling it to
  Take Over The World! *Just Kidding*
  
  The general architecture of using the plugins should be:
  
   # Import the stuff...
   use POE;
   use POE::Component::IRC;
   use POE::Component::IRC::Plugin::ExamplePlugin;
  
   # Create our session here
   POE::Session->create( ... );
  
   # Create the IRC session here
   my $irc = POE::Component::IRC->spawn() or die "Oh noooo! $!";
  
   # Create the plugin
   # Of course it could be something like $plugin = MyPlugin->new();
   my $plugin = POE::Component::IRC::Plugin::ExamplePlugin->new( ... );
  
   # Hook it up!
   $irc->plugin_add( 'ExamplePlugin', $plugin );
  
   # OOPS, we lost the plugin object!
   my $pluginobj = $irc->plugin_get( 'ExamplePlugin' );
  
   # We want a list of plugins and objects
   my $hashref = $irc->plugin_list();
  
   # Oh! We want a list of plugin aliases.
   my @aliases = keys %{ $irc->plugin_list() };
  
   # Ah, we want to remove the plugin
   $plugin = $irc->plugin_del( 'ExamplePlugin' );
  
  The plugins themselves will conform to the standard API described here. What
  they can do is limited only by imagination and the IRC RFC's ;)
  
   # Import the constants
   use POE::Component::IRC::Plugin qw( :ALL );
  
   # Our constructor
   sub new {
       ...
   }
  
   # Required entry point for PoCo-IRC
   sub PCI_register {
       my ($self, $irc) = @_;
       # Register events we are interested in
       $irc->plugin_register( $self, 'SERVER', qw( 355 kick whatever) );
  
       # Return success
       return 1;
   }
  
   # Required exit point for PoCo-IRC
   sub PCI_unregister {
       my ($self, $irc) = @_;
  
       # PCI will automatically unregister events for the plugin
  
       # Do some cleanup...
  
       # Return success
       return 1;
   }
  
   # Registered events will be sent to methods starting with IRC_
   # If the plugin registered for SERVER - irc_355
   sub S_355 {
       my($self, $irc, $line) = @_;
  
       # Remember, we receive pointers to scalars, so we can modify them
       $$line = 'frobnicate!';
  
       # Return an exit code
       return PCI_EAT_NONE;
   }
  
   # Default handler for events that do not have a corresponding plugin
   # method defined.
   sub _default {
       my ($self, $irc, $event) = splice @_, 0, 3;
  
       print "Default called for $event\n";
  
       # Return an exit code
       return PCI_EAT_NONE;
   }
  
  Plugins can even embed their own POE sessions if they need to do fancy stuff.
  Below is a template for a plugin which does just that.
  
   package POE::Plugin::Template;
  
   use POE;
   use POE::Component::IRC::Plugin qw( :ALL );
  
   sub new {
       my $package = shift;
       my $self = bless {@_}, $package;
       return $self;
   }
  
   sub PCI_register {
       my ($self, $irc) = splice @_, 0, 2;
  
       # We store a ref to the $irc object so we can use it in our
       # session handlers.
       $self->{irc} = $irc;
  
       $irc->plugin_register( $self, 'SERVER', qw(blah blah blah) );
  
       POE::Session->create(
           object_states => [
               $self => [qw(_start _shutdown)],
           ],
       );
  
       return 1;
   }
  
   sub PCI_unregister {
       my ($self, $irc) = splice @_, 0, 2;
       # Plugin is dying make sure our POE session does as well.
       $poe_kernel->call( $self->{SESSION_ID} => '_shutdown' );
       delete $self->{irc};
       return 1;
   }
  
   sub _start {
       my ($kernel, $self) = @_[KERNEL, OBJECT];
       $self->{SESSION_ID} = $_[SESSION]->ID();
       # Make sure our POE session stays around. Could use aliases but that is so messy :)
       $kernel->refcount_increment( $self->{SESSION_ID}, __PACKAGE__ );
       return;
   }
  
   sub _shutdown {
       my ($kernel, $self) = @_[KERNEL, OBJECT];
       $kernel->alarm_remove_all();
       $kernel->refcount_decrement( $self->{SESSION_ID}, __PACKAGE__ );
       return;
   }
  
  =head1 EVENT TYPES
  
  =head2 SERVER hooks
  
  Hooks that are targeted toward data received from the server will get the exact
  same arguments as if it was a normal event, look at the PoCo-IRC docs for more
  information.
  
  NOTE: Server methods are identified in the plugin namespace by the subroutine
  prefix of S_*. I.e. an irc_kick event handler would be:
  
   sub S_kick {}
  
  The only difference is instead of getting scalars, the hook will get a
  reference to the scalar, to allow it to mangle the data. This allows the plugin
  to modify data *before* they are sent out to registered sessions.
  
  They are required to return one of the L<exit codes|/EXIT CODES> so PoCo-IRC
  will know what to do.
  
  =head3 Names of potential hooks
  
   001
   socketerr
   connected
   plugin_del
   ...
  
  Keep in mind that they are always lowercased. Check out the
  L<OUTPUT EVENTS|POE::Component::IRC/OUTPUT EVENTS> section of
  POE::Component::IRC's documentation for the complete list of events.
  
  =head2 USER hooks
  
  These type of hooks have two different argument formats. They are split between
  data sent to the server, and data sent through DCC connections.
  
  NOTE: User methods are identified in the plugin namespace by the subroutine
  prefix of U_*. I.e. an irc_kick event handler would be:
  
   sub U_kick {}
  
  Hooks that are targeted to user data have it a little harder. They will receive
  a reference to the raw line about to be sent out. That means they will have to
  parse it in order to extract data out of it.
  
  The reasoning behind this is that it is not possible to insert hooks in every
  method in the C<$irc> object, as it will become unwieldy and not allow inheritance
  to work.
  
  The DCC hooks have it easier, as they do not interact with the server, and will
  receive references to the arguments specified in the DCC plugin
  L<documentation|POE::Component::IRC::Plugin::DCC/COMMANDS> regarding dcc commands.
  
  =head3 Names of potential hooks
  
   kick
   dcc_chat
   ison
   privmsg
   ...
  
  Keep in mind that they are always lowercased, and are extracted from the raw
  line about to be sent to the irc server. To be able to parse the raw line, some
  RFC reading is in order. These are the DCC events that are not given a raw
  line, they are:
  
   dcc        - $nick, $type, $file, $blocksize, $timeout
   dcc_accept - $cookie, $myfile
   dcc_resume - $cookie
   dcc_chat   - $cookie, @lines
   dcc_close  - $cookie
  
  =head2 _default
  
  If a plugin has registered for an event but doesn't have a hook method
  defined for ir, component will attempt to call a plugin's C<_default> method.
  The first parameter after the plugin and irc objects will be the handler name.
  
   sub _default {
       my ($self, $irc, $event) = splice @_, 0, 3;
  
       # $event will be something like S_public or U_dcc, etc.
       return PCI_EAT_NONE;
   }
  
  The C<_default> handler is expected to return one of the exit codes so PoCo-IRC
  will know what to do.
  
  =head1 EXIT CODES
  
  =head2 PCI_EAT_NONE
  
  This means the event will continue to be processed by remaining plugins and
  finally, sent to interested sessions that registered for it.
  
  =head2 PCI_EAT_CLIENT
  
  This means the event will continue to be processed by remaining plugins but
  it will not be sent to any sessions that registered for it. This means nothing
  will be sent out on the wire if it was an USER event, beware!
  
  =head2 PCI_EAT_PLUGIN
  
  This means the event will not be processed by remaining plugins, it will go
  straight to interested sessions.
  
  =head2 PCI_EAT_ALL
  
  This means the event will be completely discarded, no plugin or session will
  see it. This means nothing will be sent out on the wire if it was an USER
  event, beware!
  
  =head1 EXPORTS
  
  Exports the return constants for plugins to use in @EXPORT_OK
  Also, the ':ALL' tag can be used to get all of them.
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  L<Object::Pluggable|Object::Pluggable>
  
  L<Object::Pluggable::Pipeline|Object::Pluggable::Pipeline>
  
  L<POE::Session|POE::Session>
  
  =head1 AUTHOR
  
  Apocalypse <apocal@cpan.org>
  
  =cut
POE_COMPONENT_IRC_PLUGIN

$fatpacked{"POE/Component/IRC/Plugin/AutoJoin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_AUTOJOIN';
  package POE::Component::IRC::Plugin::AutoJoin;
  BEGIN {
    $POE::Component::IRC::Plugin::AutoJoin::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::AutoJoin::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use IRC::Utils qw(parse_user lc_irc);
  use POE::Component::IRC::Plugin qw(:ALL);
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %self = @_;
      return bless \%self, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = @_;
  
      if (!$self->{Channels}) {
          if ($irc->isa('POE::Component::IRC::State')) {
              for my $chan (keys %{ $irc->channels() }) {
                  my $lchan = lc_irc($chan, $irc->isupport('MAPPING'));
                  # note that this will not get the real key on ircu servers
                  # in channels where we don't have ops
                  my $key = $irc->is_channel_mode_set($chan, 'k')
                      ? $irc->channel_key($chan)
                      : ''
                  ;
  
                  $self->{Channels}->{$lchan} = $key;
              }
          }
          else {
              $self->{Channels} = {};
          }
      }
      elsif (ref $self->{Channels} eq 'ARRAY') {
          my %channels;
          $channels{lc_irc($_, $irc->isupport('MAPPING'))} = undef for @{ $self->{Channels} };
          $self->{Channels} = \%channels;
      }
  
      $self->{tried_keys} = { };
      $self->{Rejoin_delay} = 5 if !defined $self->{Rejoin_delay};
      $self->{NickServ_delay} = 5 if !defined $self->{NickServ_delay};
      $irc->plugin_register($self, 'SERVER', qw(001 474 isupport chan_mode join kick part identified));
      $irc->plugin_register($self, 'USER', qw(join));
      return 1;
  }
  
  sub PCI_unregister {
      return 1;
  }
  
  sub S_001 {
      my ($self, $irc) = splice @_, 0, 2;
      delete $self->{alarm_ids};
      return PCI_EAT_NONE;
  }
  
  # we join channels after S_isupport in case the server supports
  # CAPAB IDENTIFY-MSG, so pocoirc can turn it on before we join channels
  sub S_isupport {
      my ($self, $irc) = splice @_, 0, 2;
  
      if (!grep { $_->isa('POE::Component::IRC::Plugin::NickServID') } values %{ $irc->plugin_list() }) {
          # we don't have to wait for NickServ, so let's join
          while (my ($chan, $key) = each %{ $self->{Channels} }) {
              $irc->yield(join => $chan => (defined $key ? $key : ()));
          }
      }
      else {
          while (my ($chan, $key) = each %{ $self->{Channels} }) {
              push @{ $self->{alarm_ids} }, $irc->delay(
                  [join => $chan => (defined $key ? $key : ())],
                  $self->{NickServ_delay},
              );
          }
      }
      return PCI_EAT_NONE;
  }
  
  sub S_identified {
      my ($self, $irc) = splice @_, 0, 2;
  
      if ($self->{alarm_ids}) {
          $irc->delay_remove($_) for @{ $self->{alarm_ids} };
          delete $self->{alarm_ids};
  
          while (my ($chan, $key) = each %{ $self->{Channels} }) {
              $irc->yield(join => $chan => (defined $key ? $key : ()));
          }
      }
      return PCI_EAT_NONE;
  }
  
  # ERR_BANNEDFROMCHAN
  sub S_474 {
      my ($self, $irc) = splice @_, 0, 2;
      my $chan = ${ $_[2] }->[0];
      my $lchan = lc_irc($chan, $irc->isupport('MAPPING'));
      return PCI_EAT_NONE if !$self->{Retry_when_banned};
  
      my $key = $self->{Channels}{$lchan};
      $key = $self->{tried_keys}{$lchan} if defined $self->{tried_keys}{$lchan};
      $irc->delay([join => $chan => (defined $key ? $key : ())], $self->{Retry_when_banned});
      return PCI_EAT_NONE;
  }
  
  sub S_chan_mode {
      my ($self, $irc) = splice @_, 0, 2;
      pop @_;
      my $chan  = ${ $_[1] };
      my $mode  = ${ $_[2] };
      my $arg   = defined $_[3] ? ${ $_[3] } : '';
      my $lchan = lc_irc($chan, $irc->isupport('MAPPING'));
  
      $self->{Channels}->{$lchan} = $arg if $mode eq '+k';
      $self->{Channels}->{$lchan} = '' if $mode eq '-k';
      return PCI_EAT_NONE;
  }
  
  sub S_join {
      my ($self, $irc) = splice @_, 0, 2;
      my $joiner = parse_user(${ $_[0] });
      my $chan   = ${ $_[1] };
      my $lchan  = lc_irc($chan, $irc->isupport('MAPPING'));
  
      return PCI_EAT_NONE if $joiner ne $irc->nick_name();
      delete $self->{alarm_ids};
  
      if (defined $self->{tried_keys}{$lchan}) {
          $self->{Channels}->{$lchan} = $self->{tried_keys}{$lchan};
          delete $self->{tried_keys}{$lchan};
      }
      else {
          $self->{Channels}->{$lchan} = '';
      }
  
      return PCI_EAT_NONE;
  }
  
  sub S_kick {
      my ($self, $irc) = splice @_, 0, 2;
      my $chan   = ${ $_[1] };
      my $victim = ${ $_[2] };
      my $lchan  = lc_irc($chan, $irc->isupport('MAPPING'));
  
      if ($victim eq $irc->nick_name()) {
          if ($self->{RejoinOnKick}) {
              $irc->delay([
                  'join',
                  $chan,
                  (defined $self->{Channels}->{$lchan} ? $self->{Channels}->{$lchan} : ())
              ], $self->{Rejoin_delay});
          }
          delete $self->{Channels}->{$lchan};
      }
      return PCI_EAT_NONE;
  }
  
  sub S_part {
      my ($self, $irc) = splice @_, 0, 2;
      my $parter = parse_user(${ $_[0] });
      my $chan   = ${ $_[1] };
      my $lchan  = lc_irc($chan, $irc->isupport('MAPPING'));
  
      delete $self->{Channels}->{$lchan} if $parter eq $irc->nick_name();
      return PCI_EAT_NONE;
  }
  
  sub U_join {
      my ($self, $irc) = splice @_, 0, 2;
      my (undef, $chan, $key) = split /\s/, ${ $_[0] }, 3;
      my $lchan = lc_irc($chan, $irc->isupport('MAPPING'));
  
      $self->{tried_keys}->{$lchan} = $key if defined $key;
      return PCI_EAT_NONE;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::AutoJoin - A PoCo-IRC plugin which
  keeps you on your favorite channels
  
  =head1 SYNOPSIS
  
   use POE qw(Component::IRC::State Component::IRC::Plugin::AutoJoin);
  
   my $nickname = 'Chatter';
   my $server = 'irc.blahblahblah.irc';
  
   my %channels = (
       '#Blah'   => '',
       '#Secret' => 'secret_password',
       '#Foo'    => '',
   );
  
   POE::Session->create(
       package_states => [
           main => [ qw(_start irc_join) ],
       ],
   );
  
   $poe_kernel->run();
  
   sub _start {
       my $irc = POE::Component::IRC::State->spawn(
           Nick => $nickname,
           Server => $server,
       ) or die "Oh noooo! $!";
  
       $irc->plugin_add('AutoJoin', POE::Component::IRC::Plugin::AutoJoin->new( Channels => \%channels ));
       $irc->yield(register => qw(join);
       $irc->yield(connect => { } );
   }
  
   sub irc_join {
       my $chan = @_[ARG1];
       $irc->yield(privmsg => $chan => "hi $channel!");
   }
  
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::AutoJoin is a L<POE::Component::IRC|POE::Component::IRC>
  plugin. If you get disconnected, the plugin will join all the channels you were
  on the next time it gets connected to the IRC server. It can also rejoin a
  channel if the IRC component gets kicked from it. It keeps track of channel
  keys so it will be able to rejoin keyed channels in case of reconnects/kicks.
  
  If a L<POE::Component::IRC::Plugin::NickServID|POE::Component::IRC::Plugin::NickServID>
  plugin has been added to the IRC component, then AutoJoin will wait for a
  reply from NickServ before joining channels on connect.
  
  This plugin requires the IRC component to be
  L<POE::Component::IRC::State|POE::Component::IRC::State> or a subclass thereof.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Takes the following optional arguments:
  
  B<'Channels'>, either an array reference of channel names, or a hash reference
  keyed on channel name, containing the password for each channel. By default it
  uses the channels the component is already on if you are using
  L<POE::Component::IRC::State|POE::Component::IRC::State>.
  
  B<'RejoinOnKick'>, set this to 1 if you want the plugin to try to rejoin a
  channel (once) if you get kicked from it. Default is 0.
  
  B<'Rejoin_delay'>, the time, in seconds, to wait before rejoining a channel
  after being kicked (if B<'RejoinOnKick'> is on). Default is 5.
  
  B<'Retry_when_banned'>, if you can't join a channel due to a ban, set this
  to the number of seconds to wait between retries. Default is 0 (disabled).
  
  B<'NickServ_delay'>, how long (in seconds) to wait for a reply from NickServ
  before joining channels. Default is 5.
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head1 AUTHOR
  
  Hinrik E<Ouml>rn SigurE<eth>sson, hinrik.sig@gmail.com
  
  =cut
POE_COMPONENT_IRC_PLUGIN_AUTOJOIN

$fatpacked{"POE/Component/IRC/Plugin/BotAddressed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_BOTADDRESSED';
  package POE::Component::IRC::Plugin::BotAddressed;
  BEGIN {
    $POE::Component::IRC::Plugin::BotAddressed::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::BotAddressed::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use POE::Component::IRC::Plugin qw( :ALL );
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %args = @_;
  
      $args{lc $_} = delete $args{$_} for keys %args;
      return bless \%args, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = splice @_, 0, 2;
      $irc->plugin_register( $self, 'SERVER', qw(ctcp_action public) );
      return 1;
  }
  
  sub PCI_unregister {
      return 1;
  }
  
  sub S_ctcp_action {
      my ($self, $irc) = splice @_, 0, 2;
      my $who = ${ $_[0] };
      my $recipients = ${ $_[1] };
      my $what = ${ $_[2] };
      my $me = $irc->nick_name();
      my $chantypes = join('', @{ $irc->isupport('CHANTYPES') || ['#', '&']});
  
      my $eat = PCI_EAT_NONE;
      return $eat if $what !~ /$me/i;
  
      for my $recipient (@{ $recipients }) {
          if ($recipient =~ /^[$chantypes]/) {
              $eat = PCI_EAT_ALL if $self->{eat};
              $irc->send_event_next(irc_bot_mentioned_action => $who => [$recipient] => $what);
          }
      }
  
      return $eat;
  }
  
  sub S_public {
      my ($self, $irc) = splice @_, 0, 2;
      my $who = ${ $_[0] };
      my $channels = ${ $_[1] };
      my $what = ${ $_[2] };
      my $me = $irc->nick_name();
      my ($cmd) = $what =~ m/^\s*[@%]?\Q$me\E[:,;.!?~]?\s*(.*)$/i;
  
      return PCI_EAT_NONE if !defined $cmd && $what !~ /$me/i;
  
      for my $channel (@{ $channels }) {
          if (defined $cmd) {
              $irc->send_event_next(irc_bot_addressed => $who => [$channel] => $cmd );
          }
          else {
              $irc->send_event_next(irc_bot_mentioned => $who => [$channel] => $what);
          }
      }
  
      return $self->{eat} ? PCI_EAT_ALL : PCI_EAT_NONE;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::BotAddressed - A PoCo-IRC plugin that generates
  events when you are addressed
  
  =head1 SYNOPSIS
  
   use POE::Component::IRC::Plugin::BotAddressed;
  
   $irc->plugin_add( 'BotAddressed', POE::Component::IRC::Plugin::BotAddressed->new() );
  
   sub irc_bot_addressed {
       my ($kernel, $heap) = @_[KERNEL, HEAP];
       my $nick = ( split /!/, $_[ARG0] )[0];
       my $channel = $_[ARG1]->[0];
       my $what = $_[ARG2];
  
       print "$nick addressed me in channel $channel with the message '$what'\n";
   }
  
   sub irc_bot_mentioned {
       my ($nick) = ( split /!/, $_[ARG0] )[0];
       my ($channel) = $_[ARG1]->[0];
       my ($what) = $_[ARG2];
  
       print "$nick mentioned my name in channel $channel with the message '$what'\n";
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::BotAddressed is a
  L<POE::Component::IRC|POE::Component::IRC> plugin. It watches for public
  channel traffic (i.e. C<irc_public> and C<irc_ctcp_action>) and will generate
  an C<irc_bot_addressed>, C<irc_bot_mentioned> or C<irc_bot_mentioned_action>
  event if its name comes up in channel discussion.
  
  =head1 METHODS
  
  =head2 C<new>
  
  One optional argument:
  
  B<'eat'>, set to true to make the plugin eat the C<irc_public> /
  C<irc_ctcp_action>
  event and only generate an appropriate event, default is false.
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head1 OUTPUT EVENTS
  
  =head2 C<irc_bot_addressed>
  
  Has the same parameters passed as L<C<irc_ctcp_public>|POE::Component::IRC/irc_public>.
  C<ARG2> contains the message with the addressed nickname removed, ie. Assuming
  that your bot is called LameBOT, and someone says 'LameBOT: dance for me',
  you will actually get 'dance for me'.
  
  =head2 C<irc_bot_mentioned>
  
  Has the same parameters passed as L<C<irc_public>|POE::Component::IRC/irc_public>.
  
  =head2 C<irc_bot_mentioned_action>
  
  Has the same parameters passed as L<C<irc_ctcp_action>|POE::Component::IRC/irc_ctcp_*>.
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams <chris@bingosnet.co.uk>
  
  =cut
POE_COMPONENT_IRC_PLUGIN_BOTADDRESSED

$fatpacked{"POE/Component/IRC/Plugin/BotCommand.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_BOTCOMMAND';
  package POE::Component::IRC::Plugin::BotCommand;
  BEGIN {
    $POE::Component::IRC::Plugin::BotCommand::AUTHORITY = 'cpan:HINRIK';
  }
  # vim: set expandtab ts=4 sw=4 ai:
  $POE::Component::IRC::Plugin::BotCommand::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use IRC::Utils qw( parse_user strip_color strip_formatting );
  use POE::Component::IRC::Plugin qw( :ALL );
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %args = @_;
  
      $args{Method} = 'notice' if !defined $args{Method};
  
      for my $cmd (keys %{ $args{Commands} }) {
          if (ref $args{Commands}->{$cmd} eq 'HASH') {
              croak "$cmd: no info provided"
                  if !exists $args{Commands}->{$cmd}->{info} ;
              $args{Commands}->{lc $cmd}->{handler} = 
                  sprintf("irc_botcmd_%s", lc($cmd))
                  if !$args{Commands}->{lc $cmd}->{handler};
          }
          $args{Commands}->{lc $cmd} = delete $args{Commands}->{$cmd};
      }
      return bless \%args, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = splice @_, 0, 2;
  
      $self->{Addressed}   = 1   if !defined $self->{Addressed};
      $self->{Prefix}      = '!' if !defined $self->{Prefix};
      $self->{In_channels} = 1   if !defined $self->{In_channels};
      $self->{In_private}  = 1   if !defined $self->{In_private};
      $self->{rx_cmd_args} = qr/^(\S+)(?:\s+(.+))?$/;
      $self->{irc} = $irc;
  
      $irc->plugin_register( $self, 'SERVER', qw(msg public) );
      return 1;
  }
  
  sub PCI_unregister {
      return 1;
  }
  
  sub S_msg {
      my ($self, $irc) = splice @_, 0, 2;
      my $who   = ${ $_[0] };
      my $where = parse_user($who);
      my $what  = ${ $_[2] };
  
      return PCI_EAT_NONE if !$self->{In_private};
      $what = $self->_normalize($what);
  
      if (!$self->{Bare_private}) {
          return PCI_EAT_NONE if $what !~ s/^\Q$self->{Prefix}\E//;
      }
  
      my ($cmd, $args);
      if (!(($cmd, $args) = $what =~ $self->{rx_cmd_args})) {
          return PCI_EAT_NONE;
      }
  
      $self->_handle_cmd($who, $where, $cmd, $args);
      return $self->{Eat} ? PCI_EAT_PLUGIN : PCI_EAT_NONE;
  }
  
  sub S_public {
      my ($self, $irc) = splice @_, 0, 2;
      my $who   = ${ $_[0] };
      my $where = ${ $_[1] }->[0];
      my $what  = ${ $_[2] };
      my $me    = $irc->nick_name();
  
      return PCI_EAT_NONE if !$self->{In_channels};
      $what = $self->_normalize($what);
  
      if ($self->{Addressed}) {
          return PCI_EAT_NONE if !(($what) = $what =~ m/^\s*\Q$me\E[:,;.!?~]?\s*(.*)$/);
      }
      else {
          return PCI_EAT_NONE if $what !~ s/^\Q$self->{Prefix}\E//;
      }
  
      my ($cmd, $args);
      if (!(($cmd, $args) = $what =~ $self->{rx_cmd_args})) {
          return PCI_EAT_NONE;
      }
  
      $self->_handle_cmd($who, $where, $cmd, $args);
      return $self->{Eat} ? PCI_EAT_PLUGIN : PCI_EAT_NONE;
  }
  
  sub _normalize {
      my ($self, $line) = @_;
      $line = strip_color($line);
      $line = strip_formatting($line);
      return $line;
  }
  
  sub _handle_cmd {
      my ($self, $who, $where, $cmd, $args) = @_;
      my $irc = $self->{irc};
      my $chantypes = join('', @{ $irc->isupport('CHANTYPES') || ['#', '&']});
      my $public = $where =~ /^[$chantypes]/ ? 1 : 0;
      $cmd = lc $cmd;
  
      my $cmd_unresolved = $cmd;
  
      if((my $cmd_resolved = $self->resolve_alias($cmd)))
      {
          $cmd = $cmd_resolved;
      }
  
  
      if (defined $self->{Commands}->{$cmd}) {
          if (ref $self->{Commands}->{$cmd} eq 'HASH') {
              my @args_array = defined $args ? split /\s+/, $args : ();
              if (defined($self->{Commands}->{$cmd}->{args}) &&
                 ref($self->{Commands}->{$cmd}->{args}) eq 'ARRAY' &&
                 @{ $self->{Commands}->{$cmd}->{args} } && 
                 (@args_array < @{ $self->{Commands}->{$cmd}->{args} } ||
                 (!defined $self->{Commands}->{$cmd}->{variable} &&
                  @args_array > @{ $self->{Commands}->{$cmd}->{args} }))
              ) {
                    $irc->yield($self->{Method}, $where,
                        "Not enough or too many arguments. See help for $cmd");
                    return;
              }
  
              if(defined $self->{Commands}->{$cmd}->{variable} ||
                  (defined($self->{Commands}->{$cmd}->{args}) &&
                      ref($self->{Commands}->{$cmd}->{args}) eq 'ARRAY' &&
                      @{ $self->{Commands}->{$cmd}->{args} }))
              {
                  $args = {};
                  if( defined($self->{Commands}->{$cmd}->{args}) &&
                      ref($self->{Commands}->{$cmd}->{args}) eq 'ARRAY' &&
                      @{ $self->{Commands}->{$cmd}->{args} })
                  {
                      for (@{ $self->{Commands}->{$cmd}->{args} }) {
                          my $in_arg = shift @args_array;
                          if (ref $self->{Commands}->{$cmd}->{$_} eq 'ARRAY') {
                              my @values = @{ $self->{Commands}->{$cmd}->{$_} };
                              shift @values;
  
                              use List::MoreUtils qw(none);
                              # Check if argument has one of possible values
                              if (none { $_ eq $in_arg} @values) {
                                  $irc->yield($self->{Method}, $where,
                                      "$_ can be one of ".join '|', @values);
                                  return;
                              }
  
                          }
                          $args->{$_} = $in_arg;
                      }
                  }
  
                  # Process remaining arguments if variable is set
                  my $arg_cnt = 0;
                  if (defined $self->{Commands}->{$cmd}->{variable}) {
                      for (@args_array) {
                          $args->{"opt".$arg_cnt++} = $_;
                      }
                  }
              }
          }
      }
  
      if (ref $self->{Auth_sub} eq 'CODE') {
          my ($authed, $errors) = $self->{Auth_sub}->($self->{irc}, $who, $where, $cmd, $args, $cmd_unresolved);
  
          if (!$authed) {
              my @errors = ref $errors eq 'ARRAY'
                  ? @$errors
                  : 'You are not authorized to use this command.';
              for my $error (@errors) {
                  $irc->yield($self->{Method}, $where, $error);
              }
              return;
          }
      }
  
      if (defined $self->{Commands}->{$cmd}) {
          my $handler = (ref($self->{Commands}->{$cmd}) eq 'HASH' ? $self->{Commands}->{$cmd}->{handler} : "irc_botcmd_$cmd");
          $irc->send_event_next($handler => $who, $where, $args, $cmd, $cmd_unresolved);
      }
      elsif ($cmd =~ /^help$/i) {
          my @help = $self->_get_help($args, $public);
          $irc->yield($self->{Method} => $where => $_) for @help;
      }
      elsif (!$self->{Ignore_unknown}) {
          my @help = $self->_get_help($cmd, $public);
          $irc->yield($self->{Method} => $where => $_) for @help;
      }
  
      return;
  }
  
  sub _get_help {
      my ($self, $args, $public) = @_;
      my $irc = $self->{irc};
      my $p = $self->{Addressed} && $public
          ? $irc->nick_name().': '
          : $self->{Prefix};
  
      my @help;
      if (defined $args) {
          my $cmd = (split /\s+/, $args, 2)[0];
  
          $cmd = lc $cmd;
  
          my $cmd_resolved = $self->resolve_alias($cmd) || $cmd;
  
          if (exists $self->{Commands}->{$cmd_resolved}) {
              if (ref $self->{Commands}->{$cmd_resolved} eq 'HASH') {
                  push @help, "Syntax: $p$cmd".
                      (   defined($self->{Commands}->{$cmd_resolved}->{args}) &&
                          ref($self->{Commands}->{$cmd_resolved}->{args}) eq 'ARRAY' ?
                          " ".join ' ', @{ $self->{Commands}->{$cmd_resolved}->{args} } :
                          "" ).
                      (defined $self->{Commands}->{$cmd_resolved}->{variable} ?
                          " ..."  : "");
                  push @help, split /\015?\012/,
                      "Description: ".$self->{Commands}->{$cmd_resolved}->{info};
                  if( defined($self->{Commands}->{$cmd_resolved}->{args}) &&
                      ref($self->{Commands}->{$cmd_resolved}->{args}) eq 'ARRAY' &&
                      @{ $self->{Commands}->{$cmd_resolved}->{args} })
                  {
                      push @help, "Arguments:";
  
                      for my $arg (@{ $self->{Commands}->{$cmd_resolved}->{args} }) {
                          next if not defined $self->{Commands}->{$cmd_resolved}->{$arg};
                          if (ref $self->{Commands}->{$cmd_resolved}->{$arg} eq 'ARRAY') {
                              my @arg_usage = @{$self->{Commands}->{$cmd_resolved}->{$arg}};
                              push @help, "    $arg: ".$arg_usage[0].
                              " (".(join '|', @arg_usage[1..$#arg_usage]).")"
                          }
                          else {
                              push @help, "    $arg: ".
                                  $self->{Commands}->{$cmd_resolved}->{$arg};
                          }
                      }
                  }
  
                  push @help, "Alias of: ${p}${cmd_resolved}" .
                          (ref($self->{Commands}->{$cmd_resolved}->{args}) eq 'ARRAY' ?
                          " ".join ' ', @{ $self->{Commands}->{$cmd_resolved}->{args} } :
                          "" ).
                      (defined $self->{Commands}->{$cmd_resolved}->{variable} ?
                          " ..."  : "")
                      if $cmd_resolved ne $cmd;
  
                  my @aliases = grep { $_ ne $cmd } $self->list_aliases($cmd_resolved);
  
                  if($cmd_resolved ne $cmd)
                  {
                      push @aliases, $cmd_resolved;
                  }
  
                  push @help, "Aliases: ".join( " ", @aliases) if scalar(@aliases);
              }
              else {
                  @help = split /\015?\012/, $self->{Commands}->{$cmd};
              }
          }
          else {
              push @help, "Unknown command: $cmd";
              push @help, "To get a list of commands, use: ${p}help";
          }
      }
      else {
          if (keys %{ $self->{Commands} }) {
              push @help, 'Commands: ' . join ', ', sort keys %{ $self->{Commands} };
              push @help, "For more details, use: ${p}help <command>";
          }
          else {
              push @help, 'No commands are defined';
          }
      }
  
      if(ref($self->{'Help_sub'}) eq 'CODE')
      {
          my ($cmd, $args) = (defined $args ? split /\s+/, $args, 2 : ('', ''));
  
          my $cmd_resolved = $self->resolve_alias($cmd) || $cmd;
  
          return $self->{'Help_sub'}->($self->{irc}, $cmd, $cmd_resolved, $args, @help);
      }
      else
      {
          return @help;
      }
  }
  
  sub add {
      my ($self, $cmd, $usage) = @_;
      $cmd = lc $cmd;
      return if exists $self->{Commands}->{$cmd};
  
      if (ref $usage eq 'HASH') {
          return if !exists $usage->{info} || !@{ $usage->{args} };
      }
  
      $self->{Commands}->{$cmd} = $usage;
      return 1;
  }
  
  sub remove {
      my ($self, $cmd) = @_;
      $cmd = lc $cmd;
      return if !exists $self->{Commands}->{$cmd};
      delete $self->{Commands}->{$cmd};
      return 1;
  }
  
  sub list {
      my ($self) = @_;
      return %{ $self->{Commands} };
  }
  
  sub resolve_alias {
      my ($self, $alias) = @_;
      
      my %cmds = $self->list();
  
      #TODO: refactor using smartmatch/Perl6::Junction if feasible
      while(my ($cmd, $info) = each(%cmds))
      {
         next unless ref($info) eq 'HASH';
         next unless $info->{aliases} && ref($info->{aliases}) eq 'ARRAY';
         my @aliases = @{$info->{aliases}};
         
         foreach my $cmdalias (@aliases)
         {
             return $cmd if $alias eq $cmdalias;
         }
      }
  
      return undef;
  }
  
  sub list_aliases
  {
      my ($self, $cmd) = @_;
      $cmd = lc $cmd;
      return if !exists $self->{Commands}->{$cmd};
      return unless ref($self->{Commands}->{$cmd}) eq 'HASH';
      return unless exists $self->{Commands}->{$cmd}->{aliases} && ref($self->{Commands}->{$cmd}->{aliases}) eq 'ARRAY';
      return @{$self->{Commands}->{$cmd}->{aliases}};
  
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::BotCommand - A PoCo-IRC plugin which handles
  commands issued to your bot
  
  =head1 SYNOPSIS
  
   use POE;
   use POE::Component::Client::DNS;
   use POE::Component::IRC;
   use POE::Component::IRC::Plugin::BotCommand;
  
   my @channels = ('#channel1', '#channel2');
   my $dns = POE::Component::Client::DNS->spawn();
   my $irc = POE::Component::IRC->spawn(
       nick   => 'YourBot',
       server => 'some.irc.server',
   );
  
   POE::Session->create(
       package_states => [
           main => [ qw(_start irc_001 irc_botcmd_slap irc_botcmd_lookup dns_response) ],
       ],
   );
  
   $poe_kernel->run();
  
   sub _start {
       $irc->plugin_add('BotCommand', POE::Component::IRC::Plugin::BotCommand->new(
           Commands => {
               slap   => 'Takes one argument: a nickname to slap.',
               lookup => 'Takes two arguments: a record type (optional), and a host.',
           }
       ));
       $irc->yield(register => qw(001 botcmd_slap botcmd_lookup));
       $irc->yield(connect => { });
   }
  
   # join some channels
   sub irc_001 {
       $irc->yield(join => $_) for @channels;
       return;
   }
  
   # the good old slap
   sub irc_botcmd_slap {
       my $nick = (split /!/, $_[ARG0])[0];
       my ($where, $arg) = @_[ARG1, ARG2];
       $irc->yield(ctcp => $where, "ACTION slaps $arg");
       return;
   }
  
   # non-blocking dns lookup
   sub irc_botcmd_lookup {
       my $nick = (split /!/, $_[ARG0])[0];
       my ($where, $arg) = @_[ARG1, ARG2];
       my ($type, $host) = $arg =~ /^(?:(\w+) )?(\S+)/;
  
       my $res = $dns->resolve(
           event => 'dns_response',
           host => $host,
           type => $type,
           context => {
               where => $where,
               nick  => $nick,
           },
       );
       $poe_kernel->yield(dns_response => $res) if $res;
       return;
   }
  
   sub dns_response {
       my $res = $_[ARG0];
       my @answers = map { $_->rdatastr } $res->{response}->answer() if $res->{response};
  
       $irc->yield(
           'notice',
           $res->{context}->{where},
           $res->{context}->{nick} . (@answers
               ? ": @answers"
               : ': no answers for "' . $res->{host} . '"')
       );
  
       return;
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::BotCommand is a
  L<POE::Component::IRC|POE::Component::IRC> plugin. It provides you with a
  standard interface to define bot commands and lets you know when they are
  issued. Commands are accepted as channel or private messages.
  
  The plugin will respond to the 'help' command by default, listing available
  commands and information on how to use them. However, if you add a help
  command yourself, that one will be used instead.
  
  =head1 METHODS
  
  =head2 C<new>
  
  B<'Commands'>, a hash reference, with your commands as keys, and usage
  information as values. If the usage string contains newlines, the plugin
  will send one message for each line.
  
  If a command's value is a HASH ref like this:
  
       $irc->plugin_add('BotCommand', POE::Component::IRC::Plugin::BotCommand->new(
           Commands => {
               slap   => {
                  info => 'Slap someone',
                  args => [qw(nickname)],
                  nickname => 'nickname to slap'
               }
           }
       ));
  
  The args array reference is than used to validate number of arguments required
  and to name arguments passed to event handler. Help is than generated from
  C<info> and other hash keys which represent arguments (they are optional).
  
  An optional C<handler> key can be specified inside the HASH ref to override the event handler.
  The irc_botcmd_ prefix  is not automatically prepended  to the handler name when overriding it. 
  
  An optional C<aliases>  key can be specified inside the HASH ref containing a array ref with alias names.
  The aliases can be specified for help and to run the command.
  
  =head3 Accepting commands
  
  B<'In_channels'>, a boolean value indicating whether to accept commands in
  channels. Default is true.
  
  B<'In_private'>, a boolean value indicating whether to accept commands in
  private. Default is true.
  
  B<'Addressed'>, requires users to address the bot by name in order
  to issue commands. Default is true.
  
  B<'Prefix'>, a string which all commands must be prefixed with (except in
  channels when B<'Addressed'> is true). Default is '!'. You can set it to ''
  to allow bare commands.
  
  B<'Bare_private'>, a boolean value indicating whether bare commands (without
  the prefix) are allowed in private messages. Default is false.
  
  =head3 Authorization
  
  B<'Auth_sub'>, a subroutine reference which, if provided, will be called
  for every command. The subroutine will be called in list context. If the
  first value returned is true, the command will be processed as normal. If
  the value is false, then no events will be generated, and an error message
  will possibly be sent back to the user.
  
  You can override the default error message by returning a second value, an
  array reference of (zero or more) strings. Each string will be sent as a
  message to the user.
  
  Your subroutine will be called with the following arguments:
  
  =over 4
  
  =item 1. The IRC component object
  
  =item 2. The nick!user@host of the user
  
  =item 3. The place where the command was issued (the nickname of the user if
  it was in private)
  
  =item 4. The name of the command
  
  =item 5. The command argument string
  
  =back
  
  B<'Ignore_unauthorized'>, if true, the plugin will ignore unauthorized
  commands, rather than printing an error message upon receiving them. This is
  only relevant if B<'Auth_sub'> is also supplied. Default is false.
  
  =head3 Help Command
  
  B<'Help_sub'>, a subroutine reference which, if provided, will be called upon
  the end of the predefined help command. The subroutine will be called in list context.
  
  Your subroutine will be called with the following arguments:
  
  =over 4
  
  =item 1. The IRC component object
  
  =item 2. The command.
  
  =item 3. The resolved command(after alias processing).
  
  =item 4. The arguments.
  
  =item 5. The generated help text as array.
  
  
  =back
  
  
  =head3 Miscellaneous
  
  B<'Ignore_unknown'>, if true, the plugin will ignore undefined commands,
  rather than printing a help message upon receiving them. Default is false.
  
  B<'Method'>, how you want help messages to be delivered. Valid options are
  'notice' (the default) and 'privmsg'.
  
  B<'Eat'>, set to true to make the plugin hide
  L<C<irc_public>|POE::Component::IRC/irc_public> events from other plugins
  when they look like commands. Probably only useful when a B<'Prefix'> is
  defined. Default is false.
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head2 C<add>
  
  Adds a new command. Takes two arguments, the name of the command, and a string
  or hash reference containing its usage information (see C<new>). Returns false
  if the command has already been defined or no info or arguments are provided,
  true otherwise.
  
  =head2 C<remove>
  
  Removes a command. Takes one argument, the name of the command. Returns false
  if the command wasn't defined to begin with, true otherwise.
  
  =head2 C<list>
  
  Takes no arguments. Returns a list of key/value pairs, the keys being the
  command names and the values being the usage strings or hash references.
  
  =head2 C<resolve_alias>
  
  Takes one argument, a string to match against command aliases, if no matching
  command can be found undef is returned.
  
  =head1 OUTPUT EVENTS
  
  =head2 C<irc_botcmd_*>
  
  You will receive an event like this for every valid command issued. E.g. if
  'slap' were a valid command, you would receive an C<irc_botcmd_slap> event
  every time someone issued that command. It receives the following arguments:
  
  =over 4
  
  =item * C<ARG0>: the nick!hostmask of the user who issued the command.
  
  =item * C<ARG1> is the name of the channel in which the command was issued,
  or the sender's nickname if this was a private message.
  
  =item * C<ARG2>: a string of arguments to the command, or hash reference with
  arguments in case you defined command along with arguments, or undef if there
  were no arguments
  
  =back
  
  =head1 AUTHOR
  
  Hinrik E<Ouml>rn SigurE<eth>sson, hinrik.sig@gmail.com
  
  =cut
POE_COMPONENT_IRC_PLUGIN_BOTCOMMAND

$fatpacked{"POE/Component/IRC/Plugin/BotTraffic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_BOTTRAFFIC';
  package POE::Component::IRC::Plugin::BotTraffic;
  BEGIN {
    $POE::Component::IRC::Plugin::BotTraffic::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::BotTraffic::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use POE::Component::IRC::Plugin qw( :ALL );
  use POE::Filter::IRCD;
  use POE::Filter::IRC::Compat;
  
  sub new {
      my ($package) = @_;
      return bless { }, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = splice @_, 0, 2;
  
      $self->{filter} = POE::Filter::IRCD->new();
      $self->{compat} = POE::Filter::IRC::Compat->new();
      $irc->plugin_register( $self, 'USER', qw(privmsg notice) );
      return 1;
  }
  
  sub PCI_unregister {
      return 1;
  }
  
  sub U_notice {
      my ($self, $irc) = splice @_, 0, 2;
      my $output  = ${ $_[0] };
      my $line    = $self->{filter}->get([ $output ])->[0];
      my $text    = $line->{params}->[1];
      my $targets = [ split(/,/, $line->{params}->[0]) ];
  
      $irc->send_event_next(irc_bot_notice => $targets => $text);
  
      return PCI_EAT_NONE;
  }
  
  sub U_privmsg {
      my ($self, $irc) = splice @_, 0, 2;
      my $output = ${ $_[0] };
      my $line   = $self->{filter}->get([ $output ])->[0];
      my $text   = $line->{params}->[1];
  
      if ($text =~ /^\001/) {
          my $ctcp_event = $self->{compat}->get([$line])->[0];
          return PCI_EAT_NONE if $ctcp_event->{name} ne 'ctcp_action';
          $irc->send_event_next(irc_bot_action => @{ $ctcp_event->{args} }[1..2]);
      }
      else {
          my $chantypes = join('', @{ $irc->isupport('CHANTYPES') || ['#', '&']});
          for my $recipient ( split(/,/, $line->{params}->[0]) ) {
              my $event = 'irc_bot_msg';
              $event = 'irc_bot_public' if $recipient =~ /^[$chantypes]/;
              $irc->send_event_next($event => [ $recipient ] => $text);
          }
      }
  
      return PCI_EAT_NONE;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::BotTraffic - A PoCo-IRC plugin that generates
  events when you send messages
  
  =head1 SYNOPSIS
  
   use POE::Component::IRC::Plugin::BotTraffic;
  
   $irc->plugin_add( 'BotTraffic', POE::Component::IRC::Plugin::BotTraffic->new() );
  
   sub irc_bot_public {
       my ($kernel, $heap) = @_[KERNEL, HEAP];
       my $channel = $_[ARG0]->[0];
       my $what = $_[ARG1];
  
       print "I said '$what' on channel $channel\n";
       return;
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::BotTraffic is a L<POE::Component::IRC|POE::Component::IRC>
  plugin. It watches for when your bot sends PRIVMSGs and NOTICEs to the server
  and generates the appropriate events.
  
  These events are useful for logging what your bot says.
  
  =head1 METHODS
  
  =head2 C<new>
  
  No arguments required. Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head1 OUTPUT EVENTS
  
  These are the events generated by the plugin. Both events have C<ARG0> set
  to an arrayref of recipients and C<ARG1> the text that was sent.
  
  =head2 C<irc_bot_public>
  
  C<ARG0> will be an arrayref of recipients. C<ARG1> will be the text sent.
  
  =head2 C<irc_bot_msg>
  
  C<ARG0> will be an arrayref of recipients. C<ARG1> will be the text sent.
  
  =head2 C<irc_bot_action>
  
  C<ARG0> will be an arrayref of recipients. C<ARG1> will be the text sent.
  
  =head2 C<irc_bot_notice>
  
  C<ARG0> will be an arrayref of recipients. C<ARG1> will be the text sent.
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams [chris@bingosnet.co.uk]
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC>
  
  =cut
POE_COMPONENT_IRC_PLUGIN_BOTTRAFFIC

$fatpacked{"POE/Component/IRC/Plugin/CTCP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_CTCP';
  package POE::Component::IRC::Plugin::CTCP;
  BEGIN {
    $POE::Component::IRC::Plugin::CTCP::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::CTCP::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use POE::Component::IRC;
  use POE::Component::IRC::Plugin qw( :ALL );
  use POSIX qw(strftime);
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %args = @_;
  
      $args{ lc $_ } = delete $args{ $_ } for keys %args;
      $args{eat} = 1 if !defined ( $args{eat} ) || $args{eat} eq '0';
      return bless \%args, $package;
  }
  
  sub PCI_register {
      my ($self,$irc) = splice @_, 0, 2;
  
      $self->{irc} = $irc;
      $irc->plugin_register( $self, 'SERVER', qw(ctcp_version ctcp_clientinfo ctcp_userinfo ctcp_time ctcp_ping ctcp_source) );
  
      return 1;
  }
  
  sub PCI_unregister {
      delete $_[0]->{irc};
      return 1;
  }
  
  ## no critic (TestingAndDebugging::ProhibitNoStrict)
  sub S_ctcp_version {
      my ($self, $irc) = splice @_, 0, 2;
      my $nick = ( split /!/, ${ $_[0] } )[0];
  
      my $our_version;
      {
          no strict 'vars';
          if (defined $POE::Component::IRC::VERSION
                  && $POE::Component::IRC::VERSION ne '1, set by base.pm') {
              $our_version = 'dev-git';
          }
          else {
              $our_version = $POE::Component::IRC::VERSION;
          }
      }
  
      $irc->yield( ctcpreply => $nick => 'VERSION ' . ( defined $self->{version}
              ? $self->{version}
              : "POE::Component::IRC-$our_version"
      ));
      return PCI_EAT_CLIENT if $self->eat();
      return PCI_EAT_NONE;
  }
  
  sub S_ctcp_time {
      my ($self, $irc) = splice @_, 0, 2;
      my $nick = ( split /!/, ${ $_[0] } )[0];
  
      $irc->yield(ctcpreply => $nick => strftime('TIME %a, %d %b %Y %H:%M:%S %z', localtime));
  
      return PCI_EAT_CLIENT if $self->eat();
      return PCI_EAT_NONE;
  }
  
  sub S_ctcp_ping {
      my ($self,$irc) = splice @_, 0, 2;
      my $nick = ( split /!/, ${ $_[0] } )[0];
      my $timestamp = ${ $_[2] };
  
      $irc->yield( ctcpreply => $nick => 'PING ' . $timestamp );
  
      return PCI_EAT_CLIENT if $self->eat();
      return PCI_EAT_NONE;
  }
  
  sub S_ctcp_clientinfo {
      my ($self, $irc) = splice @_, 0, 2;
      my $nick = ( split /!/, ${ $_[0] } )[0];
  
      $irc->yield(ctcpreply => $nick => 'CLIENTINFO ' . ($self->{clientinfo}
          ? $self->{clientinfo}
          : 'http://search.cpan.org/perldoc?POE::Component::IRC::Plugin::CTCP'
      ));
  
      return PCI_EAT_CLIENT if $self->eat();
      return PCI_EAT_NONE;
  }
  
  sub S_ctcp_userinfo {
      my ($self, $irc) = splice @_, 0, 2;
      my $nick = ( split /!/, ${ $_[0] } )[0];
  
      $irc->yield( ctcpreply => $nick => 'USERINFO ' . ( $self->{userinfo} ? $self->{userinfo} : 'm33p' ) );
  
      return PCI_EAT_CLIENT if $self->eat();
      return PCI_EAT_NONE;
  }
  
  sub S_ctcp_source {
      my ($self, $irc) = splice @_, 0, 2;
      my $nick = ( split /!/, ${ $_[0] } )[0];
  
      $irc->yield( ctcpreply => $nick => 'SOURCE ' . ($self->{source}
          ? $self->{source}
          : 'http://search.cpan.org/dist/POE-Component-IRC'
      ));
  
      return PCI_EAT_CLIENT if $self->eat();
      return PCI_EAT_NONE;
  }
  
  sub eat {
      my $self = shift;
      my $value = shift;
  
      return $self->{eat} if !defined $value;
      return $self->{eat} = $value;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::CTCP - A PoCo-IRC plugin that auto-responds to CTCP requests
  
  =head1 SYNOPSIS
  
   use strict;
   use warnings;
   use POE qw(Component::IRC Component::IRC::Plugin::CTCP);
  
   my $nickname = 'Flibble' . $$;
   my $ircname = 'Flibble the Sailor Bot';
   my $ircserver = 'irc.blahblahblah.irc';
   my $port = 6667;
  
   my $irc = POE::Component::IRC->spawn(
       nick => $nickname,
       server => $ircserver,
       port => $port,
       ircname => $ircname,
   ) or die "Oh noooo! $!";
  
   POE::Session->create(
       package_states => [
           main => [ qw(_start) ],
       ],
   );
  
   $poe_kernel->run();
  
   sub _start {
       # Create and load our CTCP plugin
       $irc->plugin_add( 'CTCP' => POE::Component::IRC::Plugin::CTCP->new(
           version => $ircname,
           userinfo => $ircname,
       ));
  
       $irc->yield( register => 'all' );
       $irc->yield( connect => { } );
       return:
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::CTCP is a L<POE::Component::IRC|POE::Component::IRC>
  plugin. It watches for C<irc_ctcp_version>, C<irc_ctcp_userinfo>,
  C<irc_ctcp_ping>, C<irc_ctcp_time> and C<irc_ctcp_source> events and
  autoresponds on your behalf.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Takes a number of optional arguments:
  
  B<'version'>, a string to send in response to C<irc_ctcp_version>. Default is
  PoCo-IRC and version;
  
  B<'clientinfo'>, a string to send in response to C<irc_ctcp_clientinfo>.
  Default is L<http://search.cpan.org/perldoc?POE::Component::IRC::Plugin::CTCP>.
  
  B<'userinfo'>, a string to send in response to C<irc_ctcp_userinfo>. Default
  is 'm33p';
  
  B<'source'>, a string to send in response to C<irc_ctcp_source>. Default is
  L<http://search.cpan.org/dist/POE-Component-IRC>.
  
  B<'eat'>, by default the plugin uses PCI_EAT_CLIENT, set this to 0 to disable
  this behaviour;
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head2 C<eat>
  
  With no arguments, returns true or false on whether the plugin is "eating" CTCP
  events that it has dealt with. An argument will set "eating" to on or off
  appropriately, depending on whether the value is true or false.
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams
  
  =head1 SEE ALSO
  
  CTCP Specification L<http://www.irchelp.org/irchelp/rfc/ctcpspec.html>.
  
  =cut
POE_COMPONENT_IRC_PLUGIN_CTCP

$fatpacked{"POE/Component/IRC/Plugin/Connector.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_CONNECTOR';
  package POE::Component::IRC::Plugin::Connector;
  BEGIN {
    $POE::Component::IRC::Plugin::Connector::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::Connector::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use POE;
  use POE::Component::IRC::Plugin qw( :ALL );
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %args = @_;
  
      $args{ lc $_ } = delete $args{$_} for keys %args;
      $args{lag} = 0;
      return bless \%args, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = splice @_, 0, 2;
  
      $self->{irc} = $irc;
      POE::Session->create(
          object_states => [
              $self => [ qw(_start _auto_ping _reconnect _shutdown _start_ping _start_time_out _stop_ping _time_out) ],
          ],
      );
  
      $irc->raw_events(1);
      $irc->plugin_register( $self, 'SERVER', qw(connected disconnected 001 error socketerr pong raw) );
  
      return 1;
  }
  
  sub PCI_unregister {
      my ($self, $irc) = splice @_, 0, 2;
      delete $self->{irc};
      $poe_kernel->post( $self->{SESSION_ID} => '_shutdown' );
      $poe_kernel->refcount_decrement( $self->{SESSION_ID}, __PACKAGE__ );
      return 1;
  }
  
  sub S_connected {
      my ($self, $irc) = splice @_, 0, 2;
      $poe_kernel->post( $self->{SESSION_ID}, '_start_time_out' );
      return PCI_EAT_NONE;
  }
  
  sub S_001 {
      my ($self, $irc) = splice @_, 0, 2;
      $poe_kernel->post( $self->{SESSION_ID}, '_start_ping' );
      return PCI_EAT_NONE;
  }
  
  sub S_disconnected {
      my ($self, $irc) = splice @_, 0, 2;
      $poe_kernel->post( $self->{SESSION_ID}, '_stop_ping' );
      $poe_kernel->post( $self->{SESSION_ID}, '_reconnect' );
      return PCI_EAT_NONE;
  }
  
  sub S_error {
      my ($self, $irc) = splice @_, 0, 2;
      $poe_kernel->post( $self->{SESSION_ID}, '_stop_ping' );
      $poe_kernel->post( $self->{SESSION_ID}, '_reconnect' );
      return PCI_EAT_NONE;
  }
  
  sub S_socketerr {
      my ($self, $irc) = splice @_, 0, 2;
      $poe_kernel->post( $self->{SESSION_ID}, '_stop_ping' );
      $poe_kernel->post( $self->{SESSION_ID}, '_reconnect' );
      return PCI_EAT_NONE;
  }
  
  sub S_pong {
      my ($self, $irc) = splice @_, 0, 2;
      my $ping = shift @{ $self->{pings} };
      return PCI_EAT_NONE if !$ping;
      $self->{lag} = time() - $ping;
      $self->{seen_traffic} = 1;
      return PCI_EAT_NONE;
  }
  
  sub S_raw {
      my ($self,$irc) = splice @_, 0, 2;
      $self->{seen_traffic} = 1;
      return PCI_EAT_NONE;
  }
  
  sub lag {
      return $_[0]->{lag};
  }
  
  sub _start {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
  
      $self->{SESSION_ID} = $_[SESSION]->ID();
      $kernel->refcount_increment( $self->{SESSION_ID}, __PACKAGE__ );
      $kernel->yield( '_start_ping' ) if $self->{irc}->connected();
      return;
  }
  
  sub _start_ping {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      $self->{pings} = [ ];
      $kernel->delay( '_time_out' => undef );
      $kernel->delay( '_auto_ping' => $self->{delay} || 300 );
      return;
  }
  
  sub _auto_ping {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
  
      if (!$self->{seen_traffic}) {
          my $time = time();
          $self->{irc}->yield( 'ping' => $time );
          push @{ $self->{pings} }, $time;
      }
  
      $self->{seen_traffic} = 0;
      $kernel->yield( '_start_ping' );
      return;
  }
  
  sub _stop_ping {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      delete $self->{pings};
      $kernel->delay( '_auto_ping' => undef );
      $kernel->delay( '_time_out' => undef );
      return;
  }
  
  sub _shutdown {
      my ($kernel,$self) = @_[KERNEL, OBJECT];
  
      $kernel->yield( '_stop_ping' );
      $kernel->delay('_reconnect');
      return;
  }
  
  sub _reconnect {
      my ($kernel, $self, $session, $sender) = @_[KERNEL, OBJECT, SESSION, SENDER];
  
      my %args;
      if (ref $self->{servers} eq 'ARRAY' && @{ $self->{servers} }) {
          @args{qw(Server Port)} = @{ $self->{servers}->[0] };
          push @{ $self->{servers} }, shift @{ $self->{servers} };
      }
  
      if ($sender eq $session) {
          $self->{irc}->yield('connect' => %args);
      }
      else {
          $kernel->delay( '_reconnect' => $self->{reconnect} || 60 );
      }
  
      return;
  }
  
  sub _start_time_out {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      $kernel->delay( '_time_out' => $self->{timeout} || 60 );
      return;
  }
  
  sub _time_out {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      $self->{irc}->disconnect();
      return;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::Connector - A PoCo-IRC plugin that deals with the
  messy business of staying connected to an IRC server
  
  =head1 SYNOPSIS
  
   use POE qw(Component::IRC Component::IRC::Plugin::Connector);
  
   my $irc = POE::Component::IRC->spawn();
  
   POE::Session->create(
       package_states => [
           main => [ qw(_start lag_o_meter) ],
       ],
   );
  
   $poe_kernel->run();
  
   sub _start {
       my ($kernel, $heap) = @_[KERNEL ,HEAP];
       $irc->yield( register => 'all' );
  
       $heap->{connector} = POE::Component::IRC::Plugin::Connector->new();
  
       $irc->plugin_add( 'Connector' => $heap->{connector} );
  
       $irc->yield ( connect => { Nick => 'testbot', Server => 'someserver.com' } );
  
       $kernel->delay( 'lag_o_meter' => 60 );
       return;
   }
  
   sub lag_o_meter {
       my ($kernel,$heap) = @_[KERNEL,HEAP];
       print 'Time: ' . time() . ' Lag: ' . $heap->{connector}->lag() . "\n";
       $kernel->delay( 'lag_o_meter' => 60 );
       return;
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::Connector is a L<POE::Component::IRC|POE::Component::IRC>
  plugin that deals with making sure that your IRC bot stays connected to the IRC
  network of your choice. It implements the general algorithm as demonstrated at
  L<http://poe.perl.org/?POE_Cookbook/IRC_Bot_Reconnecting>.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Takes two optional arguments:
  
  B<'delay'>, the frequency, in seconds, at which the plugin will ping the IRC
  server. Defaults to 300.
  
  B<'reconnect'>, the time in seconds, to wait before trying to reconnect to
  the server. Defaults to 60.
  
  B<'servers'>, an array reference of IRC servers to consider. Each element should
  be an array reference containing a server host and (optionally) a port number.
  The plugin will cycle through this list of servers whenever it reconnects.
  
  Returns a plugin object suitable for use in
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head2 C<lag>
  
  Returns the current 'lag' in seconds between sending PINGs to the IRC server
  and getting PONG responses. Probably not likely to be wholely accurate.
  
  =head1 AUTHOR
  
  Chris "BinGOs" Williams <chris@bingosnet.co.uk>
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  L<POE::Component::IRC::Plugin|POE::Component::IRC::Plugin>
  
  =cut
POE_COMPONENT_IRC_PLUGIN_CONNECTOR

$fatpacked{"POE/Component/IRC/Plugin/Console.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_CONSOLE';
  package POE::Component::IRC::Plugin::Console;
  BEGIN {
    $POE::Component::IRC::Plugin::Console::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::Console::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use IRC::Utils qw(decode_irc);
  use POE qw(Wheel::SocketFactory Wheel::ReadWrite Filter::IRCD Filter::Line Filter::Stackable);
  use POE::Component::IRC::Plugin qw( :ALL );
  use Scalar::Util qw(looks_like_number);
  
  sub new {
      my $package = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %self = @_;
      return bless \%self, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = splice @_, 0, 2;
  
      $self->{irc} = $irc;
  
      $irc->plugin_register( $self, 'SERVER', qw(all) );
      $irc->plugin_register( $self, 'USER', qw(all) );
  
      POE::Session->create(
          object_states => [
              $self => [ qw(_client_error _client_flush _client_input _listener_accept _listener_failed _start _shutdown) ],
          ],
      );
  
      return 1;
  }
  
  sub PCI_unregister {
      my ($self, $irc) = splice @_, 0, 2;
  
      delete $self->{irc};
      $poe_kernel->post( $self->{SESSION_ID} => '_shutdown' );
      $poe_kernel->refcount_decrement( $self->{SESSION_ID}, __PACKAGE__ );
      return 1;
  }
  
  sub _dump {
      my ($arg) = @_;
  
      if (ref $arg eq 'ARRAY') {
          my @elems;
          for my $elem (@$arg) {
              push @elems, _dump($elem);
          }
          return '['. join(', ', @elems) .']';
      }
      elsif (ref $arg eq 'HASH') {
          my @pairs;
          for my $key (keys %$arg) {
              push @pairs, [$key, _dump($arg->{$key})];
          }
          return '{'. join(', ', map { "$_->[0] => $_->[1]" } @pairs) .'}';
      }
      elsif (ref $arg) {
          require overload;
          return overload::StrVal($arg);
      }
      elsif (defined $arg) {
          return $arg if looks_like_number($arg);
          return "'".decode_irc($arg)."'";
      }
      else {
          return 'undef';
      }
  }
  
  sub _default {
      my ($self, $irc, $event) = splice @_, 0, 3;
      return PCI_EAT_NONE if $event eq 'S_raw';
  
      pop @_;
      my @args = map { $$_ } @_;
      my @output;
  
      for my $i (0..$#args) {
          push @output, "ARG$i: " . _dump($args[$i]);
      }
  
      for my $wheel_id ( keys %{ $self->{wheels} } ) {
          next if ( $self->{exit}->{ $wheel_id } or ( not defined ( $self->{wheels}->{ $wheel_id } ) ) );
          next if !$self->{authed}{ $wheel_id };
          $self->{wheels}->{ $wheel_id }->put("$event: ".join(', ', @output));
      }
  
      return PCI_EAT_NONE;
  }
  
  sub _start {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
  
      $self->{SESSION_ID} = $_[SESSION]->ID();
      $kernel->refcount_increment( $self->{SESSION_ID}, __PACKAGE__ );
      $self->{ircd_filter} = POE::Filter::Stackable->new( Filters => [
          POE::Filter::Line->new(),
          POE::Filter::IRCD->new(),
      ]);
  
      $self->{listener} = POE::Wheel::SocketFactory->new(
          BindAddress  => 'localhost',
          BindPort     => $self->{bindport} || 0,
          SuccessEvent => '_listener_accept',
          FailureEvent => '_listener_failed',
          Reuse        => 'yes',
      );
  
      if ($self->{listener}) {
          $self->{irc}->send_event( 'irc_console_service' => $self->{listener}->getsockname() );
      }
      else {
          $self->{irc}->plugin_del( $self );
      }
  
      return;
  }
  
  sub _listener_accept {
      my ($kernel, $self, $socket, $peeradr, $peerport)
          = @_[KERNEL, OBJECT, ARG0 .. ARG2];
  
      my $wheel = POE::Wheel::ReadWrite->new(
          Handle       => $socket,
          InputFilter  => $self->{ircd_filter},
          OutputFilter => POE::Filter::Line->new(),
          InputEvent   => '_client_input',
          ErrorEvent   => '_client_error',
          FlushedEvent => '_client_flush',
      );
  
      if ( !defined $wheel ) {
          $self->{irc}->send_event( 'irc_console_rw_fail' => $peeradr => $peerport );
          return;
      }
  
      my $wheel_id = $wheel->ID();
      $self->{wheels}->{ $wheel_id } = $wheel;
      $self->{authed}->{ $wheel_id } = 0;
      $self->{exit}->{ $wheel_id } = 0;
      $self->{irc}->send_event( 'irc_console_connect' => $peeradr => $peerport => $wheel_id );
  
      return;
  }
  
  sub _listener_failed {
      delete $_[OBJECT]->{listener};
      return;
  }
  
  sub _client_input {
      my ($kernel, $self, $input, $wheel_id) = @_[KERNEL, OBJECT, ARG0, ARG1];
  
      if ($self->{authed}->{ $wheel_id } && lc ( $input->{command} ) eq 'exit') {
          $self->{exit}->{ $wheel_id } = 1;
          if (defined $self->{wheels}->{ $wheel_id }) {
              $self->{wheels}->{ $wheel_id }->put("ERROR * quiting *");
          }
          return;
      }
  
      if ( $self->{authed}->{ $wheel_id } ) {
          $self->{irc}->yield( lc ( $input->{command} ) => @{ $input->{params} } );
          return;
      }
  
      if (lc ( $input->{command} ) eq 'pass' && $input->{params}->[0] eq $self->{password} ) {
          $self->{authed}->{ $wheel_id } = 1;
          $self->{wheels}->{ $wheel_id }->put('NOTICE * Password accepted *');
          $self->{irc}->send_event( 'irc_console_authed' => $wheel_id );
          return;
      }
  
      $self->{wheels}->{ $wheel_id }->put('NOTICE * Password required * enter PASS <password> *');
      return;
  }
  
  sub _client_flush {
      my ($self, $wheel_id) = @_[OBJECT, ARG0];
      return if !$self->{exit}->{ $wheel_id };
      delete $self->{wheels}->{ $wheel_id };
      return;
  }
  
  sub _client_error {
      my ($self, $wheel_id) = @_[OBJECT, ARG3];
  
      delete $self->{wheels}->{ $wheel_id };
      delete $self->{authed}->{ $wheel_id };
      $self->{irc}->send_event( 'irc_console_close' => $wheel_id );
      return;
  }
  
  sub _shutdown {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
  
      delete $self->{listener};
      delete $self->{wheels};
      delete $self->{authed};
      return;
  }
  
  sub getsockname {
      my $self = shift;
      return if !$self->{listener};
      return $self->{listener}->getsockname();
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::Console - A PoCo-IRC plugin that provides a
  lightweight debugging and control console for your bot
  
  =head1 SYNOPSIS
  
   use POE qw(Component::IRC Component::IRC::Plugin::Console);
  
   my $nickname = 'Flibble' . $$;
   my $ircname = 'Flibble the Sailor Bot';
   my $ircserver = 'irc.blahblahblah.irc';
   my $port = 6667;
   my $bindport = 6969;
  
   my @channels = ( '#Blah', '#Foo', '#Bar' );
  
   my $irc = POE::Component::IRC->spawn(
       nick => $nickname,
       server => $ircserver,
       port => $port,
       ircname => $ircname,
   ) or die "Oh noooo! $!";
  
   POE::Session->create(
       package_states => [
           main => [ qw(_start irc_001 irc_console_service irc_console_connect
               irc_console_authed irc_console_close irc_console_rw_fail) ],
           ],
   );
  
   $poe_kernel->run();
  
   sub _start {
       $irc->plugin_add( 'Console' => POE::Component::IRC::Plugin::Console->new(
           bindport => $bindport,
           password => 'opensesame'
       );
       $irc->yield( register => 'all' );
       $irc->yield( connect => { } );
       return;
    }
  
   sub irc_001 {
       $irc->yield( join => $_ ) for @channels;
       return;
   }
  
   sub irc_console_service {
       my $getsockname = $_[ARG0];
       return;
   }
  
   sub irc_console_connect {
       my ($peeradr, $peerport, $wheel_id) = @_[ARG0 .. ARG2];
       return;
   }
  
   sub irc_console_authed {
       my $wheel_id = $_[ARG0];
       return;
   }
  
   sub irc_console_close {
       my $wheel_id = $_[ARG0];
       return;
   }
  
   sub irc_console_rw_fail {
       my ($peeradr, $peerport) = @_[ARG0, ARG1];
       return;
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::Console is a L<POE::Component::IRC|POE::Component::IRC>
  plugin that provides an interactive console running over the loopback network.
  One connects to the listening socket using a telnet client (or equivalent),
  authenticate using the applicable password. Once authed one will receive all
  events that are processed through the component. One may also issue all the
  documented component commands.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Takes two arguments:
  
  B<'password'>, the password to set for *all* console connections;
  
  B<'bindport'>, specify a particular port to bind to, defaults to 0, ie. randomly
  allocated;
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head2 C<getsockname>
  
  Gives access to the underlying listener's C<getsockname> method. See
  L<POE::Wheel::SocketFactory|POE::Wheel::SocketFactory> for details.
  
  =head1 OUTPUT EVENTS
  
  The plugin generates the following additional
  L<POE::Component::IRC|POE::Component::IRC> events:
  
  =head2 C<irc_console_service>
  
  Emitted when a listener is successfully spawned. C<ARG0> is the result of
  C<getsockname>, see above for details.
  
  =head2 C<irc_console_connect>
  
  Emitted when a client connects to the console. C<ARG0> is the peeradr, C<ARG1>
  is the peer port and C<ARG2> is the wheel id of the connection.
  
  =head2 C<irc_console_authed>
  
  Emitted when a client has successfully provided a valid password. C<ARG0> is
  the wheel id of the connection.
  
  =head2 C<irc_console_close>
  
  Emitted when a client terminates a connection. C<ARG0> is the wheel id of the
  connection.
  
  =head2 C<irc_console_rw_fail>
  
  Emitted when a L<POE::Wheel::ReadWrite|POE::Wheel::ReadWrite> could not be
  created on a socket. C<ARG0> is the peer's address, C<ARG1> is the peer's port.
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  L<POE::Wheel::SocketFactory|POE::Wheel::SocketFactory>
  
  =cut
POE_COMPONENT_IRC_PLUGIN_CONSOLE

$fatpacked{"POE/Component/IRC/Plugin/CycleEmpty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_CYCLEEMPTY';
  package POE::Component::IRC::Plugin::CycleEmpty;
  BEGIN {
    $POE::Component::IRC::Plugin::CycleEmpty::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::CycleEmpty::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use IRC::Utils qw( parse_user uc_irc );
  use POE::Component::IRC::Plugin qw( :ALL );
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %self = @_;
      return bless \%self, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = @_;
  
      if (!$irc->isa('POE::Component::IRC::State')) {
          die __PACKAGE__ . " requires PoCo::IRC::State or a subclass thereof";
      }
  
      $self->{cycling} = { };
      $self->{irc} = $irc;
      $irc->plugin_register($self, 'SERVER', qw(join kick part quit));
      return 1;
  }
  
  sub PCI_unregister {
      return 1;
  }
  
  sub S_join {
      my ($self, $irc) = splice @_, 0, 2;
      my $chan = ${ $_[1] };
      delete $self->{cycling}->{$chan};
      return PCI_EAT_NONE;
  }
  
  sub S_kick {
      my ($self, $irc) = splice @_, 0, 2;
      my $chan = ${ $_[1] };
      my $victim = ${ $_[2] };
      $self->_cycle($chan) if $victim ne $irc->nick_name();
      return PCI_EAT_NONE;
  }
  
  sub S_part {
      my ($self, $irc) = splice @_, 0, 2;
      my $parter = parse_user(${ $_[0] });
      my $chan = ${ $_[1] };
      $self->_cycle($chan) if $parter ne $irc->nick_name();
      return PCI_EAT_NONE;
  }
  
  sub S_quit {
      my ($self, $irc) = splice @_, 0, 2;
      my $quitter = parse_user(${ $_[0] });
      my $channels = @{ $_[2] }[0];
      if ($quitter ne $irc->nick_name()) {
          for my $chan (@{ $channels }) {
              $self->_cycle($chan);
          }
      }
      return PCI_EAT_NONE;
  }
  
  sub _cycle {
      my ($self, $chan) = @_;
      my $irc = $self->{irc};
      if ($irc->channel_list($chan) == 1) {
          if (!$irc->is_channel_operator($chan, $irc->nick_name)) {
              $self->{cycling}->{ uc_irc($chan) } = 1;
              my $topic = $irc->channel_topic($chan);
              $irc->yield(part => $chan);
              $irc->yield(join => $chan => $irc->channel_key($chan));
              $irc->yield(topic => $chan => $topic->{Value}) if defined $topic->{Value};
              $irc->yield(mode => $chan => '+k ' . $irc->channel_key($chan)) if defined $irc->channel_key($chan);
          }
      }
      return;
  }
  
  sub is_cycling {
      my ($self, $value) = @_;
      return 1 if $self->{cycling}->{ uc_irc($value) };
      return;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::CycleEmpty - A PoCo-IRC plugin which cycles
  channels if they become empty and opless.
  
  =head1 SYNOPSIS
  
   use POE::Component::IRC::Plugin::CycleEmpty;
  
   $irc->plugin_add('CycleEmpty', POE::Component::IRC::Plugin::CycleEmpty->new());
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::CycleEmpty is a L<POE::Component::IRC|POE::Component::IRC>
  plugin. When a channel member quits, gets kicked, or parts, the plugin will
  cycle the channel if the IRC component is alone on that channel and is not
  a channel operator. If there was a topic or a key set on the channel, they
  will be restored upon rejoining.
  
  This is useful for regaining ops in small channels if the IRC network does
  not have ChanServ or IRCNet's +R channel mode.
  
  This plugin requires the IRC component to be
  L<POE::Component::IRC::State|POE::Component::IRC::State> or a subclass thereof.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head2 C<is_cycling>
  
  One argument:
  
  A channel name
  
  Returns 1 if the plugin is currently cycling that channel, 0 otherwise.
  Useful if need to ignore the fact that the Component just parted the channel
  in question.
  
  =head1 AUTHOR
  
  Hinrik E<Ouml>rn SigurE<eth>sson, hinrik.sig@gmail.com
  
  =cut
POE_COMPONENT_IRC_PLUGIN_CYCLEEMPTY

$fatpacked{"POE/Component/IRC/Plugin/DCC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_DCC';
  package POE::Component::IRC::Plugin::DCC;
  BEGIN {
    $POE::Component::IRC::Plugin::DCC::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::DCC::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use File::Basename qw(fileparse);
  use File::Glob ':glob';
  use File::Spec::Functions 'rel2abs';
  use POE qw(Driver::SysRW Filter::Line Filter::Stream
             Wheel::ReadWrite Wheel::SocketFactory);
  use POE::Component::IRC::Plugin qw(:ALL);
  use Socket qw(INADDR_ANY unpack_sockaddr_in inet_aton inet_ntoa);
  
  use constant {
      OUT_BLOCKSIZE  => 1024,   # Send DCC data in 1k chunks
      IN_BLOCKSIZE   => 10_240, # 10k per DCC socket read
      LISTEN_TIMEOUT => 300,    # Five minutes for listening DCCs
  };
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %self = @_;
      return bless \%self, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = @_;
  
      $self->{irc} = $irc;
  
      POE::Session->create(
          object_states => [
              $self => [qw(
                  _start
                  _dcc_read
                  _dcc_failed
                  _dcc_timeout
                  _dcc_up
                  _U_dcc
                  _U_dcc_accept
                  _U_dcc_chat
                  _U_dcc_close
                  _U_dcc_resume
                  _cancel_timeout
              )],
          ],
      );
  
      $irc->plugin_register($self, 'SERVER', qw(disconnected dcc_request));
      $irc->plugin_register($self, 'USER', qw(dcc dcc_accept dcc_chat dcc_close dcc_resume));
  
      return 1;
  }
  
  sub PCI_unregister {
      my ($self) = @_;
      delete $self->{irc};
      delete $self->{$_} for qw(wheelmap dcc);
      $poe_kernel->refcount_decrement($self->{session_id}, __PACKAGE__);
      return 1;
  }
  
  sub _start {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      $self->{session_id} = $_[SESSION]->ID();
      $kernel->refcount_increment($self->{session_id}, __PACKAGE__);
      return;
  }
  
  # set the dcc ports
  sub dccports {
      my ($self, $value) = @_;
      $self->{dccports} = $value;
      return;
  }
  
  # set the NAT address
  sub nataddr {
      my ($self, $value) = @_;
      $self->{nataddr} = $value;
      return;
  }
  
  # returns information about a connection
  sub dcc_info {
      my ($self, $id) = @_;
  
      if (!$self->{dcc}->{$id}) {
          warn "dcc_info: Unknown wheel ID: $id\n";
          return;
      }
  
      my %info;
      @info{qw(nick type port file size done peeraddr)}
          = @{ $self->{dcc}->{$id} }{qw(
              nick type port file size done peeraddr
          )};
      return \%info;
  }
  
  sub _quote_file {
      my ($file) = @_;
  
      if ($file =~ /[\s"]/) {
          $file =~ s|"|\\"|g;
          $file = qq{"$file"};
      }
      return $file;
  }
  
  sub S_disconnected {
      my ($self) = $_;
      # clean up old cookies for any ignored RESUME requests
      delete $self->{resuming};
      return PCI_EAT_NONE;
  }
  
  sub S_dcc_request {
      my ($self, $irc) = splice @_, 0, 2;
      my ($user, $type, $port, $cookie, $file, $size) = map { ref =~ /REF|SCALAR/ && ${ $_ } } @_;
      my $nick = (split /!/, $user)[0];
  
      if ($type eq 'ACCEPT' && $self->{resuming}->{"$port+$nick"}) {
          # the old cookie has the peer's address
          my $old_cookie = delete $self->{resuming}->{"$port+$nick"};
          $irc->yield(dcc_accept => $old_cookie);
      }
      elsif ($type eq 'RESUME') {
          for my $cookie (values %{ $self->{dcc} }) {
              next if $cookie->{nick} ne $nick;
              next if $cookie->{port} ne $port;
              $file = _quote_file($file);
              $cookie->{done} = $size;
              $irc->yield(ctcp => $nick => "DCC ACCEPT $file $port $size");
              last;
          }
      }
  
      return PCI_EAT_NONE;
  }
  
  # this is a stub handler for all U_dcc* events which redispatches them as
  # events to our own POE session so that we can do stuff related to it,
  # namely create wheels and set alarms/delays
  sub _default {
      my ($self, $irc, $event) = splice @_, 0, 3;
      return PCI_EAT_NONE if $event !~ /^U_dcc(?:_accept|_chat|_close|_resume)?$/;
      $event =~ s/^U_/_U_/;
      pop @_;
      my @args = map { $$_ } @_;
      $poe_kernel->call($self->{session_id}, $event, @args);
      return PCI_EAT_NONE;
  }
  
  # Attempt to initiate a DCC SEND or CHAT connection with another person.
  sub _U_dcc {
      my ($kernel, $self, $nick, $type, $file, $blocksize, $timeout)
          = @_[KERNEL, OBJECT, ARG0..$#_];
  
      if (!defined $type) {
          warn "The 'dcc' command requires at least two arguments\n";
          return;
      }
  
      my $irc = $self->{irc};
      my ($bindport, $bindaddr, $factory, $port, $addr, $size);
  
      $type = uc $type;
      if ($type eq 'CHAT') {
          $file = 'chat';   # As per the semi-specification
      }
      elsif ($type eq 'SEND') {
          if (!defined $file) {
              warn "The 'dcc' command requires three arguments for a SEND\n";
              return;
          }
          $file = rel2abs(bsd_glob($file));
          $size = (stat $file)[7];
          if (!defined $size) {
              $irc->send_event(
                  'irc_dcc_error',
                  undef,
                  "Couldn't get ${file}'s size: $!",
                  $nick,
                  $type,
                  undef,
                  $file,
              );
              return;
          }
      }
  
      $bindaddr = $irc->localaddr();
  
      if ($self->{dccports}) {
          $bindport = shift @{ $self->{dccports} };
          if (!defined $bindport) {
            warn "dcc: Can't allocate listen port for DCC $type\n";
            return;
          }
      }
  
      $factory = POE::Wheel::SocketFactory->new(
          BindAddress  => $bindaddr || INADDR_ANY,
          BindPort     => $bindport,
          SuccessEvent => '_dcc_up',
          FailureEvent => '_dcc_failed',
          Reuse        => 'yes',
      );
  
      ($port, $addr) = unpack_sockaddr_in($factory->getsockname());
      $addr = inet_aton($self->{nataddr}) if $self->{nataddr};
  
      if (!defined $addr) {
          warn "dcc: Can't determine our IP address! ($!)\n";
          return;
      }
      $addr = unpack 'N', $addr;
  
      my $basename = fileparse($file);
      $basename = _quote_file($basename);
  
      # Tell the other end that we're waiting for them to connect.
      $irc->yield(ctcp => $nick => "DCC $type $basename $addr $port" . ($size ? " $size" : ''));
  
      my $alarm_id = $kernel->delay_set(
          '_dcc_timeout', ($timeout || LISTEN_TIMEOUT), $factory->ID,
      );
  
      # Store the state for this connection.
      $self->{dcc}->{ $factory->ID } = {
          open      => 0,
          nick      => $nick,
          type      => $type,
          file      => $file,
          size      => $size,
          port      => $port,
          addr      => $addr,
          done      => 0,
          blocksize => ($blocksize || OUT_BLOCKSIZE),
          listener  => 1,
          factory   => $factory,
          alarm_id  => $alarm_id,
      };
  
      return;
  }
  
  # Accepts a proposed DCC connection to another client. See '_dcc_up' for
  # the rest of the logic for this.
  sub _U_dcc_accept {
      my ($self, $cookie, $myfile) = @_[OBJECT, ARG0, ARG1];
  
      if (!defined $cookie) {
          warn "The 'dcc_accept' command requires at least one argument\n";
          return;
      }
  
      if ($cookie->{type} eq 'SEND') {
          $cookie->{type} = 'GET';
          $cookie->{file} = $myfile if defined $myfile;   # filename override
      }
  
      my $factory = POE::Wheel::SocketFactory->new(
          RemoteAddress => $cookie->{addr},
          RemotePort    => $cookie->{port},
          SuccessEvent  => '_dcc_up',
          FailureEvent  => '_dcc_failed',
      );
  
      $self->{dcc}->{$factory->ID} = $cookie;
      $self->{dcc}->{$factory->ID}->{factory} = $factory;
  
      return;
  }
  
  # Send data over a DCC CHAT connection.
  sub _U_dcc_chat {
      my ($self, $id, @data) = @_[OBJECT, ARG0..$#_];
  
      if (!defined $id || !@data) {
          warn "The 'dcc_chat' command requires at least two arguments\n";
          return;
      }
  
      if (!exists $self->{dcc}->{$id}) {
          warn "dcc_chat: Unknown wheel ID: $id\n";
          return;
      }
  
      if (!exists $self->{dcc}->{$id}->{wheel}) {
          warn "dcc_chat: No DCC wheel for id $id!\n";
          return;
      }
  
      if ($self->{dcc}->{$id}->{type} ne 'CHAT') {
          warn "dcc_chat: id $id isn't associated with a DCC CHAT connection!\n";
          return;
      }
  
      $self->{dcc}->{$id}->{wheel}->put(join "\n", @data);
      return;
  }
  
  # Terminate a DCC connection manually.
  sub _U_dcc_close {
      my ($kernel, $self, $id) = @_[KERNEL, OBJECT, ARG0];
      my $irc = $self->{irc};
  
      if (!defined $id) {
          warn "The 'dcc_close' command requires an id argument\n";
          return;
      }
  
      if (!exists $self->{dcc}->{$id}) {
          warn "dcc_close: Unknown wheel ID: $id\n";
          return;
      }
  
      if (!exists $self->{dcc}->{$id}->{wheel}) {
          warn "dcc_close: No DCC wheel for id $id!\n";
          return;
      }
  
      # pending data, wait till it has been flushed
      if ($self->{dcc}->{$id}->{wheel}->get_driver_out_octets()) {
          $kernel->delay_set(_U_dcc_close => 2, $id);
          return;
      }
  
      $irc->send_event(
          'irc_dcc_done',
          $id,
          @{ $self->{dcc}->{$id} }{qw(
              nick type port file size done peeraddr
          )},
      );
  
      # Reclaim our port if necessary.
      if ($self->{dcc}->{$id}->{listener} && $self->{dccports}) {
          push ( @{ $self->{dccports} }, $self->{dcc}->{$id}->{port} );
      }
  
      $self->_remove_dcc($id);
      return;
  }
  
  ## no critic (InputOutput::RequireBriefOpen)
  sub _U_dcc_resume {
      my ($self, $cookie, $myfile) = @_[OBJECT, ARG0, ARG1];
      my $irc = $self->{irc};
  
      my $sender_file = _quote_file($cookie->{file});
      $cookie->{file} = $myfile if defined $myfile;
      $cookie->{done} = -s $cookie->{file};
      $cookie->{resuming} = 1;
  
      if (open(my $handle, '>>', $cookie->{file})) {
          $irc->yield(ctcp => $cookie->{nick} => "DCC RESUME $sender_file $cookie->{port} $cookie->{done}");
          $self->{resuming}->{"$cookie->{port}+$cookie->{nick}"} = $cookie;
      }
      else {
          warn "dcc_resume: Can't append to file '$cookie->{file}'\n";
          return;
      }
  
      return;
  }
  
  # Accept incoming data on a DCC socket.
  sub _dcc_read {
      my ($kernel, $self, $data, $id) = @_[KERNEL, OBJECT, ARG0, ARG1];
      my $irc = $self->{irc};
  
      $id = $self->{wheelmap}->{$id};
      if ($self->{dcc}{$id}{alarm_id}) {
          $kernel->call($self->{session_id}, '_cancel_timeout', $id);
      }
  
      if ($self->{dcc}->{$id}->{type} eq 'GET') {
          # Acknowledge the received data.
          print {$self->{dcc}->{$id}->{fh}} $data;
          $self->{dcc}->{$id}->{done} += length $data;
          $self->{dcc}->{$id}->{wheel}->put(
              pack 'N', $self->{dcc}->{$id}->{done}
          );
  
          # Send an event to let people know about the newly arrived data.
          $irc->send_event(
              'irc_dcc_get',
              $id,
              @{ $self->{dcc}->{$id} }{qw(
                  nick port file size done peeraddr
              )},
          );
      }
      elsif ($self->{dcc}->{$id}->{type} eq 'SEND') {
          # Record the client's download progress.
          $self->{dcc}->{$id}->{done} = unpack 'N', substr( $data, -4 );
  
          $irc->send_event(
              'irc_dcc_send',
              $id,
              @{ $self->{dcc}->{$id} }{qw(
                  nick port file size done peeraddr
              )},
          );
  
          # Are we done yet?
          if ($self->{dcc}->{$id}->{done} >= $self->{dcc}->{$id}->{size}) {
              # Reclaim our port if necessary.
              if ( $self->{dcc}->{$id}->{listener} && $self->{dccports}) {
                  push @{ $self->{dccports} }, $self->{dcc}->{$id}->{port};
              }
  
              $irc->send_event(
                  'irc_dcc_done',
                  $id,
                  @{ $self->{dcc}->{$id} }{qw(
                      nick type port file size done peeraddr
                  )},
              );
  
              $self->_remove_dcc($id);
              return;
          }
  
          # Send the next 'blocksize'-sized packet.
          read $self->{dcc}->{$id}->{fh}, $data,
              $self->{dcc}->{$id}->{blocksize};
          $self->{dcc}->{$id}->{wheel}->put( $data );
      }
      else {
          $irc->send_event(
              'irc_dcc_' . lc $self->{dcc}->{$id}->{type},
              $id,
              @{ $self->{dcc}->{$id} }{qw(nick port)},
              $data,
              $self->{dcc}->{$id}->{peeraddr},
          );
      }
  
      return;
  }
  
  # What happens when an attempted DCC connection fails.
  sub _dcc_failed {
      my ($self, $operation, $errnum, $errstr, $id) = @_[OBJECT, ARG0 .. ARG3];
      my $irc = $self->{irc};
  
      if (!exists $self->{dcc}->{$id}) {
          if (exists $self->{wheelmap}->{$id}) {
              $id = $self->{wheelmap}->{$id};
          }
          else {
              warn "_dcc_failed: Unknown wheel ID: $id\n";
              return;
          }
      }
  
      # Reclaim our port if necessary.
      if ( $self->{dcc}->{$id}->{listener} && $self->{dccports}) {
          push ( @{ $self->{dccports} }, $self->{dcc}->{$id}->{port} );
      }
  
      DCC: {
          last DCC if $errnum != 0;
  
          # Did the peer of a DCC GET connection close the socket after the file
          # transfer finished? If so, it's not really an error.
          if ($self->{dcc}->{$id}->{type} eq 'GET') {
              if ($self->{dcc}->{$id}->{done} < $self->{dcc}->{$id}->{size}) {
                  last DCC;
              }
          }
  
          if ($self->{dcc}->{$id}->{type} =~ /^(GET|CHAT)$/) {
              $irc->send_event(
                  'irc_dcc_done',
                  $id,
                  @{ $self->{dcc}->{$id} }{qw(
                      nick type port file size done peeraddr
                  )},
              );
  
              $self->_remove_dcc($id);
          }
  
          return;
      }
  
      # something went wrong
      if ($errnum == 0 && $self->{dcc}->{$id}->{type} eq 'GET') {
          $errstr = 'Aborted by sender';
      }
      else {
          $errstr = $errstr
              ? $errstr = "$operation error $errnum: $errstr"
              : $errstr = "$operation error $errnum"
          ;
      }
  
      $irc->send_event(
          'irc_dcc_error',
          $id,
          $errstr,
          @{ $self->{dcc}->{$id} }{qw(
              nick type port file size done peeraddr
          )},
      );
  
      $self->_remove_dcc($id);
      return;
  }
  
  # What happens when a DCC connection sits waiting for the other end to
  # pick up the phone for too long.
  sub _dcc_timeout {
      my ($kernel, $self, $id) = @_[KERNEL, OBJECT, ARG0];
  
      if (exists $self->{dcc}->{$id} && !$self->{dcc}->{$id}->{open}) {
          $kernel->yield(
              '_dcc_failed',
              'connection',
              0,
              'DCC connection timed out',
              $id,
          );
      }
      return;
  }
  
  # This event occurs when a DCC connection is established.
  ## no critic (InputOutput::RequireBriefOpen)
  sub _dcc_up {
      my ($kernel, $self, $sock, $peeraddr, $id) =
          @_[KERNEL, OBJECT, ARG0, ARG1, ARG3];
      my $irc = $self->{irc};
  
      # Delete the listening socket and monitor the accepted socket
      # for incoming data
      delete $self->{dcc}->{$id}->{factory};
      $self->{dcc}->{$id}->{open} = 1;
      $self->{dcc}->{$id}->{peeraddr} = inet_ntoa($peeraddr);
  
      $self->{dcc}->{$id}->{wheel} = POE::Wheel::ReadWrite->new(
          Handle => $sock,
          Driver => ($self->{dcc}->{$id}->{type} eq 'GET'
              ? POE::Driver::SysRW->new( BlockSize => IN_BLOCKSIZE )
              : POE::Driver::SysRW->new()
          ),
          Filter => ($self->{dcc}->{$id}->{type} eq 'CHAT'
              ? POE::Filter::Line->new( Literal => "\012" )
              : POE::Filter::Stream->new()
          ),
          InputEvent => '_dcc_read',
          ErrorEvent => '_dcc_failed',
      );
  
      $self->{wheelmap}->{ $self->{dcc}->{$id}->{wheel}->ID } = $id;
  
      my $handle;
      if ($self->{dcc}->{$id}->{type} eq 'GET') {
          # check if we're resuming
          my $mode = $self->{dcc}->{$id}->{resuming} ? '>>' : '>';
  
          if ( !open $handle, $mode, $self->{dcc}->{$id}->{file} ) {
              $kernel->yield(_dcc_failed => 'open file', $! + 0, $!, $id);
              return;
          }
  
          binmode $handle;
          $self->{dcc}->{$id}->{fh} = $handle;
      }
      elsif ($self->{dcc}->{$id}->{type} eq 'SEND') {
          if (!open $handle, '<', $self->{dcc}->{$id}->{file}) {
              $kernel->yield(_dcc_failed => 'open file', $! + 0, $!, $id);
              return;
          }
  
          binmode $handle;
          seek $handle, $self->{dcc}{$id}{done}, 0;
          # Send the first packet to get the ball rolling.
          read $handle, my $buffer, $self->{dcc}->{$id}->{blocksize};
          $self->{dcc}->{$id}->{wheel}->put($buffer);
          $self->{dcc}->{$id}->{fh} = $handle;
      }
  
      # Tell any listening sessions that the connection is up.
      $irc->send_event(
          'irc_dcc_start',
          $id,
          @{ $self->{dcc}->{$id} }{qw(
              nick type port file size peeraddr
          )},
      );
  
      return;
  }
  
  sub _cancel_timeout {
      my ($kernel, $self, $id) = @_[KERNEL, OBJECT, ARG0];
      my $alarm_id = delete $self->{dcc}{$id}{alarm_id};
      $kernel->alarm_remove($alarm_id);
      return;
  }
  
  sub _remove_dcc {
      my ($self, $id) = @_;
  
      if (exists $self->{dcc}{$id}{alarm_id}) {
          $poe_kernel->call($self->{session_id}, '_cancel_timeout', $id);
      }
  
      if (exists $self->{dcc}{$id}{wheel}) {
          delete $self->{wheelmap}{ $self->{dcc}{$id}{wheel}->ID };
          if ($^O =~ /cygwin|MSWin/) {
            $self->{dcc}{$id}{wheel}->$_ for qw(shutdown_input shutdown_output);
          }
      }
  
      # flush the filehandle
      close $self->{dcc}{$id}{fh} if $self->{dcc}{$id}{type} eq 'GET';
  
      delete $self->{dcc}{$id};
      return;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::DCC - A PoCo-IRC plugin providing support for
  DCC transfers
  
  =head1 SYNOPSIS
  
   # send a file
   my $file = '/home/user/secret.pdf';
   my $recipient = 'that_guy';
   $irc->yield(dcc => $recipient => SEND => $file);
  
   # receive a file
   sub irc_dcc_request {
       my ($user, $type, $port, $cookie, $file, $size, $addr) = @_[ARG0..$#_];
       return if $type ne 'SEND';
  
       my $irc = $_[SENDER]->get_heap();
       my $nick = (split /!/, $user)[0];
  
       print "$nick wants to send me '$file' ($size bytes) from $addr:$port\n");
       $irc->yield(dcc_accept => $cookie);
   }
  
  =head1 DESCRIPTION
  
  This plugin provides the IRC commands needed to make use of DCC. It is used
  internally by L<POE::Component::IRC|POE::Component::IRC> so there's no
  need to add it manually.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Takes no arguments.
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head2 C<dccports>
  
  Sets the TCP ports that can be used for DCC sends. Takes one argument,
  an arrayref containing the port numbers.
  
  =head2 C<nataddr>
  
  Sets the public NAT address to be used for DCC sends.
  
  =head2 C<dcc_info>
  
  Takes one argument, a DCC connection id (see below). Returns a hash of
  information about the connection. The keys are: B<'nick'>, B<'type'>,
  B<'port'>, B<'file'>, B<'size'>, B<'done,'>, and B<'peeraddr'>.
  
  =head1 COMMANDS
  
  The plugin responds to the following
  L<POE::Component::IRC|POE::Component::IRC> commands.
  
  =head2 C<dcc>
  
  Send a DCC SEND or CHAT request to another person. Takes at least two
  arguments: the nickname of the person to send the request to and the type
  of DCC request (SEND or CHAT). For SEND requests, be sure to add a third
  argument for the filename you want to send. Optionally, you can add a fourth
  argument for the DCC transfer blocksize, but the default of 1024 should
  usually be fine. The fifth (and optional) argument is the request timeout
  value in seconds (default: 300).
  
  Incidentally, you can send other weird nonstandard kinds of DCCs too;
  just put something besides 'SEND' or 'CHAT' (say, 'FOO') in the type
  field, and you'll get back C<irc_dcc_foo> events (with the same arguments as
  L<C<irc_dcc_chat>|/irc_dcc_chat>) when data arrives on its DCC connection.
  
  If you are behind a firewall or Network Address Translation, you may want to
  consult L<POE::Component::IRC|POE::Component::IRC>'s
  L<C<connect>|POE::Component::IRC/spawn> for some parameters that are
  useful with this command.
  
  =head2 C<dcc_accept>
  
  Accepts an incoming DCC connection from another host. First argument:
  the magic cookie from an L<C<irc_dcc_request>|/irc_dcc_request> event.
  In the case of a DCC GET, the second argument can optionally specify a
  new name for the destination file of the DCC transfer, instead of using
  the sender's name for it. (See the L<C<irc_dcc_request>|/irc_dcc_request>
  section below for more details.)
  
  =head2 C<dcc_resume>
  
  Resumes a DCC SEND file transfer. First argument: the magic cookie from an
  L<C<irc_dcc_request>|/irc_dcc_request> event. An optional second argument
  provides the name of the file to which you want to write.
  
  =head2 C<dcc_chat>
  
  Sends lines of data to the person on the other side of a DCC CHAT connection.
  The first argument should be the wheel id of the connection which you got
  from an L<C<irc_dcc_start>|/irc_dcc_start> event, followed by all the data
  you wish to send (it'll be separated with newlines for you).
  
  =head2 C<dcc_close>
  
  Terminates a DCC SEND or GET connection prematurely, and causes DCC CHAT
  connections to close gracefully. Takes one argument: the wheel id of the
  connection which you got from an L<C<irc_dcc_start>|/irc_dcc_start>
  (or similar) event.
  
  =head1 OUTPUT EVENTS
  
  =head2 C<irc_dcc_request>
  
  B<Note:> This event is actually emitted by
  L<POE::Filter::IRC::Compat|POE::Filter::IRC::Compat>, but documented here
  to keep all the DCC documentation in one place. In case you were wondering.
  
  You receive this event when another IRC client sends you a DCC
  (e.g. SEND or CHAT) request out of the blue. You can examine the request
  and decide whether or not to accept it (with L<C<dcc_accept>|/dcc_accept>)
  here. In the case of DCC SENDs, you can also request to resume the file with
  L<C<dcc_resume>|/dcc_resume>.
  
  B<Note:> DCC doesn't provide a way to explicitly reject requests, so if you
  don't intend to accept one, just ignore it or send a
  L<NOTICE|POE::Component::IRC/notice> or L<PRIVMSG|POE::Component::IRC/privmsg>
  to the peer explaining why you're not going to accept.
  
  =over 4
  
  =item * C<ARG0>: the peer's nick!user@host
  
  =item * C<ARG1>: the DCC type (e.g. 'CHAT' or 'SEND')
  
  =item * C<ARG2>: the port which the peer is listening on
  
  =item * C<ARG3>: this connection's "magic cookie"
  
  =item * C<ARG4>: the file name (SEND only)
  
  =item * C<ARG5>: the file size (SEND only)
  
  =item * C<ARG6>: the IP address which the peer is listening on
  
  =back
  
  =head2 C<irc_dcc_start>
  
  This event notifies you that a DCC connection has been successfully
  established.
  
  =over 4
  
  =item * C<ARG0>: the connection's wheel id
  
  =item * C<ARG1>: the peer's nickname
  
  =item * C<ARG2>: the DCC type
  
  =item * C<ARG3>: the port number
  
  =item * C<ARG4>: the file name (SEND/GET only)
  
  =item * C<ARG5>: the file size (SEND/GET only)
  
  =item * C<ARG6>: the peer's IP address
  
  =back
  
  =head2 C<irc_dcc_chat>
  
  Notifies you that one line of text has been received from the
  client on the other end of a DCC CHAT connection.
  
  =over 4
  
  =item * C<ARG0>: the connection's wheel id
  
  =item * C<ARG1>: the peer's nickname
  
  =item * C<ARG2>: the port number
  
  =item * C<ARG3>: the text they sent
  
  =item * C<ARG4>: the peer's IP address
  
  =back
  
  =head2 C<irc_dcc_get>
  
  Notifies you that another block of data has been successfully
  transferred from the client on the other end of your DCC GET connection.
  
  =over 4
  
  =item * C<ARG0>: the connection's wheel id
  
  =item * C<ARG1>: the peer's nickname
  
  =item * C<ARG2>: the port number
  
  =item * C<ARG3>: the file name
  
  =item * C<ARG4>: the file size
  
  =item * C<ARG5>: transferred file size
  
  =item * C<ARG6>: the peer's IP address
  
  =back
  
  =head2 C<irc_dcc_send>
  
  Notifies you that another block of data has been successfully
  transferred from you to the client on the other end of a DCC SEND
  connection.
  
  =over 4
  
  =item * C<ARG0>: the connection's wheel id
  
  =item * C<ARG1>: the peer's nickname
  
  =item * C<ARG2>: the port number
  
  =item * C<ARG3>: the file name
  
  =item * C<ARG4>: the file size
  
  =item * C<ARG5>: transferred file size
  
  =item * C<ARG6>: the peer's IP address
  
  =back
  
  =head2 C<irc_dcc_done>
  
  You receive this event when a DCC connection terminates normally.
  Abnormal terminations are reported by L<C<irc_dcc_error>|/irc_dcc_error>.
  
  =over 4
  
  =item * C<ARG0>: the connection's wheel id
  
  =item * C<ARG1>: the peer's nickname
  
  =item * C<ARG2>: the DCC type
  
  =item * C<ARG3>: the port number
  
  =item * C<ARG4>: the filename (SEND/GET only)
  
  =item * C<ARG5>: file size (SEND/GET only)
  
  =item * C<ARG6>: transferred file size (SEND/GET only)
  
  =item * C<ARG7>: the peer's IP address
  
  =back
  
  =head2 C<irc_dcc_error>
  
  You get this event whenever a DCC connection or connection attempt
  terminates unexpectedly or suffers some fatal error. Some of the
  following values might be undefined depending the stage at which
  the connection/attempt failed.
  
  =over 4
  
  =item * C<ARG0>: the connection's wheel id
  
  =item * C<ARG1>: the error string
  
  =item * C<ARG2>: the peer's nickname
  
  =item * C<ARG3>: the DCC type
  
  =item * C<ARG4>: the port number
  
  =item * C<ARG5>: the file name
  
  =item * C<ARG6>: file size in bytes
  
  =item * C<ARG7>: transferred file size in bytes
  
  =item * C<ARG8>: the peer's IP address
  
  =back
  
  =head1 AUTHOR
  
  Dennis 'C<fimmtiu>' Taylor and Hinrik E<Ouml>rn SigurE<eth>sson, hinrik.sig@gmail.com
  
  =cut
POE_COMPONENT_IRC_PLUGIN_DCC

$fatpacked{"POE/Component/IRC/Plugin/FollowTail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_FOLLOWTAIL';
  package POE::Component::IRC::Plugin::FollowTail;
  BEGIN {
    $POE::Component::IRC::Plugin::FollowTail::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::FollowTail::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use File::Glob ':glob';
  use File::Spec::Functions 'rel2abs';
  use POE qw(Wheel::FollowTail);
  use POE::Component::IRC::Plugin qw( :ALL );
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %args = @_;
      $args{lc $_} = delete $args{$_} for keys %args;
  
      die "$package requires a 'filename' attribute" if !defined $args{filename};
      $args{filename} = bsd_glob($args{filename});
      die "File '$args{filename}' does not exist" if !-e $args{filename};
      $args{filename} = rel2abs($args{filename});
  
      return bless \%args, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = splice @_, 0, 2;
      $self->{irc} = $irc;
      POE::Session->create(
          object_states => [
              $self => [ qw(_start _shutdown _input _error _reset) ],
          ],
      );
  
      return 1;
  }
  
  sub PCI_unregister {
      my ($self, $irc) = splice @_, 0, 2;
      delete $self->{irc};
      $poe_kernel->post( $self->{session_id} => '_shutdown' );
      $poe_kernel->refcount_decrement( $self->{session_id}, __PACKAGE__ );
      return 1;
  }
  
  sub _start {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
  
      $self->{session_id} = $_[SESSION]->ID();
      $kernel->refcount_increment( $self->{session_id}, __PACKAGE__ );
  
      $self->{wheel} = POE::Wheel::FollowTail->new(
          Filename     => $self->{filename},
          InputEvent   => '_input',
          ErrorEvent   => '_error',
          ResetEvent   => '_reset',
          ( defined $self->{filter} && $self->{filter}->isa('POE::Filter')
              ? ( Filter => $self->{filter} )
              : ()
          ),
      );
  
      return;
  }
  
  sub _shutdown {
      my ($kernel, $self, $term) = @_[KERNEL, OBJECT, ARG0];
      delete $self->{wheel};
      $kernel->refcount_decrement( $self->{session_id}, __PACKAGE__ ) if $term;
      return;
  }
  
  sub _input {
      my ($kernel, $self, $input) = @_[KERNEL, OBJECT, ARG0];
      $self->{irc}->send_event( 'irc_tail_input', $self->{filename}, $input );
      return;
  }
  
  sub _error {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      $self->{irc}->send_event( 'irc_tail_error', $self->{filename}, @_[ARG0..ARG2] );
      $kernel->yield('_shutdown','TERM');
      return;
  }
  
  sub _reset {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      $self->{irc}->send_event( 'irc_tail_reset', $self->{filename} );
      return;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::FollowTail - A PoCo-IRC plugin to follow the tail
  of an ever-growing file
  
  =head1 SYNOPSIS
  
   use POE qw(Component::IRC Component::IRC::Plugin::FollowTail);
  
   my $nickname = 'Flibble' . $$;
   my $ircname = 'Flibble the Sailor Bot';
   my $ircserver = 'irc.blahblahblah.irc';
   my $filename = '/some/such/file/here';
   my @channels = ( '#Blah', '#Foo', '#Bar' );
  
   my $irc = POE::Component::IRC->spawn(
       nick => $nickname,
       server => $ircserver,
       port => $port,
       ircname => $ircname,
   ) or die "Oh noooo! $!";
  
   POE::Session->create(
       package_states => [
           main => [ qw(_start irc_001 irc_tail_input irc_tail_error irc_tail_reset) ],
       ],
   );
  
    $poe_kernel->run();
  
   sub _start {
       $irc->plugin_add( 'FollowTail' => POE::Component::IRC::Plugin::FollowTail->new(
           filename => $filename,
       ));
       $irc->yield( register => 'all' );
       $irc->yield( connect => { } );
       return;
   }
  
   sub irc_001 {
       $irc->yield( join => $_ ) for @channels;
       return;
   }
  
   sub irc_tail_input {
       my ($kernel, $sender, $filename, $input) = @_[KERNEL, SENDER, ARG0, ARG1];
       $kernel->post( $sender, 'privmsg', $_, "$filename: $input" ) for @channels;
       return;
   }
  
   sub irc_tail_error {
       my ($kernel, $sender, $filename, $errnum, $errstring)
           = @_[KERNEL, SENDER, ARG0 .. ARG2];
       $kernel->post( $sender, 'privmsg', $_, "$filename: ERROR: $errnum $errstring" ) for @channels;
       $irc->plugin_del( 'FollowTail' );
       return;
   }
  
   sub irc_tail_reset {
       my ($kernel, $sender, $filename) = @_[KERNEL, SENDER, ARG0];
       $kernel->post( $sender, 'privmsg', $_, "$filename: RESET EVENT" ) for @channels;
       return;
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::FollowTail is a L<POE::Component::IRC|POE::Component::IRC>
  plugin that uses L<POE::Wheel::FollowTail|POE::Wheel::FollowTail> to follow
  the end of an ever-growing file. It generates C<irc_tail_> prefixed events for
  each new record that is appended to its file.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Takes two arguments:
  
  B<'filename'>, the name of the file to tail, mandatory;
  
  B<'filter'>, a POE::Filter object to pass to POE::Wheel::FollowTail, optional;
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head1 OUTPUT EVENTS
  
  The plugin generates the following additional
  L<POE::Component::IRC|POE::Component::IRC> events:
  
  =head2 C<irc_tail_input>
  
  Emitted for every complete record read. C<ARG0> will be the filename,
  C<ARG1> the record which was read.
  
  =head2 C<irc_tail_error>
  
  Emitted whenever an error occurs. C<ARG0> will be the filename, C<ARG1>
  and C<ARG2> hold numeric and string values for $!, respectively.
  
  =head2 C<irc_tail_reset>
  
  Emitted every time a file is reset. C<ARG0> will be the filename.
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  L<POE::Wheel::FollowTail|POE::Wheel::FollowTail>
  
  =cut
POE_COMPONENT_IRC_PLUGIN_FOLLOWTAIL

$fatpacked{"POE/Component/IRC/Plugin/ISupport.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_ISUPPORT';
  package POE::Component::IRC::Plugin::ISupport;
  BEGIN {
    $POE::Component::IRC::Plugin::ISupport::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::ISupport::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use POE::Component::IRC::Plugin qw(:ALL);
  
  sub new {
      return bless { }, shift;
  }
  
  sub PCI_register {
      my ($self, $irc) = splice @_, 0, 2;
  
      $irc->plugin_register( $self => SERVER => qw(all) );
      $self->{irc} = $irc;
      $self->{parser} = {
          CASEMAPPING => sub {
              my ($support, $key, $val) = @_;
              $support->{$key} = $val;
          },
          CHANLIMIT => sub {
              my ($support, $key, $val) = @_;
              while ($val =~ /([^:]+):(\d+),?/g) {
                  my ($k, $v) = ($1, $2);
                  @{ $support->{$key} }{ split(//, $k) } = ($v) x length $k;
              }
          },
          CHANMODES => sub {
              my ($support, $key, $val) = @_;
              $support->{$key} = [ split(/,/, $val) ];
          },
          CHANTYPES => sub {
              my ($support, $key, $val) = @_;
              $support->{$key} = [ split(//, $val) ];
          },
          ELIST => sub {
              my ($support, $key, $val) = @_;
              $support->{$key} = [ split(//, $val) ];
          },
          IDCHAN => sub {
              my ($support, $key, $val) = @_;
              while ($val =~ /([^:]+):(\d+),?/g) {
                  my ($k, $v) = ($1, $2);
                  @{ $support->{$key} }{ split(//, $k) } = ($v) x length $k;
              }
          },
          MAXLIST => sub {
              my ($support, $key, $val) = @_;
              while ($val =~ /([^:]+):(\d+),?/g) {
                  my ($k, $v) = ($1, $2);
                  @{ $support->{$key} }{ split(//, $k) } = ($v) x length $k;
              }
          },
          PREFIX => sub {
              my ($support, $key, $val) = @_;
              if (my ($k, $v) = $val =~ /\(([^)]+)\)(.*)/ ) {
                  @{ $support->{$key} }{ split(//, $k) } = split(//, $v);
              }
          },
          STATUSMSG => sub {
              my ($support, $key, $val) = @_;
              $support->{$key} = [ split(//, $val) ];
          },
          TARGMAX => sub {
              my ($support, $key, $val) = @_;
              while ($val =~ /([^:]+):(\d*),?/g) {
                  my ($k, $v) = ($1, $2);
                  $support->{$key}->{$k} = $v;
              }
          },
          EXCEPTS => sub {
              my ($support, $flag) = @_;
              $support->{$flag} = 'e';
          },
          INVEX => sub {
              my ($support, $flag) = @_;
              $support->{$flag} = 'I';
          },
      };
  
      return 1;
  }
  
  sub PCI_unregister {
      my ($self, $irc) = splice @_, 0, 2;
      delete $self->{irc};
      return 1;
  }
  
  sub S_connected {
      my ($self, $irc) = splice @_, 0, 2;
  
      $self->{server}   = { };
      $self->{got_005}  = 0;
      $self->{done_005} = 0;
      return PCI_EAT_NONE;
  }
  
  sub S_005 {
      my ($self, $irc, @args) = @_;
      my @vals = @{ ${ $args[2] } };
      pop @vals;
      my $support = $self->{server};
  
      for my $val (@vals) {
          if ($val =~ /=/) {
              my $key;
              ($key, $val) = split(/=/, $val, 2);
              if (defined $self->{parser}->{$key}) {
                  $self->{parser}->{$key}->($support, $key, $val);
              }
              else {
                  # AWAYLEN CHANNELLEN CHIDLEN CHARSET EXCEPTS INVEX KICKLEN
                  # MAXBANS MAXCHANNELS MAXTARGETS MODES NETWORK NICKLEN STD
                  # TOPICLEN WATCH
                  $support->{$key} = $val;
              }
          }
          else {
              if (defined $self->{parser}->{$val}) {
                  $self->{parser}->{$val}->($support, $val);
              }
              else {
                  # ACCEPT CALLERID CAPAB CNOTICE CPRIVMSG FNC KNOCK MAXNICKLEN
                  # NAMESX NOQUIT PENALTY RFC2812 SAFELIST UHNAMES USERIP
                  # VCHANS WALLCHOPS WALLVOICES WHOX
                  $support->{$val} = 'on';
              }
          }
      }
  
      $self->{got_005}++;
      return PCI_EAT_NONE;
  }
  
  sub _default {
      my ($self, $irc, $event) = @_;
  
      return PCI_EAT_NONE if $self->{done_005};
      return PCI_EAT_NONE if !$self->{got_005};
  
      if ($event =~ /^S_(\d+)/ and $1 > 5) {
          $self->{done_005} = 1;
          $irc->send_event_now(irc_isupport => $self);
      }
  
      return PCI_EAT_NONE;
  }
  
  sub isupport {
      my $self = shift;
      my $value = uc ( $_[0] ) || return;
  
      return $self->{server}->{$value} if defined $self->{server}->{$value};
      return;
  }
  
  sub isupport_dump_keys {
      my $self = shift;
  
      if ( keys %{ $self->{server} } > 0 ) {
          return keys %{ $self->{server} };
      }
      return;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::ISupport - A PoCo-IRC plugin that handles server
  capabilities
  
  =head1 DESCRIPTION
  
  This handles the C<irc_005> messages that come from the server.  They
  define the capabilities support by the server.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Takes no arguments.
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head2 C<isupport>
  
  Takes one argument. the server capability to query. Returns a false value on
  failure or a value representing the applicable capability. A full list of
  capabilities is available at L<http://www.irc.org/tech_docs/005.html>.
  
  =head2 C<isupport_dump_keys>
  
  Takes no arguments, returns a list of the available server capabilities,
  which can be used with C<isupport>.
  
  =head1 INPUT
  
  This module handles the following PoCo-IRC signals:
  
  =head2 C<irc_005> (RPL_ISUPPORT or RPL_PROTOCTL)
  
  Denotes the capabilities of the server.
  
  =head2 C<all>
  
  Once the next signal is received that is I<greater> than C<irc_005>,
  it emits an C<irc_isupport> signal.
  
  =head1 OUTPUT EVENTS
  
  =head2 C<irc_isupport>
  
  Emitted by: the first signal received after C<irc_005>
  
  C<ARG0> will be the plugin object itself for ease of use.
  
  This is emitted when the support report has finished.
  
  =head1 AUTHOR
  
  Jeff C<japhy> Pinyan, F<japhy@perlmonk.org>
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  L<POE::Component::IRC::Plugin|POE::Component::IRC::Plugin>
  
  =cut
POE_COMPONENT_IRC_PLUGIN_ISUPPORT

$fatpacked{"POE/Component/IRC/Plugin/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_LOGGER';
  package POE::Component::IRC::Plugin::Logger;
  BEGIN {
    $POE::Component::IRC::Plugin::Logger::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::Logger::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use Encode::Guess;
  use Fcntl qw(O_WRONLY O_APPEND O_CREAT);
  use File::Glob ':glob';
  use File::Spec::Functions qw(catdir catfile rel2abs);
  use IO::Handle;
  use IRC::Utils qw(lc_irc parse_user strip_color strip_formatting decode_irc);
  use POE::Component::IRC::Plugin qw( :ALL );
  use POE::Component::IRC::Plugin::BotTraffic;
  use POSIX qw(strftime);
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %self = @_;
  
      if (!defined $self{Path} && ref $self{Log_sub} ne 'CODE') {
          die "$package requires a Path";
      }
      return bless \%self, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = @_;
  
      if (!$irc->isa('POE::Component::IRC::State')) {
          die __PACKAGE__ . ' requires PoCo::IRC::State or a subclass thereof';
      }
  
      if ( !grep { $_->isa('POE::Component::IRC::Plugin::BotTraffic') } values %{ $irc->plugin_list() } ) {
          $irc->plugin_add('BotTraffic', POE::Component::IRC::Plugin::BotTraffic->new());
      }
  
      if ($self->{Restricted}) {
          $self->{dir_perm} = oct 700;
          $self->{file_perm} = oct 600;
      }
      else {
          $self->{dir_perm} = oct 755;
          $self->{file_perm} = oct 644;
  
      }
  
      $self->{Path} = bsd_glob($self->{Path}) if ref $self->{Log_sub} ne 'CODE';
      if (defined $self->{Path} && ! -d $self->{Path}) {
          mkdir $self->{Path}, $self->{dir_perm}
              or die 'Cannot create directory ' . $self->{Path} . ": $!; aborted";
          $self->{Path} = rel2abs($self->{Path});
      }
  
      $self->{irc} = $irc;
      $self->{logging} = { };
      $self->{Private} = 1 if !defined $self->{Private};
      $self->{Public} = 1 if !defined $self->{Public};
      $self->{DCC} = 1 if !defined $self->{DCC};
      $self->{Format} = $self->default_format() if !defined $self->{Format};
  
      $irc->plugin_register($self, 'SERVER', qw(001 332 333 chan_mode
          ctcp_action bot_action bot_msg bot_public bot_notice join kick msg
          nick part public notice quit topic dcc_start dcc_chat dcc_done));
      $irc->plugin_register($self, 'USER', 'dcc_chat');
      return 1;
  }
  
  sub PCI_unregister {
      return 1;
  }
  
  sub S_001 {
      my ($self, $irc) = splice @_, 0, 2;
      $self->{logging} = { };
      return PCI_EAT_NONE;
  }
  
  sub S_332 {
      my ($self, $irc) = splice @_, 0, 2;
      my $chan  = decode_irc(${ $_[2] }->[0]);
      my $topic = $self->_normalize(${ $_[2] }->[1]);
  
      # only log this if we were just joining the channel
      $self->_log_entry($chan, topic_is => $chan, $topic) if !$irc->channel_list($chan);
      return PCI_EAT_NONE;
  }
  
  sub S_333 {
      my ($self, $irc) = splice @_, 0, 2;
      my ($chan, $user, $time) = @{ ${ $_[2] } };
      $chan = decode_irc($chan);
  
      # only log this if we were just joining the channel
      $self->_log_entry($chan, topic_set_by => $chan, $user, $time) if !$irc->channel_list($chan);
      return PCI_EAT_NONE;
  }
  
  sub S_chan_mode {
      my ($self, $irc) = splice @_, 0, 2;
      pop @_;
      my $nick = parse_user(${ $_[0] });
      my $chan = decode_irc(${ $_[1] });
      my $mode = ${ $_[2] };
      my $arg  = defined $_[3] ? ${ $_[3] } : '';
  
      $self->_log_entry($chan, $mode => $nick, $arg);
      return PCI_EAT_NONE;
  }
  
  sub S_ctcp_action {
      my ($self, $irc) = splice @_, 0, 2;
      my $sender     = parse_user(${ $_[0] });
      my $recipients = ${ $_[1] };
      my $msg        = $self->_normalize(${ $_[2] });
  
      for my $recipient (@{ $recipients }) {
          if ($recipient eq $irc->nick_name()) {
              $self->_log_entry($sender, action => $sender, $msg);
          }
          else {
              $recipient = decode_irc($recipient);
              $self->_log_entry($recipient, action => $sender, $msg);
          }
      }
      return PCI_EAT_NONE;
  }
  
  sub S_notice {
      my ($self, $irc) = splice @_, 0, 2;
      my $sender  = parse_user(${ $_[0] });
      my $targets = ${ $_[1] };
      my $msg     = $self->_normalize(${ $_[2] });
  
      for my $target (@{ $targets }) {
          if ($target eq $irc->nick_name()) {
              $self->_log_entry($sender, notice => $sender, $msg);
          }
          else {
              $target = decode_irc($target);
              $self->_log_entry($target, notice => $sender, $msg);
          }
      }
      return PCI_EAT_NONE;
  }
  
  
  sub S_bot_action {
      my ($self, $irc) = splice @_, 0, 2;
      my $recipients = ${ $_[0] };
      my $msg        = $self->_normalize(${ $_[1] });
  
      for my $recipient (@{ $recipients }) {
          $recipient = decode_irc($recipient);
          $self->_log_entry($recipient, action => $irc->nick_name(), $msg);
      }
      return PCI_EAT_NONE;
  }
  
  sub S_bot_msg {
      my ($self, $irc) = splice @_, 0, 2;
      my $recipients = ${ $_[0] };
      my $msg        = $self->_normalize(${ $_[1] });
  
      for my $recipient (@{ $recipients }) {
          $self->_log_entry($recipient, privmsg => $irc->nick_name(), $msg);
      }
      return PCI_EAT_NONE;
  }
  
  sub S_bot_public {
      my ($self, $irc) = splice @_, 0, 2;
      my $channels = ${ $_[0] };
      my $msg      = $self->_normalize(${ $_[1] });
  
      for my $chan (@{ $channels }) {
          $chan = decode_irc($chan);
          $self->_log_entry($chan, privmsg => $irc->nick_name(), $msg);
      }
      return PCI_EAT_NONE;
  }
  
  sub S_bot_notice {
      my ($self, $irc) = splice @_, 0, 2;
      my $targets = ${ $_[0] };
      my $msg     = $self->_normalize(${ $_[1] });
  
      for my $target (@{ $targets }) {
          $target = decode_irc($target);
          $self->_log_entry($target, notice => $irc->nick_name(), $msg);
      }
      return PCI_EAT_NONE;
  }
  
  sub S_join {
      my ($self, $irc) = splice @_, 0, 2;
      my ($joiner, $user, $host) = parse_user(${ $_[0] });
      my $chan = decode_irc(${ $_[1] });
  
      $self->_log_entry($chan, join => $joiner, "$user\@$host", $chan);
      return PCI_EAT_NONE;
  }
  
  sub S_kick {
      my ($self, $irc) = splice @_, 0, 2;
      my $kicker = parse_user(${ $_[0] });
      my $chan   = decode_irc(${ $_[1] });
      my $victim = ${ $_[2] };
      my $msg    = $self->_normalize(${ $_[3] });
  
      $self->_log_entry($chan, kick => $kicker, $victim, $chan, $msg);
      return PCI_EAT_NONE;
  }
  
  sub S_msg {
      my ($self, $irc) = splice @_, 0, 2;
      my $sender = parse_user(${ $_[0] });
      my $msg    = $self->_normalize(${ $_[2] });
  
      $self->_log_entry($sender, privmsg => $sender, $msg);
      return PCI_EAT_NONE;
  }
  
  sub S_nick {
      my ($self, $irc) = splice @_, 0, 2;
      my $old_nick = parse_user(${ $_[0] });
      my $new_nick = ${ $_[1] };
      my $channels = ${ $_[2] };
  
      for my $chan (@{ $channels }) {
          $chan = decode_irc($chan);
          $self->_log_entry($chan, nick_change => $old_nick, $new_nick);
      }
      return PCI_EAT_NONE;
  }
  
  sub S_part {
      my ($self, $irc) = splice @_, 0, 2;
      my ($parter, $user, $host) = parse_user(${ $_[0] });
      my $chan = decode_irc(${ $_[1] });
      my $msg  = ref $_[2] eq 'SCALAR' ? ${ $_[2] } : '';
      $msg = $self->_normalize($msg);
  
      $self->_log_entry($chan, part => $parter, "$user\@$host", $chan, $msg);
      return PCI_EAT_NONE;
  }
  
  sub S_public {
      my ($self, $irc) = splice @_, 0, 2;
      my $sender   = parse_user(${ $_[0] });
      my $channels = ${ $_[1] };
      my $msg      = $self->_normalize(${ $_[2] });
  
      for my $chan (@{ $channels }) {
          $chan = decode_irc($chan);
          $self->_log_entry($chan, privmsg => $sender, $msg);
      }
      return PCI_EAT_NONE;
  }
  
  sub S_quit {
      my ($self, $irc) = splice @_, 0, 2;
      my ($quitter, $user, $host) = parse_user(${ $_[0] });
      my $msg      = $self->_normalize(${ $_[1] });
      my $channels = ${ $_[2] };
  
      for my $chan (@{ $channels }) {
          $chan = decode_irc($chan);
          $self->_log_entry($chan, quit => $quitter, "$user\@$host", $msg);
      }
      return PCI_EAT_NONE;
  }
  
  sub S_topic {
      my ($self, $irc) = splice @_, 0, 2;
      my $changer   = parse_user(${ $_[0] });
      my $chan      = decode_irc(${ $_[1] });
      my $new_topic = $self->_normalize(${ $_[2] });
  
      $self->_log_entry($chan, topic_change => $changer, $new_topic);
      return PCI_EAT_NONE;
  }
  
  sub S_dcc_start {
      my ($self, $irc) = splice @_, 0, 2;
      my $nick = ${ $_[1] };
      my $type = ${ $_[2] };
      my $port = ${ $_[3] };
      my $addr = ${ $_[6] };
  
      return PCI_EAT_NONE if $type ne 'CHAT';
      $self->_log_entry("=$nick", dcc_start => $nick, "$addr:$port");
      return PCI_EAT_NONE;
  }
  
  sub S_dcc_chat {
      my ($self, $irc) = splice @_, 0, 2;
      my $nick = ${ $_[1] };
      my $msg  = $self->_normalize(${ $_[3] });
  
      if (my ($action) = $msg =~ /\001ACTION (.*?)\001/) {
          $self->_log_entry("=$nick", action => $nick, $action);
      }
      else {
          $self->_log_entry("=$nick", privmsg => $nick, $msg);
      }
      return PCI_EAT_NONE;
  }
  
  sub U_dcc_chat {
      my ($self, $irc) = splice @_, 0, 2;
      pop @_;
      my ($id, @lines) = @_;
      $_ = $$_ for @lines;
      my $me = $irc->nick_name();
  
      my ($dcc) = grep { $_->isa('POE::Component::IRC::Plugin::DCC') } values %{ $irc->plugin_list() };
      my $info = $dcc->dcc_info($$id);
      my $nick = $info->{nick};
  
      for my $msg (@lines) {
          $msg = $self->_normalize($msg);
          if (my ($action) = $msg =~ /\001ACTION (.*?)\001/) {
              $self->_log_entry("=$nick", action => $me, $action);
          }
          else {
              $self->_log_entry("=$nick", privmsg => $me, $msg);
          }
      }
      return PCI_EAT_NONE;
  }
  
  sub S_dcc_done {
      my ($self, $irc) = splice @_, 0, 2;
      my $nick = ${ $_[1] };
      my $type = ${ $_[2] };
      my $port = ${ $_[3] };
      my $addr = ${ $_[7] };
  
      return PCI_EAT_NONE if $type ne 'CHAT';
      $self->_log_entry("=$nick", dcc_done => $nick, "$addr:$port");
      return PCI_EAT_NONE;
  }
  
  sub _log_entry {
      my ($self, $context, $type, @args) = @_;
      my ($date, $time) = split / /, (strftime '%Y-%m-%d %H:%M:%S ', localtime);
      $context = lc_irc $context, $self->{irc}->isupport('CASEMAPPING');
      my $chantypes = join('', @{ $self->{irc}->isupport('CHANTYPES') || ['#', '&']});
  
      if ($context =~ /^[$chantypes]/) {
          return if !$self->{Public};
      }
      elsif ($context =~ /^=/) {
          return if !$self->{DCC};
      }
      else {
          return if !$self->{Private};
      }
  
      return if $type eq 'notice' && !$self->{Notices};
  
      if (ref $self->{Log_sub} eq 'CODE') {
          $self->{Log_sub}->($context, $type, @args);
          return;
      }
  
      return if !defined $self->{Format}->{$type};
  
      # slash is problematic in a filename, replace it with underscore
      $context =~ s!/!_!g;
  
      my $log_file;
      if ($self->{Sort_by_date}) {
          my $log_dir = catdir($self->{Path}, $context);
          if (! -d $log_dir) {
              mkdir $log_dir, $self->{dir_perm}
                  or die "Couldn't create directory $log_dir: $!; aborted";
          }
          $log_file = catfile($self->{Path}, $context, "$date.log");
      }
      else {
          $log_file = catfile($self->{Path}, "$context.log");
      }
  
      $log_file = $self->_open_log($log_file);
  
      if (!$self->{logging}->{$context}) {
          print $log_file "***\n*** LOGGING BEGINS\n***\n";
          $self->{logging}->{$context} = 1;
      }
      my $line = "$time " . $self->{Format}->{$type}->(@args);
      $line = "$date $line" if !$self->{Sort_by_date};
      print $log_file $line, "\n";
      return;
  }
  
  sub _open_log {
      my ($self, $file_name) = @_;
      sysopen(my $log, $file_name, O_WRONLY|O_APPEND|O_CREAT, $self->{file_perm})
          or die "Couldn't open or create file '$file_name': $!; aborted";
      binmode($log, ':encoding(utf8)');
      $log->autoflush(1);
      return $log;
  }
  
  sub _normalize {
      my ($self, $line) = @_;
      $line = decode_irc($line);
      $line = strip_color($line) if $self->{Strip_color};
      $line = strip_formatting($line) if $self->{Strip_formatting};
      return $line;
  }
  
  sub default_format {
      return {
          '+b'         => sub { my ($nick, $mask) = @_;            "--- $nick sets ban on $mask" },
          '-b'         => sub { my ($nick, $mask) = @_;            "--- $nick removes ban on $mask" },
          '+e'         => sub { my ($nick, $mask) = @_;            "--- $nick sets exempt on $mask" },
          '-e'         => sub { my ($nick, $mask) = @_;            "--- $nick removes exempt on $mask" },
          '+I'         => sub { my ($nick, $mask) = @_;            "--- $nick sets invite on $mask" },
          '-I'         => sub { my ($nick, $mask) = @_;            "--- $nick removes invite on $mask" },
          '+h'         => sub { my ($nick, $subject) = @_;         "--- $nick gives channel half-operator status to $subject" },
          '-h'         => sub { my ($nick, $subject) = @_;         "--- $nick removes channel half-operator status from $subject" },
          '+o'         => sub { my ($nick, $subject) = @_;         "--- $nick gives channel operator status to $subject" },
          '-o'         => sub { my ($nick, $subject) = @_;         "--- $nick removes channel operator status from $subject" },
          '+v'         => sub { my ($nick, $subject) = @_;         "--- $nick gives voice to $subject" },
          '-v'         => sub { my ($nick, $subject) = @_;         "--- $nick removes voice from $subject" },
          '+k'         => sub { my ($nick, $key) = @_;             "--- $nick sets channel keyword to $key" },
          '-k'         => sub { my ($nick) = @_;                   "--- $nick removes channel keyword" },
          '+l'         => sub { my ($nick, $limit) = @_;           "--- $nick sets channel user limit to $limit" },
          '-l'         => sub { my ($nick) = @_;                   "--- $nick removes channel user limit" },
          '+i'         => sub { my ($nick) = @_;                   "--- $nick enables invite-only channel status" },
          '-i'         => sub { my ($nick) = @_;                   "--- $nick disables invite-only channel status" },
          '+m'         => sub { my ($nick) = @_;                   "--- $nick enables channel moderation" },
          '-m'         => sub { my ($nick) = @_;                   "--- $nick disables channel moderation" },
          '+n'         => sub { my ($nick) = @_;                   "--- $nick disables external messages" },
          '-n'         => sub { my ($nick) = @_;                   "--- $nick enables external messages" },
          '+p'         => sub { my ($nick) = @_;                   "--- $nick enables private channel status" },
          '-p'         => sub { my ($nick) = @_;                   "--- $nick disables private channel status" },
          '+s'         => sub { my ($nick) = @_;                   "--- $nick enables secret channel status" },
          '-s'         => sub { my ($nick) = @_;                   "--- $nick disables secret channel status" },
          '+t'         => sub { my ($nick) = @_;                   "--- $nick enables topic protection" },
          '-t'         => sub { my ($nick) = @_;                   "--- $nick disables topic protection" },
          nick_change  => sub { my ($old_nick, $new_nick) = @_;    "--- $old_nick is now known as $new_nick" },
          topic_is     => sub { my ($chan, $topic) = @_;           "--- Topic for $chan is: $topic" },
          topic_change => sub { my ($nick, $topic) = @_;           "--- $nick changes the topic to: $topic" },
          privmsg      => sub { my ($nick, $msg) = @_;             "<$nick> $msg" },
          notice       => sub { my ($nick, $msg) = @_;             ">$nick< $msg" },
          action       => sub { my ($nick, $action) = @_;          "* $nick $action" },
          dcc_start    => sub { my ($nick, $address) = @_;         "--> Opened DCC chat connection with $nick ($address)" },
          dcc_done     => sub { my ($nick, $address) = @_;         "<-- Closed DCC chat connection with $nick ($address)" },
          join         => sub { my ($nick, $userhost, $chan) = @_; "--> $nick ($userhost) joins $chan" },
          part         => sub {
              my ($nick, $userhost, $chan, $msg) = @_;
              my $line = "<-- $nick ($userhost) leaves $chan";
              $line .= " ($msg)" if $msg ne '';
              return $line;
          },
          quit         => sub {
              my ($nick, $userhost, $msg) = @_;
              my $line = "<-- $nick ($userhost) quits";
              $line .= " ($msg)" if $msg ne '';
              return $line;
          },
          kick         => sub {
              my ($kicker, $victim, $chan, $msg) = @_;
              my $line = "<-- $kicker kicks $victim from $chan";
              $line .= " ($msg)" if $msg ne '';
              return $line;
          },
          topic_set_by => sub {
              my ($chan, $user, $time) = @_;
              my $date = localtime $time;
              return "--- Topic for $chan was set by $user at $date";
          },
      }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::Logger - A PoCo-IRC plugin which
  logs public, private, and DCC chat messages to disk
  
  =head1 SYNOPSIS
  
   use POE::Component::IRC::Plugin::Logger;
  
   $irc->plugin_add('Logger', POE::Component::IRC::Plugin::Logger->new(
       Path    => '/home/me/irclogs',
       DCC     => 0,
       Private => 0,
       Public  => 1,
   ));
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::Logger is a L<POE::Component::IRC|POE::Component::IRC>
  plugin. It logs messages and CTCP ACTIONs to either F<#some_channel.log> or
  F<some_nickname.log> in the supplied path. In the case of DCC chats, a '=' is
  prepended to the nickname (like in irssi).
  
  The plugin tries to detect UTF-8 encoding of every message or else falls back
  to CP1252, like irssi (and, supposedly, mIRC) does by default. Resulting log
  files will be UTF-8 encoded. The default log format is similar to xchat's,
  except that it's sane and parsable.
  
  This plugin requires the IRC component to be L<POE::Component::IRC::State|POE::Component::IRC::State>
  or a subclass thereof. It also requires a L<POE::Component::IRC::Plugin::BotTraffic|POE::Component::IRC::Plugin::BotTraffic>
  to be in the plugin pipeline. It will be added automatically if it is not
  present.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Arguments:
  
  B<'Path'>, the place where you want the logs saved.
  
  B<'Private'>, whether or not to log private messages. Defaults to 1.
  
  B<'Public'>, whether or not to log public messages. Defaults to 1.
  
  B<'DCC'>, whether or not to log DCC chats. Defaults to 1.
  
  B<'Notices'>, whether or not to log NOTICEs. Defaults to 0.
  
  B<'Sort_by_date'>, whether or not to split log files by date, i.e.
  F<#channel/YYYY-MM-DD.log> instead of F<#channel.log>. If enabled, the date
  will be omitted from the timestamp. Defaults to 0.
  
  B<'Strip_color'>, whether or not to strip all color codes from messages. Defaults
  to 0.
  
  B<'Strip_formatting'>, whether or not to strip all formatting codes from messages.
  Defaults to 0.
  
  B<'Restricted'>, set this to 1 if you want all directories/files to be created
  without read permissions for other users (i.e. 700 for dirs and 600 for files).
  Defaults to 1.
  
  B<'Format'>, a hash reference representing the log format, if you want to define
  your own. See the source for details.
  
  B<'Log_sub'>, a subroutine reference which can be used to override the file
  logging. Use this if you want to store logs in a database instead, for
  example. It will be called with 3 arguments: the context (a channel name or
  nickname), a type (e.g. 'privmsg' or '+b', and any arguments to that type.
  You can make use L</default_format> to create logs that match the default
  log format. B<Note:> You must take care of handling date/time and stripping
  colors/formatting codes yourself.
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head2 C<default_format>
  
  Returns a hash reference of type/subroutine pairs, for formatting logs
  according to the default log format.
  
  =head1 AUTHOR
  
  Hinrik E<Ouml>rn SigurE<eth>sson, hinrik.sig@gmail.com
  
  =cut
POE_COMPONENT_IRC_PLUGIN_LOGGER

$fatpacked{"POE/Component/IRC/Plugin/NickReclaim.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_NICKRECLAIM';
  package POE::Component::IRC::Plugin::NickReclaim;
  BEGIN {
    $POE::Component::IRC::Plugin::NickReclaim::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::NickReclaim::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use IRC::Utils qw(parse_user);
  use POE::Component::IRC::Plugin qw(PCI_EAT_NONE);
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %args = @_;
      $args{ lc $_ } = delete $args{$_} for keys %args;
  
      if (!defined $args{poll} || $args{poll} !~ /^\d+$/) {
          $args{poll} = 30;
      }
  
      return bless \%args, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = @_;
      $irc->plugin_register( $self, 'SERVER', qw(001 433 nick quit) );
      $irc->plugin_register( $self, 'USER', qw(nick) );
  
      $self->{_desired_nick} = $irc->nick_name();
      return 1;
  }
  
  sub PCI_unregister {
      return 1;
  }
  
  sub U_nick {
      my $self = shift;
      my ($nick) = ${ $_[1] } =~ /^NICK +(.+)/i;
  
      if (!defined $self->{_temp_nick} || $self->{_temp_nick} ne $nick) {
          delete $self->{_temp_nick};
          $self->{_desired_nick} = $nick;
      }
      return PCI_EAT_NONE;
  }
  
  sub S_001 {
      my ($self, $irc) = splice @_, 0, 2;
      $self->{_reclaimed} = $irc->nick_name eq $self->{_desired_nick} ? 1 : 0;
      return PCI_EAT_NONE;
  }
  
  # ERR_NICKNAMEINUSE
  sub S_433 {
      my ($self, $irc) = splice @_, 0, 2;
      my $offending = ${ $_[2] }->[0];
  
      if (!$irc->logged_in || $irc->nick_name() eq $offending) {
          my $temp_nick = "${offending}_";
          $self->{_temp_nick} = $temp_nick;
  
          $irc->yield('nick', $temp_nick);
      }
  
      $irc->delay_remove($self->{_alarm_id}) if defined $self->{_alarm_id};
      $self->{_alarm_id} = $irc->delay(
          ['nick', $self->{_desired_nick} ],
          $self->{poll}
      );
  
    return PCI_EAT_NONE;
  }
  
  sub S_quit {
      my ($self, $irc) = splice @_, 0, 2;
      my $who = parse_user(${ $_[0] });
  
      if ($who eq $irc->nick_name) {
          $irc->delay_remove($self->{_alarm_id}) if defined $self->{_alarm_id};
      }
      elsif (!$self->{_reclaimed} && $who eq $self->{_desired_nick}) {
          $irc->delay_remove($self->{_alarm_id}) if defined $self->{_alarm_id};
          $irc->yield('nick', $self->{_desired_nick});
      }
  
      return PCI_EAT_NONE;
  }
  
  sub S_nick {
      my ($self, $irc) = splice @_, 0, 2;
      my $old_nick = parse_user(${ $_[0] });
      my $new_nick = ${ $_[1] };
  
      if ($new_nick eq $irc->nick_name) {
          if ($new_nick eq $self->{_desired_nick}) {
              $self->{_reclaimed} = 1;
              $irc->delay_remove($self->{_alarm_id}) if defined $self->{_alarm_id};
          }
      }
      elsif ($old_nick eq $self->{_desired_nick}) {
          $irc->delay_remove($self->{_alarm_id}) if defined $self->{_alarm_id};
          $irc->yield('nick', $self->{_desired_nick});
      }
  
      return PCI_EAT_NONE;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::NickReclaim - A PoCo-IRC plugin for reclaiming
  your nickname
  
  =head1 SYNOPSIS
  
   use strict;
   use warnings;
   use POE qw(Component::IRC Component::IRC::Plugin::NickReclaim);
  
   my $nickname = 'Flibble' . $$;
   my $ircname = 'Flibble the Sailor Bot';
   my $ircserver = 'irc.blahblahblah.irc';
   my $port = 6667;
  
   my $irc = POE::Component::IRC->spawn(
       nick => $nickname,
       server => $ircserver,
       port => $port,
       ircname => $ircname,
   ) or die "Oh noooo! $!";
  
   POE::Session->create(
       package_states => [
           main => [ qw(_start) ],
       ],
   );
  
    $poe_kernel->run();
  
   sub _start {
       $irc->yield( register => 'all' );
  
       # Create and load our NickReclaim plugin, before we connect
       $irc->plugin_add( 'NickReclaim' =>
           POE::Component::IRC::Plugin::NickReclaim->new( poll => 30 ) );
  
       $irc->yield( connect => { } );
       return;
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::NickReclaim - A
  L<POE::Component::IRC|POE::Component::IRC> plugin automagically deals with
  your bot's nickname being in use and reclaims it when it becomes available
  again.
  
  It registers and handles 'irc_433' events. On receiving a 433 event it will
  reset the nickname to the 'nick' specified with C<spawn> or C<connect>,
  appendedwith an underscore, and then poll to try and change it to the
  original nickname. If someone in your channel who has the nickname you're
  after quits or changes nickname, the plugin will try to reclaim it
  immediately.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Takes one optional argument:
  
  B<'poll'>, the number of seconds between nick change attempts, default is 30;
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams
  
  With amendments applied by Zoffix Znet
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  =cut
POE_COMPONENT_IRC_PLUGIN_NICKRECLAIM

$fatpacked{"POE/Component/IRC/Plugin/NickServID.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_NICKSERVID';
  package POE::Component::IRC::Plugin::NickServID;
  BEGIN {
    $POE::Component::IRC::Plugin::NickServID::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::NickServID::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use IRC::Utils qw( uc_irc parse_user );
  use POE::Component::IRC::Plugin qw( :ALL );
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %self = @_;
  
      die "$package requires a Password" if !defined $self{Password};
      return bless \%self, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = @_;
      $self->{nick} = $irc->{nick};
      $self->{irc} = $irc;
      $irc->plugin_register($self, 'SERVER', qw(isupport nick notice));
      return 1;
  }
  
  sub PCI_unregister {
      return 1;
  }
  
  # we identify after S_isupport so that pocoirc has a chance to turn on
  # CAPAB IDENTIFY-MSG (if the server supports it) before the AutoJoin
  # plugin joins channels
  sub S_isupport {
      my ($self, $irc) = splice @_, 0, 2;
      $irc->yield(nickserv => "IDENTIFY $self->{Password}");
      return PCI_EAT_NONE;
  }
  
  sub S_nick {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my $new_nick = uc_irc( ${ $_[1] }, $mapping );
  
      if ( $new_nick eq uc_irc($self->{nick}, $mapping) ) {
          $irc->yield(nickserv => "IDENTIFY $self->{Password}");
      }
      return PCI_EAT_NONE;
  }
  
  sub S_notice {
      my ($self, $irc) = splice @_, 0, 2;
      my $sender    = parse_user(${ $_[0] });
      my $recipient = parse_user(${ $_[1] }->[0]);
      my $msg       = ${ $_[2] };
  
      return PCI_EAT_NONE if $recipient ne $irc->nick_name();
      return PCI_EAT_NONE if $sender !~ /^nickserv$/i;
      return PCI_EAT_NONE if $msg !~ /now (?:identified|recognized)/;
      $irc->send_event_next('irc_identified');
      return PCI_EAT_NONE;
  }
  
  # ERR_NICKNAMEINUSE
  sub S_433 {
      my ($self, $irc) = splice @_, 0, 2;
      my $offending = ${ $_[2] }->[0];
      my $reason    = ${ $_[2] }->[1];
  
      if ($irc->nick_name() eq $offending && $reason eq "Nickname is registered to someone else") {
          $irc->yield(nickserv => "IDENTIFY $self->{Password}");
      }
  
      return PCI_EAT_NONE;
  }
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::NickServID - A PoCo-IRC plugin which identifies with NickServ when needed
  
  =head1 SYNOPSIS
  
   use POE::Component::IRC::Plugin::NickServID;
  
   $irc->plugin_add( 'NickServID', POE::Component::IRC::Plugin::NickServID->new(
       Password => 'opensesame'
   ));
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::NickServID is a L<POE::Component::IRC|POE::Component::IRC>
  plugin. It identifies with NickServ on connect and when you change your nick,
  if your nickname matches the supplied password.
  
  B<Note>: If you have a cloak and you don't want to be seen without it, make sure
  you don't join channels until after you've identified yourself. If you use the
  L<AutoJoin plugin|POE::Component::IRC::Plugin::AutoJoin>, it will be taken
  care of for you.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Arguments:
  
  'Password', the NickServ password.
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s plugin_add() method.
  
  =head1 OUTPUT EVENTS
  
  =head2 C<irc_identified>
  
  This event will be sent when you have identified with NickServ. No arguments
  are passed with it.
  
  =head1 AUTHOR
  
  Hinrik E<Ouml>rn SigurE<eth>sson, hinrik.sig@gmail.com
  
  =cut
POE_COMPONENT_IRC_PLUGIN_NICKSERVID

$fatpacked{"POE/Component/IRC/Plugin/PlugMan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_PLUGMAN';
  package POE::Component::IRC::Plugin::PlugMan;
  BEGIN {
    $POE::Component::IRC::Plugin::PlugMan::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::PlugMan::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use IRC::Utils qw( matches_mask parse_user );
  use POE::Component::IRC::Plugin qw( :ALL );
  
  BEGIN {
      # Turn on the debugger's symbol source tracing
      $^P |= 0x10;
  
      # Work around bug in pre-5.8.7 perl where turning on $^P
      # causes caller() to be confused about eval {}'s in the stack.
      # (See http://rt.perl.org/rt3/Ticket/Display.html?id=35059 for more info.)
      eval 'sub DB::sub' if $] < 5.008007;
  }
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %args = @_;
      $args{ lc $_ } = delete $args{ $_ } for keys %args;
      return bless \%args, $package;
  }
  
  ##########################
  # Plugin related methods #
  ##########################
  
  sub PCI_register {
      my ($self, $irc) = @_;
  
      $self->{irc} = $irc;
      $irc->plugin_register( $self, 'SERVER', qw(public msg) );
  
      $self->{commands} = {
          PLUGIN_ADD => sub {
              my ($self, $method, $recipient, @cmd) = @_;
              my $msg = $self->load(@cmd) ? 'Done.' : 'Nope';
              $self->{irc}->yield($method => $recipient => $msg);
          },
          PLUGIN_DEL => sub {
              my ($self, $method, $recipient, @cmd) = @_;
              my $msg = $self->unload(@cmd) ? 'Done.' : 'Nope';
              $self->{irc}->yield($method => $recipient => $msg);
          },
          PLUGIN_RELOAD => sub {
              my ($self, $method, $recipient, @cmd) = @_;
              my $msg = $self->reload(@cmd) ? 'Done.' : 'Nope';
              $self->{irc}->yield($method => $recipient => $msg);
          },
          PLUGIN_LIST => sub {
              my ($self, $method, $recipient, @cmd) = @_;
              my @aliases = keys %{ $self->{irc}->plugin_list() };
              my $msg = @aliases
                  ? 'Plugins [ ' . join(', ', @aliases ) . ' ]'
                  : 'No plugins loaded.';
              $self->{irc}->yield($method => $recipient => $msg);
          },
          PLUGIN_LOADED => sub {
              my ($self, $method, $recipient, @cmd) = @_;
              my @aliases = $self->loaded();
              my $msg = @aliases
                  ? 'Managed Plugins [ ' . join(', ', @aliases ) . ' ]'
                  : 'No managed plugins loaded.';
              $self->{irc}->yield($method => $recipient => $msg);
          },
      };
  
      return 1;
  }
  
  sub PCI_unregister {
      my ($self, $irc) = @_;
      delete $self->{irc};
      return 1;
  }
  
  sub S_public {
      my ($self, $irc) = splice @_, 0 , 2;
      my $who     = ${ $_[0] };
      my $channel = ${ $_[1] }->[0];
      my $what    = ${ $_[2] };
      my $me      = $irc->nick_name();
  
      my ($command) = $what =~ m/^\s*\Q$me\E[:,;.!?~]?\s*(.*)$/i;
      return PCI_EAT_NONE if !$command || !$self->_authed($who, $channel);
  
      my (@cmd) = split(/ +/, $command);
      my $cmd = uc (shift @cmd);
  
      if (defined $self->{commands}->{$cmd}) {
          $self->{commands}->{$cmd}->($self, 'privmsg', $channel, @cmd);
      }
  
      return PCI_EAT_NONE;
  }
  
  sub S_msg {
      my ($self, $irc) = splice @_, 0 , 2;
      my $who     = ${ $_[0] };
      my $nick    = parse_user($who);
      my $channel = ${ $_[1] }->[0];
      my $command = ${ $_[2] };
      my (@cmd)   = split(/ +/,$command);
      my $cmd     = uc (shift @cmd);
  
      return PCI_EAT_NONE if !$self->_authed($who, $channel);
  
      if (defined $self->{commands}->{$cmd}) {
          $self->{commands}->{$cmd}->($self, 'notice', $nick, @cmd);
      }
  
      return PCI_EAT_NONE;
  }
  
  ###############################
  # Plugin manipulation methods #
  ###############################
  
  sub load {
      my ($self, $desc, $plugin) = splice @_, 0, 3;
      return if !$desc || !$plugin;
  
      my $object;
      my $module = ref $plugin || $plugin;
      if (! ref $plugin){
          $module .= '.pm' if $module !~ /\.pm$/;
          $module =~ s/::/\//g;
  
          eval "require $plugin";
          if ($@) {
              my $error = $@;
              delete $INC{$module};
              $self->_unload_subs($plugin);
              die $error;
          }
  
          $object = $plugin->new( @_ );
          return if !$object;
      } else {
          $object = $plugin;
          $plugin = ref $object;
      }
  
      my $args = [ @_ ];
      $self->{plugins}->{ $desc }->{module} = $module;
      $self->{plugins}->{ $desc }->{plugin} = $plugin;
  
      my $return = $self->{irc}->plugin_add( $desc, $object );
      if ( $return ) {
          # Stash away arguments for use later by _reload.
          $self->{plugins}->{ $desc }->{args} = $args;
      }
      else {
          # Cleanup
          delete $self->{plugins}->{ $desc };
      }
  
      return $return;
  }
  
  sub unload {
      my ($self, $desc) = splice @_, 0, 2;
      return if !$desc;
  
      my $plugin = $self->{irc}->plugin_del( $desc );
      return if !$plugin;
      my $module = $self->{plugins}->{ $desc }->{module};
      my $file = $self->{plugins}->{ $desc }->{plugin};
      delete $INC{$module};
      delete $self->{plugins}->{ $desc };
      $self->_unload_subs($file);
      return 1;
  }
  
  sub _unload_subs {
      my $self = shift;
      my $file = shift || return;
  
      for my $sym ( grep { index( $_, "$file:" ) == 0 } keys %DB::sub ) {
          eval { undef &$sym };
          warn "$sym: $@\n" if $@;
          delete $DB::sub{$sym};
      }
  
      return 1;
  }
  
  sub reload {
      my ($self, $desc) = splice @_, 0, 2;
      return if !defined $desc;
  
      my $plugin_state = $self->{plugins}->{ $desc };
      return if !$plugin_state;
      warn "Unloading plugin $desc\n" if $self->{debug};
      return if !$self->unload( $desc );
  
      warn "Loading plugin $desc " . $plugin_state->{plugin} . ' [ ' . join(', ',@{ $plugin_state->{args} }) . " ]\n" if $self->{debug};
      return if !$self->load( $desc, $plugin_state->{plugin}, @{ $plugin_state->{args} } );
      return 1;
  }
  
  sub loaded {
      my $self = shift;
      return keys %{ $self->{plugins} };
  }
  
  sub _authed {
      my ($self, $who, $chan) = @_;
  
      return $self->{auth_sub}->($self->{irc}, $who, $chan) if $self->{auth_sub};
      return 1 if matches_mask($self->{botowner}, $who);
      return;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::PlugMan - A PoCo-IRC plugin that provides plugin
  management services.
  
  =head1 SYNOPSIS
  
   use strict;
   use warnings;
   use POE qw(Component::IRC::State);
   use POE::Component::IRC::Plugin::PlugMan;
  
   my $botowner = 'somebody!*@somehost.com';
   my $irc = POE::Component::IRC::State->spawn();
  
   POE::Session->create(
       package_states => [
           main => [ qw(_start irc_plugin_add) ],
       ],
   );
  
   sub _start {
       $irc->yield( register => 'all' );
       $irc->plugin_add( 'PlugMan' => POE::Component::IRC::Plugin::PlugMan->new( botowner => $botowner ) );
       return;
   }
  
   sub irc_plugin_add {
       my ($desc, $plugin) = @_[ARG0, ARG1];
  
       if ($desc eq 'PlugMan') {
           $plugin->load( 'Connector', 'POE::Component::IRC::Plugin::Connector' );
       }
       return;
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::PlugMan is a POE::Component::IRC plugin management
  plugin. It provides support for 'on-the-fly' loading, reloading and unloading
  of plugin modules, via object methods that you can incorporate into your own
  code and a handy IRC interface.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Takes two optional arguments:
  
  B<'botowner'>, an IRC mask to match against for people issuing commands via the
  IRC interface;
  
  B<'auth_sub'>, a sub reference which will be called to determine if a user
  may issue commands via the IRC interface. Overrides B<'botowner'>. It will be
  called with three arguments: the IRC component object, the nick!user@host and
  the channel name as arguments. It should return a true value if the user is
  authorized, a false one otherwise.
  
  B<'debug'>, set to a true value to see when stuff goes wrong;
  
  Not setting B<'botowner'> or B<'auth_sub'> effectively disables the IRC
  interface.
  
  If B<'botowner'> is specified the plugin checks that it is being loaded into a
  L<POE::Component::IRC::State|POE::Component::IRC::State> or sub-class and will
  fail to load otherwise.
  
  Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  =head2 C<load>
  
  Loads a managed plugin.
  
  Takes two mandatory arguments, a plugin descriptor and a plugin package name.
  Any other arguments are used as options to the loaded plugin constructor.
  
   $plugin->load( 'Connector', 'POE::Component::IRC::Plugin::Connector', delay, 120 );
  
  Returns true or false depending on whether the load was successfully or not.
  
  =head2 C<unload>
  
  Unloads a managed plugin.
  
  Takes one mandatory argument, a plugin descriptor.
  
   $plugin->unload( 'Connector' );
  
  Returns true or false depending on whether the unload was successfully or not.
  
  =head2 C<reload>
  
  Unloads and loads a managed plugin, with applicable plugin options.
  
  Takes one mandatory argument, a plugin descriptor.
  
   $plugin->reload( 'Connector' );
  
  =head2 C<loaded>
  
  Takes no arguments.
  
   $plugin->loaded();
  
  Returns a list of descriptors of managed plugins.
  
  =head1 INPUT
  
  An IRC interface is enabled by specifying a "botowner" mask to
  L<C<new>|/new>. Commands may be either invoked via a PRIVMSG directly to
  your bot or in a channel by prefixing the command with the nickname of your
  bot. One caveat, the parsing of the irc command is very rudimentary (it
  merely splits the line on spaces).
  
  =head2 C<plugin_add>
  
  Takes the same arguments as L<C<load>|/load>.
  
  =head2 C<plugin_del>
  
  Takes the same arguments as L<C<unload>|/unload>.
  
  =head2 C<plugin_reload>
  
  Takes the same arguments as L<C<reload>|/reload>.
  
  =head2 C<plugin_loaded>
  
  Returns a list of descriptors of managed plugins.
  
  =head2 C<plugin_list>
  
  Returns a list of descriptors of *all* plugins loaded into the current PoCo-IRC
  component.
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC::State|POE::Component::IRC::State>
  
  L<POE::Component::IRC::Plugin|POE::Component::IRC::Plugin>
  
  =cut
POE_COMPONENT_IRC_PLUGIN_PLUGMAN

$fatpacked{"POE/Component/IRC/Plugin/Proxy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_PROXY';
  package POE::Component::IRC::Plugin::Proxy;
  BEGIN {
    $POE::Component::IRC::Plugin::Proxy::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::Proxy::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use Socket qw(inet_ntoa);
  use POE qw(Wheel::SocketFactory Wheel::ReadWrite Filter::IRCD
             Filter::Line Filter::Stackable);
  use POE::Component::IRC::Plugin qw(PCI_EAT_NONE);
  
  sub new {
      my ($package) = shift;
      croak "$package requires an even number of arguments" if @_ & 1;
      my %args = @_;
      $args{ lc $_ } = delete $args{ $_ } for keys %args;
      return bless \%args, $package;
  }
  
  sub PCI_register {
      my ($self, $irc) = splice @_, 0, 2;
  
      if (!$irc->isa('POE::Component::IRC::State')) {
          die __PACKAGE__ . ' requires PoCo::IRC::State or a subclass thereof';
      }
  
      $irc->raw_events(1);
      $self->{irc} = $irc;
      $irc->plugin_register(
          $self,
          'SERVER',
          qw(
              connected
              disconnected
              001
              error
              socketerr
              raw
          )
      );
  
      POE::Session->create(
          object_states => [
              $self => [qw(
                  _client_error
                  _client_flush
                  _client_input
                  _listener_accept
                  _listener_failed
                  _start
                  _shutdown
                  _spawn_listener
              )],
          ],
      );
  
      return 1;
  }
  
  sub PCI_unregister {
      my ($self, $irc) = splice @_, 0, 2;
      $poe_kernel->post($self->{SESSION_ID} => _shutdown => delete $self->{irc});
      $poe_kernel->refcount_decrement($self->{SESSION_ID}, __PACKAGE__);
      return 1;
  }
  
  sub S_connected {
      my ($self, $irc) = splice @_, 0, 2;
      $self->{stashed} = 0;
      $self->{stash} = [ ];
      return PCI_EAT_NONE;
  }
  
  sub S_001 {
      my ($self, $irc) = splice @_, 0, 2;
      $poe_kernel->post($self->{SESSION_ID} => '_shutdown');
      $poe_kernel->post($self->{SESSION_ID} => '_spawn_listener');
      return PCI_EAT_NONE;
  }
  
  sub S_disconnected {
      my ($self, $irc) = splice @_, 0, 2;
      $poe_kernel->post($self->{SESSION_ID} => '_shutdown');
      return PCI_EAT_NONE;
  }
  
  sub S_socketerr {
      my ($self, $irc) = splice @_, 0, 2;
      $poe_kernel->post($self->{SESSION_ID} => '_shutdown');
      return PCI_EAT_NONE;
  }
  
  sub S_error {
      my ($self, $irc) = splice @_, 0, 2;
      $poe_kernel->post($self->{SESSION_ID} => '_shutdown');
      return PCI_EAT_NONE;
  }
  
  sub S_raw {
      my ($self, $irc) = splice @_, 0, 2;
      my $line  = ${ $_[0] };
      my $input = $self->{irc_filter}->get( [$line] )->[0];
  
      return PCI_EAT_NONE if $input->{command} eq 'PING';
  
      for my $wheel_id (keys %{ $self->{wheels} }) {
          $self->_send_to_client($wheel_id, $line);
      }
  
      return PCI_EAT_NONE if $self->{stashed};
  
      if ($input->{command} =~ /^(?:NOTICE|\d{3})$/) {
          push @{ $self->{stash} }, $line;
      }
  
      $self->{stashed} = 1 if $input->{command} =~ /^(?:376|422)$/;
      return PCI_EAT_NONE;
  }
  
  sub _send_to_client {
      my ($self, $wheel_id, $line) = splice @_, 0, 3;
      return if !defined $self->{wheels}->{ $wheel_id }->{wheel};
      return if !$self->{wheels}->{ $wheel_id }->{reg};
  
      $self->{wheels}->{ $wheel_id }->{wheel}->put($line);
      return;
  }
  
  sub _close_wheel {
      my ($self, $wheel_id) = splice @_, 0, 2;
      return if !defined $self->{wheels}->{ $wheel_id };
  
      delete $self->{wheels}->{ $wheel_id };
      $self->{irc}->send_event(irc_proxy_close => $wheel_id);
      return;
  }
  
  sub _start {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
  
      $self->{SESSION_ID} = $_[SESSION]->ID();
      $kernel->refcount_increment($self->{SESSION_ID}, __PACKAGE__);
  
      $self->{irc_filter} = POE::Filter::IRCD->new();
      $self->{ircd_filter} = POE::Filter::Stackable->new(
          Filters => [
              POE::Filter::Line->new(),
              $self->{irc_filter},
          ],
      );
  
      if ($self->{irc}->connected()) {
          $kernel->yield('_spawn_listener');
      }
      return;
  }
  
  sub _spawn_listener {
      my $self = $_[OBJECT];
  
      $self->{listener} = POE::Wheel::SocketFactory->new(
          BindAddress  => $self->{bindaddress} || 'localhost',
          BindPort     => $self->{bindport} || 0,
          SuccessEvent => '_listener_accept',
          FailureEvent => '_listener_failed',
          Reuse        => 'yes',
      );
  
      if (!$self->{listener}) {
          my $irc = $self->{irc};
          $irc->plugin_del($self);
          return;
      }
  
      $self->{irc}->send_event(irc_proxy_up => $self->{listener}->getsockname());
      return;
  }
  
  sub _listener_accept {
      my ($self, $socket, $peeradr, $peerport) = @_[OBJECT, ARG0 .. ARG2];
  
      my $wheel = POE::Wheel::ReadWrite->new(
          Handle       => $socket,
          InputFilter  => $self->{ircd_filter},
          OutputFilter => POE::Filter::Line->new(),
          InputEvent   => '_client_input',
          ErrorEvent   => '_client_error',
          FlushedEvent => '_client_flush',
      );
  
      if ($wheel) {
          my $wheel_id = $wheel->ID();
          $self->{wheels}->{ $wheel_id }->{wheel} = $wheel;
          $self->{wheels}->{ $wheel_id }->{port} = $peerport;
          $self->{wheels}->{ $wheel_id }->{peer} = inet_ntoa( $peeradr );
          $self->{wheels}->{ $wheel_id }->{start} = time;
          $self->{wheels}->{ $wheel_id }->{reg} = 0;
          $self->{wheels}->{ $wheel_id }->{register} = 0;
          $self->{irc}->send_event(irc_proxy_connect => $wheel_id);
      }
      else {
          $self->{irc}->send_event(irc_proxy_rw_fail => inet_ntoa( $peeradr ) => $peerport);
      }
  
      return;
  }
  
  sub _listener_failed {
      delete ( $_[OBJECT]->{listener} );
      return;
  }
  
  sub _client_flush {
      my ($self, $wheel_id) = @_[OBJECT, ARG0];
  
      return if !defined $self->{wheels}->{ $wheel_id } || !$self->{wheels}->{ $wheel_id }->{quiting};
      $self->_close_wheel($wheel_id);
      return;
  }
  
  # this code needs refactoring
  ## no critic (Subroutines::ProhibitExcessComplexity)
  sub _client_input {
      my ($self, $input, $wheel_id) = @_[OBJECT, ARG0, ARG1];
      my ($irc, $wheels) = ($self->{irc}, $self->{wheels});
  
      return if $wheels->{$wheel_id}{quiting};
  
      if ($input->{command} eq 'QUIT') {
          $self->_close_wheel($wheel_id);
          return;
      }
  
      if ($input->{command} eq 'PASS' && $wheels->{$wheel_id}{reg} < 2) {
          $wheels->{$wheel_id}{pass} = $input->{params}[0];
      }
  
      if ($input->{command} eq 'NICK' && $wheels->{$wheel_id}{reg} < 2) {
          $wheels->{$wheel_id}{nick} = $input->{params}[0];
          $wheels->{$wheel_id}{register}++;
      }
  
      if ($input->{command} eq 'USER' && $wheels->{$wheel_id}{reg} < 2) {
          $wheels->{$wheel_id}{user} = $input->{params}[0];
          $wheels->{$wheel_id}{register}++;
      }
  
      if (!$wheels->{$wheel_id}{reg} && $wheels->{$wheel_id}{register} >= 2) {
          my $password = delete $wheels->{$wheel_id}{pass};
          $wheels->{$wheel_id}{reg} = 1;
  
          if (!$password || $password ne $self->{password}) {
              $self->_send_to_client($wheel_id,
                  'ERROR :Closing Link: * ['
                  . ($wheels->{$wheel_id}{user} || 'unknown')
                  . '@' . $wheels->{$wheel_id}{peer}
                  . '] (Unauthorised connection)'
              );
              $wheels->{$wheel_id}{quiting}++;
              return;
          }
  
          my $nickname = $irc->nick_name();
          my $fullnick = $irc->nick_long_form($nickname);
          if ($nickname ne $wheels->{$wheel_id}{nick}) {
              $self->_send_to_client($wheel_id, "$wheels->{$wheel_id}{nick} NICK :$nickname");
          }
  
          for my $line (@{ $self->{stash} }) {
              $self->_send_to_client($wheel_id, $line);
          }
  
          for my $channel ($irc->nick_channels($nickname)) {
              $self->_send_to_client($wheel_id, ":$fullnick JOIN $channel");
              $irc->yield(names => $channel);
              $irc->yield(topic => $channel);
          }
  
          $irc->send_event(irc_proxy_authed => $wheel_id);
          return;
      }
  
      return if !$wheels->{$wheel_id}{reg};
  
      if ($input->{command} =~ /^(?:NICK|USER|PASS)$/) {
          return;
      }
  
      if ($input->{command} eq 'PING') {
          $self->_send_to_client($wheel_id, "PONG $input->{params}[0]");
          return;
      }
  
      if ($input->{command} eq 'PONG' and $input->{params}[0] =~ /^[0-9]+$/) {
          $wheels->{$wheel_id}{lag} = time() - $input->{params}[0];
          return;
      }
  
      $irc->yield(quote => $input->{raw_line});
      return;
  }
  
  sub _client_error {
      my ($self, $wheel_id) = @_[OBJECT, ARG3];
  
      $self->_close_wheel($wheel_id);
      return;
  }
  
  sub _shutdown {
      my $self = $_[OBJECT];
      my $irc = $self->{irc} || $_[ARG0];
  
      my $mysockaddr = $self->getsockname();
      delete $self->{listener};
  
      for my $wheel_id ( $self->list_wheels() ) {
          $self->_close_wheel( $wheel_id );
      }
      delete $self->{wheels};
      $irc->send_event(irc_proxy_down => $mysockaddr);
  
      return;
  }
  
  sub getsockname {
      my ($self) = @_;
      return if !$self->{listener};
      return $self->{listener}->getsockname();
  }
  
  sub list_wheels {
      my ($self) = @_;
      return keys %{ $self->{wheels} };
  }
  
  sub wheel_info {
      my ($self, $wheel_id) = @_;
      return if !defined $self->{wheels}->{ $wheel_id };
      return $self->{wheels}->{ $wheel_id }->{start} if !wantarray;
      return map { $self->{wheels}->{ $wheel_id }->{$_} } qw(peer port start lag);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::Proxy - A PoCo-IRC plugin that provides a
  lightweight IRC proxy/bouncer
  
  =head1 SYNOPSIS
  
   use strict;
   use warnings;
   use POE qw(Component::IRC::State Component::IRC::Plugin::Proxy Component::IRC::Plugin::Connector);
  
   my $irc = POE::Component::IRC::State->spawn();
  
   POE::Session->create(
       package_states => [
           main => [ qw(_start) ],
       ],
       heap => { irc => $irc },
   );
  
   $poe_kernel->run();
  
   sub _start {
       my ($kernel, $heap) = @_[KERNEL, HEAP];
       $heap->{irc}->yield( register => 'all' );
       $heap->{proxy} = POE::Component::IRC::Plugin::Proxy->new( bindport => 6969, password => "m00m00" );
       $heap->{irc}->plugin_add( 'Connector' => POE::Component::IRC::Plugin::Connector->new() );
       $heap->{irc}->plugin_add( 'Proxy' => $heap->{proxy} );
       $heap->{irc}->yield ( connect => { Nick => 'testbot', Server => 'someserver.com' } );
       return;
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::Proxy is a L<POE::Component::IRC>
  plugin that provides lightweight IRC proxy/bouncer server to your
  L<POE::Component::IRC> bots. It enables multiple IRC
  clients to be hidden behind a single IRC client-server connection.
  
  Spawn a L<POE::Component::IRC::State> session and add in a
  POE::Component::IRC::Plugin::Proxy plugin object, specifying a bindport and a
  password the connecting IRC clients have to use. When the component is
  connected to an IRC network a listening port is opened by the plugin for
  multiple IRC clients to connect.
  
  Neat, huh? >;o)
  
  This plugin will activate L<POE::Component::IRC>'s raw
  events (L<C<irc_raw>|POE::Component::IRC/irc_raw>) by calling
  C<< $irc->raw_events(1) >>.
  
  This plugin requires the IRC component to be
  L<POE::Component::IRC::State> or a subclass thereof.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Takes a number of arguments:
  
  B<'password'>, the password to require from connecting clients;
  
  B<'bindaddress'>, a local address to bind the listener to, default is 'localhost';
  
  B<'bindport'>, what port to bind to, default is 0, ie. randomly allocated by OS;
  
  Returns an object suitable for passing to
  L<POE::Component::IRC>'s C<plugin_add> method.
  
  =head2 C<getsockname>
  
  Takes no arguments. Accesses the listeners C<getsockname> method. See
  L<POE::Wheel::SocketFactory> for details of the
  return value;
  
  =head2 C<list_wheels>
  
  Takes no arguments. Returns a list of wheel ids of the current connected clients.
  
  =head2 C<wheel_info>
  
  Takes one parameter, a wheel ID to query. Returns undef if an invalid wheel id
  is passed. In a scalar context returns the time that the client connected in
  unix time. In a list context returns a list consisting of the peer address,
  port, tthe connect time and the lag in seconds for that connection.
  
  =head1 OUTPUT EVENTS
  
  The plugin emits the following L<POE::Component::IRC>
  events:
  
  =head2 C<irc_proxy_up>
  
  Emitted when the listener is successfully started. C<ARG0> is the result of the
  listener C<getsockname>.
  
  =head2 C<irc_proxy_connect>
  
  Emitted when a client connects to the listener. C<ARG0> is the wheel ID of the
  client.
  
  =head2 C<irc_proxy_rw_fail>
  
  Emitted when the L<POE::Wheel::ReadWrite> fails on a
  connection. C<ARG0> is the wheel ID of the client.
  
  =head2 C<irc_proxy_authed>
  
  Emitted when a connecting client successfully negotiates an IRC session with
  the plugin. C<ARG0> is the wheel ID of the client.
  
  =head2 C<irc_proxy_close>
  
  Emitted when a connected client disconnects. C<ARG0> is the wheel ID of the
  client.
  
  =head2 C<irc_proxy_down>
  
  Emitted when the listener is successfully shutdown. C<ARG0> is the result of the
  listener C<getsockname>.
  
  =head1 QUIRKS
  
  Connecting IRC clients will not be able to change nickname. This is a feature.
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC>
  
  L<POE::Component::IRC::State>
  
  =cut
POE_COMPONENT_IRC_PLUGIN_PROXY

$fatpacked{"POE/Component/IRC/Plugin/Whois.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_PLUGIN_WHOIS';
  package POE::Component::IRC::Plugin::Whois;
  BEGIN {
    $POE::Component::IRC::Plugin::Whois::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Plugin::Whois::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use POE;
  use POE::Component::IRC::Plugin qw( PCI_EAT_NONE );
  use IRC::Utils qw(uc_irc);
  
  sub new {
      return bless { }, shift;
  }
  
  sub PCI_register {
      my( $self, $irc ) = @_;
      $irc->plugin_register( $self, 'SERVER', qw(307 310 311 312 313 314 317 318 319 330 338 369) );
      return 1;
  }
  
  sub PCI_unregister {
      return 1;
  }
  
  # RPL_WHOISUSER
  sub S_311 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my @args = @{ ${ $_[2] } };
      my $real = pop @args;
      my ($rnick,$user,$host) = @args;
      my $nick = uc_irc $rnick, $mapping;
  
      $self->{WHOIS}->{ $nick }->{nick} = $rnick;
      $self->{WHOIS}->{ $nick }->{user} = $user;
      $self->{WHOIS}->{ $nick }->{host} = $host;
      $self->{WHOIS}->{ $nick }->{real} = $real;
  
      return PCI_EAT_NONE;
  }
  
  # RPL_WHOISOPERATOR
  sub S_313 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my $nick = uc_irc ${ $_[2] }->[0], $mapping;
      my $oper = ${ $_[2] }->[1];
  
      $self->{WHOIS}->{ $nick }->{oper} = $oper;
      return PCI_EAT_NONE;
  }
  
  # RPL_WHOISSERVER
  sub S_312 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my ($nick,$server) = @{ ${ $_[2] } };
      $nick = uc_irc $nick, $mapping;
  
      # This can be returned in reply to either a WHOIS or a WHOWAS *sigh*
      if ( defined $self->{WHOWAS}->{ $nick } ) {
          $self->{WHOWAS}->{ $nick }->{server} = $server;
      }
      else {
          $self->{WHOIS}->{ $nick }->{server} = $server;
      }
  
      return PCI_EAT_NONE;
  }
  
  # RPL_WHOISIDLE
  sub S_317 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my ($nick,@args) = @{ ${ $_[2] } };
      $nick = uc_irc $nick, $mapping;
  
      $self->{WHOIS}->{ $nick }->{idle} = $args[0];
      $self->{WHOIS}->{ $nick }->{signon} = $args[1];
  
      return PCI_EAT_NONE;
  }
  
  # RPL_WHOISCHANNELS
  sub S_319 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my @args = @{ ${ $_[2] } };
      my $nick = uc_irc shift ( @args ), $mapping;
      my @chans = split / /, shift @args;
  
      if ( !defined $self->{WHOIS}->{ $nick }->{channels} ) {
          $self->{WHOIS}->{ $nick }->{channels} = [ @chans ];
      }
      else {
          push( @{ $self->{WHOIS}->{ $nick }->{channels} }, @chans );
      }
  
    return PCI_EAT_NONE;
  }
  
  # RPL_WHOISACCOUNT
  sub S_330 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my ($nick, $ident) = @{ ${ $_[2] } };
  
      $self->{WHOIS}->{ uc_irc ( $nick, $mapping  ) }->{identified} = $ident;
  
      return PCI_EAT_NONE;
  }
  
  {
      no warnings 'once';
      *S_307 = \&S_330;   # RPL_WHOISREGNICK
  }
  
  # RPL_WHOISMODES
  sub S_310 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my ($nick, $modes) = @{ ${ $_[2] } };
  
      $self->{WHOIS}->{ uc_irc ( $nick, $mapping  ) }->{modes} = $modes;
  
      return PCI_EAT_NONE;
  }
  
  # RPL_WHOISACTUALLY (Hybrid/Ratbox/others)
  sub S_338 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my $nick = uc_irc ${ $_[2] }->[0], $mapping;
      my $ip = ${ $_[2] }->[1];
  
      $self->{WHOIS}->{ $nick }->{actually} = $ip;
  
      return PCI_EAT_NONE;
  }
  
  # RPL_ENDOFWHOIS
  sub S_318 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my $nick = uc_irc ${ $_[2] }->[0], $mapping;
      my $whois = delete $self->{WHOIS}->{ $nick };
  
      $irc->send_event_next( 'irc_whois', $whois ) if defined $whois;
      return PCI_EAT_NONE;
  }
  
  # RPL_WHOWASUSER
  sub S_314 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my @args = @{ ${ $_[2] } };
      my $real = pop @args;
      my ($rnick,$user,$host) = @args;
      my $nick = uc_irc $rnick, $mapping;
  
      $self->{WHOWAS}->{ $nick }->{nick} = $rnick;
      $self->{WHOWAS}->{ $nick }->{user} = $user;
      $self->{WHOWAS}->{ $nick }->{host} = $host;
      $self->{WHOWAS}->{ $nick }->{real} = $real;
  
      return PCI_EAT_NONE;
  }
  
  # RPL_ENDOFWHOWAS
  sub S_369 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my $nick = uc_irc ${ $_[2] }->[0], $mapping;
  
      my $whowas = delete $self->{WHOWAS}->{ $nick };
      $irc->send_event_next( 'irc_whowas', $whowas ) if defined $whowas;
      return PCI_EAT_NONE;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Plugin::Whois - A PoCo-IRC plugin that generates events
  for WHOIS and WHOWAS replies
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Plugin::Whois is the reimplementation of the C<irc_whois>
  and C<irc_whowas> code from L<POE::Component::IRC|POE::Component::IRC> as a
  plugin. It is used internally by L<POE::Component::IRC|POE::Component::IRC>
  so there is no need to use this plugin yourself.
  
  =head1 METHODS
  
  =head2 C<new>
  
  No arguments required. Returns a plugin object suitable for feeding to
  L<POE::Component::IRC|POE::Component::IRC>'s C<plugin_add> method.
  
  
  =head1 AUTHOR
  
  Chris "BinGOs" Williams
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  L<POE::Component::IRC::Plugin|POE::Component::IRC::Plugin>
  
  =cut
POE_COMPONENT_IRC_PLUGIN_WHOIS

$fatpacked{"POE/Component/IRC/Qnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_QNET';
  package POE::Component::IRC::Qnet;
  BEGIN {
    $POE::Component::IRC::Qnet::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Qnet::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use POE;
  use POE::Component::IRC::Constants qw(:ALL);
  use base qw(POE::Component::IRC);
  
  sub _create {
      my $self = shift;
  
      $self->SUPER::_create();
  
      # Stuff specific to IRC-Qnet
      my @qbot_commands = qw(
          hello
          whoami
          challengeauth
          showcommands
          auth
          challenge
          help
          unlock
          requestpassword
          reset
          newpass
          email
          authhistory
          banclear
          op
          invite
          removeuser
          banlist
          recover
          limit
          unbanall
          whois
          version
          autolimit
          ban
          clearchan
          adduser
          settopic
          chanflags
          deopall
          requestowner
          bandel
          chanlev
          key
          welcome
          voice
      );
  
  
    $self->{OBJECT_STATES_HASHREF}->{'qbot_' . $_} = '_qnet_bot_commands' for @qbot_commands;
    $self->{server} = 'irc.quakenet.org';
    $self->{QBOT} = 'Q@Cserve.quakenet.org';
  
    return 1;
  }
  
  sub _qnet_bot_commands {
      my ($kernel, $state, $self) = @_[KERNEL,STATE,OBJECT];
      my $message = join ' ', @_[ARG0 .. $#_];
  
      my $pri = $self->{IRC_CMDS}->{'privmsghi'}->[CMD_PRI];
      my $command = "PRIVMSG ";
      my ($target,$cmd) = split(/_/,$state);
      $command .= join(' :',$self->{uc $target},uc($cmd));
      $command = join(' ',$command,$message) if defined ( $message );
      $kernel->yield( 'sl_prioritized', $pri, $command );
  
      return;
  }
  
  sub service_bots {
      my ($self, %args) = @_;
  
      for my $botname ( qw(QBOT) ) {
          if ( defined ( $args{$botname} ) ) {
              $self->{$botname} = $args{$botname};
          }
      }
  
      return 1;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Qnet - A fully event-driven IRC client module for Quakenet
  
  =head1 SYNOPSIS
  
   use strict;
   use warnings;
   use POE qw(Component::IRC::Qnet);
  
   my $nickname = 'Flibble' . $$;
   my $ircname = 'Flibble the Sailor Bot';
   my $port = 6667;
   my $qauth = 'FlibbleBOT';
   my $qpass = 'fubar';
   my @channels = ( '#Blah', '#Foo', '#Bar' );
  
   # We create a new PoCo-IRC object and component.
   my $irc = POE::Component::IRC::Qnet->spawn(
       nick => $nickname,
       port => $port,
       ircname => $ircname,
   ) or die "Oh noooo! $!";
  
   POE::Session->create(
       package_states => [
           main => [ qw(_default _start irc_001 irc_public) ],
       ],
       heap => { irc => $irc },
   );
  
   $poe_kernel->run();
  
   sub _start {
       my ($kernel, $heap) = @_[KERNEL, HEAP];
  
       # We get the session ID of the component from the object
       # and register and connect to the specified server.
       my $irc_session = $heap->{irc}->session_id();
       $kernel->post( $irc_session => register => 'all' );
       $kernel->post( $irc_session => connect => { } );
       return;
   }
  
   sub irc_001 {
       my ($kernel, $sender) = @_[KERNEL, SENDER];
  
       # Get the component's object at any time by accessing the heap of
       # the SENDER
       my $poco_object = $sender->get_heap();
       print "Connected to ", $poco_object->server_name(), "\n";
  
       # Lets authenticate with Quakenet's Q bot
       $kernel->post( $sender => qbot_auth => $qauth => $qpass );
  
       return;
   }
  
   sub irc_public {
       my ($kernel, $sender, $who, $where, $what) = @_[KERNEL, SENDER, ARG0 .. ARG2];
       my $nick = ( split /!/, $who )[0];
       my $channel = $where->[0];
  
       if ( my ($rot13) = $what =~ /^rot13 (.+)/ ) {
           $rot13 =~ tr[a-zA-Z][n-za-mN-ZA-M];
           $kernel->post( $sender => privmsg => $channel => "$nick: $rot13" );
       }
       return;
   }
  
   # We registered for all events, this will produce some debug info.
   sub _default {
       my ($event, $args) = @_[ARG0 .. $#_];
       my @output = ( "$event: " );
  
       for my $arg ( @$args ) {
           if (ref $arg eq 'ARRAY') {
               push( @output, '[' . join(', ', @$arg ) . ']' );
           }
           else {
               push ( @output, "'$arg'" );
           }
       }
       print join ' ', @output, "\n";
       return 0;
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Qnet is an extension to L<POE::Component::IRC|POE::Component::IRC>
  specifically for use on Quakenet L<http://www.quakenet.org/>. See the
  documentation for L<POE::Component::IRC|POE::Component::IRC> for general usage.
  This document covers the extensions.
  
  The module provides a number of additional commands for communicating with the
  Quakenet service bot Q.
  
  =head1 METHODS
  
  =head2 C<service_bots>
  
  The component will query Q its default name on Quakenet. If you
  wish to override these settings, use this method to configure them.
  
   $irc->service_bots(QBOT => 'W@blah.network.net');
  
  In most cases you shouldn't need to mess with these >;o)
  
  =head1 INPUT
  
  The Quakenet service bots accept input as PRIVMSG. This module provides a
  wrapper around the L<POE::Component::IRC> "privmsg" command.
  
  =head2 C<qbot_*>
  
  Send commands to the Q bot. Pass additional command parameters as arguments to
  the event.
  
   $kernel->post ('my client' => qbot_auth => $q_user => $q_pass);
  
  =head1 OUTPUT EVENTS
  
  All output from the Quakenet service bots is sent as NOTICEs.
  Use L<C<irc_notice>|POE::Component::IRC/irc_notice> to trap these.
  
  =head2 C<irc_whois>
  
  Has all the same hash keys in C<ARG1> as L<POE::Component::IRC|POE::Component::IRC>,
  with the addition of B<'account'>, which contains the name of their Q auth account,
  if they have authed, or a false value if they haven't.
  
  =head1 BUGS
  
  A few have turned up in the past and they are sure to again. Please use
  L<http://rt.cpan.org/> to report any. Alternatively, email the current maintainer.
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams E<lt>chris@bingosnet.co.ukE<gt>
  
  Based on the original POE::Component::IRC by:
  
  Dennis Taylor, <dennis@funkplanet.com>
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC>
  
  L<http://www.quakenet.org/>
  
  =cut
POE_COMPONENT_IRC_QNET

$fatpacked{"POE/Component/IRC/Qnet/State.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_QNET_STATE';
  package POE::Component::IRC::Qnet::State;
  BEGIN {
    $POE::Component::IRC::Qnet::State::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::Qnet::State::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use POE;
  use IRC::Utils qw(uc_irc normalize_mask parse_user);
  use POE::Component::IRC::Plugin qw(:ALL);
  use base qw(POE::Component::IRC::State POE::Component::IRC::Qnet);
  
  sub _create {
      my $self = shift;
  
      $self->SUPER::_create();
  
      # Stuff specific to IRC-Qnet
      my @qbot_commands = qw(
          hello
          whoami
          challengeauth
          showcommands
          auth
          challenge
          help
          unlock
          requestpassword
          reset
          newpass
          email
          authhistory
          banclear
          op
          invite
          removeuser
          banlist
          recover
          limit
          unbanall
          whois
          version
          autolimit
          ban
          clearchan
          adduser
          settopic
          chanflags
          deopall
          requestowner
          bandel
          chanlev
          key
          welcome
          voice
          );
  
      $self->{OBJECT_STATES_HASHREF}->{'qbot_' . $_} = '_qnet_bot_commands' for @qbot_commands;
      $self->{OBJECT_STATES_HASHREF}->{'resync_chan'} = '_resync_chan';
      $self->{OBJECT_STATES_HASHREF}->{'resync_nick'} = '_resync_nick';
      $self->{server} = 'irc.quakenet.org';
      $self->{QBOT} = 'Q@Cserve.quakenet.org';
  
      return 1;
  }
  
  sub _resync_chan {
      my ($kernel, $self, @channels) = @_[KERNEL, OBJECT, ARG0 .. $#_];
  
      my $mapping = $self->isupport('CASEMAPPING');
      my $nickname = $self->nick_name();
      my $flags = '%cunharsft';
  
      for my $channel ( @channels ) {
          next if !$self->is_channel_member( $channel, $nickname );
  
          my $uchan = uc_irc $channel, $mapping;
          delete $self->{STATE}->{Chans}->{ $uchan };
          $self->{CHANNEL_SYNCH}->{ $uchan } = { MODE => 0, WHO => 0, BAN => 0, _time => time() };
          $self->{STATE}->{Chans}->{ $uchan } = { Name => $channel, Mode => '' };
  
          $self->yield ( 'sl' => "WHO $channel $flags,101" );
          $self->yield ( 'mode' => $channel );
          $self->yield ( 'mode' => $channel => 'b');
      }
  
      return;
  }
  
  sub _resync_nick {
      my ($kernel, $self, $nick, @channels) = @_[KERNEL ,OBJECT, ARG0 .. $#_];
  
      my $info = $self->nick_info( $nick );
      return if !$info;
      $nick = $info->{Nick};
      my $user = $info->{User};
      my $host = $info->{Host};
      my $mapping = $self->isupport('CASEMAPPING');
      my $unick = uc_irc $nick, $mapping;
      my $flags = '%cunharsft';
  
      for my $channel ( @channels ) {
          next if !$self->is_channel_member( $channel, $nick );
  
          my $uchan = uc_irc $channel, $mapping;
          $self->yield ( 'sl' => "WHO $nick $flags,102" );
          $self->{STATE}->{Nicks}->{ $unick }->{Nick} = $nick;
          $self->{STATE}->{Nicks}->{ $unick }->{User} = $user;
          $self->{STATE}->{Nicks}->{ $unick }->{Host} = $host;
          $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = '';
          $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick } = '';
          push @{ $self->{NICK_SYNCH}->{ $unick } }, $channel;
      }
  
      return;
  }
  
  # Qnet extension to RPL_WHOIS
  sub S_330 {
      my ($self, $irc) = splice @_, 0, 2;
      my ($nick, $account) = ( split / /, ${ $_[1] } )[0..1];
  
      $self->{WHOIS}->{ $nick }->{account} = $account;
      return PCI_EAT_NONE;
  }
  
  # Qnet extension RPL_WHOEXT
  sub S_354 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my ($query, $channel, $user, $host, $server, $nick, $status, $auth, $real)
          = @{ ${ $_[2] } };
      my $unick = uc_irc $nick, $mapping;
      my $uchan = uc_irc $channel, $mapping;
  
      $self->{STATE}->{Nicks}->{ $unick }->{Nick} = $nick;
      $self->{STATE}->{Nicks}->{ $unick }->{User} = $user;
      $self->{STATE}->{Nicks}->{ $unick }->{Host} = $host;
      $self->{STATE}->{Nicks}->{ $unick }->{Real} = $real;
      $self->{STATE}->{Nicks}->{ $unick }->{Server} = $server;
      $self->{STATE}->{Nicks}->{ $unick }->{Auth} = $auth if ( $auth );
  
      if ( $auth and defined ( $self->{USER_AUTHED}->{ $unick } ) ) {
          $self->{USER_AUTHED}->{ $unick } = $auth;
      }
  
      if ( $query eq '101' ) {
          my $whatever = '';
          $whatever .= 'o' if $status =~ /\@/;
          $whatever .= 'v' if $status =~ /\+/;
          $whatever .= 'h' if $status =~ /\%/;
          $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = $whatever;
          $self->{STATE}->{Chans}->{ $uchan }->{Name} = $channel;
          $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick } = $whatever;
      }
  
      if ( $status =~ /\*/ ) {
          $self->{STATE}->{Nicks}->{ $unick }->{IRCop} = 1;
      }
  
      return PCI_EAT_NONE;
  }
  
  # RPL_ENDOFWHO
  sub S_315 {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my $channel = ${ $_[2] }->[0];
      my $uchan = uc_irc $channel, $mapping;
  
      if ( exists $self->{STATE}->{Chans}->{ $uchan } ) {
          if ( $self->_channel_sync($channel, 'WHO' ) ) {
              my $rec = delete $self->{CHANNEL_SYNCH}->{ $uchan };
              $self->send_event_next( 'irc_chan_sync', $channel, time() - $rec->{_time} );
          }
      }
      # it's apparently a nickname
      elsif ( defined $self->{USER_AUTHED}->{ $uchan } ) {
          $self->send_event_next( 'irc_nick_authed', $channel, delete $self->{USER_AUTHED}->{ $uchan } );
      }
      else {
          my $chan = shift @{ $self->{NICK_SYNCH}->{ $uchan } };
          delete $self->{NICK_SYNCH}->{ $uchan } if !@{ $self->{NICK_SYNCH}->{ $uchan } };
          $self->send_event_next( 'irc_nick_sync', $channel, $chan );
      }
  
      return PCI_EAT_NONE;
  }
  
  sub S_join {
      my ($self, $irc) = splice @_, 0, 2;
      my ($nick, $user, $host) = parse_user(${ $_[0] } );
      my $channel = ${ $_[1] };
  
      my $mapping = $irc->isupport('CASEMAPPING');
      my $uchan = uc_irc $channel, $mapping;
      my $unick = uc_irc $nick, $mapping;
      my $flags = '%cunharsft';
  
      if ( $unick eq uc_irc ( $self->nick_name(), $mapping ) ) {
          delete $self->{STATE}->{Chans}->{ $uchan };
          $self->{CHANNEL_SYNCH}->{ $uchan } = {
              MODE => 0,
              WHO => 0,
              BAN => 0,
              _time => time()
          };
          $self->{STATE}->{Chans}->{ $uchan } = { Name => $channel, Mode => '' };
  
          $self->yield ( 'sl' => "WHO $channel $flags,101" );
          $self->yield ( 'mode' => $channel );
          $self->yield ( 'mode' => $channel => 'b');
  
      }
      else {
          my $netsplit = "$unick!$user\@$host";
          if ( exists $self->{NETSPLIT}->{Users}->{ $netsplit } ) {
              # restore state from NETSPLIT if it hasn't expired.
              my $nuser = delete $self->{NETSPLIT}->{Users}->{ $netsplit };
              if ( ( time - $nuser->{stamp} ) < ( 60 * 60 ) ) {
                $self->{STATE}->{Nicks}->{ $unick } = $nuser->{meta};
                $self->send_event_next(irc_nick_sync => $nick, $channel);
              }
              return PCI_EAT_NONE;
          }
          if ( exists $self->{STATE}->{Nicks}->{ $unick }->{Real} ) {
              $self->send_event_next(irc_nick_sync => $nick, $channel);
              return PCI_EAT_NONE;
          }
          $self->yield ( 'sl' => "WHO $nick $flags,102" );
          $self->{STATE}->{Nicks}->{ $unick }->{Nick} = $nick;
          $self->{STATE}->{Nicks}->{ $unick }->{User} = $user;
          $self->{STATE}->{Nicks}->{ $unick }->{Host} = $host;
          $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = '';
          $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick } = '';
          push @{ $self->{NICK_SYNCH}->{ $unick } }, $channel;
      }
  
      return PCI_EAT_NONE;
  }
  
  sub S_chan_mode {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      pop @_;
      my $who = ${ $_[0] };
      my $source = uc_irc ( ( split /!/, $who )[0], $mapping );
      my $mode = ${ $_[2] };
      my $arg = defined $_[3] ? ${ $_[3] } : '';
      my $uarg = uc_irc $arg, $mapping;
  
      return PCI_EAT_NONE if $source !~ /^[Q]$/ || $mode !~ /[ov]/;
  
      if ( !$self->is_nick_authed($arg) && !$self->{USER_AUTHED}->{ $uarg } ) {
         $self->{USER_AUTHED}->{ $uarg } = 0;
         $self->yield ( 'sl' => "WHO $arg " . '%cunharsft,102' );
      }
  
      return PCI_EAT_NONE;
  }
  
  sub S_part {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my $nick = uc_irc ( ( split /!/, ${ $_[0] } )[0], $mapping );
      my $channel = uc_irc ${ $_[1] }, $mapping;
      if ( ref $_[2] eq 'ARRAY' ) {
          push @{ $_[-1] }, '', $self->is_nick_authed( $nick );
      }
      else {
          push @{ $_[-1] }, $self->is_nick_authed( $nick );
      }
  
      if ( $nick eq uc_irc ( $self->nick_name(), $mapping ) ) {
          delete $self->{STATE}->{Nicks}->{ $nick }->{CHANS}->{ $channel };
          delete $self->{STATE}->{Chans}->{ $channel }->{Nicks}->{ $nick };
          for my $member ( keys %{ $self->{STATE}->{Chans}->{ $channel }->{Nicks} } ) {
             delete $self->{STATE}->{Nicks}->{ $member }->{CHANS}->{ $channel };
             if ( keys %{ $self->{STATE}->{Nicks}->{ $member }->{CHANS} } <= 0 ) {
                  delete $self->{STATE}->{Nicks}->{ $member };
             }
          }
          delete $self->{STATE}->{Chans}->{ $channel };
      }
      else {
          delete $self->{STATE}->{Nicks}->{ $nick }->{CHANS}->{ $channel };
          delete $self->{STATE}->{Chans}->{ $channel }->{Nicks}->{ $nick };
          if ( keys %{ $self->{STATE}->{Nicks}->{ $nick }->{CHANS} } <= 0 ) {
                  delete $self->{STATE}->{Nicks}->{ $nick };
          }
      }
  
      return PCI_EAT_NONE;
  }
  
  sub S_quit {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my $nick = ( split /!/, ${ $_[0] } )[0];
      my $msg = ${ $_[1] };
      push @{ $_[2] }, [ $self->nick_channels( $nick ) ];
      push @{ $_[2] }, $self->is_nick_authed( $nick );
      my $unick = uc_irc $nick, $mapping;
      my $netsplit = 0;
  
      # Check if it is a netsplit
      $netsplit = 1 if _is_netsplit( $msg );
  
      if ( $unick eq uc_irc ( $self->nick_name(), $mapping ) ) {
          delete $self->{STATE};
      }
      else {
          for my $channel ( keys %{ $self->{STATE}->{Nicks}->{ $unick }->{CHANS} } ) {
                  delete $self->{STATE}->{Chans}->{ $channel }->{Nicks}->{ $unick };
          }
          my $nickstate = delete $self->{STATE}->{Nicks}->{ $unick };
          if ( $netsplit ) {
            delete $nickstate->{CHANS};
            $self->{NETSPLIT}->{Users}->{ "$unick!" . join '@', @{$nickstate}{qw(User Host)} } =
               { meta => $nickstate, stamp => time };
          }
      }
  
      return PCI_EAT_NONE;
  }
  
  sub _is_netsplit {
    my $msg = shift || return;
    return 1 if $msg =~ /^\s*\S+\.[a-z]{2,} \S+\.[a-z]{2,}$/i;
    return 0;
  }
  
  sub S_kick {
      my ($self, $irc) = splice @_, 0, 2;
      my $mapping = $irc->isupport('CASEMAPPING');
      my $channel = ${ $_[1] };
      my $nick = ${ $_[2] };
      my $unick = uc_irc $nick, $mapping;
      my $uchan = uc_irc $channel, $mapping;
  
      push @{ $_[-1] }, $self->nick_long_form( $nick );
      push @{ $_[-1] }, $self->is_nick_authed( $nick );
  
      if ( $unick eq uc_irc ( $self->nick_name(), $mapping ) ) {
          delete $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan };
          delete $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick };
          for my $member ( keys %{ $self->{STATE}->{Chans}->{ $uchan }->{Nicks} } ) {
             delete $self->{STATE}->{Nicks}->{ $member }->{CHANS}->{ $uchan };
             if ( keys %{ $self->{STATE}->{Nicks}->{ $member }->{CHANS} } <= 0 ) {
                  delete $self->{STATE}->{Nicks}->{ $member };
             }
          }
          delete $self->{STATE}->{Chans}->{ $uchan };
      }
      else {
          delete $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan };
          delete $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick };
          if ( keys %{ $self->{STATE}->{Nicks}->{ $unick }->{CHANS} } <= 0 ) {
              delete $self->{STATE}->{Nicks}->{ $unick };
          }
      }
  
      return PCI_EAT_NONE;
  }
  
  sub is_nick_authed {
      my ($self, $nick) = @_;
      my $mapping = $self->isupport('CASEMAPPING');
      my $unick = uc_irc $nick, $mapping;
  
      return if !$self->_nick_exists($nick);
  
      if (defined $self->{STATE}->{Nicks}->{ $unick }->{Auth}) {
          return $self->{STATE}->{Nicks}->{ $unick }->{Auth};
      }
  
      return;
  }
  
  sub find_auth_nicks {
      my ($self, $auth, $channel) = @_;
      my $mapping = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc $channel, $mapping;
  
      return if !$self->_channel_exists($channel);
      my @results;
  
      for my $nick ( keys %{ $self->{STATE}->{Chans}->{ $uchan }->{Nicks} } ) {
          if (defined ( $self->{STATE}->{Nicks}->{ $nick }->{Auth} )
              && $self->{STATE}->{Nicks}->{ $nick }->{Auth} eq $auth) {
              push @results, $self->{STATE}->{Nicks}->{ $nick }->{Nick};
          }
      }
  
      return @results;
  }
  
  sub ban_mask {
      my ($self, $channel, $mask) = @_;
      $mask = normalize_mask($mask);
      my $mapping = $self->isupport('CASEMAPPING');
      my @result;
  
      return if !$self->_channel_exists($channel);
  
      # Convert the mask from IRC to regex.
      $mask = u_irc ( $mask, $mapping );
      $mask = quotemeta $mask;
      $mask =~ s/\\\*/[\x01-\xFF]{0,}/g;
      $mask =~ s/\\\?/[\x01-\xFF]{1,1}/g;
  
      for my $nick ( $self->channel_list($channel) ) {
          my $long_form = $self->nick_long_form($nick);
  
          if ( uc_irc ( $long_form ) =~ /^$mask$/ ) {
              push @result, $nick;
              next;
          }
  
          if ( my $auth = $self->is_nick_authed( $nick ) ) {
              $long_form =~ s/\@(.+)$/\@$auth.users.quakenet.org/;
              push @result, $nick if uc_irc ( $long_form ) =~ /^$mask$/;
          }
      }
  
      return @result;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::Qnet::State - A fully event-driven IRC client module
  for Quakenet with nickname and channel tracking
  
  =head1 SYNOPSIS
  
   # A simple Rot13 'encryption' bot
  
   use strict;
   use warnings;
   use POE qw(Component::IRC::Qnet::State);
  
   my $nickname = 'Flibble' . $$;
   my $ircname = 'Flibble the Sailor Bot';
   my $ircserver = 'irc.blahblahblah.irc';
   my $port = 6667;
   my $qauth = 'FlibbleBOT';
   my $qpass = 'fubar';
  
   my @channels = ( '#Blah', '#Foo', '#Bar' );
  
   # We create a new PoCo-IRC object and component.
   my $irc = POE::Component::IRC::Qnet::State->spawn(
       nick => $nickname,
       server => $ircserver,
       port => $port,
       ircname => $ircname,
   ) or die "Oh noooo! $!";
  
   POE::Session->create(
       package_states => [
           main => [ qw(_default _start irc_001 irc_public) ],
       ],
       heap => { irc => $irc },
   );
  
   $poe_kernel->run();
  
   sub _start {
       my ($kernel, $heap) = @_[KERNEL, HEAP];
  
       # We get the session ID of the component from the object
       # and register and connect to the specified server.
       my $irc_session = $heap->{irc}->session_id();
       $kernel->post( $irc_session => register => 'all' );
       $kernel->post( $irc_session => connect => { } );
  
       return;
   }
  
   sub irc_001 {
       my ($kernel, $sender) = @_[KERNEL, SENDER];
  
       # Get the component's object at any time by accessing the heap of
       # the SENDER
       my $poco_object = $sender->get_heap();
       print "Connected to ", $poco_object->server_name(), "\n";
  
       # Lets authenticate with Quakenet's Q bot
       $kernel->post( $sender => qbot_auth => $qauth => $qpass );
  
       # In any irc_* events SENDER will be the PoCo-IRC session
       $kernel->post( $sender => join => $_ ) for @channels;
  
       return;
   }
  
   sub irc_public {
       my ($kernel, $sender, $who, $where, $what) = @_[KERNEL, SENDER, ARG0, .. ARG2];
       my $nick = ( split /!/, $who )[0];
       my $channel = $where->[0];
       my $poco_object = $sender->get_heap();
  
       if ( my ($rot13) = $what =~ /^rot13 (.+)/ ) {
           # Only operators can issue a rot13 command to us.
           return if !$poco_object->is_channel_operator( $channel, $nick );
  
           $rot13 =~ tr[a-zA-Z][n-za-mN-ZA-M];
           $kernel->post( $sender => privmsg => $channel => "$nick: $rot13" );
       }
  
       return;
   }
  
   # We registered for all events, this will produce some debug info.
   sub _default {
       my ($event, $args) = @_[ARG0 .. $#_];
       my @output = ( "$event: " );
  
       for my $arg ( @$args ) {
           if (ref $arg eq 'ARRAY') {
               push( @output, '[' . join(', ', @$arg ) . ']' );
           }
           else {
               push ( @output, "'$arg'" );
           }
       }
  
       print join ' ', @output, "\n";
       return 0;
   }
  
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::Qnet::State is an extension to
  L<POE::Component::IRC::Qnet|POE::Component::IRC::Qnet> specifically for use on
  Quakenet L<http://www.quakenet.org/>, which includes the nickname and channel
  tracking from L<POE::Component::IRC::State|POE::Component::IRC::State>. See
  the documentation for L<POE::Component::IRC::Qnet|POE::Component::IRC::Qnet>
  and L<POE::Component::IRC::State|POE::Component::IRC::State> for general usage.
  This document covers the extensions.
  
  =head1 METHODS
  
  =over
  
  =item C<ban_mask>
  
  Expects a channel and a ban mask, as passed to MODE +b-b. Returns a list of
  nicks on that channel that match the specified ban mask or an empty list if the
  channel doesn't exist in the state or there are no matches. Follows Quakenet
  ircd rules for matching authed users.
  
  =item C<is_nick_authed>
  
  Expects a nickname as parameter. Will return that users authname (account) if
  that nick is in the state  and have authed with Q. Returns a false value if
  the user is not authed or the nick doesn't exist in the state.
  
  =item C<find_auth_nicks>
  
  Expects an authname and a channel name. Will return a list of nicks on the
  given channel that have authed with the given authname.
  
  =item C<nick_info>
  
  Expects a nickname. Returns a hashref containing similar information to that
  returned by WHOIS. Returns a false value if the nickname doesn't exist in the
  state. The hashref contains the following keys: B<'Nick'>, B<'User'>,
  B<'Host'>, B<'Server'>, B<'Auth'>, if authed, and, if applicable, B<'IRCop'>.
  
  =back
  
  =head1 INPUT
  
  These additional events are accepted:
  
  =over
  
  =item C<resync_chan>
  
  Accepts a list of channels, will resynchronise each of those channels as if
  they have been joined for the first time. Expect to see an
  L<C<irc_chan_sync>|POE::Component::IRC::State/irc_chan_sync> event for each
  channel given.
  
  =item C<resync_nick>
  
  Accepts a nickname and a list of channels. Will resynchronise the given nickname
  and issue an L<C<irc_nick_sync>|POE::Component::IRC::State/irc_nick_sync>
  event for each of the given channels (assuming that nick is on each of those channels).
  
  =back
  
  =head1 OUTPUT EVENTS
  
  This module returns one additional event over and above the usual events:
  
  =over
  
  =item C<irc_nick_authed>
  
  Sent when the component detects that a user has authed with Q. Due to the
  mechanics of Quakenet you will usually only receive this if an unauthed user
  joins a channel, then at some later point auths with Q. The component 'detects'
  the auth by seeing if Q decides to +v or +o the user. Klunky? Indeed. But
  it is the only way to do it, unfortunately.
  
  =back
  
  The following two C<irc_*> events are the same as their
  L<POE::Component::IRC::State|POE::Component::IRC::State> counterparts, with
  the additional parameters:
  
  =over
  
  =item C<irc_quit>
  
  C<ARG3> contains the quitting clients auth name if applicable.
  
  =item C<irc_part>
  
  C<ARG3> contains the parting clients auth name if applicable.
  
  =item C<irc_kick>
  
  C<ARG5> contains the kick victim's auth name if applicable.
  
  =back
  
  =head1 CAVEATS
  
  Like L<POE::Component::IRC::State|POE::Component::IRC::State> this component
  registers itself for a number of events. The main difference with
  L<POE::Component::IRC::State|POE::Component::IRC::State> is that it uses an
  extended form of 'WHO' supported by the Quakenet ircd, asuka. This WHO returns
  a different numeric reply than the original WHO, namely, C<irc_354>. Also, due
  to the way Quakenet is configured all users will appear to be on the server
  '*.quakenet.org'.
  
  =head1 BUGS
  
  A few have turned up in the past and they are sure to again. Please use
  L<http://rt.cpan.org/> to report any. Alternatively, email the current
  maintainer.
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams <chris@bingosnet.co.uk>
  
  Based on the original POE::Component::IRC by:
  
  Dennis Taylor
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  L<POE::Component::IRC::State|POE::Component::IRC::State>
  
  L<POE::Component::IRC::Qnet|POE::Component::IRC::Qnet>
  
  L<http://www.quakenet.org/>
  
  =cut
POE_COMPONENT_IRC_QNET_STATE

$fatpacked{"POE/Component/IRC/State.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_IRC_STATE';
  package POE::Component::IRC::State;
  BEGIN {
    $POE::Component::IRC::State::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Component::IRC::State::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use IRC::Utils qw(uc_irc parse_mode_line normalize_mask);
  use POE;
  use POE::Component::IRC::Plugin qw(PCI_EAT_NONE);
  use base qw(POE::Component::IRC);
  
  # Event handlers for tracking the STATE. $self->{STATE} is used as our
  # namespace. uc_irc() is used to create unique keys.
  
  # RPL_WELCOME
  # Make sure we have a clean STATE when we first join the network and if we
  # inadvertently get disconnected.
  sub S_001 {
      my $self = shift;
      $self->SUPER::S_001(@_);
      shift @_;
  
      delete $self->{STATE};
      delete $self->{NETSPLIT};
      $self->{STATE}{usermode} = '';
      $self->yield(mode => $self->nick_name());
      return PCI_EAT_NONE;
  }
  
  sub S_disconnected {
      my $self = shift;
      $self->SUPER::S_disconnected(@_);
      shift @_;
  
      my $nickinfo = $self->nick_info($self->nick_name());
      $nickinfo = {} if !defined $nickinfo;
      my $channels = $self->channels();
      push @{ $_[-1] }, $nickinfo, $channels;
      return PCI_EAT_NONE;
  }
  
  sub S_error {
      my $self = shift;
      $self->SUPER::S_error(@_);
      shift @_;
  
      my $nickinfo = $self->nick_info($self->nick_name());
      $nickinfo = {} if !defined $nickinfo;
      my $channels = $self->channels();
      push @{ $_[-1] }, $nickinfo, $channels;
      return PCI_EAT_NONE;
  }
  
  sub S_socketerr {
      my ($self, undef) = splice @_, 0, 2;
      my $nickinfo = $self->nick_info($self->nick_name());
      $nickinfo = {} if !defined $nickinfo;
      my $channels = $self->channels();
      push @{ $_[-1] }, $nickinfo, $channels;
      return PCI_EAT_NONE;
  }
  
  sub S_join {
      my ($self, undef) = splice @_, 0, 2;
      my ($nick, $user, $host) = split /[!@]/, ${ $_[0] };
      my $map   = $self->isupport('CASEMAPPING');
      my $chan  = ${ $_[1] };
      my $uchan = uc_irc($chan, $map);
      my $unick = uc_irc($nick, $map);
  
      if ($unick eq uc_irc($self->nick_name(), $map)) {
          delete $self->{STATE}{Chans}{ $uchan };
          $self->{CHANNEL_SYNCH}{ $uchan } = {
              MODE  => 0,
              WHO   => 0,
              BAN   => 0,
              _time => time(),
          };
          $self->{STATE}{Chans}{ $uchan } = {
              Name => $chan,
              Mode => ''
          };
  
          # fake a WHO sync if we're only interested in people's user@host
          # and the server provides those in the NAMES reply
          if (exists $self->{whojoiners} && !$self->{whojoiners}
              && $self->isupport('UHNAMES')) {
              $self->_channel_sync($chan, 'WHO');
          }
          else {
              $self->yield(who => $chan);
          }
          $self->yield(mode => $chan);
          $self->yield(mode => $chan => 'b');
      }
      else {
        SWITCH: {
          my $netsplit = "$unick!$user\@$host";
          if ( exists $self->{NETSPLIT}{Users}{ $netsplit } ) {
              # restore state from NETSPLIT if it hasn't expired.
              my $nuser = delete $self->{NETSPLIT}{Users}{ $netsplit };
              if ( ( time - $nuser->{stamp} ) < ( 60 * 60 ) ) {
                $self->{STATE}{Nicks}{ $unick } = $nuser->{meta};
                $self->send_event_next(irc_nick_sync => $nick, $chan);
                last SWITCH;
              }
          }
          if ( (!exists $self->{whojoiners} || $self->{whojoiners})
              && !exists $self->{STATE}{Nicks}{ $unick }{Real}) {
                  $self->yield(who => $nick);
                  push @{ $self->{NICK_SYNCH}{ $unick } }, $chan;
          }
          else {
              # Fake 'irc_nick_sync'
              $self->send_event_next(irc_nick_sync => $nick, $chan);
          }
        }
      }
  
      $self->{STATE}{Nicks}{ $unick }{Nick} = $nick;
      $self->{STATE}{Nicks}{ $unick }{User} = $user;
      $self->{STATE}{Nicks}{ $unick }{Host} = $host;
      $self->{STATE}{Nicks}{ $unick }{CHANS}{ $uchan } = '';
      $self->{STATE}{Chans}{ $uchan }{Nicks}{ $unick } = '';
  
      return PCI_EAT_NONE;
  }
  
  sub S_chan_sync {
      my ($self, undef) = splice @_, 0, 2;
      my $chan = ${ $_[0] };
  
      if ($self->{awaypoll}) {
          $poe_kernel->state(_away_sync => $self);
          $poe_kernel->delay_add(_away_sync => $self->{awaypoll} => $chan);
      }
  
      return PCI_EAT_NONE;
  }
  
  sub S_part {
      my ($self, undef) = splice @_, 0, 2;
      my $map   = $self->isupport('CASEMAPPING');
      my $nick  = uc_irc((split /!/, ${ $_[0] } )[0], $map);
      my $uchan = uc_irc(${ $_[1] }, $map);
  
      if ($nick eq uc_irc($self->nick_name(), $map)) {
          delete $self->{STATE}{Nicks}{ $nick }{CHANS}{ $uchan };
          delete $self->{STATE}{Chans}{ $uchan }{Nicks}{ $nick };
  
          for my $member ( keys %{ $self->{STATE}{Chans}{ $uchan }{Nicks} } ) {
              delete $self->{STATE}{Nicks}{ $member }{CHANS}{ $uchan };
              if ( keys %{ $self->{STATE}{Nicks}{ $member }{CHANS} } <= 0 ) {
                  delete $self->{STATE}{Nicks}{ $member };
              }
          }
  
          delete $self->{STATE}{Chans}{ $uchan };
      }
      else {
          delete $self->{STATE}{Nicks}{ $nick }{CHANS}{ $uchan };
          delete $self->{STATE}{Chans}{ $uchan }{Nicks}{ $nick };
          if ( !keys %{ $self->{STATE}{Nicks}{ $nick }{CHANS} } ) {
              delete $self->{STATE}{Nicks}{ $nick };
          }
      }
  
      return PCI_EAT_NONE;
  }
  
  sub S_quit {
      my ($self, undef) = splice @_, 0, 2;
      my $map   = $self->isupport('CASEMAPPING');
      my $nick  = (split /!/, ${ $_[0] })[0];
      my $msg   = ${ $_[1] };
      my $unick = uc_irc($nick, $map);
      my $netsplit = 0;
  
      push @{ $_[-1] }, [ $self->nick_channels( $nick ) ];
  
      # Check if it is a netsplit
      $netsplit = 1 if _is_netsplit( $msg );
  
      if ($unick ne uc_irc($self->nick_name(), $map)) {
          for my $uchan ( keys %{ $self->{STATE}{Nicks}{ $unick }{CHANS} } ) {
              delete $self->{STATE}{Chans}{ $uchan }{Nicks}{ $unick };
              # No don't stash the channel state.
              #$self->{NETSPLIT}{Chans}{ $uchan }{NICKS}{ $unick } = $chanstate
              #  if $netsplit;
          }
  
          my $nickstate = delete $self->{STATE}{Nicks}{ $unick };
          if ( $netsplit ) {
            delete $nickstate->{CHANS};
            $self->{NETSPLIT}{Users}{ "$unick!" . join '@', @{$nickstate}{qw(User Host)} } =
               { meta => $nickstate, stamp => time };
          }
      }
  
      return PCI_EAT_NONE;
  }
  
  sub _is_netsplit {
    my $msg = shift || return;
    return 1 if $msg =~ /^\s*\S+\.[a-z]{2,} \S+\.[a-z]{2,}$/i;
    return 0;
  }
  
  sub S_kick {
      my ($self, undef) = splice @_, 0, 2;
      my $chan  = ${ $_[1] };
      my $nick  = ${ $_[2] };
      my $map   = $self->isupport('CASEMAPPING');
      my $unick = uc_irc($nick, $map);
      my $uchan = uc_irc($chan, $map);
  
      push @{ $_[-1] }, $self->nick_long_form( $nick );
  
      if ( $unick eq uc_irc($self->nick_name(), $map)) {
          delete $self->{STATE}{Nicks}{ $unick }{CHANS}{ $uchan };
          delete $self->{STATE}{Chans}{ $uchan }{Nicks}{ $unick };
  
          for my $member ( keys %{ $self->{STATE}{Chans}{ $uchan }{Nicks} } ) {
              delete $self->{STATE}{Nicks}{ $member }{CHANS}{ $uchan };
              if ( keys %{ $self->{STATE}{Nicks}{ $member }{CHANS} } <= 0 ) {
                  delete $self->{STATE}{Nicks}{ $member };
              }
          }
  
          delete $self->{STATE}{Chans}{ $uchan };
      }
      else {
          delete $self->{STATE}{Nicks}{ $unick }{CHANS}{ $uchan };
          delete $self->{STATE}{Chans}{ $uchan }{Nicks}{ $unick };
          if ( keys %{ $self->{STATE}{Nicks}{ $unick }{CHANS} } <= 0 ) {
              delete $self->{STATE}{Nicks}{ $unick };
          }
      }
  
      return PCI_EAT_NONE;
  }
  
  sub S_nick {
      my $self = shift;
      $self->SUPER::S_nick(@_);
      shift @_;
  
      my $nick  = (split /!/, ${ $_[0] })[0];
      my $new   = ${ $_[1] };
      my $map   = $self->isupport('CASEMAPPING');
      my $unick = uc_irc($nick, $map);
      my $unew  = uc_irc($new, $map);
  
      push @{ $_[-1] }, [ $self->nick_channels( $nick ) ];
  
      if ($unick eq $unew) {
          # Case Change
          $self->{STATE}{Nicks}{ $unick }{Nick} = $new;
      }
      else {
          my $user = delete $self->{STATE}{Nicks}{ $unick };
          $user->{Nick} = $new;
  
          for my $channel ( keys %{ $user->{CHANS} } ) {
             $self->{STATE}{Chans}{ $channel }{Nicks}{ $unew } = $user->{CHANS}{ $channel };
             delete $self->{STATE}{Chans}{ $channel }{Nicks}{ $unick };
          }
  
          $self->{STATE}{Nicks}{ $unew } = $user;
      }
  
      return PCI_EAT_NONE;
  }
  
  sub S_chan_mode {
      my ($self, undef) = splice @_, 0, 2;
      pop @_;
      my $who  = ${ $_[0] };
      my $chan = ${ $_[1] };
      my $mode = ${ $_[2] };
      my $arg  = defined $_[3] ? ${ $_[3] } : '';
      my $map  = $self->isupport('CASEMAPPING');
      my $me   = uc_irc($self->nick_name(), $map);
  
      return PCI_EAT_NONE if $mode !~ /\+[qoah]/ || $me ne uc_irc($arg, $map);
  
      my $excepts = $self->isupport('EXCEPTS');
      my $invex = $self->isupport('INVEX');
      $self->yield(mode => $chan, $excepts ) if $excepts;
      $self->yield(mode => $chan, $invex ) if $invex;
  
      return PCI_EAT_NONE;
  }
  
  # RPL_UMODEIS
  sub S_221 {
      my ($self, undef) = splice @_, 0, 2;
      my $mode = ${ $_[1] };
      $mode =~ s/^\+//;
      $self->{STATE}->{usermode} = $mode;
      return PCI_EAT_NONE;
  }
  
  # RPL_CHANNEL_URL
  sub S_328 {
      my ($self, undef) = splice @_, 0, 2;
      my ($chan, $url) = @{ ${ $_[2] } };
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
  
      return PCI_EAT_NONE if !$self->_channel_exists($chan);
      $self->{STATE}{Chans}{ $uchan }{Url} = $url;
      return PCI_EAT_NONE;
  }
  
  # RPL_UNAWAY
  sub S_305 {
      my ($self, undef) = splice @_, 0, 2;
      $self->{STATE}->{away} = 0;
      return PCI_EAT_NONE;
  }
  
  # RPL_NOWAWAY
  sub S_306 {
      my ($self, undef) = splice @_, 0, 2;
      $self->{STATE}->{away} = 1;
      return PCI_EAT_NONE;
  }
  
  # this code needs refactoring
  ## no critic (Subroutines::ProhibitExcessComplexity ControlStructures::ProhibitCascadingIfElse)
  sub S_mode {
      my ($self, undef) = splice @_, 0, 2;
      my $map   = $self->isupport('CASEMAPPING');
      my $who   = ${ $_[0] };
      my $chan  = ${ $_[1] };
      my $uchan = uc_irc($chan, $map);
      pop @_;
      my @modes = map { ${ $_ } } @_[2 .. $#_];
  
      # CHANMODES is [$list_mode, $always_arg, $arg_when_set, $no_arg]
      # A $list_mode always has an argument
      my $prefix = $self->isupport('PREFIX') || { o => '@', v => '+' };
      my $statmodes = join '', keys %{ $prefix };
      my $chanmodes = $self->isupport('CHANMODES') || [ qw(beI k l imnpstaqr) ];
      my $alwaysarg = join '', $statmodes,  @{ $chanmodes }[0 .. 1];
  
      # Do nothing if it is UMODE
      if ($uchan ne uc_irc($self->nick_name(), $map)) {
          my $parsed_mode = parse_mode_line( $prefix, $chanmodes, @modes );
          for my $mode (@{ $parsed_mode->{modes} }) {
              my $orig_arg;
              if (length $chanmodes->[2] && length $alwaysarg && $mode =~ /^(.[$alwaysarg]|\+[$chanmodes->[2]])/) {
                  $orig_arg = shift @{ $parsed_mode->{args} };
              }
  
              my $flag;
              my $arg = $orig_arg;
  
              if (length $statmodes && (($flag) = $mode =~ /\+([$statmodes])/)) {
                  $arg = uc_irc($arg, $map);
                  if (!$self->{STATE}{Nicks}{ $arg }{CHANS}{ $uchan } || $self->{STATE}{Nicks}{ $arg }{CHANS}{ $uchan } !~ /$flag/) {
                      $self->{STATE}{Nicks}{ $arg }{CHANS}{ $uchan } .= $flag;
                      $self->{STATE}{Chans}{ $uchan }{Nicks}{ $arg } = $self->{STATE}{Nicks}{ $arg }{CHANS}{ $uchan };
                  }
              }
              elsif (length $statmodes && (($flag) = $mode =~ /-([$statmodes])/)) {
                  $arg = uc_irc($arg, $map);
                  if ($self->{STATE}{Nicks}{ $arg }{CHANS}{ $uchan } =~ /$flag/) {
                      $self->{STATE}{Nicks}{ $arg }{CHANS}{ $uchan } =~ s/$flag//;
                      $self->{STATE}{Chans}{ $uchan }{Nicks}{ $arg } = $self->{STATE}{Nicks}{ $arg }{CHANS}{ $uchan };
                  }
              }
              elsif (length $chanmodes->[0] && (($flag) = $mode =~ /\+([$chanmodes->[0]])/)) {
                  $self->{STATE}{Chans}{ $uchan }{Lists}{ $flag }{ $arg } = {
                      SetBy => $who,
                      SetAt => time(),
                  };
              }
              elsif (length $chanmodes->[0] && (($flag) = $mode =~ /-([$chanmodes->[0]])/)) {
                  delete $self->{STATE}{Chans}{ $uchan }{Lists}{ $flag }{ $arg };
              }
  
              # All unhandled modes with arguments
              elsif (length $chanmodes->[3] && (($flag) = $mode =~ /\+([^$chanmodes->[3]])/)) {
                  $self->{STATE}{Chans}{ $uchan }{Mode} .= $flag if $self->{STATE}{Chans}{ $uchan }{Mode} !~ /$flag/;
                  $self->{STATE}{Chans}{ $uchan }{ModeArgs}{ $flag } = $arg;
              }
              elsif (length $chanmodes->[3] && (($flag) = $mode =~ /-([^$chanmodes->[3]])/)) {
                  $self->{STATE}{Chans}{ $uchan }{Mode} =~ s/$flag//;
                  delete $self->{STATE}{Chans}{ $uchan }{ModeArgs}{ $flag };
              }
  
              # Anything else doesn't have arguments so just adjust {Mode} as necessary.
              elsif (($flag) = $mode =~ /^\+(.)/ ) {
                  $self->{STATE}{Chans}{ $uchan }{Mode} .= $flag if $self->{STATE}{Chans}{ $uchan }{Mode} !~ /$flag/;
              }
              elsif (($flag) = $mode =~ /^-(.)/ ) {
                  $self->{STATE}{Chans}{ $uchan }{Mode} =~ s/$flag//;
              }
              $self->send_event_next(irc_chan_mode => $who, $chan, $mode, (defined $orig_arg ? $orig_arg : ()));
          }
  
          # Lets make the channel mode nice
          if ( $self->{STATE}{Chans}{ $uchan }{Mode} ) {
              $self->{STATE}{Chans}{ $uchan }{Mode} = join('', sort {uc $a cmp uc $b} ( split( //, $self->{STATE}{Chans}{ $uchan }{Mode} ) ) );
          }
      }
      else {
          my $parsed_mode = parse_mode_line( @modes );
          for my $mode (@{ $parsed_mode->{modes} }) {
              my $flag;
              if ( ($flag) = $mode =~ /^\+(.)/ ) {
                  $self->{STATE}{usermode} .= $flag if $self->{STATE}{usermode} !~ /$flag/;
              }
              elsif ( ($flag) = $mode =~ /^-(.)/ ) {
                  $self->{STATE}{usermode} =~ s/$flag//;
              }
              $self->send_event_next(irc_user_mode => $who, $chan, $mode );
          }
      }
  
      return PCI_EAT_NONE;
  }
  
  sub S_topic {
      my ($self, undef) = splice @_, 0, 2;
      my $who   = ${ $_[0] };
      my $chan  = ${ $_[1] };
      my $topic = ${ $_[2] };
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      push @{ $_[-1] }, $self->{STATE}{Chans}{$uchan}{Topic};
  
      $self->{STATE}{Chans}{ $uchan }{Topic} = {
          Value => $topic,
          SetBy => $who,
          SetAt => time(),
      };
  
      return PCI_EAT_NONE;
  }
  
  # RPL_NAMES
  sub S_353 {
      my ($self, undef) = splice @_, 0, 2;
      my @data   = @{ ${ $_[2] } };
      shift @data if $data[0] =~ /^[@=*]$/;
      my $chan   = shift @data;
      my @nicks  = split /\s+/, shift @data;
      my $map    = $self->isupport('CASEMAPPING');
      my $uchan  = uc_irc($chan, $map);
      my $prefix = $self->isupport('PREFIX') || { o => '@', v => '+' };
      my $search = join '|', map { quotemeta } values %$prefix;
      $search    = qr/(?:$search)/;
  
      for my $nick (@nicks) {
          my $status;
          if ( ($status) = $nick =~ /^($search+)/ ) {
             $nick =~ s/^($search+)//;
          }
  
          my ($user, $host);
          if ($self->isupport('UHNAMES')) {
              ($nick, $user, $host) = split /[!@]/, $nick;
          }
  
          my $unick    = uc_irc($nick, $map);
          $status      = '' if !defined $status;
          my $whatever = '';
          my $existing = $self->{STATE}{Nicks}{$unick}{CHANS}{$uchan} || '';
  
          for my $mode (keys %$prefix) {
              if ($status =~ /\Q$prefix->{$mode}/ && $existing !~ /\Q$prefix->{$mode}/) {
                  $whatever .= $mode;
              }
          }
  
          $existing .= $whatever if !length $existing || $existing !~ /$whatever/;
          $self->{STATE}{Nicks}{$unick}{CHANS}{$uchan} = $existing;
          $self->{STATE}{Chans}{$uchan}{Nicks}{$unick} = $existing;
          $self->{STATE}{Nicks}{$unick}{Nick} = $nick;
          if ($self->isupport('UHNAMES')) {
              $self->{STATE}{Nicks}{$unick}{User} = $user;
              $self->{STATE}{Nicks}{$unick}{Host} = $host;
          }
      }
      return PCI_EAT_NONE;
  }
  
  # RPL_WHOREPLY
  sub S_352 {
      my ($self, undef) = splice @_, 0, 2;
      my ($chan, $user, $host, $server, $nick, $status, $rest) = @{ ${ $_[2] } };
      my ($hops, $real) = split /\x20/, $rest, 2;
      my $map   = $self->isupport('CASEMAPPING');
      my $unick = uc_irc($nick, $map);
      my $uchan = uc_irc($chan, $map);
  
      $self->{STATE}{Nicks}{ $unick }{Nick} = $nick;
      $self->{STATE}{Nicks}{ $unick }{User} = $user;
      $self->{STATE}{Nicks}{ $unick }{Host} = $host;
  
      if ( !exists $self->{whojoiners} || $self->{whojoiners} ) {
          $self->{STATE}{Nicks}{ $unick }{Hops} = $hops;
          $self->{STATE}{Nicks}{ $unick }{Real} = $real;
          $self->{STATE}{Nicks}{ $unick }{Server} = $server;
          $self->{STATE}{Nicks}{ $unick }{IRCop} = 1 if $status =~ /\*/;
      }
  
      if ( exists $self->{STATE}{Chans}{ $uchan } ) {
          my $whatever = '';
          my $existing = $self->{STATE}{Nicks}{ $unick }{CHANS}{ $uchan } || '';
          my $prefix = $self->isupport('PREFIX') || { o => '@', v => '+' };
  
          for my $mode ( keys %{ $prefix } ) {
              if ($status =~ /\Q$prefix->{$mode}/ && $existing !~ /\Q$prefix->{$mode}/ ) {
                  $whatever .= $mode;
              }
          }
  
          $existing .= $whatever if !$existing || $existing !~ /$whatever/;
          $self->{STATE}{Nicks}{ $unick }{CHANS}{ $uchan } = $existing;
          $self->{STATE}{Chans}{ $uchan }{Nicks}{ $unick } = $existing;
          $self->{STATE}{Chans}{ $uchan }{Name} = $chan;
  
          if ($self->{STATE}{Chans}{ $uchan }{AWAY_SYNCH} && $unick ne uc_irc($self->nick_name(), $map)) {
              if ( $status =~ /G/ && !$self->{STATE}{Nicks}{ $unick }{Away} ) {
                  $self->send_event_next(irc_user_away => $nick, [ $self->nick_channels( $nick ) ] );
              }
              elsif ($status =~ /H/ && $self->{STATE}{Nicks}{ $unick }{Away} ) {
                  $self->send_event_next(irc_user_back => $nick, [ $self->nick_channels( $nick ) ] );
              }
          }
  
          if ($self->{awaypoll}) {
              $self->{STATE}{Nicks}{ $unick }{Away} = $status =~ /G/ ? 1 : 0;
          }
      }
  
      return PCI_EAT_NONE;
  }
  
  # RPL_ENDOFWHO
  sub S_315 {
      my ($self, undef) = splice @_, 0, 2;
      my $what  = ${ $_[2] }->[0];
      my $map   = $self->isupport('CASEMAPPING');
      my $uwhat = uc_irc($what, $map);
  
      if ( exists $self->{STATE}{Chans}{ $uwhat } ) {
          my $chan = $what; my $uchan = $uwhat;
          if ( $self->_channel_sync($chan, 'WHO') ) {
              my $rec = delete $self->{CHANNEL_SYNCH}{ $uchan };
              $self->send_event_next(irc_chan_sync => $chan, time() - $rec->{_time} );
          }
          elsif ( $self->{STATE}{Chans}{ $uchan }{AWAY_SYNCH} ) {
              $self->{STATE}{Chans}{ $uchan }{AWAY_SYNCH} = 0;
              $poe_kernel->delay_add(_away_sync => $self->{awaypoll} => $chan );
              $self->send_event_next(irc_away_sync_end => $chan );
          }
      }
      else {
          my $nick = $what; my $unick = $uwhat;
          my $chan = shift @{ $self->{NICK_SYNCH}{ $unick } };
          delete $self->{NICK_SYNCH}{ $unick } if !@{ $self->{NICK_SYNCH}{ $unick } };
          $self->send_event_next(irc_nick_sync => $nick, $chan );
      }
  
      return PCI_EAT_NONE;
  }
  
  # RPL_CREATIONTIME
  sub S_329 {
      my ($self, undef) = splice @_, 0, 2;
      my $map   = $self->isupport('CASEMAPPING');
      my $chan  = ${ $_[2] }->[0];
      my $time  = ${ $_[2] }->[1];
      my $uchan = uc_irc($chan, $map);
  
      $self->{STATE}->{Chans}{ $uchan }{CreationTime} = $time;
      return PCI_EAT_NONE;
  }
  
  # RPL_BANLIST
  sub S_367 {
      my ($self, undef) = splice @_, 0, 2;
      my @args  = @{ ${ $_[2] } };
      my $chan  = shift @args;
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      my ($mask, $who, $when) = @args;
  
      $self->{STATE}{Chans}{ $uchan }{Lists}{b}{ $mask } = {
          SetBy => $who,
          SetAt => $when,
      };
      return PCI_EAT_NONE;
  }
  
  # RPL_ENDOFBANLIST
  sub S_368 {
      my ($self, undef) = splice @_, 0, 2;
      my @args  = @{ ${ $_[2] } };
      my $chan  = shift @args;
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
  
      if ($self->_channel_sync($chan, 'BAN')) {
          my $rec = delete $self->{CHANNEL_SYNCH}{ $uchan };
          $self->send_event_next(irc_chan_sync => $chan, time() - $rec->{_time} );
      }
  
      return PCI_EAT_NONE;
  }
  
  # RPL_INVITELIST
  sub S_346 {
      my ($self, undef) = splice @_, 0, 2;
      my ($chan, $mask, $who, $when) = @{ ${ $_[2] } };
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      my $invex = $self->isupport('INVEX');
  
      $self->{STATE}{Chans}{ $uchan }{Lists}{ $invex }{ $mask } = {
          SetBy => $who,
          SetAt => $when
      };
  
      return PCI_EAT_NONE;
  }
  
  # RPL_ENDOFINVITELIST
  sub S_347 {
      my ($self, undef) = splice @_, 0, 2;
      my ($chan) = @{ ${ $_[2] } };
      my $map    = $self->isupport('CASEMAPPING');
      my $uchan  = uc_irc($chan, $map);
  
      $self->send_event_next(irc_chan_sync_invex => $chan);
      return PCI_EAT_NONE;
  }
  
  # RPL_EXCEPTLIST
  sub S_348 {
      my ($self, undef) = splice @_, 0, 2;
      my ($chan, $mask, $who, $when) = @{ ${ $_[2] } };
      my $map     = $self->isupport('CASEMAPPING');
      my $uchan   = uc_irc($chan, $map);
      my $excepts = $self->isupport('EXCEPTS');
  
      $self->{STATE}{Chans}{ $uchan }{Lists}{ $excepts }{ $mask } = {
          SetBy => $who,
          SetAt => $when,
      };
      return PCI_EAT_NONE;
  }
  
  # RPL_ENDOFEXCEPTLIST
  sub S_349 {
      my ($self, undef) = splice @_, 0, 2;
      my ($chan) = @{ ${ $_[2] } };
      my $map    = $self->isupport('CASEMAPPING');
      my $uchan  = uc_irc($chan, $map);
  
      $self->send_event_next(irc_chan_sync_excepts => $chan);
      return PCI_EAT_NONE;
  }
  
  # RPL_CHANNELMODEIS
  sub S_324 {
      my ($self, undef) = splice @_, 0, 2;
      my @args  = @{ ${ $_[2] } };
      my $chan  = shift @args;
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      my $modes = $self->isupport('CHANMODES') || [ qw(beI k l imnpstaqr) ];
      my $prefix = $self->isupport('PREFIX') || { o => '@', v => '+' };
  
      my $parsed_mode = parse_mode_line($prefix, $modes, @args);
      for my $mode (@{ $parsed_mode->{modes} }) {
          $mode =~ s/\+//;
          my $arg = '';
          if ($mode =~ /[^$modes->[3]]/) {
              # doesn't match a mode with no args
              $arg = shift @{ $parsed_mode->{args} };
          }
  
          if ( $self->{STATE}{Chans}{ $uchan }{Mode} ) {
              $self->{STATE}{Chans}{ $uchan }{Mode} .= $mode if $self->{STATE}{Chans}{ $uchan }{Mode} !~ /$mode/;
          }
          else {
              $self->{STATE}{Chans}{ $uchan }{Mode} = $mode;
          }
  
          $self->{STATE}{Chans}{ $uchan }{ModeArgs}{ $mode } = $arg if defined ( $arg );
      }
  
      if ( $self->{STATE}{Chans}{ $uchan }{Mode} ) {
          $self->{STATE}{Chans}{ $uchan }{Mode} = join('', sort {uc $a cmp uc $b} split //, $self->{STATE}{Chans}{ $uchan }{Mode} );
      }
  
      if ( $self->_channel_sync($chan, 'MODE') ) {
          my $rec = delete $self->{CHANNEL_SYNCH}{ $uchan };
          $self->send_event_next(irc_chan_sync => $chan, time() - $rec->{_time} );
      }
  
      return PCI_EAT_NONE;
  }
  
  # RPL_TOPIC
  sub S_332 {
      my ($self, undef) = splice @_, 0, 2;
      my $chan  = ${ $_[2] }->[0];
      my $topic = ${ $_[2] }->[1];
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
  
      $self->{STATE}{Chans}{ $uchan }{Topic}{Value} = $topic;
      return PCI_EAT_NONE;
  }
  
  # RPL_TOPICWHOTIME
  sub S_333 {
      my ($self, undef) = splice @_, 0, 2;
      my ($chan, $who, $when) = @{ ${ $_[2] } };
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
  
      $self->{STATE}{Chans}{ $uchan }{Topic}{SetBy} = $who;
      $self->{STATE}{Chans}{ $uchan }{Topic}{SetAt} = $when;
  
      return PCI_EAT_NONE;
  }
  
  # Methods for STATE query
  # Internal methods begin with '_'
  #
  
  sub umode {
      my ($self) = @_;
      return $self->{STATE}{usermode};
  }
  
  sub is_user_mode_set {
      my ($self, $mode) = @_;
  
      if (!defined $mode) {
          warn 'User mode is undefined';
          return;
      }
  
      $mode = (split //, $mode)[0] || return;
      $mode =~ s/[^A-Za-z]//g;
      return if !$mode;
  
      return 1 if $self->{STATE}{usermode} =~ /$mode/;
      return;
  }
  
  sub _away_sync {
      my ($self, $chan) = @_[OBJECT, ARG0];
      my $map = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
  
      $self->{STATE}{Chans}{ $uchan }{AWAY_SYNCH} = 1;
      $self->yield(who => $chan);
      $self->send_event(irc_away_sync_start => $chan);
  
      return;
  }
  
  sub _channel_sync {
      my ($self, $chan, $sync) = @_;
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
  
      return if !$self->_channel_exists($chan) || !defined $self->{CHANNEL_SYNCH}{ $uchan };
      $self->{CHANNEL_SYNCH}{ $uchan }{ $sync } = 1 if $sync;
  
      for my $item ( qw(BAN MODE WHO) ) {
          return if !$self->{CHANNEL_SYNCH}{ $uchan }{ $item };
      }
  
      return 1;
  }
  
  sub _nick_exists {
      my ($self, $nick) = @_;
      my $map   = $self->isupport('CASEMAPPING');
      my $unick = uc_irc($nick, $map);
  
      return 1 if exists $self->{STATE}{Nicks}{ $unick };
      return;
  }
  
  sub _channel_exists {
      my ($self, $chan) = @_;
      my $map = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
  
      return 1 if exists $self->{STATE}{Chans}{ $uchan };
      return;
  }
  
  sub _nick_has_channel_mode {
      my ($self, $chan, $nick, $flag) = @_;
      my $map = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      my $unick = uc_irc($nick, $map);
      $flag = (split //, $flag)[0];
  
      return if !$self->is_channel_member($uchan, $unick);
      return 1 if $self->{STATE}{Nicks}{ $unick }{CHANS}{ $uchan } =~ /$flag/;
      return;
  }
  
  # Returns all the channels that the bot is on with an indication of
  # whether it has operator, halfop or voice.
  sub channels {
      my ($self) = @_;
      my $map    = $self->isupport('CASEMAPPING');
      my $unick  = uc_irc($self->nick_name(), $map);
  
      my %result;
      if (defined $unick && $self->_nick_exists($unick)) {
          for my $uchan ( keys %{ $self->{STATE}{Nicks}{ $unick }{CHANS} } ) {
              $result{ $self->{STATE}{Chans}{ $uchan }{Name} } = $self->{STATE}{Nicks}{ $unick }{CHANS}{ $uchan };
          }
      }
  
      return \%result;
  }
  
  sub nicks {
      my ($self) = @_;
      return map { $self->{STATE}{Nicks}{$_}{Nick} } keys %{ $self->{STATE}{Nicks} };
  }
  
  sub nick_info {
      my ($self, $nick) = @_;
  
      if (!defined $nick) {
          warn 'Nickname is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $unick = uc_irc($nick, $map);
  
      return if !$self->_nick_exists($nick);
  
      my $user = $self->{STATE}{Nicks}{ $unick };
      my %result = %{ $user };
  
      # maybe we haven't synced this user's info yet
      if (defined $result{User} && defined $result{Host}) {
          $result{Userhost} = "$result{User}\@$result{Host}";
      }
      delete $result{'CHANS'};
  
      return \%result;
  }
  
  sub nick_long_form {
      my ($self, $nick) = @_;
  
      if (!defined $nick) {
          warn 'Nickname is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $unick = uc_irc($nick, $map);
  
      return if !$self->_nick_exists($nick);
  
      my $user = $self->{STATE}{Nicks}{ $unick };
      return unless exists $user->{User} && exists $user->{Host};
      return "$user->{Nick}!$user->{User}\@$user->{Host}";
  }
  
  sub nick_channels {
      my ($self, $nick) = @_;
  
      if (!defined $nick) {
          warn 'Nickname is undefined';
          return;
      }
      my $map   = $self->isupport('CASEMAPPING');
      my $unick = uc_irc($nick, $map);
  
      return if !$self->_nick_exists($nick);
      return map { $self->{STATE}{Chans}{$_}{Name} } keys %{ $self->{STATE}{Nicks}{ $unick }{CHANS} };
  }
  
  sub channel_list {
      my ($self, $chan) = @_;
  
      if (!defined $chan) {
          warn 'Channel is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
  
      return if !$self->_channel_exists($chan);
      return map { $self->{STATE}{Nicks}{$_}{Nick} } keys %{ $self->{STATE}{Chans}{ $uchan }{Nicks} };
  }
  
  sub is_away {
      my ($self, $nick) = @_;
  
      if (!defined $nick) {
          warn 'Nickname is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $unick = uc_irc($nick, $map);
  
      if ($unick eq uc_irc($self->nick_name())) {
          # more accurate
          return 1 if $self->{STATE}{away};
          return;
      }
  
      return if !$self->_nick_exists($nick);
      return 1 if $self->{STATE}{Nicks}{ $unick }{Away};
      return;
  }
  
  sub is_operator {
      my ($self, $nick) = @_;
  
      if (!defined $nick) {
          warn 'Nickname is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $unick = uc_irc($nick, $map);
  
      return if !$self->_nick_exists($nick);
  
      return 1 if $self->{STATE}{Nicks}{ $unick }{IRCop};
      return;
  }
  
  sub is_channel_mode_set {
      my ($self, $chan, $mode) = @_;
  
      if (!defined $chan || !defined $mode) {
          warn 'Channel or mode is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      $mode = (split //, $mode)[0];
  
      return if !$self->_channel_exists($chan) || !$mode;
      $mode =~ s/[^A-Za-z]//g;
  
      if (defined $self->{STATE}{Chans}{ $uchan }{Mode}
          && $self->{STATE}{Chans}{ $uchan }{Mode} =~ /$mode/) {
          return 1;
      }
  
      return;
  }
  
  sub is_channel_synced {
      my ($self, $chan) = @_;
  
      if (!defined $chan) {
          warn 'Channel is undefined';
          return;
      }
  
      return $self->_channel_sync($chan);
  }
  
  sub channel_creation_time {
      my ($self, $chan) = @_;
  
      if (!defined $chan) {
          warn 'Channel is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
  
      return if !$self->_channel_exists($chan);
      return if !exists $self->{STATE}{Chans}{ $uchan }{CreationTime};
  
      return $self->{STATE}{Chans}{ $uchan }{CreationTime};
  }
  
  sub channel_limit {
      my ($self, $chan) = @_;
  
      if (!defined $chan) {
          warn 'Channel is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
  
      return if !$self->_channel_exists($chan);
  
      if ( $self->is_channel_mode_set($chan, 'l')
          && defined $self->{STATE}{Chans}{ $uchan }{ModeArgs}{l} ) {
          return $self->{STATE}{Chans}{ $uchan }{ModeArgs}{l};
      }
  
      return;
  }
  
  sub channel_key {
      my ($self, $chan) = @_;
  
      if (!defined $chan) {
          warn 'Channel is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      return if !$self->_channel_exists($chan);
  
      if ( $self->is_channel_mode_set($chan, 'k')
          && defined $self->{STATE}{Chans}{ $uchan }{ModeArgs}{k} ) {
          return $self->{STATE}{Chans}{ $uchan }{ModeArgs}{k};
      }
  
      return;
  }
  
  sub channel_modes {
      my ($self, $chan) = @_;
  
      if (!defined $chan) {
          warn 'Channel is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      return if !$self->_channel_exists($chan);
  
      my %modes;
      if ( defined $self->{STATE}{Chans}{ $uchan }{Mode} ) {
          %modes = map { ($_ => '') } split(//, $self->{STATE}{Chans}{ $uchan }{Mode});
      }
      if ( defined $self->{STATE}{Chans}{ $uchan }->{ModeArgs} ) {
          my %args = %{ $self->{STATE}{Chans}{ $uchan }{ModeArgs} };
          @modes{keys %args} = values %args;
      }
  
      return \%modes;
  }
  
  sub is_channel_member {
      my ($self, $chan, $nick) = @_;
  
      if (!defined $chan || !defined $nick) {
          warn 'Channel or nickname is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      my $unick = uc_irc($nick, $map);
  
      return if !$self->_channel_exists($chan) || !$self->_nick_exists($nick);
      return 1 if defined $self->{STATE}{Chans}{ $uchan }{Nicks}{ $unick };
      return;
  }
  
  sub is_channel_operator {
      my ($self, $chan, $nick) = @_;
  
      if (!defined $chan || !defined $nick) {
          warn 'Channel or nickname is undefined';
          return;
      }
  
      return 1 if $self->_nick_has_channel_mode($chan, $nick, 'o');
      return;
  }
  
  sub has_channel_voice {
      my ($self, $chan, $nick) = @_;
  
      if (!defined $chan || !defined $nick) {
          warn 'Channel or nickname is undefined';
          return;
      }
  
      return 1 if $self->_nick_has_channel_mode($chan, $nick, 'v');
      return;
  }
  
  sub is_channel_halfop {
      my ($self, $chan, $nick) = @_;
  
      if (!defined $chan || !defined $nick) {
          warn 'Channel or nickname is undefined';
          return;
      }
  
      return 1 if $self->_nick_has_channel_mode($chan, $nick, 'h');
      return;
  }
  
  sub is_channel_owner {
      my ($self, $chan, $nick) = @_;
  
      if (!defined $chan || !defined $nick) {
          warn 'Channel or nickname is undefined';
          return;
      }
  
      return 1 if $self->_nick_has_channel_mode($chan, $nick, 'q');
      return;
  }
  
  sub is_channel_admin {
      my ($self, $chan, $nick) = @_;
  
      if (!defined $chan || !defined $nick) {
          warn 'Channel or nickname is undefined';
          return;
      }
  
      return 1 if $self->_nick_has_channel_mode($chan, $nick, 'a');
      return;
  }
  
  sub ban_mask {
      my ($self, $chan, $mask) = @_;
  
      if (!defined $chan || !defined $mask) {
          warn 'Channel or mask is undefined';
          return;
      }
  
      my $map = $self->isupport('CASEMAPPING');
      $mask = normalize_mask($mask);
      my @result;
  
      return if !$self->_channel_exists($chan);
  
      # Convert the mask from IRC to regex.
      $mask = uc_irc($mask, $map);
      $mask = quotemeta $mask;
      $mask =~ s/\\\*/[\x01-\xFF]{0,}/g;
      $mask =~ s/\\\?/[\x01-\xFF]{1,1}/g;
  
      for my $nick ( $self->channel_list($chan) ) {
          push @result, $nick if uc_irc($self->nick_long_form($nick)) =~ /^$mask$/;
      }
  
      return @result;
  }
  
  
  sub channel_ban_list {
      my ($self, $chan) = @_;
  
      if (!defined $chan) {
          warn 'Channel is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      my %result;
  
      return if !$self->_channel_exists($chan);
  
      if ( defined $self->{STATE}{Chans}{ $uchan }{Lists}{b} ) {
          %result = %{ $self->{STATE}{Chans}{ $uchan }{Lists}{b} };
      }
  
      return \%result;
  }
  
  sub channel_except_list {
      my ($self, $chan) = @_;
  
      if (!defined $chan) {
          warn 'Channel is undefined';
          return;
      }
  
      my $map     = $self->isupport('CASEMAPPING');
      my $uchan   = uc_irc($chan, $map);
      my $excepts = $self->isupport('EXCEPTS');
      my %result;
  
      return if !$self->_channel_exists($chan);
  
      if ( defined $self->{STATE}{Chans}{ $uchan }{Lists}{ $excepts } ) {
          %result = %{ $self->{STATE}{Chans}{ $uchan }{Lists}{ $excepts } };
      }
  
      return \%result;
  }
  
  sub channel_invex_list {
      my ($self, $chan) = @_;
  
      if (!defined $chan) {
          warn 'Channel is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      my $invex = $self->isupport('INVEX');
      my %result;
  
      return if !$self->_channel_exists($chan);
  
      if ( defined $self->{STATE}{Chans}{ $uchan }{Lists}{ $invex } ) {
          %result = %{ $self->{STATE}{Chans}{ $uchan }{Lists}{ $invex } };
      }
  
      return \%result;
  }
  
  sub channel_topic {
      my ($self, $chan) = @_;
  
      if (!defined $chan) {
          warn 'Channel is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      my %result;
  
      return if !$self->_channel_exists($chan);
  
      if ( defined $self->{STATE}{Chans}{ $uchan }{Topic} ) {
          %result = %{ $self->{STATE}{Chans}{ $uchan }{Topic} };
      }
  
      return \%result;
  }
  
  sub channel_url {
      my ($self, $chan) = @_;
  
      if (!defined $chan) {
          warn 'Channel is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
  
      return if !$self->_channel_exists($chan);
      return $self->{STATE}{Chans}{ $uchan }{Url};
  }
  
  sub nick_channel_modes {
      my ($self, $chan, $nick) = @_;
  
      if (!defined $chan || !defined $nick) {
          warn 'Channel or nick is undefined';
          return;
      }
  
      my $map   = $self->isupport('CASEMAPPING');
      my $uchan = uc_irc($chan, $map);
      my $unick = uc_irc($nick, $map);
  
      return if !$self->is_channel_member($chan, $nick);
  
      return $self->{STATE}{Nicks}{ $unick }{CHANS}{ $uchan };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::IRC::State - A fully event-driven IRC client module with
  nickname and channel tracking
  
  =head1 SYNOPSIS
  
   # A simple Rot13 'encryption' bot
  
   use strict;
   use warnings;
   use POE qw(Component::IRC::State);
  
   my $nickname = 'Flibble' . $$;
   my $ircname = 'Flibble the Sailor Bot';
   my $ircserver = 'irc.blahblahblah.irc';
   my $port = 6667;
  
   my @channels = ( '#Blah', '#Foo', '#Bar' );
  
   # We create a new PoCo-IRC object and component.
   my $irc = POE::Component::IRC::State->spawn(
       nick => $nickname,
       server => $ircserver,
       port => $port,
       ircname => $ircname,
   ) or die "Oh noooo! $!";
  
   POE::Session->create(
       package_states => [
           main => [ qw(_default _start irc_001 irc_public) ],
       ],
       heap => { irc => $irc },
   );
  
   $poe_kernel->run();
  
   sub _start {
       my ($kernel, $heap) = @_[KERNEL, HEAP];
  
       # We get the session ID of the component from the object
       # and register and connect to the specified server.
       my $irc_session = $heap->{irc}->session_id();
       $kernel->post( $irc_session => register => 'all' );
       $kernel->post( $irc_session => connect => { } );
       return;
   }
  
   sub irc_001 {
       my ($kernel, $sender) = @_[KERNEL, SENDER];
  
       # Get the component's object at any time by accessing the heap of
       # the SENDER
       my $poco_object = $sender->get_heap();
       print "Connected to ", $poco_object->server_name(), "\n";
  
       # In any irc_* events SENDER will be the PoCo-IRC session
       $kernel->post( $sender => join => $_ ) for @channels;
       return;
   }
  
   sub irc_public {
       my ($kernel ,$sender, $who, $where, $what) = @_[KERNEL, SENDER, ARG0 .. ARG2];
       my $nick = ( split /!/, $who )[0];
       my $channel = $where->[0];
       my $poco_object = $sender->get_heap();
  
       if ( my ($rot13) = $what =~ /^rot13 (.+)/ ) {
           # Only operators can issue a rot13 command to us.
           return if !$poco_object->is_channel_operator( $channel, $nick );
  
           $rot13 =~ tr[a-zA-Z][n-za-mN-ZA-M];
           $kernel->post( $sender => privmsg => $channel => "$nick: $rot13" );
       }
       return;
   }
  
   # We registered for all events, this will produce some debug info.
   sub _default {
       my ($event, $args) = @_[ARG0 .. $#_];
       my @output = ( "$event: " );
  
       for my $arg ( @$args ) {
           if (ref $arg  eq 'ARRAY') {
               push( @output, '[' . join(', ', @$arg ) . ']' );
           }
           else {
               push ( @output, "'$arg'" );
           }
       }
       print join ' ', @output, "\n";
       return 0;
   }
  
  =head1 DESCRIPTION
  
  POE::Component::IRC::State is a sub-class of L<POE::Component::IRC|POE::Component::IRC>
  which tracks IRC state entities such as nicks and channels. See the
  documentation for L<POE::Component::IRC|POE::Component::IRC> for general usage.
  This document covers the extra methods that POE::Component::IRC::State provides.
  
  The component tracks channels and nicks, so that it always has a current
  snapshot of what channels it is on and who else is on those channels. The
  returned object provides methods to query the collected state.
  
  =head1 CONSTRUCTORS
  
  POE::Component::IRC::State's constructors, and its C<connect> event, all
  take the same arguments as L<POE::Component::IRC|POE::Component::IRC> does, as
  well as two additional ones:
  
  B<'AwayPoll'>, the interval (in seconds) in which to poll (i.e. C<WHO #channel>)
  the away status of channel members. Defaults to 0 (disabled). If enabled, you
  will receive C<irc_away_sync_*> / L<C<irc_user_away>|/irc_user_away> /
  L<C<irc_user_back>|/irc_user_back> events, and will be able to use the
  L<C<is_away>|/is_away> method for users other than yourself. This can cause
  a lot of increase in traffic, especially if you are on big channels, so if you
  do use this, you probably don't want to set it too low. For reference, X-Chat
  uses 300 seconds (5 minutes).
  
  B<'WhoJoiners'>, a boolean indicating whether the component should send a
  C<WHO nick> for every person which joins a channel. Defaults to on
  (the C<WHO> is sent). If you turn this off, L<C<is_operator>|/is_operator>
  will not work and L<C<nick_info>|/nick_info> will only return the keys
  B<'Nick'>, B<'User'>, B<'Host'> and B<'Userhost'>.
  
  =head1 METHODS
  
  All of the L<POE::Component::IRC|POE::Component::IRC> methods are supported,
  plus the following:
  
  =head2 C<ban_mask>
  
  Expects a channel and a ban mask, as passed to MODE +b-b. Returns a list of
  nicks on that channel that match the specified ban mask or an empty list if
  the channel doesn't exist in the state or there are no matches.
  
  =head2 C<channel_ban_list>
  
  Expects a channel as a parameter. Returns a hashref containing the banlist
  if the channel is in the state, a false value if not. The hashref keys are the
  entries on the list, each with the keys B<'SetBy'> and B<'SetAt'>. These keys
  will hold the nick!hostmask of the user who set the entry (or just the nick
  if it's all the ircd gives us), and the time at which it was set respectively.
  
  =head2 C<channel_creation_time>
  
  Expects a channel as parameter. Returns channel creation time or a false value.
  
  =head2 C<channel_except_list>
  
  Expects a channel as a parameter. Returns a hashref containing the ban
  exception list if the channel is in the state, a false value if not. The
  hashref keys are the entries on the list, each with the keys B<'SetBy'> and
  B<'SetAt'>. These keys will hold the nick!hostmask of the user who set the
  entry (or just the nick if it's all the ircd gives us), and the time at which
  it was set respectively.
  
  =head2 C<channel_invex_list>
  
  Expects a channel as a parameter. Returns a hashref containing the invite
  exception list if the channel is in the state, a false value if not. The
  hashref keys are the entries on the list, each with the keys B<'SetBy'> and
  B<'SetAt'>. These keys will hold the nick!hostmask of the user who set the
  entry (or just the nick if it's all the ircd gives us), and the time at which
  it was set respectively.
  
  =head2 C<channel_key>
  
  Expects a channel as parameter. Returns the channel key or a false value.
  
  =head2 C<channel_limit>
  
  Expects a channel as parameter. Returns the channel limit or a false value.
  
  =head2 C<channel_list>
  
  Expects a channel as parameter. Returns a list of all nicks on the specified
  channel. If the component happens to not be on that channel an empty list will
  be returned.
  
  =head2 C<channel_modes>
  
  Expects a channel as parameter. Returns a hash ref keyed on channel mode, with
  the mode argument (if any) as the value. Returns a false value instead if the
  channel is not in the state.
  
  =head2 C<channels>
  
  Takes no parameters. Returns a hashref, keyed on channel name and whether the
  bot is operator, halfop or
  has voice on that channel.
  
   for my $channel ( keys %{ $irc->channels() } ) {
       $irc->yield( 'privmsg' => $channel => 'm00!' );
   }
  
  =head2 C<channel_topic>
  
  Expects a channel as a parameter. Returns a hashref containing topic
  information if the channel is in the state, a false value if not. The hashref
  contains the following keys: B<'Value'>, B<'SetBy'>, B<'SetAt'>. These keys
  will hold the topic itself, the nick!hostmask of the user who set it (or just
  the nick if it's all the ircd gives us), and the time at which it was set
  respectively.
  
  If the component happens to not be on the channel, nothing will be returned.
  
  =head2 C<channel_url>
  
  Expects a channel as a parameter. Returns the channel's URL. If the channel
  has no URL or the component is not on the channel, nothing will be returned.
  
  =head2 C<has_channel_voice>
  
  Expects a channel and a nickname as parameters. Returns a true value if
  the nick has voice on the specified channel. Returns false if the nick does
  not have voice on the channel or if the nick/channel does not exist in the state.
  
  =head2 C<is_away>
  
  Expects a nick as parameter. Returns a true value if the specified nick is away.
  Returns a false value if the nick is not away or not in the state. This will
  only work for your IRC user unless you specified a value for B<'AwayPoll'> in
  L<C<spawn>|POE::Component::IRC/spawn>.
  
  =head2 C<is_channel_admin>
  
  Expects a channel and a nickname as parameters. Returns a true value if
  the nick is an admin on the specified channel. Returns false if the nick is
  not an admin on the channel or if the nick/channel does not exist in the state.
  
  =head2 C<is_channel_halfop>
  
  Expects a channel and a nickname as parameters. Returns a true value if
  the nick is a half-operator on the specified channel. Returns false if the nick
  is not a half-operator on the channel or if the nick/channel does not exist in
  the state.
  
  =head2 C<is_channel_member>
  
  Expects a channel and a nickname as parameters. Returns a true value if
  the nick is on the specified channel. Returns false if the nick is not on the
  channel or if the nick/channel does not exist in the state.
  
  =head2 C<is_channel_mode_set>
  
  Expects a channel and a single mode flag C<[A-Za-z]>. Returns a true value
  if that mode is set on the channel.
  
  =head2 C<is_channel_operator>
  
  Expects a channel and a nickname as parameters. Returns a true value if
  the nick is an operator on the specified channel. Returns false if the nick is
  not an operator on the channel or if the nick/channel does not exist in the state.
  
  =head2 C<is_channel_owner>
  
  Expects a channel and a nickname as parameters. Returns a true value if
  the nick is an owner on the specified channel. Returns false if the nick is
  not an owner on the channel or if the nick/channel does not exist in the state.
  
  =head2 C<is_channel_synced>
  
  Expects a channel as a parameter. Returns true if the channel has been synced.
  Returns false if it has not been synced or if the channel is not in the state.
  
  =head2 C<is_operator>
  
  Expects a nick as parameter. Returns a true value if the specified nick is
  an IRC operator. Returns a false value if the nick is not an IRC operator
  or is not in the state.
  
  =head2 C<is_user_mode_set>
  
  Expects single user mode flag C<[A-Za-z]>. Returns a true value if that user
  mode is set.
  
  =head2 C<nick_channel_modes>
  
  Expects a channel and a nickname as parameters. Returns the modes of the
  specified nick on the specified channel (ie. qaohv). If the nick is not on the
  channel in the state, a false value will be returned.
  
  =head2 C<nick_channels>
  
  Expects a nickname. Returns a list of the channels that that nickname and the
  component are on. An empty list will be returned if the nickname does not
  exist in the state.
  
  =head2 C<nick_info>
  
  Expects a nickname. Returns a hashref containing similar information to that
  returned by WHOIS. Returns a false value if the nickname doesn't exist in the
  state. The hashref contains the following keys:
  
  B<'Nick'>, B<'User'>, B<'Host'>, B<'Userhost'>, B<'Hops'>, B<'Real'>,
  B<'Server'> and, if applicable, B<'IRCop'>.
  
  =head2 C<nick_long_form>
  
  Expects a nickname. Returns the long form of that nickname, ie. C<nick!user@host>
  or a false value if the nick is not in the state.
  
  =head2 C<nicks>
  
  Takes no parameters. Returns a list of all the nicks, including itself, that it
  knows about. If the component happens to be on no channels then an empty list
  is returned.
  
  =head2 C<umode>
  
  Takes no parameters. Returns the current user mode set for the bot.
  
  =head1 OUTPUT EVENTS
  
  =head2 Augmented events
  
  New parameters are added to the following
  L<POE::Component::IRC|POE::Component::IRC> events.
  
  =head3 C<irc_quit>
  
  See also L<C<irc_quit>|POE::Component::IRC/irc_quit> in
  L<POE::Component::IRC|POE::Component::IRC>.
  
  Additional parameter C<ARG2> contains an arrayref of channel names that are
  common to the quitting client and the component.
  
  =head3 C<irc_nick>
  
  See also L<C<irc_nick>|POE::Component::IRC/irc_nick> in
  L<POE::Component::IRC|POE::Component::IRC>.
  
  Additional parameter C<ARG2> contains an arrayref of channel names that are
  common to the nick hanging client and the component.
  
  =head3 C<irc_kick>
  
  See also L<C<irc_kick>|POE::Component::IRC/irc_kick> in
  L<POE::Component::IRC|POE::Component::IRC>.
  
  Additional parameter C<ARG4> contains the full nick!user@host of the kicked
  individual.
  
  =head3 C<irc_topic>
  
  See also L<C<irc_kick>|POE::Component::IRC/irc_kick> in
  L<POE::Component::IRC|POE::Component::IRC>.
  
  Additional parameter C<ARG3> contains the old topic hashref, like the one
  returned by L<C<channel_topic>|/channel_topic>.
  
  =head3 C<irc_disconnected>
  
  =head3 C<irc_error>
  
  =head3 C<irc_socketerr>
  
  These three all have two additional parameters. C<ARG1> is a hash of
  information about your IRC user (see L<C<nick_info>|/nick_info>), while
  C<ARG2> is a hash of the channels you were on (see
  L<C<channels>|/channels>).
  
  =head2 New events
  
  As well as all the usual L<POE::Component::IRC|POE::Component::IRC> C<irc_*>
  events, there are the following events you can register for:
  
  =head3 C<irc_away_sync_start>
  
  Sent whenever the component starts to synchronise the away statuses of channel
  members. C<ARG0> is the channel name. You will only receive this event if you
  specified a value for B<'AwayPoll'> in L<C<spawn>|POE::Component::IRC/spawn>.
  
  =head3 C<irc_away_sync_end>
  
  Sent whenever the component has completed synchronising the away statuses of
  channel members. C<ARG0> is the channel name. You will only receive this event if
  you specified a value for B<'AwayPoll'> in L<C<spawn>|POE::Component::IRC/spawn>.
  
  =head3 C<irc_chan_mode>
  
  This is almost identical to L<C<irc_mode>|POE::Component::IRC/irc_mode>,
  except that it's sent once for each individual mode with it's respective
  argument if it has one (ie. the banmask if it's +b or -b). However, this
  event is only sent for channel modes.
  
  =head3 C<irc_chan_sync>
  
  Sent whenever the component has completed synchronising a channel that it has
  joined. C<ARG0> is the channel name and C<ARG1> is the time in seconds that
  the channel took to synchronise.
  
  =head3 C<irc_chan_sync_invex>
  
  Sent whenever the component has completed synchronising a channel's INVEX
  (invite list). Usually triggered by the component being opped on a channel.
  C<ARG0> is the channel name.
  
  =head3 C<irc_chan_sync_excepts>
  
  Sent whenever the component has completed synchronising a channel's EXCEPTS
  (ban exemption list). Usually triggered by the component being opped on a
  channel. C<ARG0> is the channel.
  
  =head3 C<irc_nick_sync>
  
  Sent whenever the component has completed synchronising a user who has joined
  a channel the component is on. C<ARG0> is the user's nickname and C<ARG1> the
  channel they have joined.
  
  =head3 C<irc_user_away>
  
  Sent when an IRC user sets his/her status to away. C<ARG0> is the nickname,
  C<ARG1> is an arrayref of channel names that are common to the nickname
  and the component. You will only receive this event if you specified a value
  for B<'AwayPoll'> in L<C<spawn>|POE::Component::IRC/spawn>.
  
  B<Note:> This above is only for users I<other than yourself>. To know when you
  change your own away status, register for the C<irc_305> and C<irc_306> events.
  
  =head3 C<irc_user_back>
  
  Sent when an IRC user unsets his/her away status. C<ARG0> is the nickname,
  C<ARG1> is an arrayref of channel names that are common to the nickname and
  the component. You will only receive this event if you specified a value for
  B<'AwayPoll'> in L<C<spawn>|POE::Component::IRC/spawn>.
  
  B<Note:> This above is only for users I<other than yourself>. To know when you
  change your own away status, register for the C<irc_305> and C<irc_306> events.
  
  =head3 C<irc_user_mode>
  
  This is almost identical to L<C<irc_mode>|POE::Component::IRC/irc_mode>,
  except it is sent for each individual umode that is being set.
  
  =head1 CAVEATS
  
  The component gathers information by registering for C<irc_quit>, C<irc_nick>,
  C<irc_join>, C<irc_part>, C<irc_mode>, C<irc_kick> and various numeric replies.
  When the component is asked to join a channel, when it joins it will issue
  'WHO #channel', 'MODE #channel', and 'MODE #channel b'. These will solicit
  between them the numerics, C<irc_352>, C<irc_324> and C<irc_329>, respectively.
  When someone joins a channel the bot is on, it issues a 'WHO nick'. You may
  want to ignore these.
  
  Currently, whenever the component sees a topic or channel list change, it will
  use C<time> for the SetAt value and the full address of the user who set it
  for the SetBy value. When an ircd gives us its record of such changes, it will
  use its own time (obviously) and may only give us the nickname of the user,
  rather than their full address. Thus, if our C<time> and the ircd's time do
  not match, or the ircd uses the nickname only, ugly inconsistencies can develop.
  This leaves the B<'SetAt'> and B<'SetBy'> values inaccurate at best, and you
  should use them with this in mind (for now, at least).
  
  =head1 AUTHOR
  
  Chris Williams <chris@bingosnet.co.uk>
  
  With contributions from Lyndon Miller.
  
  =head1 LICENCE
  
  This module may be used, modified, and distributed under the same
  terms as Perl itself. Please see the license that came with your Perl
  distribution for details.
  
  =head1 SEE ALSO
  
  L<POE::Component::IRC|POE::Component::IRC>
  
  L<POE::Component::IRC::Qnet::State|POE::Component::IRC::Qnet::State>
  
  =cut
POE_COMPONENT_IRC_STATE

$fatpacked{"POE/Component/Server/TCP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_SERVER_TCP';
  package POE::Component::Server::TCP;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw(carp croak);
  use Socket qw(INADDR_ANY inet_ntoa inet_aton AF_INET AF_UNIX PF_UNIX);
  use Errno qw(ECONNABORTED ECONNRESET);
  
  BEGIN {
    # under perl-5.6.2 the warning "leaks" from the eval, while newer versions don't...
    # it's due to Exporter.pm behaving differently, so we have to shut it up
    no warnings 'redefine';
    local *Carp::carp = sub { die @_ };
  
    # Socket::GetAddrInfo provides getaddrinfo where earlier Perls' Socket don't.
    eval { Socket->import('getaddrinfo') };
    if ($@) {
      # :newapi is legacy, but we include it to be sure in case the user has an old version of GAI
      eval { require Socket::GetAddrInfo; Socket::GetAddrInfo->import( qw(:newapi getaddrinfo) ) };
      if ($@) {
        *getaddrinfo = sub { Carp::confess("Unable to use IPv6: Socket::GetAddrInfo not available") };
      }
    }
  }
  
  # Explicit use to import the parameter constants.
  use POE::Session;
  use POE::Driver::SysRW;
  use POE::Filter::Line;
  use POE::Wheel::ReadWrite;
  use POE::Wheel::SocketFactory;
  
  sub DEBUG () { 0 }
  
  # Create the server.  This is just a handy way to encapsulate
  # POE::Session->create().  Because the states are so small, it uses
  # real inline coderefs.
  
  sub new {
    my $type = shift;
  
    # Helper so we don't have to type it all day.  $mi is a name I call
    # myself.
    my $mi = $type . '->new()';
  
    # If they give us lemons, tell them to make their own damn
    # lemonade.
    croak "$mi requires an even number of parameters" if (@_ & 1);
    my %param = @_;
  
    # Extract parameters.
    my $alias   = delete $param{Alias};
    my $address = delete $param{Address};
    my $hname   = delete $param{Hostname};
    my $port    = delete $param{Port};
    my $domain  = delete($param{Domain}) || AF_INET;
    my $concurrency = delete $param{Concurrency};
  
    $port = 0 unless defined $port;
  
    foreach (
      qw(
        Acceptor Error ClientInput
        ClientPreConnect ClientConnected ClientDisconnected
        ClientError ClientFlushed
        ClientLow ClientHigh
      )
    ) {
      croak "$_ must be a coderef"
        if defined($param{$_}) and ref($param{$_}) ne 'CODE';
    }
  
    my $high_mark_level = delete $param{HighMark};
    my $low_mark_level  = delete $param{LowMark};
    my $high_event      = delete $param{ClientHigh};
    my $low_event       = delete $param{ClientLow};
  
    my $mark_param_count = (
      grep { defined $_ }
      ($high_mark_level, $low_mark_level, $high_event, $low_event)
    );
    if ($mark_param_count and $mark_param_count < 4) {
      croak "If you use the Mark settings, you must define all four";
    }
  
    $high_event = sub { } unless defined $high_event;
    $low_event  = sub { } unless defined $low_event;
  
    my $accept_callback = delete $param{Acceptor};
    my $error_callback  = delete $param{Error};
  
    my $client_input    = delete $param{ClientInput};
  
    # Acceptor and ClientInput are mutually exclusive.
    croak "$mi needs either an Acceptor or a ClientInput but not both"
      unless defined($accept_callback) xor defined($client_input);
  
    # Make sure ClientXyz are accompanied by ClientInput.
    unless (defined($client_input)) {
      foreach (grep /^Client/, keys %param) {
        croak "$_ not permitted without ClientInput";
      }
    }
  
    my $client_pre_connect  = delete $param{ClientPreConnect};
    my $client_connected    = delete $param{ClientConnected};
    my $client_disconnected = delete $param{ClientDisconnected};
    my $client_error        = delete $param{ClientError};
    my $client_filter       = delete $param{ClientFilter};
    my $client_infilter     = delete $param{ClientInputFilter};
    my $client_outfilter    = delete $param{ClientOutputFilter};
    my $client_flushed      = delete $param{ClientFlushed};
    my $session_type        = delete $param{SessionType};
    my $session_params      = delete $param{SessionParams};
    my $server_started      = delete $param{Started};
    my $server_stopped      = delete $param{Stopped};
    my $listener_args       = delete $param{ListenerArgs};
  
    $listener_args = [] unless defined $listener_args;
    croak "ListenerArgs must be an array reference"
      unless ref($listener_args) eq 'ARRAY';
  
    if (exists $param{Args}) {
      if (exists $param{ClientArgs}) {
        carp "Args is deprecated, and ignored since ClientArgs is present";
        delete $param{Args};
      }
      else {
        carp "Args is deprecated but allowed for now.  Please use ClientArgs";
      }
    }
  
    my $client_args = delete($param{ClientArgs}) || delete($param{Args});
  
    if ( (defined $client_infilter and ! defined $client_outfilter) or
      (defined $client_outfilter and ! defined $client_infilter) ) {
      croak "ClientInputFilter must be used with ClientOutputFilter";
    }
  
    if (defined $client_filter and defined $client_infilter) {
      carp "ClientFilter ignored with ClientInputFilter and ClientOutputFilter";
      undef $client_filter;
    }
  
    # Defaults.
  
    $concurrency = -1 unless defined $concurrency;
    my $accept_session_id;
  
    if (!defined $address && defined $hname) {
      $address = inet_aton($hname);
    }
    $address = INADDR_ANY unless defined $address;
  
    $error_callback = \&_default_server_error unless defined $error_callback;
  
    $session_type = 'POE::Session' unless defined $session_type;
    if (defined($session_params) && ref($session_params)) {
      if (ref($session_params) ne 'ARRAY') {
        croak "SessionParams must be an array reference";
      }
    } else {
      $session_params = [ ];
    }
  
    if (defined $client_input) {
      $client_error  = \&_default_client_error unless defined $client_error;
      $client_args         = []     unless defined $client_args;
  
      # Extra states.
  
      my $inline_states = delete $param{InlineStates};
      $inline_states = {} unless defined $inline_states;
  
      my $package_states = delete $param{PackageStates};
      $package_states = [] unless defined $package_states;
  
      my $object_states = delete $param{ObjectStates};
      $object_states = [] unless defined $object_states;
  
      my $shutdown_on_error = 1;
      if (exists $param{ClientShutdownOnError}) {
        $shutdown_on_error = delete $param{ClientShutdownOnError};
      }
  
      croak "InlineStates must be a hash reference"
        unless ref($inline_states) eq 'HASH';
  
      croak "PackageStates must be a list or array reference"
        unless ref($package_states) eq 'ARRAY';
  
      croak "ObjectsStates must be a list or array reference"
        unless ref($object_states) eq 'ARRAY';
  
      croak "ClientArgs must be an array reference"
        unless ref($client_args) eq 'ARRAY';
  
      # Sanity check, thanks to crab@irc for making this mistake, ha!
      # TODO we could move this to POE::Session and make it a
      # "sanity checking" sub somehow...
      if (POE::Kernel::ASSERT_USAGE) {
        my %forbidden_handlers = (
          _child => 1,
          _start => 1,
          _stop => 1,
          shutdown => 1,
          tcp_server_got_error => 1,
          tcp_server_got_flush => 1,
          tcp_server_got_high => 1,
          tcp_server_got_input => 1,
          tcp_server_got_low => 1,
        );
  
        if (
          my @forbidden_inline_handlers = (
            grep { exists $inline_states->{$_} }
            keys %forbidden_handlers
          )
        ) {
          croak "These InlineStates aren't allowed: @forbidden_inline_handlers";
        }
  
        my %handlers = (
          PackageStates => $package_states,
          ObjectStates => $object_states,
        );
  
        while (my ($name, $states) = each(%handlers)) {
          my %states_hash = @$states;
          my @forbidden_handlers;
          while (my ($package, $handlers) = each %states_hash) {
            croak "Undefined $name member for $package" unless (
              defined $handlers
            );
  
            if (ref($handlers) eq 'HASH') {
              push(
                @forbidden_handlers,
                grep { exists $handlers->{$_} }
                keys %forbidden_handlers
              );
            }
            elsif (ref($handlers) eq 'ARRAY') {
              push(
                @forbidden_handlers,
                grep { exists $forbidden_handlers{$_} }
                @$handlers
              );
            }
            else {
              croak "Unknown $name member type for $package";
            }
          }
  
          croak "These $name aren't allowed: @forbidden_handlers" if (
            @forbidden_handlers
          );
        }
      }
  
      # Revise the acceptor callback so it spawns a session.
  
      unless (defined $accept_callback) {
        $accept_callback = sub {
          my ($socket, $remote_addr, $remote_port) = @_[ARG0, ARG1, ARG2];
  
          $session_type->create(
            @$session_params,
            inline_states => {
              _start => sub {
                my ( $kernel, $session, $heap ) = @_[KERNEL, SESSION, HEAP];
  
                $heap->{shutdown} = 0;
                $heap->{shutdown_on_error} = $shutdown_on_error;
  
                # Unofficial UNIX support, suggested by Damir Dzeko.
                # Real UNIX socket support should go into a separate
                # module, but if that module only differs by four
                # lines of code it would be bad to maintain two
                # modules for the price of one.  One solution would be
                # to pull most of this into a base class and derive
                # TCP and UNIX versions from that.
                if (
                  $domain == AF_UNIX or $domain == PF_UNIX
                ) {
                  $heap->{remote_ip} = "LOCAL";
                }
                elsif (length($remote_addr) == 4) {
                  $heap->{remote_ip} = inet_ntoa($remote_addr);
                }
                else {
                  $heap->{remote_ip} = ( getaddrinfo($remote_addr) )[1];
                }
  
                $heap->{remote_port} = $remote_port;
  
                my $socket = $_[ARG0];
                if ($client_pre_connect) {
                  $socket = $client_pre_connect->(@_);
                  unless (defined($socket) and ref($socket) and fileno($socket)) {
                    # TODO - The user ought to know what's going on
                    # here, since it's triggered by something their
                    # callback has done.  Should we expose a callback
                    # anyway to avoid potential confusion?
                    return;
                  }
                }
  
                $heap->{client} = POE::Wheel::ReadWrite->new(
                  Handle       => $socket,
                  Driver       => POE::Driver::SysRW->new(),
                  _get_filters(
                    $client_filter,
                    $client_infilter,
                    $client_outfilter
                  ),
                  InputEvent   => 'tcp_server_got_input',
                  ErrorEvent   => 'tcp_server_got_error',
                  FlushedEvent => 'tcp_server_got_flush',
  
                  (
                    $mark_param_count
                    ? (
                      HighMark  => $high_mark_level,
                      HighEvent => 'tcp_server_got_high',
                      LowMark   => $low_mark_level,
                      LowEvent  => 'tcp_server_got_low',
                    )
                    : ()
                  ),
                );
  
                # Expand the Args constructor array, and place a copy
                # into @_[ARG0..].  There are only 2 parameters.
                splice(@_, ARG0, 2, @{$_[ARG1]});
  
                $client_connected and $client_connected->(@_);
              },
              tcp_server_got_high => $high_event,
              tcp_server_got_low => $low_event,
  
              # To quiet ASSERT_STATES.
              _child  => sub { },
  
              tcp_server_got_input => sub {
                return if $_[HEAP]->{shutdown};
                $client_input->(@_);
                undef;
              },
              tcp_server_got_error => sub {
                DEBUG and warn(
                  "$$: $alias child Error ARG0=$_[ARG0] ARG1=$_[ARG1]"
                );
                unless ($_[ARG0] eq 'accept' and $_[ARG1] == ECONNABORTED) {
                  $client_error->(@_);
                  if ($_[HEAP]->{shutdown_on_error}) {
                    $_[HEAP]->{got_an_error} = 1;
                    $_[KERNEL]->yield("shutdown");
                  }
                }
              },
              tcp_server_got_flush => sub {
                my $heap = $_[HEAP];
                DEBUG and warn "$$: $alias child Flush";
                $client_flushed and $client_flushed->(@_);
                if ($heap->{shutdown}) {
                  DEBUG and warn "$$: $alias child Flush, callback";
                  $client_disconnected and $client_disconnected->(@_);
                  delete $heap->{client};
                }
              },
              shutdown => sub {
                DEBUG and warn "$$: $alias child Shutdown";
                my $heap = $_[HEAP];
                $heap->{shutdown} = 1;
                if (defined $heap->{client}) {
                  if (
                    $heap->{got_an_error} or
                    not $heap->{client}->get_driver_out_octets()
                  ) {
                    DEBUG and warn "$$: $alias child Shutdown, callback";
                    $client_disconnected and $client_disconnected->(@_);
                    delete $heap->{client};
                  }
                }
              },
              _stop => sub {
                ## concurrency on close
                DEBUG and warn(
                  "$$: $alias _stop accept_session = $accept_session_id"
                );
                if( defined $accept_session_id ) {
                  $_[KERNEL]->call( $accept_session_id, 'disconnected' );
                }
                else {
                  # This means that the Server::TCP was shutdown before
                  # this connection closed.  So it doesn't really matter that
                  # we can't decrement the connection counter.
                  DEBUG and warn(
                    "$$: $_[HEAP]->{alias} Disconnected from a connection ",
                    "without POE::Component::Server::TCP parent"
                  );
                }
                return;
              },
  
              # User supplied states.
              %$inline_states
            },
  
            # More user supplied states.
            package_states => $package_states,
            object_states  => $object_states,
  
            # XXX - If you change the number of args here, also change
            # the splice elsewhere.
            args => [ $socket, $client_args ],
          );
        };
      }
    };
  
    # Complain about strange things we're given.
    foreach (sort keys %param) {
      carp "$mi doesn't recognize \"$_\" as a parameter";
    }
  
    ## verify concurrency on accept
    my $orig_accept_callback = $accept_callback;
    $accept_callback = sub {
      $_[HEAP]->{connections}++;
      DEBUG and warn(
        "$$: $_[HEAP]->{alias} Connection opened ",
        "($_[HEAP]->{connections} open)"
      );
      if( $_[HEAP]->{concurrency} != -1 and $_[HEAP]->{listener} ) {
        if( $_[HEAP]->{connections} >= $_[HEAP]->{concurrency} ) {
          DEBUG and warn(
            "$$: $_[HEAP]->{alias} Concurrent connection limit reached, ",
            "pausing accept"
          );
          $_[HEAP]->{listener}->pause_accept()
        }
      }
      $orig_accept_callback->(@_);
    };
  
    # Create the session, at long last.
    # This is done inline so that closures can customize it.
    # We save the accept session's ID to avoid self reference.
  
    $accept_session_id = $session_type->create(
      @$session_params,
      inline_states => {
        _start => sub {
          if (defined $alias) {
            $_[HEAP]->{alias} = $alias;
            $_[KERNEL]->alias_set( $alias );
          }
  
          $_[HEAP]->{concurrency} = $concurrency;
          $_[HEAP]->{connections} = 0;
  
          $_[HEAP]->{listener} = POE::Wheel::SocketFactory->new(
            ( ($domain == AF_UNIX or $domain == PF_UNIX)
              ? ()
              : ( BindPort => $port )
            ),
            BindAddress  => $address,
            SocketDomain => $domain,
            Reuse        => 'yes',
            SuccessEvent => 'tcp_server_got_connection',
            FailureEvent => 'tcp_server_got_error',
          );
          $server_started and $server_started->(@_);
        },
        # Catch an error.
        tcp_server_got_error => $error_callback,
  
        # We accepted a connection.  Do something with it.
        tcp_server_got_connection => $accept_callback,
  
        # concurrency on close.
        disconnected => sub {
          $_[HEAP]->{connections}--;
          DEBUG and warn(
            "$$: $_[HEAP]->{alias} Connection closed ",
            "($_[HEAP]->{connections} open)"
          );
          if ($_[HEAP]->{connections} < 0) {
            warn(
              "Excessive 'disconnected' event ",
              "from $_[CALLER_FILE] at line $_[CALLER_LINE]\n"
            );
            $_[HEAP]->{connections} = 0;
          }
          if( $_[HEAP]->{concurrency} != -1 and $_[HEAP]->{listener} ) {
            if( $_[HEAP]->{connections} == ($_[HEAP]->{concurrency}-1) ) {
              DEBUG and warn(
                "$$: $_[HEAP]->{alias} Concurrent connection limit ",
                "reestablished, resuming accept"
              );
              $_[HEAP]->{listener}->resume_accept();
            }
          }
        },
  
        set_concurrency => sub {
          $_[HEAP]->{concurrency} = $_[ARG0];
          DEBUG and warn(
            "$$: $_[HEAP]->{alias} Concurrent connection ",
            "limit = $_[HEAP]->{concurrency}"
          );
          if( $_[HEAP]->{concurrency} != -1 and $_[HEAP]->{listener} ) {
            if( $_[HEAP]->{connections} >= $_[HEAP]->{concurrency} ) {
              DEBUG and warn(
                "$$: $_[HEAP]->{alias} Concurrent connection limit ",
                "reached, pausing accept"
              );
              $_[HEAP]->{listener}->pause_accept()
            }
            else {
              DEBUG and warn(
                "$$: $_[HEAP]->{alias} Concurrent connection limit ",
                "reestablished, resuming accept"
              );
              $_[HEAP]->{listener}->resume_accept();
            }
          }
        },
  
        # Shut down.
        shutdown => sub {
          delete $_[HEAP]->{listener};
          $_[KERNEL]->alias_remove( $_[HEAP]->{alias} )
            if defined $_[HEAP]->{alias};
        },
  
        # Dummy states to prevent warnings.
        _stop   => sub {
          DEBUG and warn "$$: $_[HEAP]->{alias} _stop";
          $server_stopped and $server_stopped->(@_);
          undef($accept_session_id);
          return 0;
        },
        _child  => sub { },
      },
  
      args => $listener_args,
    )->ID;
  
    # Return the session ID.
    return $accept_session_id;
  }
  
  sub _get_filters {
      my ($client_filter, $client_infilter, $client_outfilter) = @_;
      if (defined $client_infilter or defined $client_outfilter) {
        return (
          "InputFilter"  => _load_filter($client_infilter),
          "OutputFilter" => _load_filter($client_outfilter)
        );
      }
      elsif (defined $client_filter) {
        return ( "Filter" => _load_filter($client_filter) );
      }
      else {
        return ( Filter => POE::Filter::Line->new(), );
      }
  
  }
  
  # Get something: either arrayref, ref, or string
  # Return filter
  sub _load_filter {
      my $filter = shift;
      if (ref ($filter) eq 'ARRAY') {
          my @args = @$filter;
          $filter = shift @args;
          if ( _test_filter($filter) ){
              return $filter->new(@args);
          } else {
              return POE::Filter::Line->new(@args);
          }
      }
      elsif (ref $filter) {
          return $filter->clone();
      }
      else {
          if ( _test_filter($filter) ) {
              return $filter->new();
          } else {
              return POE::Filter::Line->new();
          }
      }
  }
  
  # Test if a Filter can be loaded, return success or failure
  sub _test_filter {
      my $filter = shift;
      my $eval = eval {
          (my $mod = $filter) =~ s!::!/!g;
          require "$mod.pm";
          1;
      };
      if (!$eval and $@) {
          carp(
            "Failed to load [$filter]\n" .
            "Reason $@\nUsing default POE::Filter::Line "
          );
          return 0;
      }
      return 1;
  }
  
  # The default server error handler logs to STDERR and shuts down the
  # server.
  
  sub _default_server_error {
    warn("$$: ".
      'Server ', $_[SESSION]->ID,
      " got $_[ARG0] error $_[ARG1] ($_[ARG2])\n"
    );
    delete $_[HEAP]->{listener};
  }
  
  # The default client error handler logs to STDERR
  
  sub _default_client_error {
    my ($syscall, $errno, $error) = @_[ARG0..ARG2];
    unless ($syscall eq "read" and ($errno == 0 or $errno == ECONNRESET)) {
      $error = "(no error)" unless $errno;
      warn("$$: ".
        'Client session ', $_[SESSION]->ID,
        " got $syscall error $errno ($error)\n"
      );
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Component::Server::TCP - a simplified TCP server
  
  =head1 SYNOPSIS
  
    #!perl
  
    use warnings;
    use strict;
  
    use POE qw(Component::Server::TCP);
  
    POE::Component::Server::TCP->new(
      Port => 12345,
      ClientConnected => sub {
        print "got a connection from $_[HEAP]{remote_ip}\n";
        $_[HEAP]{client}->put("Smile from the server!");
      },
      ClientInput => sub {
        my $client_input = $_[ARG0];
        $client_input =~ tr[a-zA-Z][n-za-mN-ZA-M];
        $_[HEAP]{client}->put($client_input);
      },
    );
  
    POE::Kernel->run;
    exit;
  
  =head1 DESCRIPTION
  
  POE::Component::Server::TCP implements a generic multi-Session server.
  Simple services may be put together in a few lines of code.  For
  example, a server that echoes input back to the client:
  
    use POE qw(Component::Server::TCP);
    POE::Component::Server::TCP->new(
      Port => 12345,
      ClientInput => sub { $_[HEAP]{client}->put($_[ARG0]) },
    );
    POE::Kernel->run();
  
  =head2 Accepting Connections Yourself
  
  POE::Component::Server::TCP has a default mode where it accepts new
  connections and creates the sessions to handle them.  Programs can do
  this themselves by providing their own C<Acceptor> callbacks.  See
  L</Acceptor> for details.
  
  =head2 Master Listener Session
  
  At creation time, POE::Component::Server::TCP starts one POE::Session
  to listen for new connections.  The component's C<Alias> refers to
  this master session.
  
  If C<Acceptor> is specified, then it's up to that callback to deal
  with newly accepted sockets.  Its parameters are that of
  POE::Wheel::SocketFactory's C<SuccessEvent>.
  
  Otherwise, the default C<Acceptor> callback will start a new session
  to handle each connection.  These child sessions do not have their own
  aliases, but their C<ClientConnected> and C<ClientDisconnected>
  callbacks may be used to register and unregister the sessions with a
  shared namespace, such as a hash keyed on session IDs, or an object
  that manages such a hash.
  
    my %client_namespace;
  
    sub handle_client_connected {
      my $client_session_id = $_[SESSION]->ID;
      $client_namespace{$client_session_id} = \%anything;
    }
  
    sub handle_client_disconnected {
      my $client_session_id = $_[SESSION]->ID;
      $client_namespace{$client_session_id} = \%anything;
    }
  
  The component's C<Started> callback is invoked at the end of the
  master session's start-up routine.  The @_[ARG0..$#_] parameters are
  set to a copy of the values in the server's C<ListenerArgs>
  constructor parameter.  The other parameters are standard for
  POE::Session's _start handlers.
  
  The component's C<Stopped> callback is invoked at the beginning of the
  master session's _stop routine. The parameters are standard for
  POE::Session's _stop handlers.
  
  The component's C<Error> callback is invoked when the server has a
  problem listening for connections.  C<Error> may also be called if the
  component's default acceptor has trouble accepting a connection.
  C<Error> receives the usual ones for L<POE::Wheel::SocketFactory/FailureEvent> and
  L<POE::Wheel::ReadWrite/ErrorEvent>.
  
  =head2 Default Child Connection Sessions
  
  If C<Acceptor> isn't specified, POE::Component::Server::TCP's default
  handler will start a new session for each new client connection.  As
  mentioned above, these child sessions have no aliases of their own,
  but they may set aliases or register themselves another way during
  their C<ClientConnected> and C<ClientDisconnected> callbacks.
  
  It can't be stressed enough that the following callbacks are executed
  within the context of dynamic child sessions---one per client
  connection---and not in the master listening session.  This has been a
  major point of confusion.  We welcome suggestions for making this
  clearer.
  
  =for comment
  TODO - Document some of the implications of having each connection
  handled by a separate session.
  
  The component's C<ClientInput> callback defines how child sessions
  will handle input from their clients.  Its parameters are that of
  POE::Wheel::ReadWrite's C<InputEvent>.
  
  As mentioned C<ClientConnected> is called at the end of the child
  session's C<_start> routine.  The C<ClientConneted> callback receives
  the same parameters as the client session's _start does.  The arrayref
  passed to the constructor's C<Args> parameter is flattened and
  included in C<ClientConnected>'s parameters as @_[ARG0..$#_].
  
    sub handle_client_connected {
      my @constructor_args = @_[ARG0..$#_];
      ...
    }
  
  C<ClientPreConnect> is called before C<ClientConnected>, and its
  purpose is to allow programs to reject connections or condition
  sockets before they're given to POE::Wheel::ReadWrite for management.
  
  The C<ClientPreConnect> handler is called with the client socket in
  $_[ARG0], and its return value is significant.  It must return a
  valid client socket if the connection is acceptable.  It must return
  undef to reject the connection.
  
  Most $_[HEAP] values are valid in the C<ClientPreConnect> handler.
  Obviously, $_[HEAP]{client} is not because that wheel hasn't been
  created yet.
  
  In the following example, the C<ClientPreConnect> handler returns the
  client socket after it has been upgraded to an SSL connection.
  
    sub handle_client_pre_connect {
  
      # Make sure the remote address and port are valid.
      return undef unless validate(
        $_[HEAP]{remote_ip}, $_[HEAP]{remote_port}
      );
  
      # SSLify the socket, which is in $_[ARG0].
      my $socket = eval { Server_SSLify($_[ARG0]) };
      return undef if $@;
  
      # Return the SSL-ified socket.
      return $socket;
    }
  
  C<ClientDisconnected> is called when the client has disconnected,
  either because the remote socket endpoint has closed or the local
  endpoint has been closed by the server.  This doesn't mean the
  client's session has ended, but the session most likely will very
  shortly.  C<ClientDisconnected> is called from a couple disparate
  places within the component, so its parameters are neither consistent
  nor generally useful.
  
  C<ClientError> is called when an error has occurred on the socket.
  Its parameters are those of POE::Wheel::ReadWrite's C<ErrorEvent>.
  
  C<ClientFlushed> is called when all pending output has been flushed to
  the client socket.  Its parameters come from POE::Wheel::ReadWrite's
  C<ErrorEvent>.
  
  =head2 Performance Considerations
  
  This ease of use comes at a price: POE::Component::Server::TCP often
  performs significantly slower than a comparable server written with
  POE::Wheel::SocketFactory and POE::Wheel::ReadWrite.
  
  If performance is your primary goal, POE::Kernel's select_read() and
  select_write() perform about the same as IO::Select, but your code
  will be portable across every event loop POE supports.
  
  =head2 Special Needs Considerations
  
  POE::Component::Server::TCP is written to be easy for the most common
  use cases.  Programs with more special needs should consider using
  POE::Wheel::SocketFactory and POE::Wheel::ReadWrite instead.  These
  are lower-level modules, and using them requires more effort.  They
  are more flexible and customizable, however.
  
  =head1 PUBLIC METHODS
  
  =head2 new
  
  new() starts a server based on POE::Component::Server::TCP and returns
  a session ID for the master listening session.  All error handling is
  done within the server, via the C<Error> and C<ClientError> callbacks.
  
  The server may be shut down by posting a "shutdown" event to the
  master session, either by its ID or the name given to it by the
  C<Alias> parameter.
  
  POE::Component::Server::TCP does a lot of work in its constructor.
  The design goal is to push as much overhead into one-time construction
  so that ongoing run-time has less overhead.  Because of this, the
  server's constructor can take quite a daunting number of parameters.
  
  POE::Component::Server::TCP always returns a POE::Session ID for the
  session that will be listening for new connections.
  
  Many of the constructor parameters have been previously described.
  They are covered briefly again below.
  
  =head3 Server Session Configuration
  
  These constructor parameters affect POE::Component::Server::TCP's main
  listening session.
  
  =for comment
  TODO - Document the shutdown procedure somewhere.
  
  =head4 Acceptor
  
  C<Acceptor> defines a CODE reference that POE::Wheel::SocketFactory's
  C<SuccessEvent> will trigger to handle new connections.  Therefore the
  parameters passed to C<Acceptor> are identical to those given to
  C<SuccessEvent>.
  
  C<Acceptor> is optional; the default handler will create a new session
  for each connection.  All the "Client" constructor parameters are used
  to customize this session.  In other words, C<ClientInput> and such
  B<are not used when C<Acceptor> is set>.
  
  The default C<Acceptor> adds significant convenience and flexibility
  to POE::Component::Server::TCP, but it's not always a good fit for
  every application.  In some cases, a custom C<Acceptor> or even
  rolling one's own server with POE::Wheel::SocketFactory and
  POE::Wheel::ReadWrite may be better and/or faster.
  
    Acceptor => sub {
      my ($socket, $remote_address, $remote_port) = @_[ARG0..ARG2];
      # Set up something to interact with the client.
    }
  
  =head4 Address
  
  C<Address> defines a single interface address the server will bind to.
  It defaults to INADDR_ANY or INADDR6_ANY, when using IPv4 or IPv6,
  respectively.  It is often used with C<Port>.
  
  The value in C<Address> is passed to POE::Wheel::SocketFactory's
  C<BindAddress> parameter, so it may be in whatever form that module
  supports.  At the time of this writing, that may be a dotted IPv4
  quad, an IPv6 address, a host name, or a packed Internet address.  See
  also L</Hostname>.
  
  =for comment
  TODO - Example, using the lines below.
  
    Address => '127.0.0.1'   # Localhost IPv4
    Address => "::1"         # Localhost IPv6
  
  =head4 Alias
  
  C<Alias> is an optional name that will be given to the server's master
  listening session.  Events sent to this name will not be delivered to
  individual connections.
  
  The server's C<Alias> may be important if it's necessary to shut a
  server down.
  
    sub sigusr1_handler {
      $_[KERNEL]->post(chargen_server => 'shutdown');
      $_[KERNEL]->sig_handled();
    }
  
  =head4 Concurrency
  
  C<Concurrency> controls how many connections may be active at the same
  time.  It defaults to -1, which allows POE::Component::Server::TCP to
  accept concurrent connections until the process runs out of resources.
  
  Setting C<Concurrency> to 0 prevents the server from accepting new
  connections.  This may be useful if a server must perform lengthy
  initialization before allowing connections.  When the initialization
  finishes, it can yield(set_concurrency => -1) to enable connections.
  Likewise, a running server may yield(set_concurrency => 0) or any
  other number to dynamically tune its concurrency.  See L</EVENTS> for
  more about the set_concurrency event.
  
  Note: For C<Concurrency> to work with a custom C<Acceptor>, the
  server's listening session must receive a C<disconnected> event
  whenever clients disconnect.  Otherwise the listener cannot mediate
  between its connections.
  
  Example:
  
    Acceptor => sub {
      # ....
      POE::Session->create(
        # ....
        inline_states => {
          _start => sub {
            # ....
            # remember who our parent is
            $_[HEAP]->{server_tcp} = $_[SENDER]->ID;
            # ....
          },
          got_client_disconnect => sub {
            # ....
            $_[KERNEL]->post( $_[HEAP]->{server_tcp} => 'disconnected' );
            # ....
          }
        }
      );
    }
  
  
  =head4 Domain
  
  C<Domain> sets the address or protocol family within which to operate.
  The C<Domain> may be any value that POE::Wheel::SocketFactory
  supports.  AF_INET (Internet address space) is used by default.
  
  Use AF_INET6 for IPv6 support.  This constant is exported by L<Socket>
  or L<Socket6>, depending on your version of Perl. Also be sure to have
  L<Socket::GetAddrInfo> installed, which is required by
  L<POE::Wheel::SocketFactory> for IPv6 support.
  
  =head4 Error
  
  C<Error> is the callback that will be invoked when the server socket
  reports an error.  The Error callback will be used to handle
  POE::Wheel::SocketFactory's FailureEvent, so it will receive the same
  parameters as discussed there.
  
  A default error handler will be provided if Error is omitted.  The
  default handler will log the error to STDERR and shut down the server.
  Active connections will be permitted to complete their transactions.
  
    Error => sub {
      my ($syscall_name, $err_num, $err_str) = @_[ARG0..ARG2];
      # Handle the error.
    }
  
  =head4 Hostname
  
  C<Hostname> is the optional non-packed name of the interface the TCP
  server will bind to.  The hostname will always be resolved via
  inet_aton() and so can either be a dotted quad or a name.  Name
  resolution is a one-time start-up action; there are no ongoing
  run-time penalties for using it.
  
  C<Hostname> guarantees name resolution, where C<Address> does not.
  It's therefore preferred to use C<Hostname> in cases where resolution
  must always be done.
  
  =head4 InlineStates
  
  C<InlineStates> is optional.  If specified, it must hold a hashref of
  named callbacks.  Its syntax is that of POE:Session->create()'s
  inline_states parameter.
  
  Remember: These InlineStates handlers will be added to the client
  sessions, not to the main listening session.  A yield() in the listener
  will not reach these handlers.
  
  If POE::Kernel::ASSERT_USAGE is enabled, the constructor will croak() if it
  detects a state that it uses internally. For example, please use the "Started"
  and "Stopped" callbacks if you want to specify your own "_start" and "_stop"
  events respectively.
  
  =head4 ObjectStates
  
  If C<ObjectStates> is specified, it must holde an arrayref of objects
  and the events they will handle.  The arrayref must follow the syntax
  for POE::Session->create()'s object_states parameter.
  
  Remember: These ObjectStates handlers will be added to the client 
  sessions, not to the main listening session.  A yield() in the listener
  will not reach these handlers.
  
  If POE::Kernel::ASSERT_USAGE is enabled, the constructor will croak() if it
  detects a state that it uses internally. For example, please use the "Started"
  and "Stopped" callbacks if you want to specify your own "_start" and "_stop"
  events respectively.
  
  =head4 PackageStates
  
  When the optional C<PackageStates> is set, it must hold an arrayref of
  package names and the events they will handle  The arrayref must
  follow the syntax for POE::Session->create()'s package_states
  parameter.
  
  Remember: These PackageStates handlers will be added to the client 
  sessions, not to the main listening session.  A yield() in the listener
  will not reach these handlers.
  
  If POE::Kernel::ASSERT_USAGE is enabled, the constructor will croak() if it
  detects a state that it uses internally. For example, please use the "Started"
  and "Stopped" callbacks if you want to specify your own "_start" and "_stop"
  events respectively.
  
  =head4 Port
  
  C<Port> contains the port the listening socket will be bound to.  It
  defaults to 0, which usually lets the operating system pick a
  port at random.
  
    Port => 30023
  
  It is often used with C<Address>.
  
  =head4 Started
  
  C<Started> sets an optional callback that will be invoked within the
  main server session's context.  It notifies the server that it has
  fully started.  The callback's parameters are the usual for a
  session's _start handler.
  
  =head4 Stopped
  
  C<Stopped> sets an optional callback that will be invoked within the
  main server session's context.  It notifies the server that it has
  fully stopped.  The callback's parameters are the usual for a
  session's _stop handler.
  
  =head4 ListenerArgs
  
  C<ListenerArgs> is passed to the listener session as the C<args> parameter.  In
  other words, it must be an arrayref, and the values are passed into the
  C<Started> handler as ARG0, ARG1, etc.
  
  =head3 Connection Session Configuration
  
  These constructor parameters affect the individual sessions that
  interact with established connections.
  
  =head4 ClientArgs
  
  C<ClientArgs> is optional.  When specified, it holds an ARRAYREF that
  will be expanded one level and passed to the C<ClientConnected>
  callback in @_[ARG0..$#_].
  
  =head4 ClientConnected
  
  Each new client connection is handled by a new POE::Session instance.
  C<ClientConnected> is a callback that notifies the application when a
  client's session is started and ready for operation.  Banners are
  often sent to the remote client from this callback.
  
  The @_[ARG0..$#_] parameters to C<ClientConnected> are a copy of the
  values in the C<ClientArgs> constructor parameter's array reference.
  The other @_ members are standard for a POE::Session _start handler.
  
  C<ClientConnected> is called once per session start-up.  It will never
  be called twice for the same connection.
  
    ClientConnected => sub {
      $_[HEAP]{client}->put("Hello, client!");
      # Other client initialization here.
    },
  
  =head4 ClientDisconnected
  
  C<ClientDisconnected> is a callback that will be invoked when the
  client disconnects or has been disconnected by the server.  It's
  useful for cleaning up global client information, such as chat room
  structures.  C<ClientDisconnected> callbacks receive the usual POE
  parameters, but nothing special is included.
  
    ClientDisconnected => sub {
      warn "Client disconnected"; # log it
    }
  
  =head4 ClientError
  
  The C<ClientError> callback is invoked when a client socket reports an
  error.  C<ClientError> is called with POE's usual parameters, plus the
  common error parameters: $_[ARG0] describes what was happening at the
  time of failure.  $_[ARG1] and $_[ARG2] contain the numeric and string
  versions of $!, respectively.
  
  C<ClientError> is optional.  If omitted, POE::Component::Server::TCP
  will provide a default callback that logs most errors to STDERR.
  
  If C<ClientShutdownOnError> is set, the connection will be shut down
  after C<ClientError> returns.  If C<ClientDisconnected> is specified,
  it will be called as the client session is cleaned up.
  
  C<ClientError> is triggered by POE::Wheel::ReadWrite's ErrorEvent, so
  it follows that event's form.  Please see the ErrorEvent documentation
  in POE::Wheel::ReadWrite for more details.
  
    ClientError => sub {
      my ($syscall_name, $error_num, $error_str) = @_[ARG0..ARG2];
      # Handle the client error here.
    }
  
  =head4 ClientFilter
  
  C<ClientFilter> specifies the POE::Filter object or class that will
  parse input from each client and serialize output before it's sent to
  each client.
  
  C<ClientFilter> may be a SCALAR, in which case it should name the
  POE::Filter class to use.  Each new connection will be given a freshly
  instantiated filter of that class.  No constructor parameters will be
  passed.
  
    ClientFilter => "POE::Filter::Stream",
  
  Some filters require constructor parameters.  These may be specified
  by an ARRAYREF.  The first element is the POE::Filter class name, and
  subsequent elements are passed to the class' constructor.
  
    ClientFilter => [ "POE::Filter::Line", Literal => "\n" ],
  
  C<ClientFilter> may also be given an archetypical POE::Filter OBJECT.
  In this case, each new client session will receive a clone() of the
  given object.
  
    ClientFilter => POE::Filter::Line->new(Literal => "\n"),
  
  C<ClientFilter> is optional.  The component will use
  "POE::Filter::Line" if it is omitted.  There is L</ClientInputFilter>
  and L</ClientOutputFilter> if you want to specify a different filter
  for both directions.
  
  Filter modules are not automatically loaded.  Be sure that the program
  loads the class before using it.
  
  =head4 ClientFlushed
  
  C<ClientFlushed> exposes POE::Wheel::ReadWrite's C<FlushedEvent> as a
  callback.  It is called whenever the client's output buffer has been
  fully flushed to the client socket.  At this point it's safe to shut
  down the socket without losing data.
  
  C<ClientFlushed> is useful for streaming servers, where a "flushed"
  event signals the need to send more data.
  
    ClientFlushed => sub {
      my $data_source = $_[HEAP]{file_handle};
      my $read_count = sysread($data_source, my $buffer = "", 65536);
      if ($read_count) {
        $_[HEAP]{client}->put($buffer);
      }
      else {
        $_[KERNEL]->yield("shutdown");
      }
    },
  
  POE::Component::Server::TCP's default C<Acceptor> ensures that data is
  flushed before finishing a client shutdown.
  
  =head4 ClientInput
  
  C<ClientInput> defines a per-connection callback to handle client
  input.  This callback receives its parameters directly from
  POE::Wheel::ReadWrite's C<InputEvent>.  ARG0 contains the input
  record, the format of which is defined by C<ClientFilter> or
  C<ClientInputFilter>.  ARG1 has the wheel's unique ID, and so on.
  Please see POE:Wheel::ReadWrite for an in-depth description of
  C<InputEvent>.
  
  C<ClientInput> and C<Acceptor> are mutually exclusive.  Enabling one
  prohibits the other.
  
    ClientInput => sub {
      my $input = $_[ARG0];
      $_[HEAP]{wheel}->put("You said: $input");
    },
  
  =head4 ClientInputFilter
  
  C<ClientInputFilter> is used with C<ClientOutputFilter> to specify
  different protocols for input and output.  Both must be used together.
  Both follow the same usage as L</ClientFilter>.  Overrides the filter set
  by L</ClientFilter>.
  
    ClientInputFilter  => [ "POE::Filter::Line", Literal => "\n" ],
    ClientOutputFilter => 'POE::Filter::Stream',
  
  =head4 ClientOutputFilter
  
  C<ClientOutputFilter> is used with C<ClientInputFilter> to specify
  different protocols for input and output.  Both must be used together.
  Both follow the same usage as L</ClientFilter>.  Overrides the filter set
  by L</ClientFilter>.
  
    ClientInputFilter  => POE::Filter::Line->new(Literal => "\n"),
    ClientOutputFilter => 'POE::Filter::Stream',
  
  =head4 ClientShutdownOnError
  
  C<ClientShutdownOnError> tells the component whether client
  connections should be shut down automatically if an error is detected.
  It defaults to "true".  Setting it to false (0, undef, "") turns off
  this feature.
  
  The application is responsible for dealing with client errors if this
  feature is disabled.  Not doing so may cause the component to emit a
  constant stream of errors, eventually bogging down the application
  with dead connections that spin out of control.
  
  Yes, this is terrible.  You have been warned.
  
  =head4 SessionParams
  
  C<SessionParams> specifies additional parameters that will be passed
  to the C<SessionType> constructor at creation time.  It must be an
  array reference.
  
    SessionParams => [ options => { debug => 1, trace => 1 } ],
  
  Note: POE::Component::Server::TCP supplies its own POE::Session
  constructor parameters.  Conflicts between them and C<SessionParams>
  may cause the component to behave erratically.  To avoid such
  problems, please limit SessionParams to the C<options> hash.  See
  L<POE::Session> for an known options.
  
  We may enable other options later.  Please let us know if you need
  something.
  
  =head4 SessionType
  
  C<SessionType> specifies the POE::Session subclass that will be
  created for each new client connection.  "POE::Session" is the
  default.
  
    SessionType => "POE::Session::MultiDispatch"
  
  =head1 EVENTS
  
  It's possible to manipulate a TCP server component by sending it
  messages.
  
  =head2 Main Server Commands
  
  These events must be sent to the main server, usually by the alias set
  in its L<Alias> parameter.
  
  =head3 disconnected
  
  The "disconnected" event informs the TCP server that a connection was
  closed.  It is needed when using L</Concurrency> with an L</Acceptor>
  callback.  The custom Acceptor must provide its own disconnect
  notification so that the server's connection counting logic works.
  
  Otherwise Concurrency clients will be accepted, and then no more.  The
  server will never know when clients have disconnected.
  
  =head3 set_concurrency
  
  "set_concurrency" set the number of simultaneous connections the
  server will be willing to accept.  See L</Concurrency> for more
  details.  "set_concurrency" must have one parameter: the new maximum
  connection count.
  
    $kernel->call("my_server_alias", "set_concurrency", $max_count);
  
  =head3 shutdown
  
  The "shutdown" event starts a graceful server shutdown.  No new
  connections will be accepted.  Existing connections will be allowed to
  finish.  The server will be destroyed after the last connection ends.
  
  =head2 Per-Connection Commands
  
  These commands affect each client connection session.
  
  =head3 shutdown
  
  Sending "shutdown" to an individual client session instructs the
  server to gracefully shut down that connection.  No new input will be
  received, and any buffered output will be sent before the session
  ends.
  
  Client sessions usually yield("shutdown") when they wish to disconnect
  the client.
  
    ClientInput => sub {
      if ($_[ARG0] eq "quit") {
        $_[HEAP]{client}->put("B'bye!");
        $_[KERNEL]->yield("shutdown");
        return;
      }
  
      # Handle other input here.
    },
  
  =head1 Reserved HEAP Members
  
  Unlike most POE modules, POE::Component::Server::TCP stores data in
  the client sessions' HEAPs.  These values are provided as conveniences
  for application developers.
  
  =head2 HEAP Members for Master Listening Sessions
  
  The master listening session holds different data than client
  connections.
  
  =head3 alias
  
  $_[HEAP]{alias} contains the server's Alias.
  
  =head3 concurrency
  
  $_[HEAP]{concurrency} remembers the server's C<Concurrency> parameter.
  
  =head3 connections
  
  $_[HEAP]{connections} is used to track the current number of
  concurrent client connections.  It's incremented whenever a new
  connection is accepted, and it's decremented whenever a client
  disconnects.
  
  =head3 listener
  
  $_[HEAP]{listener} contains the POE::Wheel::SocketFactory object used
  to listen for connections and accept them.
  
  =head2 HEAP Members for Connection Sessions
  
  These data members exist within the individual connections' sessions.
  
  =head3 client
  
  $_[HEAP]{client} contains a POE::Wheel::ReadWrite object used to
  interact with the client.  All POE::Wheel::ReadWrite methods work.
  
  =head3 got_an_error
  
  $_[HEAP]{got_an_error} remembers whether the client connection has
  already encountered an error.  It is part of the shutdown-on-error
  procedure.
  
  =head3 remote_ip
  
  $_[HEAP]{remote_ip} contains the remote client's numeric address in
  human-readable form.
  
  =head3 remote_port
  
  $_[HEAP]{remote_port} contains the remote client's numeric socket port
  in human-readable form.
  
  =head3 remote_addr
  
  $_[HEAP]{remote_addr} contains the remote client's packed socket
  address in computer-readable form.
  
  =head3 shutdown
  
  $_[HEAP]{shutdown} is true if the client is in the process of shutting
  down.  The component uses it to ignore client input during shutdown,
  and to close the connection after pending output has been flushed.
  
  =head3 shutdown_on_error
  
  $_[HEAP]{shutdown_on_error} remembers whether the client connection
  should automatically shut down if an error occurs.
  
  =head1 SEE ALSO
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  L<POE::Component::Client::TCP> is the client-side counterpart to this
  module.
  
  This component uses and exposes features from L<POE::Filter>,
  L<POE::Wheel::SocketFactory>, and L<POE::Wheel::ReadWrite>.
  
  =head1 BUGS
  
  This looks nothing like what Ann envisioned.
  
  This component currently does not accept many of the options that
  POE::Wheel::SocketFactory does.
  
  This component will not bind to several addresses at once.  This may
  be a limitation in SocketFactory, but it's not by design.
  
  This component needs better error handling.
  
  Some use cases require different session classes for the listener and
  the connection handlers.  This isn't currently supported.  Please send
  patches. :)
  
  =for comment
  TODO - Document that Reuse is set implicitly.
  
  =head1 AUTHORS & COPYRIGHTS
  
  POE::Component::Server::TCP is Copyright 2000-2013 by Rocco Caputo.
  All rights are reserved.  POE::Component::Server::TCP is free
  software, and it may be redistributed and/or modified under the same
  terms as Perl itself.
  
  POE::Component::Server::TCP is based on code, used with permission,
  from Ann Barcomb E<lt>kudra@domaintje.comE<gt>.
  
  POE::Component::Server::TCP is based on code, used with permission,
  from Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_COMPONENT_SERVER_TCP

$fatpacked{"POE/Component/Syndicator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_COMPONENT_SYNDICATOR';
  package POE::Component::Syndicator;
  BEGIN {
    $POE::Component::Syndicator::AUTHORITY = 'cpan:HINRIK';
  }
  BEGIN {
    $POE::Component::Syndicator::VERSION = '0.06';
  }
  
  use strict;
  use warnings FATAL => 'all';
  use Carp qw(carp croak);
  use Object::Pluggable::Constants qw(:ALL);
  use POE;
  use base 'Object::Pluggable';
  
  use constant REFCOUNT_TAG => 'POE::Component::Syndicator registered';
  
  sub _pluggable_event {
      my ($self, $event, @args) = @_;
      $self->send_event($event, @args);
      return;
  }
  
  sub _syndicator_init {
      my ($self, %args) = @_;
  
      $args{prefix} = 'syndicator_' if !defined $args{prefix};
      $self->{_syndicator}{prefix} = $args{prefix};
  
      if (defined $args{types}) {
          croak("'types' argument must be an array") if ref $args{types} ne 'ARRAY';
          if (@{ $args{types} } == 4) {
              $self->{_syndicator}{server_event} = $args{types}[0];
              $self->{_syndicator}{user_event} = $args{types}[2];
              $args{types} = { @{ $args{types} } };
          }
          elsif (@{ $args{types} } == 2) {
              $self->{_syndicator}{server_event} = $args{types}[0];
              $self->{_syndicator}{user_event} = $args{types}[1];
          }
          else {
              croak('Only two event types are supported');
          }
      }
      else {
          $args{types} = { SERVER => 'S', USER => 'U' };
          $self->{_syndicator}{server_event} = 'SERVER';
          $self->{_syndicator}{user_event} = 'USER';
      }
  
      # set up the plugin system
      $self->_pluggable_init(
          prefix     => delete $args{prefix},
          reg_prefix => delete $args{reg_prefix},
          debug      => delete $args{debug},
          types      => delete $args{types},
      );
  
      if (ref $args{object_states} eq 'ARRAY') {
          my $start_stop = "Don't install handlers for _start or _stop. Use"
                      . "_syndicator_started or _syndicator_stopped instead";
          my $reg_unreg = "Don't install handlers for register or unregister."
                          . " Those are handled by POE::Component::Syndicator";
  
          for (my $i = 1; $i <= $#{ $args{object_states} }; $i += 2) {
              my $events = $args{object_states}[$i];
              if (ref $events eq 'HASH') {
                  if (defined $events->{_start} || defined $events->{_stop}) {
                      croak($start_stop);
                  }
                  elsif (defined $events->{register} || defined $events->{unregister}) {
                      croak($reg_unreg);
                  }
              }
              elsif (ref $events eq 'ARRAY') {
                  for my $event (@$events) {
                      if ($event eq '_start' || $event eq '_stop') {
                          croak($start_stop);
                      }
                      elsif ($event eq 'register' || $event eq 'unregister') {
                          croak($reg_unreg);
                      }
                  }
              }
          }
      }
  
      # set up our POE session
      POE::Session->create(
          object_states => [
              $self => {
                  _start     => '_syndicator_start',
                  _default   => '_syndicator_default',
                  _stop      => '_syndicator_stop',
                  register   => '_syndicator_register',
                  unregister => '_syndicator_unregister',
              },
              $self => [qw(
                  _syndicator_shutdown
                  _syndicator_send_pending_events
                  _syndicator_delay
                  _syndicator_delay_remove
                  _syndicator_sig_register
                  _syndicator_sig_shutdown
                  _syndicator_sig_die
              )],
              ($args{object_states} ? @{ $args{object_states} } : ()),
          ],
          ($args{options} ? (options => delete $args{options}) : ()),
          args => [%args],
          heap => $self,
      );
  
      return;
  }
  
  sub _syndicator_sig_die {
      my ($kernel, $self, $ex) = @_[KERNEL, OBJECT, ARG1];
      chomp $ex->{error_str};
  
      my $error = "Event $ex->{event} in session ".$ex->{dest_session}->ID
          ." raised exception:\n    $ex->{error_str}";
  
      warn $error, "\n";
      $kernel->sig_handled();
      return;
  }
  
  sub _syndicator_destroy {
      my ($self, @args) = @_;
      $self->call('_syndicator_shutdown', @args);
      return;
  }
  
  sub _syndicator_shutdown {
      my ($kernel, $self, @args) = @_[KERNEL, OBJECT, ARG0..$#_];
      return if $self->{_shutting_down};
      $kernel->alarm_remove_all();
      $self->_pluggable_destroy();
      $self->send_event($self->{_syndicator}{prefix} . 'shutdown', @args);
      $self->{_shutting_down} = 1;
      return;
  }
  
  sub _syndicator_start {
      my ($kernel, $sender, $session, $self, %args)
          = @_[KERNEL, SENDER, SESSION, OBJECT, ARG0..$#_];
  
      $kernel->sig('DIE', '_syndicator_sig_die');
      $self->{_syndicator}{session_id} = $session->ID();
  
      # set an alias to keep our session alive
      if (defined $args{alias}) {
          $kernel->alias_set($args{alias});
          $self->{_syndicator}{session_alias} = $args{alias};
      }
      else {
          $kernel->alias_set("$self");
          $self->{_syndicator}{session_alias} = "$self";
      }
  
      $args{register_signal} = 'SYNDICATOR_REGISTER' if !defined $args{register_signal};
      $kernel->sig($args{register_signal}, '_syndicator_sig_register');
      $args{shutdown_signal} = 'SYNDICATOR_SHUTDOWN' if !defined $args{shutdown_signal};
      $kernel->sig($args{shutdown_signal}, '_syndicator_sig_shutdown');
  
      # if called from a parent session, register the parent for all events
      # and detach our session from the parent
      if ($sender != $kernel) {
          my $sender_id = $sender->ID;
          my $prefix = $self->{_syndicator}{prefix};
          $self->{_syndicator}{events}{all}{$sender_id} = $sender_id;
          $self->{_syndicator}{sessions}{$sender_id}{ref} = $sender_id;
          $self->{_syndicator}{sessions}{$sender_id}{refcnt}++;
          $kernel->refcount_increment($sender_id, REFCOUNT_TAG);
          $kernel->post($sender, "${prefix}registered", $self);
          $kernel->detach_myself();
      }
  
      $kernel->call($session, 'syndicator_started');
      return;
  }
  
  sub _syndicator_default {
      my ($self, $event, $args) = @_[OBJECT, ARG0, ARG1];
      return if $event =~ /^_/;
      return if $event =~ /^syndicator_(?:started|stopped)$/;
      $self->send_user_event($event, [@$args]);
      return;
  }
  
  sub _syndicator_stop {
      my ($kernel, $self) = @_[KERNEL, OBJECT];
      $kernel->call($self->{_syndicator}{session_id}, 'syndicator_stopped');
      return;
  }
  
  sub _syndicator_unregister_sessions {
      my ($self) = @_;
  
      for my $session_id ( keys %{ $self->{_syndicator}{sessions} } ) {
          my $refcnt = $self->{_syndicator}{sessions}{$session_id}{refcnt};
          while ($refcnt-- > 0) {
              $poe_kernel->refcount_decrement($session_id, REFCOUNT_TAG);
          }
          delete $self->{_syndicator}{sessions}{$session_id};
      }
  
      return;
  }
  
  sub yield {
      my ($self, @args) = @_;
      $poe_kernel->post($self->{_syndicator}{session_id}, @args);
      return;
  }
  
  sub _syndicator_sig_register {
      my ($kernel, $self, $session, $signal, $sender, @events)
          = @_[KERNEL, OBJECT, SESSION, ARG0..$#_];
  
      if (!@events || !defined $sender) {
          warn "Signal $signal: not enough arguments\n";
          return;
      }
  
      my $sender_id;
      if (my $ref = $kernel->alias_resolve($sender)) {
          $sender_id = $ref->ID();
      }
      else {
          warn "Signal $signal: can't resolve sender $sender\n";
          return;
      }
  
      $self->_syndicator_reg($sender_id, @events);
      return;
  }
  
  sub _syndicator_sig_shutdown {
      my ($kernel, $self, @args) = @_[KERNEL, OBJECT, ARG2..$#_];
      $kernel->yield('shutdown', @args) if !$self->{_shutdown_event_sent};
      $self->{_shutdown_event_sent} = 1;
      return;
  }
  
  sub _syndicator_register {
      my ($kernel, $self, $session, $sender, @events)
          = @_[KERNEL, OBJECT, SESSION, SENDER, ARG0 .. $#_];
  
      @events = 'all' if !@events;
      my $sender_id = $sender->ID();
      $self->_syndicator_reg($sender_id, @events);
      return;
  }
  
  sub _syndicator_reg {
      my ($self, $sender_id, @events) = @_;
      my $prefix = $self->{_syndicator}{prefix};
  
      for my $event (@events) {
          $self->{_syndicator}{events}{$event}{$sender_id} = $sender_id;
          $self->{_syndicator}{sessions}{$sender_id}{ref} = $sender_id;
  
          if (!$self->{_syndicator}{sessions}{$sender_id}{refcnt}
              && $sender_id ne $self->{_syndicator}{session_id}) {
              $poe_kernel->refcount_increment($sender_id, REFCOUNT_TAG);
          }
  
          $self->{_syndicator}{sessions}{$sender_id}{refcnt}++;
      }
  
      # BINGOS:
      # Apocalypse is gonna hate me for this as 'registered' events will bypass
      # the plugin system, but I can't see how this event will be relevant
      # without some sort of reference, like what session has registered. I'm
      # not going to start hurling session references around at this point :)
      $poe_kernel->post($sender_id, "${prefix}registered", $self);
      return;
  }
  
  sub _syndicator_unregister {
      my ($kernel, $self, $session, $sender, @events)
          = @_[KERNEL, OBJECT, SESSION, SENDER, ARG0 .. $#_];
  
      @events = 'all' if !@events;
      my $sender_id = $sender->ID();
      my $prefix = $self->{_syndicator}{prefix};
  
      for my $event (@events) {
          my $blah = delete $self->{_syndicator}{events}{$event}{$sender_id};
          if (!defined $blah) {
              warn "Sender $sender_id hasn't registered for '$event' events";
              next;
          }
          if (!keys %{ $self->{_syndicator}{events}{$event} }) {
              delete $self->{_syndicator}{events}{$event};
          }
  
          if (--$self->{_syndicator}{sessions}{$sender_id}{refcnt} <= 0) {
              delete $self->{_syndicator}{sessions}{$sender_id};
              if ($session != $sender) {
                  $kernel->refcount_decrement($sender_id, REFCOUNT_TAG);
              }
          }
      }
  
      return;
  }
  
  sub delay {
      my ($self, $arrayref, $time) = @_;
  
      if (!defined $arrayref || ref $arrayref ne 'ARRAY' || !@$arrayref) {
          croak('First argument to delay() must be a populated ARRAYREF');
      }
  
      croak('No time specified') if !defined $time;
  
      return $self->call('_syndicator_delay', [@$arrayref], $time);
  }
  
  sub _syndicator_delay {
      my ($kernel, $self, $arrayref, $time) = @_[KERNEL, OBJECT, ARG0, ARG1];
  
      my $event = shift @$arrayref;
      my $alarm_id = $kernel->delay_set($event, $time, @$arrayref);
      if ($alarm_id) {
          my $prefix = $self->{_syndicator}{prefix};
          $self->send_event("${prefix}delay_set", $alarm_id, $event, @$arrayref);
      }
      return $alarm_id;
  }
  
  sub delay_remove {
      my ($self, $alarm_id) = @_;
      croak('No alarm id specified') if !defined $alarm_id;
      return $self->call('_syndicator_delay_remove', $alarm_id);
  }
  
  sub _syndicator_delay_remove {
      my ($kernel, $self, $alarm_id) = @_[KERNEL, OBJECT, ARG0];
  
      my @old_alarm_list = $kernel->alarm_remove($alarm_id);
      if (@old_alarm_list) {
          my $args = $old_alarm_list[-1];
          my $prefix = $self->{_syndicator}{prefix};
          $self->send_event("${prefix}delay_removed", $alarm_id, $args);
          return $args;
      }
  
      return;
  }
  
  sub call {
      my ($self, @args) = @_;
      return $poe_kernel->call($self->{_syndicator}{session_id}, @args);
  }
  
  sub session_id {
      my ($self) = @_;
      return $self->{_syndicator}{session_id};
  }
  
  sub session_alias {
      my ($self) = @_;
      return $self->{_syndicator}{session_alias};
  }
  
  sub send_user_event {
      my ($self, $event, $args) = @_;
  
      push @{ $self->{_syndicator}{pending_events} }, [];
      my $user_type = $self->{_syndicator}{user_event};
      my $eat = $self->_pluggable_process($user_type, $event, $args);
      $self->call('_syndicator_send_pending_events');
      return $eat;
  }
  
  sub send_event {
      my ($self, $event, @args) = @_;
      $self->yield('_syndicator_send_pending_events', $event, @args);
      return;
  }
  
  sub send_event_now {
      my ($self, $event, @args) = @_;
      $self->call('_syndicator_send_pending_events', $event, @args);
      return;
  }
  
  sub send_event_next {
      my ($self, $event, @args) = @_;
  
      if (!$self->{_syndicator}{pending_events}
          || !@{ $self->{_syndicator}{pending_events} }) {
          croak('send_event_next() can only be called from an event handler');
      }
      else {
          $event =~ s/^\Q$self->{_syndicator}{prefix}//;
          push @{ $self->{_syndicator}{pending_events}[-1] }, [$event, \@args];
      }
      return;
  }
  
  sub _syndicator_send_pending_events {
      my ($kernel, $session, $self, $new_event, @args)
          = @_[KERNEL, SESSION, OBJECT, ARG0, ARG1..$#_];
      my $session_id = $session->ID();
      my %sessions;
      my $prefix = $self->{_syndicator}{prefix};
  
      # create new context if we were passed an event directly
      if (defined $new_event) {
          $new_event =~ s/^\Q$prefix//;
          my @our_events = [$new_event, \@args];
          push @{ $self->{_syndicator}{pending_events} }, \@our_events;
      }
  
      while (my ($ev) = shift @{ $self->{_syndicator}{pending_events}[-1] }) {
          last if !defined $ev;
          my ($event, $args) = @$ev;
  
          my @ids = (
              (exists $self->{_syndicator}{events}{all}
                  ? values %{ $self->{_syndicator}{events}{all} }
                  : ()),
              (exists $self->{_syndicator}{events}{$event}
                  ? values %{ $self->{_syndicator}{events}{$event} }
                  : ()),
          );
  
          $sessions{$_} = $_ for @ids;
  
          # Make sure our session gets notified of any requested events before
          # any other bugger
          if (delete $sessions{$session_id}) {
              $kernel->call($session_id, "$prefix$event", @$args);
          }
  
          # then let the plugin system process this
          my $server_type = $self->{_syndicator}{server_event};
          if ($self->_pluggable_process($server_type, $event, $args) != PLUGIN_EAT_ALL) {
              # and finally, let registered sessions process it
              for my $session (values %sessions) {
                  # We have to use call() here to maintain consistency, for
                  # example if a subclass maintains state which needs to make
                  # sense at the time this event is delivered (e.g.
                  # POE::Component::IRC::State). But this is not good if the
                  # user decides to use $poe_kernel->run_while() (which
                  # POE::Quickie and LWP::UserAgent::POE do). But then again
                  # that's a risk for everyone using call(), and the user
                  # should know not to use such modules in event handlers
                  # which might get call()ed by foreign sessions.
                  $kernel->call($session, "$prefix$event", @$args);
              }
          }
  
          # unregister all sessions if we're shutting down
          if ($event eq 'shutdown') {
              $self->_syndicator_unregister_sessions();
          }
      }
  
      pop @{ $self->{_syndicator}{pending_events} };
      return;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Component::Syndicator - A POE component base class which implements the Observer pattern
  
  =head1 SYNOPSIS
  
   package POE::Component::IRC;
  
   use strict;
   use warnings;
   use POE;
   use base 'POE::Component::Syndicator';
  
   # our constructor
   sub spawn {
       my ($package, %args) = @_;
  
       # process arguments...
  
       my $self = bless \%args, $package;
  
       # set up our plugin system and POE session
       $self->_syndicator_init(
           prefix        => 'irc_',
           reg_prefix    => 'PCI_',
           types         => [SERVER => 'S', USER => 'U'],
           object_states => [qw(
               syndicator_started
               shutdown
           )],
       );
  
       return $self;
   }
  
   sub syndicator_started {
       my ($kernel, $self) = @_[KERNEL, OBJECT];
  
       # connect to a server, etc...
   }
  
   # plugin handler for SERVER event 'hlagh'
   sub S_hlagh {
       # ...
   }
  
   sub shutdown {
       my ($kernel, $self) = @_[KERNEL, OBJECT];
  
       # disconnect from a server, etc...
  
       # shut down the syndicator
       $self->_syndicator_destroy();
   }
  
  =head1 DESCRIPTION
  
  POE::Component::Syndicator is a base class for POE components which need
  to handle a persistent resource (e.g. a connection to an IRC server) for
  one or more sessions in an extendable way.
  
  This module (as well as L<Object::Pluggable|Object::Pluggable>, which this
  module inherits from) was born out of
  L<POE::Component::IRC|POE::Component::IRC>, the guts of which quickly
  spread to other POE components. Now they can all inherit from this module
  instead.
  
  The component provides an event queue, which can be managed with the methods
  documented below. It handles delivery of events to the object itself, all
  interested plugins, and all interested sessions.
  
  =head2 Component lifetime
  
  You start by calling L<C<_syndicator_init>|/_syndicator_init>, which will
  create a POE session with your object as its heap, and a few event handlers
  installed. The events described in L</Local events> delimit the start and
  end of the session's lifetime. In between those, interested plugins and
  sessions will receive various events, usually starting with
  L<C<syndicator_registered>|/_syndicator_registered>. In this phase, your
  subclass and plugins can call the L<methods|/METHODS> and send the
  L<events|/Input events> documented below. When the component has been shut
  down, sessions (but not plugins) will receive a
  L<C<syndicator_shutdown>|/_syndicator_shutdown> event. After this, the
  component will become unusable.
  
  =head2 A note on events
  
  In this document, an I<event> (unless explicitly referred to as a I<POE event>)
  is defined as a message originating from POE::Component::Syndicator, delivered
  to plugins (and the subclass) via plugin methods and to registered sessions as
  POE events.
  
  Interested sessions are considered consumers only, so they always receive
  copies of event arguments, whereas interested plugins and subclasses receive
  scalar references to them. This allows them to alter, add, or remove event
  arguments before sessions (or even other plugins) receive them. For more
  information about plugins, see L<Object::Pluggable|Object::Pluggable>'s
  documentation. A subclass does not have to register for plugin events.
  
  Two event types are supported: SERVER and USER, though their names can be
  overriden (see L<C<_syndicator_init>|/_syndicator_init>).
  
  =head3 SERVER events
  
  These represent data received from the network or some other outside resource
  (usually a server, hence the default name).
  
  SERVER events are generated by the L<C<send_event*>|/send_event> methods.
  These events are delivered to the subclass and plugins (method C<S_foo>) and
  interested sessions (event C<syndicator_foo>).
  
  =head3 USER events
  
  These represent commands about to be sent to a server or some other resource.
  
  USER events are generated by L<C<send_user_event>|/send_user_event>. In
  addition, all POE events sent to this component's session (e.g. with
  L<C<yield>|/yield>) which do not have a handler will generate corresponding
  USER events. USER events are considered more private, so they are only
  delivered to the subclass and plugins, not to sessions.
  
  =head1 PRIVATE METHODS
  
  The following methods should only be called by a subclass.
  
  =head2 C<_syndicator_init>
  
  You should call this in your constructor. It initializes
  L<Object::Pluggable|Object::Pluggable>, creates the Syndicator's POE session,
  and calls the L<C<syndicator_started>|/syndicator_started> POE events. It
  takes the following arguments:
  
  B<'prefix'>, a prefix for all your event names, when sent to interested
  sessions. If you don't supply this, L<Object::Pluggable|Object::Pluggable>'s
  default (B<'pluggable'>) will be used.
  
  B<'reg_prefix'>, the prefix for the C<register()>/C<unregister()>
  plugin methods  If you don't supply this, L<Object::Pluggable|Object::Pluggable>'s
  default (B<'plugin_'>) will be used.
  
  B<'debug'>, a boolean, if true, will cause a warning to be printed
  every time a plugin event handler raises an exception.
  
  B<'types'>, a 2-element arrayref of the types of events that your
  component will support, or a 4-element (2 pairs) arrayref where the event
  types are keys and their abbrevations (used as plugin event method prefixes)
  are values (see L</A note on events> and L<Object::Pluggable|Object::Pluggable>
  for more information). The two event types are fundamentally different, so
  make sure you supply them in the right order. If you don't provide this
  argument, C<< [ SERVER => 'S', USER => 'U' ] >> will be used.
  
  B<'register_signal'>, the name of the register signal (see L</SIGNALS>).
  Defaults to B<'SYNDICATOR_REGISTER'>.
  
  B<'shutdown_signal'>, the name of the shutdown signal (see L</SIGNALS>).
  Defaults to B<'SYNDICATOR_SHUTDOWN'>.
  
  B<'object_states'> an arrayref of additional object states to add to
  the POE session. Same as the 'object_states' argument to
  L<POE::Session|POE::Session>'s C<create> method. You'll want to add a handler
  for at least the L<C<syndicator_started>|/syndicator_started> event.
  
  B<'options'>, a hash of options for L<POE::Session|POE::Session>'s
  constructor.
  
  If you call C<_syndicator_init> from inside another POE session, the
  component will automatically register that session as wanting all events.
  That session will first receive a
  L<C<syndicator_registered>|/syndicator_registered> event.
  
  =head2 C<_syndicator_destroy>
  
  Call this method when you want Syndicator to clean up (delete all plugins,
  etc) and make sure it won't keep the POE session alive after all remaining
  events have been processed. A L<C<syndicator_shutdown>|/syndicator_shutdown>
  event (or similar, depending on the prefix you chose) will be generated.
  Any argument passed to C<_syndicator_destroy> will be passed along with that
  event.
  
  B<Note:> this method will clear all alarms for the POE session.
  
  =head1 PUBLIC METHODS
  
  =head2 C<session_id>
  
  Returns the component's POE session id.
  
  =head2 C<session_alias>
  
  Returns the component's POE session alias.
  
  =head2 C<yield>
  
  This method provides an alternative, object-based means of posting events to the
  component. First argument is the event to post, following arguments are sent as
  arguments to the resultant post.
  
  =head2 C<call>
  
  This method provides an alternative, object-based means of calling events to the
  component. First argument is the event to call, following arguments are sent as
  arguments to the resultant call.
  
  =head2 C<send_event>
  
  Adds a new SERVER event onto the end of the queue. The event will be
  processed after other pending events, if any. First argument is an event name,
  the rest are the event arguments.
  
   $component->send_event('irc_public, 'foo!bar@baz.com', ['#mychan'], 'message');
  
  =head2 C<send_event_next>
  
  Adds a new SERVER event to the start of the queue. The event will be the next
  one to be processed. First argument is an event name, the rest are the event
  arguments.
  
  =head2 C<send_event_now>
  
  Sends a new SERVER event immediately. Execution of the current POE event will
  be suspended (i.e. this call will block) until the new event has been
  processed by the component class and all plugins. First argument is an event
  name, the rest are the event arguments.
  
  =head2 C<send_user_event>
  
  Sends a new USER event immediately. You should call this before every command
  you send to your remote server/resource. Only the subclass and plugins will
  see this event. Takes two arguments, an event name and an arrayref of
  arguments. Returns one of the C<EAT> constants listed in
  L<Object::Pluggable::Constants|Object::Pluggable::Constants>. After this
  method returns, the arrayref's contents may have been modified by the
  subclass or plugins.
  
   $component->send_user_event('PRIVMSG', '#mychan', 'message');
  
  =head2 C<delay>
  
  This method provides a way of posting delayed events to the component. The
  first argument is an arrayref consisting of the delayed command to post and
  any command arguments. The second argument is the time in seconds that one
  wishes to delay the command being posted.
  
   my $alarm_id = $component->delay(['mode', $channel, '+o', $dude], 60);
  
  =head2 C<delay_remove>
  
  This method removes a previously scheduled delayed event from the component.
  Takes one argument, the C<alarm_id> that was returned by a
  L<C<delay>|/delay> method call. Returns an arrayref of arguments to the
  event that was originally requested to be delayed.
  
   my $arrayref = $component->delay_remove($alarm_id);
  
  =head1 EVENTS
  
  =head2 Local events
  
  The component will send the following POE events to its session.
  
  =head3 C<syndicator_started>
  
  Called after the session has been started (like C<_start> in
  L<POE::Kernel|POE::Kernel/Session Management>. This is where you should do
  your POE-related setup work such as adding new event handlers to the session.
  
  =head3 C<syndicator_stopped>
  
  Called right before the session is about to die (like C<_stop> in
  L<POE::Kernel|POE::Kernel/Session Management>).
  
  =head2 Input events
  
  Other POE sessions can send the following POE events to the Syndicator's
  session.
  
  =head3 C<register>
  
  Takes any amount of arguments: a list of event names that your session wants
  to listen for, minus the prefix (specified in
  L<C<syndicator_init>/_syndicator_init>).
  
   $kernel->post('my syndicator', 'register', qw(join part quit kick));
  
  Registering for the special event B<'all'> will cause it to send all
  events to your session. Calling it with no event names is equivalent to
  calling it with B<'all'> as an argumente.
  
  Registering will generate a L<C<syndicator_registered>|/syndicator_registered>
  event that your session can trap.
  
  Registering with multiple component sessions can be tricky, especially if
  one wants to marry up sessions/objects, etc. Check the L<SIGNALS|/SIGNALS>
  section for an alternative method of registering with multiple components.
  
  =head3 C<unregister>
  
  Takes any amount of arguments: a list of event names which you I<don't> want
  to receive. If you've previously done a L<C<register>|/register>
  for a particular event which you no longer care about, this event will
  tell the component to stop sending them to you. (If you haven't, it just
  ignores you. No big deal.) Calling it with no event names is equivalent to
  calling it with B<'all'> as an argument.
  
  If you have registered for the special event B<'all'>, attempting to
  unregister individual events will not work. This is a 'feature'.
  
  =head3 C<shutdown>
  
  By default, POE::Component::Syndicator sessions never go away. You can send
  its session a C<shutdown> event manually to make it delete itself.
  Terminating multiple Syndicators can be tricky. Check the L</SIGNALS> section
  for a method of doing that.
  
  =head3 C<_default>
  
  Any POE events sent to the Syndicator's session which do not have a handler
  will go to the Syndicator's C<_default> handler, will generate
  L</USER events> of the same name. If you install your own C<_default>
  handler, make sure you do the same thing before you handle an event:
  
   use Object::Pluggable::Constants 'PLUGIN_EAT_ALL';
  
   $poe_kernel->state('_default', $self, '__default');
  
   sub __default {
       my ($self, $event, $args) = @_[OBJECT, ARG0, ARG1];
  
       # do nothing if a plugin eats the event
       return if $self->send_user_event($event, [@$args]) == PLUGIN_EAT_ALL;
  
       # handle the event
       # ...
   }
  
  Note that the handler for the C<_default> event must be named something other
  than '_default', because that name is reserved for the plugin-type default
  handler (see the L<Object::Pluggable|Object::Pluggable/PLUGINS> docs).
  
  =head2 Output events
  
  The Syndicator will send the following events at various times. The
  B<'syndicator_'> prefix in these event names can be customized with a
  B<'prefix'> argument to L<C<_syndicator_init>/_syndicator_init>.
  
  =head3 C<syndicator_registered>
  
  Sent once to the requesting session on registration (see
  L<C<register>|/register>). C<ARG0> is a reference to the component's object.
  
  =head3 C<syndicator_shutdown>
  
  Sent to all interested sessions when the component has been shut down. See
  L<C<_syndicator_destroy>|/_syndicator_destroy>.
  
  =head3 C<syndicator_delay_set>
  
  Sent to the subclass, plugins, and all interested sessions on a successful
  addition of a delayed event using the L<C<delay>|/delay> method. C<ARG0> will
  be the alarm_id which can be used later with L<C<delay_remove>|/delay_remove>.
  Subsequent parameters are the arguments that were passed to L<C<delay>|/delay>.
  
  =head3 C<syndicator_delay_removed>
  
  Sent to the subclass, plugins, and all interested sessions when a delayed
  event is successfully removed. C<ARG0> will be the alarm_id that was removed.
  Subsequent parameters are the arguments that were passed to L<C<delay>|/delay>.
  
  =head3 All other events
  
  All other events sent by the Syndicator are USER events (generated with
  L<C<send_user_event>|/send_user_event>) and SERVER events (generated with
  L<C<send_event*>|/send_event>) which will be delivered normally. Your
  subclass and plugins are responsible for generating them.
  
  =head1 SIGNALS
  
  The component will handle a number of custom signals that you may send using
  L<POE::Kernel|POE::Kernel>'s C<signal> method. They allow any session to
  communicate with every instance of the component in certain ways without
  having references to their objects or knowing about their sessions. The names
  of these signals can be customized with
  L<C<_syndicator_init>|/_syndicator_init>.
  
  =head2 C<SYNDICATOR_REGISTER>
  
  Registers for an event with the component. See L<C<register>|/register>.
  
  =head2 C<SYNDICATOR_SHUTDOWN>
  
  Causes a 'shutdown' event to be sent to your session. Any arguments to the
  signal will be passed along to the event. That's where you should clean up
  and call L<C<_syndicator_destroy>|/_syndicator_destroy>.
  
  =head1 AUTHOR
  
  Hinrik E<Ouml>rn SigurE<eth>sson, L<hinrik.sig@gmail.com>,
  Chris C<BinGOs> Williams L<chris@bingosnet.co.uk>,
  Apocalypse L<apocal@cpan.org>, and probably others.
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2011 Hinrik E<Ouml>rn SigurE<eth>sson
  
  This program is free software, you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
POE_COMPONENT_SYNDICATOR

$fatpacked{"POE/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_DRIVER';
  package POE::Driver;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw(croak);
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
    croak "$type is not meant to be used directly";
  }
  
  #------------------------------------------------------------------------------
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Driver - an abstract interface for buffered, non-blocking I/O
  
  =head1 SYNOPSIS
  
  This is a contrived example of how POE::Filter and POE::Driver objects
  may be used in a stand-alone application.
  
    my $driver = POE::Driver::SysRW->new();
    my $filter = POE::Filter::Line->new();
  
    my $list_of_octet_chunks = $filter->put("A line of text.");
  
    $driver->put( $list_of_octet_chunks );
  
    my $octets_remaining_in_buffer = $driver->flush($filehandle);
    die "couldn't flush everything" if $octets_remaining_in_buffer;
  
    while (1) {
      my $octets_list = $driver->get($filehandle);
      die $! unless defined $octets_list;
  
      $filter->get_one_start($octets_list);
      while (my $line = $filter->get_one()) {
        print "Input: $line\n";
      }
    }
  
  Most programs will use POE::Filter and POE::Driver objects as
  parameters to POE::Wheel constructors.  See the synopses for
  particular classes for details.
  
  =head1 DESCRIPTION
  
  POE::Driver is a common API for I/O drivers that can read from and
  write to various files, sockets, pipes, and other devices.
  
  POE "drivers" implement the specifics of reading and writing to
  devices.  Drivers plug into POE::Wheel objects so that wheels may
  support a large number of device types without implementing a separate
  subclass for each.
  
  As mentioned in the SYNOPSIS, POE::Driver objects may be used in
  stand-alone applications.
  
  =head2 Public Driver Methods
  
  These methods are the generic Driver interface, and every driver must
  implement them.  Specific drivers may have additional methods related
  to their particular tasks.
  
  =head3 new
  
  new() creates, initializes, and returns a new driver.  Specific
  drivers may have different constructor parameters.  The default
  constructor parameters should configure the driver for the most common
  use case.
  
  =head3 get FILEHANDLE
  
  get() immediately tries to read information from a FILEHANDLE.  It
  returns an array reference on success---even if nothing was read from
  the FILEHANDLE.  get() returns undef on error, and $! will be set to
  the reason why get() failed.
  
  The returned arrayref will be empty if nothing was read from the
  FILEHANDLE.
  
  In an EOF condition, get() returns undef with the numeric value of $!
  set to zero.
  
  The arrayref returned by get() is suitable for passing to any
  POE::Filter's get() or get_one_start() method.  Wheels do exactly this
  internally.
  
  =over
  
  =item put ARRAYREF
  
  put() accepts an ARRAYREF of raw octet chunks.  These octets are added
  to the driver's internal output queue or buffer.  put() returns the
  number of octets pending output after the new octets are buffered.
  
  Some drivers may flush data immediately from their put() methods.
  
  =item flush FILEHANDLE
  
  flush() attempts to write a driver's buffered data to a given
  FILEHANDLE.  The driver should flush as much data as possible in a
  single flush() call.
  
  flush() returns the number of octets remaining in the driver's output
  queue or buffer after the maximum amount of data has been written.
  
  flush() denotes success or failure by the value of $! after it
  returns.  $! will always numerically equal zero on success.  On
  failure, $! will contain the usual Errno value.  In either case,
  flush() will return the number of octets in the driver's output queue.
  
  =item get_out_messages_buffered
  
  get_out_messages_buffered() returns the number of messages enqueued in
  the driver's output queue, rounded up to the nearest whole message.
  Some applications require the message count rather than the octet
  count.
  
  Messages are raw octet chunks enqueued by put().  The following put()
  call enqueues two messages for a total of six octets:
  
    $filter->put( [ "one", "two" ] );
  
  It is possible for a flush() call to write part of a message.  A
  partial message still counts as one message.
  
  =back
  
  =head1 SEE ALSO
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  L<POE::Wheel> - A base class for POE::Session mix-ins.
  
  L<POE::Filter> - A base class for data parsers and serializers.
  
  L<POE::Driver::SysRW> - A driver that encapsulates sysread() and
  buffered syswrite().
  
  =head1 BUGS
  
  There is no POE::Driver::SendRecv, but nobody has needed one so far.
  sysread() and syswrite() manage to do almost everything people need.
  
  In theory, drivers should be pretty much interchangeable.  In
  practice, there seems to be an impermeable barrier between the
  different SOCK_* types.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_DRIVER

$fatpacked{"POE/Driver/SysRW.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_DRIVER_SYSRW';
  # Copyright 1998-2013 Rocco Caputo <rcaputo@cpan.org>.  All rights
  # reserved.  This program is free software; you can redistribute it
  # and/or modify it under the same terms as Perl itself.
  
  package POE::Driver::SysRW;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Errno qw(EAGAIN EWOULDBLOCK);
  use Carp qw(croak);
  
  sub OUTPUT_QUEUE        () { 0 }
  sub CURRENT_OCTETS_DONE () { 1 }
  sub CURRENT_OCTETS_LEFT () { 2 }
  sub BLOCK_SIZE          () { 3 }
  sub TOTAL_OCTETS_LEFT   () { 4 }
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
    my $self = bless [
      [ ],   # OUTPUT_QUEUE
      0,     # CURRENT_OCTETS_DONE
      0,     # CURRENT_OCTETS_LEFT
      65536, # BLOCK_SIZE
      0,     # TOTAL_OCTETS_LEFT
    ], $type;
  
    if (@_) {
      if (@_ % 2) {
        croak "$type requires an even number of parameters, if any";
      }
      my %args = @_;
      if (defined $args{BlockSize}) {
        $self->[BLOCK_SIZE] = delete $args{BlockSize};
        croak "$type BlockSize must be greater than 0"
          if ($self->[BLOCK_SIZE] <= 0);
      }
      if (keys %args) {
        my @bad_args = sort keys %args;
        croak "$type has unknown parameter(s): @bad_args";
      }
    }
  
    $self;
  }
  
  #------------------------------------------------------------------------------
  
  sub put {
    my ($self, $chunks) = @_;
    my $old_queue_octets = $self->[TOTAL_OCTETS_LEFT];
  
    # Need to check lengths in octets, not characters.
    BEGIN { eval { require bytes } and bytes->import; }
  
    foreach (grep { length } @$chunks) {
      $self->[TOTAL_OCTETS_LEFT] += length;
      push @{$self->[OUTPUT_QUEUE]}, $_;
    }
  
    if ($self->[TOTAL_OCTETS_LEFT] && (!$old_queue_octets)) {
      $self->[CURRENT_OCTETS_LEFT] = length($self->[OUTPUT_QUEUE]->[0]);
      $self->[CURRENT_OCTETS_DONE] = 0;
    }
  
    $self->[TOTAL_OCTETS_LEFT];
  }
  
  #------------------------------------------------------------------------------
  
  sub get {
    my ($self, $handle) = @_;
  
    my $result = sysread($handle, my $buffer = '', $self->[BLOCK_SIZE]);
  
    # sysread() returned a positive number of octets.  Return whatever
    # was read.
    return [ $buffer ] if $result;
  
    # 18:01 <dngor> sysread() clears $! when it returns 0 for eof?
    # 18:01 <merlyn> nobody clears $!
    # 18:01 <merlyn> returning 0 is not an error
    # 18:01 <merlyn> returning -1 is an error, and sets $!
    # 18:01 <merlyn> eof is not an error. :)
  
    # 18:21 <dngor> perl -wle '$!=1; warn "\$!=",$!+0; \
    #               warn "sysread=",sysread(STDIN,my $x="",100); \
    #               die "\$!=",$!+0' < /dev/null
    # 18:23 <lathos> $!=1 at foo line 1.
    # 18:23 <lathos> sysread=0 at foo line 1.
    # 18:23 <lathos> $!=0 at foo line 1.
    # 18:23 <lathos> 5.6.0 on Darwin.
    # 18:23 <dngor> Same, 5.6.1 on fbsd 4.4-stable.
    #               read(2) must be clearing errno or something.
  
    # sysread() returned 0, signifying EOF.  Although $! is magically
    # set to 0 on EOF, it may not be portable to rely on this.
    if (defined $result) {
      $! = 0;
      return undef;
    }
  
    # Nonfatal sysread() error.  Return an empty list.
    return [ ] if $! == EAGAIN or $! == EWOULDBLOCK;
  
    # fatal sysread error
    undef;
  }
  
  #------------------------------------------------------------------------------
  
  sub flush {
    my ($self, $handle) = @_;
  
    # Need to check lengths in octets, not characters.
    BEGIN { eval { require bytes } and bytes->import; }
  
    # Reset errno in case there is nothing to write.
    # https://rt.cpan.org/Public/Bug/Display.html?id=87721
    $! = 0;
  
    # syswrite() it, like we're supposed to
    while (@{$self->[OUTPUT_QUEUE]}) {
      my $wrote_count = syswrite(
        $handle,
        $self->[OUTPUT_QUEUE]->[0],
        $self->[CURRENT_OCTETS_LEFT],
        $self->[CURRENT_OCTETS_DONE],
      );
  
      # Errors only count if syswrite() failed.
      $! = 0 if defined $wrote_count;
  
      unless ($wrote_count) {
        $! = 0 if $! == EAGAIN or $! == EWOULDBLOCK;
        last;
      }
  
      $self->[CURRENT_OCTETS_DONE] += $wrote_count;
      $self->[TOTAL_OCTETS_LEFT] -= $wrote_count;
      unless ($self->[CURRENT_OCTETS_LEFT] -= $wrote_count) {
        shift(@{$self->[OUTPUT_QUEUE]});
        if (@{$self->[OUTPUT_QUEUE]}) {
          $self->[CURRENT_OCTETS_DONE] = 0;
          $self->[CURRENT_OCTETS_LEFT] = length($self->[OUTPUT_QUEUE]->[0]);
        }
        else {
          $self->[CURRENT_OCTETS_DONE] = $self->[CURRENT_OCTETS_LEFT] = 0;
        }
      }
    }
  
    $self->[TOTAL_OCTETS_LEFT];
  }
  
  #------------------------------------------------------------------------------
  
  sub get_out_messages_buffered {
    scalar(@{$_[0]->[OUTPUT_QUEUE]});
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Driver::SysRW - buffered, non-blocking I/O using sysread and syswrite
  
  =head1 SYNOPSIS
  
  L<POE::Driver/SYNOPSIS> illustrates how the interface works.  This
  module is merely one implementation.
  
  =head1 DESCRIPTION
  
  This driver implements L<POE::Driver> using sysread and syswrite.
  
  =head1 PUBLIC METHODS
  
  POE::Driver::SysRW introduces some additional features not covered in
  the base interface.
  
  =head2 new [BlockSize => OCTETS]
  
  new() creates a new buffered I/O driver that uses sysread() to read
  data from a handle and syswrite() to flush data to that handle.  The
  constructor accepts one optional named parameter, C<BlockSize>, which
  indicates the maximum number of OCTETS that will be read at one time.
  
  C<BlockSize> is 64 kilobytes (65536 octets) by default.  Higher values
  may improve performance in streaming applications, but the trade-off
  is a lower event granularity and increased resident memory usage.
  
  Lower C<BlockSize> values reduce memory consumption somewhat with
  corresponding throughput penalties.
  
    my $driver = POE::Driver::SysRW->new;
  
    my $driver = POE::Driver::SysRW->new( BlockSize => $block_size );
  
  Drivers are commonly instantiated within POE::Wheel constructor calls:
  
    $_[HEAP]{wheel} = POE::Wheel::ReadWrite->new(
      InputHandle => \*STDIN,
      OutputHandle => \*STDOUT,
      Driver => POE::Driver::SysRW->new(),
      Filter => POE::Filter::Line->new(),
    );
  
  Applications almost always use POE::Driver::SysRW, so POE::Wheel
  objects almost always will create their own if no Driver is specified.
  
  =head2 All Other Methods
  
  POE::Driver::SysRW documents the abstract interface documented in
  POE::Driver.  Please see L<POE::Driver> for more details about the
  following methods:
  
  =over 4
  
  =item flush
  
  =item get
  
  =item get_out_messages_buffered
  
  =item put
  
  =back
  
  =head1 SEE ALSO
  
  L<POE::Driver>, L<POE::Wheel>.
  
  Also see the SEE ALSO section of L<POE>, which contains a brief
  roadmap of POE's documentation.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_DRIVER_SYSRW

$fatpacked{"POE/Filter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER';
  package POE::Filter;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw(croak);
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
    croak "$type is not meant to be used directly";
  }
  
  # Return all the messages possible to parse in the current input
  # buffer.  This uses the newer get_one_start() and get_one(), which is
  # implementation dependent.
  
  sub get {
    my ($self, $stream) = @_;
    my @return;
  
    $self->get_one_start($stream);
    while (1) {
      my $next = $self->get_one();
      last unless @$next;
      push @return, @$next;
    }
  
    return \@return;
  }
  
  sub clone {
    my $self = shift;
    my $buf = (ref($self->[0]) eq 'ARRAY') ? [ ] : '';
    my $nself = bless [
      $buf,                     # BUFFER
      @$self[1..$#$self],  # everything else
    ], ref $self;
    return $nself;
  }
  
  
  sub __param_max
  
  {
      my( $type, $name, $default, $params ) = @_;
      return $default    # 512 MB
          unless defined $params->{$name};
  
      my $ret = $params->{$name};
      croak "$name must be a number"
              unless $ret =~ /^\d+$/;
      croak "$name must greater then 0"
              unless $ret > 0;
      return $ret;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Filter - protocol abstractions for POE::Wheel and standalone use
  
  =head1 SYNOPSIS
  
  To use with POE::Wheel classes, pass a POE::Filter object to one of
  the "...Filter" constructor parameters:
  
    #!perl
  
    use POE qw(Filter::Line Wheel::FollowTail);
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[HEAP]{tailor} = POE::Wheel::FollowTail->new(
            Filename => "/var/log/system.log",
            InputEvent => "got_log_line",
            Filter => POE::Filter::Line->new(),
          );
        },
        got_log_line => sub {
          print "Log: $_[ARG0]\n";
        }
      }
    );
  
    POE::Kernel->run();
    exit;
  
  Standalone use without POE:
  
    #!perl
  
    use warnings;
    use strict;
    use POE::Filter::Line;
  
    my $filter = POE::Filter::Line->new( Literal => "\n" );
  
    # Prints three lines: one, two three.
  
    $filter->get_one_start(["one\ntwo\nthr", "ee\nfour"]);
    while (1) {
      my $line = $filter->get_one();
      last unless @$line;
      print $line->[0], "\n";
    }
  
    # Prints two lines: four, five.
  
    $filter->get_one_start(["\nfive\n"]);
    while (1) {
      my $line = $filter->get_one();
      last unless @$line;
      print $line->[0], "\n";
    }
  
  =head1 DESCRIPTION
  
  POE::Filter objects plug into the wheels and define how the data will
  be serialized for writing and parsed after reading.  POE::Wheel
  objects are responsible for moving data, and POE::Filter objects
  define how the data should look.
  
  POE::Filter objects are simple by design.  They do not use POE
  internally, so they are limited to serialization and parsing.  This
  may complicate implementation of certain protocols (like HTTP 1.x),
  but it allows filters to be used in stand-alone programs.
  
  Stand-alone use is very important.  It allows application developers
  to create lightweight blocking libraries that may be used as simple
  clients for POE servers.  POE::Component::IKC::ClientLite is a notable
  example.  This lightweight, blocking event-passing client supports
  thin clients for gridded POE applications.  The canonical use case is
  to inject events into an IKC application or grid from CGI interfaces,
  which require lightweight resource use.
  
  POE filters and drivers pass data in array references.  This is
  slightly awkward, but it minimizes the amount of data that must be
  copied on Perl's stack.
  
  =head1 PUBLIC INTERFACE
  
  All POE::Filter classes must support the minimal interface, defined
  here.  Specific filters may implement and document additional methods.
  
  =head2 new PARAMETERS
  
  new() creates and initializes a new filter.  Constructor parameters
  vary from one POE::Filter subclass to the next, so please consult the
  documentation for your desired filter.
  
  =head2 clone
  
  clone() creates and initializes a new filter based on the constructor
  parameters of the existing one.  The new filter is a near-identical
  copy, except that its buffers are empty.
  
  Certain components, such as POE::Component::Server::TCP, use clone().
  These components accept a master or template filter at creation time,
  then clone() that filter for each new connection.
  
    my $new_filter = $old_filter->clone();
  
  =head2 get_one_start ARRAYREF
  
  get_one_start() accepts an array reference containing unprocessed
  stream chunks.  The chunks are added to the filter's internal buffer
  for parsing by get_one().
  
  The L</SYNOPSIS> shows get_one_start() in use.
  
  =head2 get_one
  
  get_one() parses zero or one complete item from the filter's internal
  buffer.  The data is returned as an ARRAYREF suitable for passing to
  another filter or a POE::Wheel object.  Filters will return empty
  ARRAYREFs if they don't have enough raw data to build a complete item.
  
  get_one() is the lazy form of get().  It only parses only one item at
  a time from the filter's buffer.  This is vital for applications that
  may switch filters in mid-stream, as it ensures that the right filter
  is in use at any given time.
  
  The L</SYNOPSIS> shows get_one() in use.  Note how it assumes the
  return is always an ARRAYREF, and it implicitly handles empty ones.
  
  =head2 get ARRAYREF
  
  get() is the greedy form of get_one().  It accepts an array reference
  containing unprocessed stream chunks, and it adds that data to the
  filter's internal buffer.  It then parses as many full items as
  possible from the buffer and returns them in another array reference.
  Any unprocessed data remains in the filter's buffer for the next call.
  
  As with get_one(), get() will return an empty array reference if the
  filter doesn't contain enough raw data to build a complete item.
  
  In fact, get() is implemented in POE::Filter in terms of
  get_one_start() and get_one().
  
  Here's the get() form of the SYNOPSIS stand-alone example:
  
    #!perl
  
    use warnings;
    use strict;
    use POE::Filter::Line;
  
    my $filter = POE::Filter::Line->new( Literal => "\n" );
  
    # Prints three lines: one, two three.
  
    my $lines = $filter->get(["one\ntwo\nthr", "ee\nfour"]);
    foreach my $line (@$lines) {
      print "$line\n";
    }
  
    # Prints two lines: four, five.
  
    $lines = $filter->get(["\nfive\n"]);
    foreach my $line (@$lines) {
      print "$line\n";
    }
  
  get() should not be used with wheels that support filter switching.
  Its greedy nature means that it often parses streams well in advance
  of a wheel's events.  By the time an application changes the wheel's
  filter, it's too late: The old filter has already parsed the rest of
  the received data.
  
  Consider a stream of letters, numbers, and periods.  The periods
  signal when to switch filters from one that parses letters to one that
  parses numbers.
  
  In our hypothetical application, letters must be handled one at a
  time, but numbers may be handled in chunks.  We'll use
  POE::Filter::Block with a BlockSize of 1 to parse letters, and
  POE::FIlter::Line with a Literal terminator of "." to handle numbers.
  
  Here's the sample stream:
  
    abcdefg.1234567.hijklmnop.890.q
  
  We'll start with a ReadWrite wheel configured to parse characters.
  
    $_[HEAP]{wheel} = POE::Wheel::ReadWrite->new(
      Filter => POE::Filter::Block->new( BlockSize => 1 ),
      Handle => $socket,
      InputEvent => "got_letter",
    );
  
  The "got_letter" handler will be called 8 times.  One for each letter
  from a through g, and once for the period following g.  Upon receiving
  the period, it will switch the wheel into number mode.
  
    sub handle_letter {
      my $letter = $_[ARG0];
      if ($letter eq ".") {
        $_[HEAP]{wheel}->set_filter(
          POE::Filter::Line->new( Literal => "." )
        );
        $_[HEAP]{wheel}->event( InputEvent => "got_number" );
      }
      else {
        print "Got letter: $letter\n";
      }
    }
  
  If the greedy get() were used, the entire input stream would have been
  parsed as characters in advance of the first handle_letter() call.
  The set_filter() call would have been moot, since there would be no
  data left to be parsed.
  
  The "got_number" handler receives contiguous runs of digits as
  period-terminated lines.  The greedy get() would cause a similar
  problem as above.
  
    sub handle_numbers {
      my $numbers = $_[ARG0];
      print "Got number(s): $numbers\n";
      $_[HEAP]->{wheel}->set_filter(
        POE::Filter::Block->new( BlockSize => 1 )
      );
      $_[HEAP]->{wheel}->event( InputEvent => "got_letter" );
    }
  
  So don't do it!
  
  =head2 put ARRAYREF
  
  put() serializes items into a stream of octets that may be written to
  a file or sent across a socket.  It accepts a reference to a list of
  items, and it returns a reference to a list of marshalled stream
  chunks.  The number of output chunks is not necessarily related to the
  number of input items.
  
  In stand-alone use, put()'s output may be sent directly:
  
    my $line_filter = POE::Filter::Line->new();
    my $lines = $line_filter->put(\@list_of_things);
    foreach my $line (@$lines) {
      print $line;
    }
  
  The list reference it returns may be passed directly to a driver or
  filter.  Drivers and filters deliberately share the same put()
  interface so that things like this are possible:
  
    $driver->put(
      $transfer_encoding_filter->put(
        $content_encoding_filter->put(
          \@items
        )
      )
    );
  
    1 while $driver->flush(\*STDOUT);
  
  =head2 get_pending
  
  get_pending() returns any data remaining in a filter's input buffer.
  The filter's input buffer is not cleared, however.  get_pending()
  returns a list reference if there's any data, or undef if the filter
  was empty.
  
  POE::Wheel objects use get_pending() during filter switching.
  Unprocessed data is fetched from the old filter with get_pending() and
  injected into the new filter with get_one_start().
  
    use POE::Filter::Line;
    use POE::Filter::Stream;
  
    my $line_filter = POE::Filter::Line->new();
    $line_filter->get_one_start([ "not a complete line" ]);
  
    my $stream_filter = POE::Filter::Stream->new();
    my $line_buffer = $line_filter->get_pending();
    $stream_filter->get_one_start($line_buffer) if $line_buffer;
  
    print "Stream: $_\n" foreach (@{ $stream_filter->get_one });
  
  Full items are serialized whole, so there is no corresponding "put"
  buffer or accessor.
  
  =head1 SEE ALSO
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  POE is bundled with the following filters:
  
  L<POE::Filter::Block>
  L<POE::Filter::Grep>
  L<POE::Filter::HTTPD>
  L<POE::Filter::Line>
  L<POE::Filter::Map>
  L<POE::Filter::RecordBlock>
  L<POE::Filter::Reference>
  L<POE::Filter::Stackable>
  L<POE::Filter::Stream>
  
  =head1 BUGS
  
  In theory, filters should be interchangeable.  In practice, stream and
  block protocols tend to be incompatible.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_FILTER

$fatpacked{"POE/Filter/Block.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER_BLOCK';
  package POE::Filter::Block;
  
  use strict;
  use POE::Filter;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  @ISA = qw(POE::Filter);
  
  use Carp qw(croak);
  
  sub FRAMING_BUFFER () { 0 }
  sub BLOCK_SIZE     () { 1 }
  sub EXPECTED_SIZE  () { 2 }
  sub ENCODER        () { 3 }
  sub DECODER        () { 4 }
  sub MAX_LENGTH     () { 5 }
  sub MAX_BUFFER     () { 6 }
  sub FIRST_UNUSED   () { 7 }
  
  use base 'Exporter';
  our @EXPORT_OK = qw( FIRST_UNUSED );
  
  #------------------------------------------------------------------------------
  
  sub _default_decoder {
    my $stuff = shift;
    unless ($$stuff =~ s/^(\d+)\0//s) {
      warn length($1), " strange bytes removed from stream"
        if $$stuff =~ s/^(\D+)//s;
      return;
    }
    return $1;
  }
  
  sub _default_encoder {
    my $stuff = shift;
    substr($$stuff, 0, 0) = length($$stuff) . "\0";
    return;
  }
  
  sub new {
    my $type = shift;
    croak "$type must be given an even number of parameters" if @_ & 1;
    my %params = @_;
  
    my $max_buffer = $type->__param_max( MaxBuffer => 512*1024*1024, \%params );
  
    my ($encoder, $decoder, $max_length);
    my $block_size = delete $params{BlockSize};
    if (defined $block_size) {
      croak "$type doesn't support zero or negative block sizes"
        if $block_size < 1;
      croak "Can't use both LengthCodec and BlockSize at the same time"
        if exists $params{LengthCodec};
      croak "Can't use both MaxLength and BlockSize at the same time"
        if exists $params{MaxLength};
    }
    else {
      my $codec = delete $params{LengthCodec};
      if ($codec) {
        croak "LengthCodec must be an array reference"
          unless ref($codec) eq "ARRAY";
        croak "LengthCodec must contain two items"
          unless @$codec == 2;
        ($encoder, $decoder) = @$codec;
        croak "LengthCodec encoder must be a code reference"
          unless ref($encoder) eq "CODE";
        croak "LengthCodec decoder must be a code reference"
          unless ref($decoder) eq "CODE";
      }
      else {
        $encoder = \&_default_encoder;
        $decoder = \&_default_decoder;
      }
      $max_length = $type->__param_max( MaxLength => 64*1024*1024, \%params );
      croak "MaxBuffer is not large enough for MaxLength blocks"
          unless $max_buffer >= $max_length + length( $max_length ) + 1;
    }
  
    delete @params{qw(MaxLength MaxBuffer LengthCode BlockSize)};
    carp("$type ignores unknown parameters: ", join(', ', sort keys %params))
      if scalar keys %params;
  
    my $self = bless [
      '',           # FRAMING_BUFFER
      $block_size,  # BLOCK_SIZE
      undef,        # EXPECTED_SIZE
      $encoder,     # ENCODER
      $decoder,     # DECODER
      $max_length,  # MAX_LENGTH
      $max_buffer   # MAX_BUFFER
    ], $type;
  
    $self;
  }
  
  
  #------------------------------------------------------------------------------
  # get() is inherited from POE::Filter.
  
  #------------------------------------------------------------------------------
  # 2001-07-27 RCC: The get_one() variant of get() allows Wheel::Xyz to
  # retrieve one filtered block at a time.  This is necessary for filter
  # changing and proper input flow control.
  
  sub get_one_start {
    my ($self, $stream) = @_;
    $self->[FRAMING_BUFFER] .= join '', @$stream;
    die "Framing buffer exceeds the limit"
      if $self->[MAX_BUFFER] < length( $self->[FRAMING_BUFFER] );
  }
  
  sub get_one {
    my $self = shift;
  
    # Need to check lengths in octets, not characters.
    BEGIN { eval { require bytes } and bytes->import; }
  
    # If a block size is specified, then pull off a block of that many
    # bytes.
  
    if (defined $self->[BLOCK_SIZE]) {
      return [ ] unless length($self->[FRAMING_BUFFER]) >= $self->[BLOCK_SIZE];
      my $block = substr($self->[FRAMING_BUFFER], 0, $self->[BLOCK_SIZE]);
      substr($self->[FRAMING_BUFFER], 0, $self->[BLOCK_SIZE]) = '';
      return [ $block ];
    }
  
    # Otherwise we're doing the variable-length block thing.  Look for a
    # length marker, and then pull off a chunk of that length.  Repeat.
  
    unless( defined($self->[EXPECTED_SIZE]) ) {
      $self->[EXPECTED_SIZE] = $self->[DECODER]->(\$self->[FRAMING_BUFFER]);
      die "Expected size of next block exceeds the limit"
          if defined($self->[EXPECTED_SIZE]) and 
             $self->[EXPECTED_SIZE] > $self->[MAX_LENGTH];
    }
    if ( defined($self->[EXPECTED_SIZE]) ) {
      return [ ] if length($self->[FRAMING_BUFFER]) < $self->[EXPECTED_SIZE];
  
      # Four-arg substr() would be better here, but it's not compatible
      # with Perl as far back as we support.
      my $block = substr($self->[FRAMING_BUFFER], 0, $self->[EXPECTED_SIZE]);
      substr($self->[FRAMING_BUFFER], 0, $self->[EXPECTED_SIZE]) = '';
      $self->[EXPECTED_SIZE] = undef;
  
      return [ $block ];
    }
  
    return [ ];
  }
  
  #------------------------------------------------------------------------------
  
  sub put {
    my ($self, $blocks) = @_;
    my @raw;
  
    # Need to check lengths in octets, not characters.
    BEGIN { eval { require bytes } and bytes->import; }
  
    # If a block size is specified, then just assume the put is right.
    # This will cause quiet framing errors on the receiving side.  Then
    # again, we'll have quiet errors if the block sizes on both ends
    # differ.  Ah, well!
  
    if (defined $self->[BLOCK_SIZE]) {
      @raw = join '', @$blocks;
    }
  
    # No specified block size. Do the variable-length block thing. This
    # steals a lot of Artur's code from the Reference filter.
  
    else {
      @raw = @$blocks;
      foreach (@raw) {
        $self->[ENCODER]->(\$_);
      }
    }
  
    \@raw;
  }
  
  #------------------------------------------------------------------------------
  
  sub get_pending {
    my $self = shift;
    return undef unless length $self->[FRAMING_BUFFER];
    [ $self->[FRAMING_BUFFER] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Filter::Block - translate data between streams and blocks
  
  =head1 SYNOPSIS
  
    #!perl
  
    use warnings;
    use strict;
    use POE::Filter::Block;
  
    my $filter = POE::Filter::Block->new( BlockSize => 8 );
  
    # Prints three lines: abcdefgh, ijklmnop, qrstuvwx.
    # Bytes "y" and "z" remain in the buffer and await completion of the
    # next 8-byte block.
  
    $filter->get_one_start([ "abcdefghijklmnopqrstuvwxyz" ]);
    while (1) {
      my $block = $filter->get_one();
      last unless @$block;
      print $block->[0], "\n";
    }
  
    # Print one line: yz123456
  
    $filter->get_one_start([ "123456" ]);
    while (1) {
      my $block = $filter->get_one();
      last unless @$block;
      print $block->[0], "\n";
    }
  
  =head1 DESCRIPTION
  
  POE::Filter::Block translates data between serial streams and blocks.
  It can handle fixed-length and length-prepended blocks, and it may be
  extended to handle other block types.
  
  Fixed-length blocks are used when Block's constructor is called with a
  BlockSize value.  Otherwise the Block filter uses length-prepended
  blocks.
  
  Users who specify block sizes less than one deserve what they get.
  
  In variable-length mode, a LengthCodec parameter may be specified.
  The LengthCodec value should be a reference to a list of two
  functions: the length encoder, and the length decoder:
  
    LengthCodec => [ \&encoder, \&decoder ]
  
  The encoder takes a reference to a buffer and prepends the buffer's
  length to it.  The default encoder prepends the ASCII representation
  of the buffer's length and a chr(0) byte to separate the length from
  the actual data:
  
    sub _default_encoder {
      my $stuff = shift;
      substr($$stuff, 0, 0) = length($$stuff) . "\0";
      return;
    }
  
  The corresponding decoder returns the block length after removing it
  and the separator from the buffer.  It returns nothing if no length
  can be determined.
  
    sub _default_decoder {
      my $stuff = shift;
      unless ($$stuff =~ s/^(\d+)\0//s) {
        warn length($1), " strange bytes removed from stream"
          if $$stuff =~ s/^(\D+)//s;
        return;
      }
      return $1;
    }
  
  This filter holds onto incomplete blocks until they are completed in a
  framing buffer.  To control memory usage, a maximum framing buffer size is
  imposed.  This maximum size defaults to 512 MB (512*1024*1024 octets).  You
  may change this size limit with the C<MaxBuffer> parameter.
  
      MaxBuffer => 1099511627776  # One terabyte!
  
  The size of each individual block is also limited.  By default, each block
  may be no more then 64 MB.  You may change this size limit with the
  C<MaxLength> parameter.
  
      MaxLength => 10             # small blocks
  
  Remember that MaxBuffer needs to be larger then MaxLength.  What's more, it
  needs to have room for the length prefix.
  
  If either the C<MaxLength> or C<MaxBuffer> constraint is exceeded,
  C<POE::Filter::Bock> will throw an exception.
  
  
  =head1 PUBLIC FILTER METHODS
  
  POE::Filter::Block has no additional public methods.
  
  =head1 SEE ALSO
  
  Please see L<POE::Filter> for documentation regarding the base
  interface.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 BUGS
  
  The put() method doesn't verify block sizes.
  
  =head1 AUTHORS & COPYRIGHTS
  
  The Block filter was contributed by Dieter Pearcey, with changes by
  Rocco Caputo.
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_FILTER_BLOCK

$fatpacked{"POE/Filter/Grep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER_GREP';
  # 2001/01/25 shizukesa@pobox.com
  
  package POE::Filter::Grep;
  
  use strict;
  use POE::Filter;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  @ISA = qw(POE::Filter);
  
  use Carp qw(croak carp);
  
  sub BUFFER   () { 0 }
  sub CODEGET  () { 1 }
  sub CODEPUT  () { 2 }
  
  sub FIRST_UNUSED     () { 3 }  # First unused $self offset.
  
  use base 'Exporter';
  our @EXPORT_OK = qw( FIRST_UNUSED );
  
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
    croak "$type must be given an even number of parameters" if @_ & 1;
    my %params = @_;
  
    croak "$type requires a Code or both Get and Put parameters" unless (
      defined($params{Code}) or
      (defined($params{Get}) and defined($params{Put}))
    );
    croak "Code element is not a subref"
      unless (defined $params{Code} ? ref $params{Code} eq 'CODE' : 1);
    croak "Get or Put element is not a subref"
      unless ((defined $params{Get} ? (ref $params{Get} eq 'CODE') : 1)
        and   (defined $params{Put} ? (ref $params{Put} eq 'CODE') : 1));
  
    my $get = $params{Code} || $params{Get};
    my $put = $params{Code} || $params{Put};
  
    delete @params{qw(Code Get Put)};
    carp("$type ignores unknown parameters: ", join(', ', sort keys %params))
      if scalar keys %params;
  
    my $self = bless [
      [ ],    # BUFFER
      $get,   # CODEGET
      $put,   # CODEPUT
    ], $type;
  }
  
  #------------------------------------------------------------------------------
  # get() is inherited from POE::Filter.
  
  #------------------------------------------------------------------------------
  # 2001-07-27 RCC: The get_one variant of get() allows Wheel::Xyz to
  # retrieve one filtered record at a time.  This is necessary for
  # filter changing and proper input flow control.
  
  sub get_one_start {
    my ($self, $stream) = @_;
    push( @{$self->[BUFFER]}, @$stream ) if defined $stream;
  }
  
  sub get_one {
    my $self = shift;
  
    # Must be a loop so that the buffer will be altered as items are
    # tested.
    while (@{$self->[BUFFER]}) {
      my $next_record = shift @{$self->[BUFFER]};
      return [ $next_record ] if (
        grep { $self->[CODEGET]->($_) } $next_record
      );
    }
  
    return [ ];
  }
  
  #------------------------------------------------------------------------------
  
  sub put {
    my ($self, $data) = @_;
    [ grep { $self->[CODEPUT]->($_) } @$data ];
  }
  
  #------------------------------------------------------------------------------
  # 2001-07-27 RCC: This filter now tracks state, so get_pending has
  # become useful.
  
  sub get_pending {
    my $self = shift;
    return undef unless @{$self->[BUFFER]};
    [ @{$self->[BUFFER]} ];
  }
  
  #------------------------------------------------------------------------------
  
  sub modify {
    my ($self, %params) = @_;
  
    for (keys %params) {
      (carp("Modify $_ element must be given a coderef") and next) unless (ref $params{$_} eq 'CODE');
      if (lc eq 'code') {
          $self->[CODEGET] = $params{$_};
          $self->[CODEPUT] = $params{$_};
      }
      elsif (lc eq 'put') {
          $self->[CODEPUT] = $params{$_};
      }
      elsif (lc eq 'get') {
          $self->[CODEGET] = $params{$_};
      }
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Filter::Grep - select or remove items based on simple rules
  
  =head1 SYNOPSIS
  
    #!perl
  
    use POE qw(
      Wheel::FollowTail
      Filter::Line Filter::Grep Filter::Stackable
    );
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          my $parse_input_as_lines = POE::Filter::Line->new();
  
          my $select_sudo_log_lines = POE::Filter::Grep->new(
            Put => sub { 1 },
            Get => sub {
              my $input = shift;
              return $input =~ /sudo\[\d+\]/i;
            },
          );
  
          my $filter_stack = POE::Filter::Stackable->new(
            Filters => [
              $parse_input_as_lines, # first on get, last on put
              $select_sudo_log_lines, # first on put, last on get
            ]
          );
  
          $_[HEAP]{tailor} = POE::Wheel::FollowTail->new(
            Filename => "/var/log/system.log",
            InputEvent => "got_log_line",
            Filter => $filter_stack,
          );
        },
        got_log_line => sub {
          print "Log: $_[ARG0]\n";
        }
      }
    );
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Filter::Grep selects or removes items based on simple tests.  It
  may be used to filter input, output, or both.  This filter is named
  and modeled after Perl's built-in grep() function.
  
  POE::Filter::Grep is designed to be combined with other filters
  through POE::Filter::Stackable.  In the L</SYNOPSIS> example, a filter
  stack is created to parse logs as lines and remove all entries that
  don't pertain to a sudo process.  (Or if your glass is half full, the
  stack only selects entries that DO mention sudo.)
  
  =head1 PUBLIC FILTER METHODS
  
  In addition to the usual POE::Filter methods, POE::Filter::Grep also
  supports the following.
  
  =head2 new
  
  new() constructs a new POE::Filter::Grep object.  It must either be
  called with a single Code parameter, or both a Put and a Get
  parameter.  The values for Code, Put, and Get are code references
  that, when invoked, return true to select an item or false to reject
  it.  A Code function will be used for both input and output, while Get
  and Put functions allow input and output to be filtered in different
  ways.  The item in question will be passed as the function's sole
  parameter.
  
    sub reject_bidoofs {
      my $pokemon = shift;
      return 1 if $pokemon ne "bidoof";
      return;
    }
  
    my $gotta_catch_nearly_all = POE::Filter::Grep->new(
      Code => \&reject_bidoofs,
    );
  
  Enforce read-only behavior:
  
    my $read_only = POE::Filter::Grep->new(
      Get => sub { 1 },
      Put => sub { 0 },
    );
  
  =head2 modify
  
  modify() changes a POE::Filter::Grep object's behavior at run-time.
  It accepts the same parameters as new(), and it replaces the existing
  tests with new ones.
  
    # Don't give away our Dialgas.
    $gotta_catch_nearly_all->modify(
      Get => sub { 1 },
      Put => sub { return shift() ne "dialga" },
    );
  
  =head1 SEE ALSO
  
  L<POE::Filter> for more information about filters in general.
  
  L<POE::Filter::Stackable> for more details on stacking filters.
  
  =head1 BUGS
  
  None known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  The Grep filter was contributed by Dieter Pearcey.  Documentation is
  provided by Rocco Caputo.
  
  Please see the L<POE> manpage for more information about authors and
  contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_FILTER_GREP

$fatpacked{"POE/Filter/HTTPD.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER_HTTPD';
  # Filter::HTTPD Copyright 1998 Artur Bergman <artur@vogon.se>.
  # Thanks go to Gisle Aas for his excellent HTTP::Daemon.  Some of the
  # get code was copied out if, unfortunately HTTP::Daemon is not easily
  # subclassed for POE because of the blocking nature.
  # 2001-07-27 RCC: This filter will not support the newer get_one()
  # interface.  It gets single things by default, and it does not
  # support filter switching.  If someone absolutely needs to switch to
  # and from HTTPD filters, they should submit their request as a patch.
  
  package POE::Filter::HTTPD;
  
  use strict;
  use POE::Filter;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364';
  # NOTE - Should be #.### (three decimal places)
  @ISA = qw(POE::Filter);
  
  sub DEBUG () { 0 }
  
  sub BUFFER        () { 0 } # raw data buffer to build requests
  sub STATE         () { 1 } # built a full request
  sub REQUEST       () { 2 } # partial request being built
  sub CLIENT_PROTO  () { 3 } # client protocol version requested
  sub CONTENT_LEN   () { 4 } # expected content length
  sub CONTENT_ADDED () { 5 } # amount of content added to request
  sub CONTENT_MAX   () { 6 } # max amount of content
  sub STREAMING     () { 7 } # we want to work in streaming mode
  sub MAX_BUFFER    () { 8 } # max size of framing buffer
  sub FIRST_UNUSED  () { 9 }
  
  sub ST_HEADERS    () { 0x01 } # waiting for complete header block
  sub ST_CONTENT    () { 0x02 } # waiting for complete body
  
  use Carp qw(croak);
  use HTTP::Status qw( status_message RC_BAD_REQUEST RC_OK RC_LENGTH_REQUIRED 
                                      RC_REQUEST_ENTITY_TOO_LARGE );
  use HTTP::Request ();
  use HTTP::Response ();
  use HTTP::Date qw(time2str);
  use URI ();
  
  my $HTTP_1_0 = _http_version("HTTP/1.0");
  my $HTTP_1_1 = _http_version("HTTP/1.1");
  
  use base 'Exporter';
  our @EXPORT_OK = qw( FIRST_UNUSED );
  
  
  
  #------------------------------------------------------------------------------
  # Set up some routines for convert wide chars (which aren't allowed in HTTP headers)
  # into MIME encoded equivalents.
  # See ->headers_as_strings
  BEGIN {
      eval "use utf8";
      if( $@ ) {
          DEBUG and warn "We don't have utf8.";
          *HAVE_UTF8 = sub { 0 };
      }
      else {        
          *HAVE_UTF8 = sub { 1 };
          my $downgrade = sub {   
                          my $ret = $_[0];
                          utf8::downgrade( $ret );
                          return $ret 
                      };
          eval "use Email::MIME::RFC2047::Encoder";
          if( $@ ) {
              DEBUG and warn "We don't have Email::MIME::RFC2047::Encoder";
              *encode_value = sub {
                Carp::cluck(
                  "Downgrading wide characters in HTTP header. " .
                  "Consier installing Email::MIME::RFC2047::Encoder"
                );
                $downgrade->( @_ );
              };
          }
          else {
              my $encoder = Email::MIME::RFC2047::Encoder->new( encoding => 'iso-8859-1', 
                                                                method => 'Q'
                                                              );
              *encode_value = sub { $downgrade->( $encoder->encode_text( @_ ) ) };
          }
      }
  }
  
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
    croak "$type requires an even number of parameters" if @_ and @_ & 1;
    my %params = @_;
  
    my $max_content = $type->__param_max( MaxContent => 1024*1024, \%params );
    my $max_buffer = $type->__param_max( MaxBuffer => 512*1024*1024, \%params );
    my $streaming = $params{Streaming} || 0;
  
    croak "MaxBuffer is not large enough for MaxContent"
          unless $max_buffer >= $max_content + length( $max_content ) + 1;
  
    delete @params{qw(MaxContent MaxBuffer Streaming)};
    carp("$type ignores unknown parameters: ", join(', ', sort keys %params))
      if scalar keys %params;
  
    return bless(
      [
        '',         # BUFFER
        ST_HEADERS, # STATE
        undef,      # REQUEST
        undef,      # CLIENT_PROTO
        0,          # CONTENT_LEN
        0,          # CONTENT_ADDED
        $max_content, # CONTENT_MAX
        $streaming, # STREAMING
        $max_buffer # MAX_BUFFER
      ],
      $type
    );
  }
  
  #------------------------------------------------------------------------------
  
  sub get_one_start {
    my ($self, $stream) = @_;
      
    $self->[BUFFER] .= join( '', @$stream );
    DEBUG and warn "$$:poe-filter-httpd: Buffered ".length( $self->[BUFFER] )." bytes";
    die "Framing buffer exceeds the limit"
      if $self->[MAX_BUFFER] < length( $self->[BUFFER] );
  }
  
  sub get_one {
    my ($self) = @_;
  
    # Need to check lengths in octets, not characters.
    BEGIN { eval { require bytes } and bytes->import; }
  
    # Waiting for a complete suite of headers.
    if ($self->[STATE] & ST_HEADERS) {
      DEBUG and warn "$$:poe-filter-httpd: Looking for headers";
      # Strip leading whitespace.
      $self->[BUFFER] =~ s/^\s+//;
  
      # No blank line yet.  Side effect: Raw headers block is extracted
      # from the input buffer.
      return [] unless (
        $self->[BUFFER] =~
        s/^(\S.*?(?:\x0D\x0A?\x0D\x0A?|\x0A\x0D?\x0A\x0D?))//s
      );
  
      # Raw headers block from the input buffer.
      my $rh = $1;
  
      # Parse the request line.
      if ($rh !~ s/^(\w+)[ \t]+(\S+)(?:[ \t]+(HTTP\/\d+\.\d+))?[^\012]*\012//) {
        return [
          $self->_build_error(RC_BAD_REQUEST, "Request line parse failure. ($rh)")
        ];
      }
  
      # Create an HTTP::Request object from values in the request line.
      my ($method, $request_path, $proto) = ($1, $2, ($3 || "HTTP/0.9"));
  
      # Fix a double starting slash on the path.  It happens.
      $request_path =~ s!^//+!/!;
  
      my $r = HTTP::Request->new($method, URI->new($request_path));
      $r->protocol($proto);
      $self->[CLIENT_PROTO] = $proto = _http_version($proto);
  
      # Parse headers.
  
      my ($key, $val);
      HEADER: while ($rh =~ s/^([^\012]*)\012//) {
        local $_ = $1;
        s/\015$//;
        if (/^([\w\-~]+)\s*:\s*(.*)/) {
          $r->push_header($key, $val) if $key;
          ($key, $val) = ($1, $2);
        }
        elsif (/^\s+(.*)/) {
          $val .= " $1";
        }
        else {
          last HEADER;
        }
      }
  
      $r->push_header($key, $val) if $key;
  
      # We got a full set of headers.  Fall through to content if we
      # have a content length.
  
      my $cl = $r->content_length();
      if( defined $cl ) {
          unless( $cl =~ /^\s*(\d+)\s*$/ ) {
              $r = $self->_build_error(RC_BAD_REQUEST, 
                                   "Content-Length is not a number.",
                                   $r);
              $self->[BUFFER] = '';
              $self->_reset();
              return [ $r ];
          }
          $cl = $1 || 0;
      }
      my $ce = $r->content_encoding();
      
  #   The presence of a message-body in a request is signaled by the
  #   inclusion of a Content-Length or Transfer-Encoding header field in
  #   the request's message-headers. A message-body MUST NOT be included in
  #   a request if the specification of the request method (section 5.1.1)
  #   does not allow sending an entity-body in requests. A server SHOULD
  #   read and forward a message-body on any request; if the request method
  #   does not include defined semantics for an entity-body, then the
  #   message-body SHOULD be ignored when handling the request.
  #   - RFC2616
  
      unless( defined $cl || defined $ce ) {
          # warn "No body";
          $self->_reset();
          return [ $r ];
      }
      
      # PG- GET shouldn't have a body. But RFC2616 talks about Content-Length
      # for HEAD.  And My reading of RFC2616 is that HEAD is the same as GET.
      # So logically, GET can have a body.  And RFC2616 says we SHOULD ignore
      # it.
      #
      # What's more, in apache 1.3.28, a body on a GET or HEAD is read
      # and discarded.  See ap_discard_request_body() in http_protocol.c and
      # default_handler() in http_core.c
      #
      # Neither Firefox 2.0 nor Lynx 2.8.5 set Content-Length on a GET
  
  #   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests
  #   containing a message-body MUST include a valid Content-Length header
  #   field unless the server is known to be HTTP/1.1 compliant. If a
  #   request contains a message-body and a Content-Length is not given,
  #   the server SHOULD respond with 400 (bad request) if it cannot
  #   determine the length of the message, or with 411 (length required) if
  #   it wishes to insist on receiving a valid Content-Length.
  # - RFC2616 
  #
  # PG- This seems to imply that we can either detect the length (but how
  #     would one do that?) or require a Content-Length header.  We do the
  #     latter.
  # 
  # PG- Dispite all the above, I'm not fully sure this implements RFC2616
  #     properly.  There's something about transfer-coding that I don't fully
  #     understand.
  
      if ( not $cl) {         
        # assume a Content-Length of 0 is valid pre 1.1
        if ($self->[CLIENT_PROTO] >= $HTTP_1_1 and not defined $cl) {
          # We have Content-Encoding, but not Content-Length.
          $r = $self->_build_error(RC_LENGTH_REQUIRED, 
                                   "No content length found.",
                                   $r);
        }
        $self->[BUFFER] = '';
        $self->_reset();
        return [ $r ];
      }
  
      # Prevent DOS of a server by malicious clients
      if( not $self->[STREAMING] and $cl > $self->[CONTENT_MAX] ) {
          $r = $self->_build_error(RC_REQUEST_ENTITY_TOO_LARGE, 
                                   "Content of $cl octets not accepted.",
                                   $r);
          $self->[BUFFER] = '';
          $self->_reset();
          return [ $r ];
      }
  
      $self->[REQUEST] = $r;
      $self->[CONTENT_LEN] = $cl;
      $self->[STATE] = ST_CONTENT;
      # Fall through to content.
    }
  
    # Waiting for content.
    if ($self->[STATE] & ST_CONTENT) {
      my $r         = $self->[REQUEST];
      my $cl_needed = $self->[CONTENT_LEN] - $self->[CONTENT_ADDED];
      die "already got enough content ($cl_needed needed)" if $cl_needed < 1;
  
      if( $self->[STREAMING] ) {
          DEBUG and warn "$$:poe-filter-httpd: Streaming request content";
          my @ret;
          # do we have a request?
          if( $self->[REQUEST] ) {
              DEBUG and warn "$$:poe-filter-httpd: Sending request";
              push @ret, $self->[REQUEST];    # send it to the wheel
              $self->[REQUEST] = undef;
          }
          # do we have some content ?
          if( length( $self->[BUFFER] ) ) {   # send it to the wheel
              my $more = substr($self->[BUFFER], 0, $cl_needed);
              DEBUG and warn "$$:poe-filter-httpd: Sending content";
              push @ret, $more;
              $self->[CONTENT_ADDED] += length($more);
              substr( $self->[BUFFER], 0, length($more) ) = "";
              # is that enough content?
              if( $self->[CONTENT_ADDED] >= $self->[CONTENT_LEN] ) {
                  DEBUG and warn "$$:poe-filter-httpd: All content received ($self->[CONTENT_ADDED] >= $self->[CONTENT_LEN])";
                  # Strip MSIE 5.01's extra CRLFs
                  $self->[BUFFER] =~ s/^\s+//;
                  $self->_reset;
              } 
          }
          return \@ret;
      }
  
      # Not enough content to complete the request.  Add it to the
      # request content, and return an incomplete status.
      if (length($self->[BUFFER]) < $cl_needed) {
        $r->add_content($self->[BUFFER]);
        $self->[CONTENT_ADDED] += length($self->[BUFFER]);
        $self->[BUFFER] = "";
        return [];
      }
  
      # Enough data.  Add it to the request content.
      # PG- CGI.pm only reads Content-Length: bytes from STDIN.
  
      # Four-argument substr() would be ideal here, but it's not
      # entirely backward compatible.
      $r->add_content(substr($self->[BUFFER], 0, $cl_needed));
      substr($self->[BUFFER], 0, $cl_needed) = "";
  
      # Some browsers (like MSIE 5.01) send extra CRLFs after the
      # content.  Shame on them.
      $self->[BUFFER] =~ s/^\s+//;
  
      # XXX Should we throw the body away on a GET or HEAD? Probably not.
  
      # XXX Should we parse Multipart Types bodies?
  
      # Prepare for the next request, and return this one.
      $self->_reset();
      return [ $r ];
    }
  
    # What are we waiting for?
    die "unknown state $self->[STATE]";
  }
  
  # Prepare for next request
  sub _reset
  {
     my($self) = @_;
     $self->[STATE] = ST_HEADERS;
     @$self[REQUEST, CLIENT_PROTO]       = (undef, undef);
     @$self[CONTENT_LEN, CONTENT_ADDED]  = (0, 0);
  }
  
  
  #------------------------------------------------------------------------------
  
  sub put {
    my ($self, $responses) = @_;
    my @raw;
  
    # HTTP::Response's as_string method returns the header lines
    # terminated by "\n", which does not do the right thing if we want
    # to send it to a client.  Here I've stolen HTTP::Response's
    # as_string's code and altered it to use network newlines so picky
    # browsers like lynx get what they expect.
    # PG- $r->as_string( "\x0D\x0A" ); would accomplish the same thing, no?
  
    foreach (@$responses) {
      my $code           = $_->code;
      my $status_message = status_message($code) || "Unknown Error";
      my $message        = $_->message  || "";
      my $proto          = $_->protocol || 'HTTP/1.0';
  
      my $status_line = "$proto $code";
      $status_line   .= " ($status_message)"  if $status_message ne $message;
      $status_line   .= " $message" if length($message);
  
      # Use network newlines, and be sure not to mangle newlines in the
      # response's content.
  
      my @headers;
      push @headers, $status_line;
  
      # Perl can magically promote a string to UTF-8 if it is concatinated
      # with another UTF-8 string.  This behaviour changed between 5.8.8 and
      # 5.10.1.  This is normaly not a problem, but POE::Driver::SysRW uses
      # syswrite(), which sends POE's internal buffer as-is.  
      # In other words, if the header contains UTF-8, the content will be
      # promoted to UTF-8 and syswrite() will send those wide bytes, which
      # will corrupt any images.
      # For instance, 00 e7 ff 00 00 00 05
      # will become,  00 c3 a7 c3 bf 00 00 00 05
      #
      # The real bug is in HTTP::Message->headers_as_string, which doesn't respect
      # the following:
      # 
      # "The TEXT rule is only used for descriptive field contents and values
      #  that are not intended to be interpreted by the message parser.  Words
      #  of *TEXT MAY contain characters from character sets other than ISO-
      #  8859-1 [22] only when encoded according to the rules of RFC 2047
      #  [14]. " -- RFC2616 section 2.2
      # http://www.ietf.org/rfc/rfc2616.txt
      # http://www.ietf.org/rfc/rfc2047.txt
      my $endl = "\x0D\x0A";
      push @headers, $self->headers_as_strings( $_->headers, $endl );
      push @raw, join( $endl, @headers, "", "") . $_->content;
    }
  
    \@raw;
  }
  
  sub headers_as_strings
  {
      my( $self, $H, $endl ) = @_;
      my @ret;
      # $H is a HTTP::Headers object
      foreach my $name ( $H->header_field_names ) {
          # message-header = field-name ":" [ field-value ]
          # field-name     = token
          # RFC2616 section 4.2
          #
          # token          = 1*<any CHAR except CTLs or separators>
          # separators     = "(" | ")" | "<" | ">" | "@"
          #                  | "," | ";" | ":" | "\" | <">
          #                  | "/" | "[" | "]" | "?" | "="
          #                  | "{" | "}" | SP | HT
          # CHAR           = <any US-ASCII character (octets 0 - 127)>        
          # CTL            = <any US-ASCII control character
          #                                (octets 0 - 31) and DEL (127)> 
          # SP             = <US-ASCII SP, space (32)> 
          # HT             = <US-ASCII HT, horizontal-tab (9)>
          # RFC2616 section 2.2 
  
          # In other words, plain ascii text.  HTTP::Headers doesn't check for
          # this, of course.  So if we complain here, the cluck ends up in
          # the wrong place.  Doing the simplest thing
          utf8::downgrade( $name ) if HAVE_UTF8;
  
          # Deal with header values
          foreach my $value ( $H->header( $name ) ) {
              if( HAVE_UTF8 and utf8::is_utf8( $value ) ) {
                  DEBUG and warn "$$: Header $name is UTF-8";
                  $value = encode_value( $value );
              }
              
              push @ret, join ": ", $name, _process_newline( $value, $endl );
          }
      }
      return @ret;
  }
  
  # This routine is lifted as-is from HTTP::Headers
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # initial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  #------------------------------------------------------------------------------
  
  sub get_pending {
    my $self = shift;
    return [ $self->[BUFFER] ] if length $self->[BUFFER];
    return undef;
  }
  
  #------------------------------------------------------------------------------
  # Functions specific to HTTPD;
  #------------------------------------------------------------------------------
  
  # Internal function to parse an HTTP status line and return the HTTP
  # protocol version.
  
  sub _http_version {
    local($_) = shift;
    return 0 unless m,^(?:HTTP/)?(\d+)\.(\d+)$,i;
    $1 * 1000 + $2;
  }
  
  # Build a basic response, given a status, a content type, and some
  # content.
  
  sub _build_basic_response {
    my ($self, $content, $content_type, $status, $message) = @_;
  
    # Need to check lengths in octets, not characters.
    BEGIN { eval { require bytes } and bytes->import; }
  
    $content_type ||= 'text/html';
    $status       ||= RC_OK;
  
    my $response = HTTP::Response->new($status, $message);
  
    $response->push_header( 'Content-Type', $content_type );
    $response->push_header( 'Content-Length', length($content) );
    $response->content($content);
  
    return $response;
  }
  
  sub _build_error {
    my($self, $status, $details, $req) = @_;
  
    $status  ||= RC_BAD_REQUEST;
    $details ||= '';
    my $message = status_message($status) || "Unknown Error";
  
    my $resp = $self->_build_basic_response(
      ( "<html>" .
        "<head>" .
        "<title>Error $status: $message</title>" .
        "</head>" .
        "<body>" .
        "<h1>Error $status: $message</h1>" .
        "<p>$details</p>" .
        "</body>" .
        "</html>"
      ),
      "text/html",
      $status,
      $message
    );
    $resp->request( $req ) if $req;
    return $resp;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Filter::HTTPD - parse simple HTTP requests, and serialize HTTP::Response
  
  =head1 SYNOPSIS
  
    #!perl
  
    use warnings;
    use strict;
  
    use POE qw(Component::Server::TCP Filter::HTTPD);
    use HTTP::Response;
  
    POE::Component::Server::TCP->new(
      Port         => 8088,
      ClientFilter => 'POE::Filter::HTTPD',  ### <-- HERE WE ARE!
  
      ClientInput => sub {
        my $request = $_[ARG0];
  
        # It's a response for the client if there was a problem.
        if ($request->isa("HTTP::Response")) {
          my $response = $request;
  
          $request = $response->request;
          warn "ERROR: ", $request->message if $request;
  
          $_[HEAP]{client}->put($response);
          $_[KERNEL]->yield("shutdown");
          return;
        }
  
        my $request_fields = '';
        $request->headers()->scan(
          sub {
            my ($header, $value) = @_;
            $request_fields .= (
              "<tr><td>$header</td><td>$value</td></tr>"
            );
          }
        );
  
        my $response = HTTP::Response->new(200);
        $response->push_header( 'Content-type', 'text/html' );
        $response->content(
          "<html><head><title>Your Request</title></head>" .
          "<body>Details about your request:" .
          "<table border='1'>$request_fields</table>" .
          "</body></html>"
        );
  
        $_[HEAP]{client}->put($response);
        $_[KERNEL]->yield("shutdown");
      }
    );
  
    print "Aim your browser at port 8088 of this host.\n";
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Filter::HTTPD interprets input streams as HTTP 0.9, 1.0 or 1.1
  requests.  It returns a HTTP::Request objects upon successfully
  parsing a request.  
  
  On failure, it returns an HTTP::Response object describing the
  failure.  The intention is that application code will notice the
  HTTP::Response and send it back without further processing. The
  erroneous request object is sometimes available via the
  L<HTTP::Response/$r-E<gt>request> method.  This is illustrated in the
  L</SYNOPSIS>.
  
  For output, POE::Filter::HTTPD accepts HTTP::Response objects and
  returns their corresponding streams.
  
  Please see L<HTTP::Request> and L<HTTP::Response> for details about
  how to use these objects.
  
  HTTP headers are not allowed to have UTF-8 characters; they must be
  ISO-8859-1.  POE::Filter::HTTPD will convert all UTF-8 into the MIME encoded
  equivalent.  It uses L<utf8::is_utf8> for detection-8 and
  L<Email::MIME::RFC2047::Encoder> for convertion.  If L<utf8> is not
  installed, no conversion happens.  If L<Email::MIME::RFC2047::Encoder> is
  not installed, L<utf8::downgrade> is used instead.  In this last case, you will
  see a warning if you try to send UTF-8 headers.
  
  
  =head1 PUBLIC FILTER METHODS
  
  POE::Filter::HTTPD implements the basic POE::Filter interface.
  
  =head2 new
  
  new() accepts a list of named parameters.
  
  C<MaxBuffer> sets the maximum amount of data the filter will hold in memory. 
  Defaults to 512 MB (536870912 octets).  Because POE::Filter::HTTPD copies
  all data into memory, setting this number to high would allow a malicious
  HTTPD client to fill all server memory and swap.
  
  C<MaxContent> sets the maximum size of the content of an HTTP request. 
  Defaults to 1 MB (1038336 octets).  Because POE::Filter::HTTPD copies all
  data into memory, setting this number to high would allow a malicious HTTPD
  client to fill all server memory and swap.  Ignored if L</Streaming> is set.
  
  C<Streaming> turns on request streaming mode.  Defaults to off.  In
  streaming mode this filter will return either an HTTP::Request object or a
  block of content.  The HTTP::Request object's content will return empty. 
  The blocks of content will be parts of the request's body, up to
  Content-Length in size.  You distinguish between request objects and content
  blocks using C<Scalar::Util/bless> (See L</Streaming request> below).  This
  option superceeds L</MaxContent>.
  
  =head1 CAVEATS
  
  Some versions of libwww are known to generate invalid HTTP.  For
  example, this code (adapted from the HTTP::Request::Common
  documentation) will cause an error in a POE::Filter::HTTPD daemon:
  
  NOTE: Using this test with libwww-perl/5.834 showed that it added
  the proper HTTP/1.1 data! We're not sure which version of LWP fixed
  this. This example is valid for older LWP installations, beware!
  
    use HTTP::Request::Common;
    use LWP::UserAgent;
  
    my $ua = LWP::UserAgent->new();
    $ua->request(POST 'http://example.com', [ foo => 'bar' ]);
  
  By default, HTTP::Request is HTTP version agnostic. It makes no
  attempt to add an HTTP version header unless you specifically declare
  a protocol using C<< $request->protocol('HTTP/1.0') >>.
  
  According to the HTTP 1.0 RFC (1945), when faced with no HTTP version
  header, the parser is to default to HTTP/0.9.  POE::Filter::HTTPD
  follows this convention.  In the transaction detailed above, the
  Filter::HTTPD based daemon will return a 400 error since POST is not a
  valid HTTP/0.9 request type.
  
  Upon handling a request error, it is most expedient and reliable to
  respond with the error and shut down the connection.  Invalid HTTP
  requests may corrupt the request stream.  For example, the absence of
  a Content-Length header signals that a request has no content.
  Requests with content but without that header will be broken into a
  content-less request and invalid data.  The invalid data may also
  appear to be a request!  Hilarity will ensue, possibly repeatedly,
  until the filter can find the next valid request.  By shutting down
  the connection on the first sign of error, the client can retry its
  request with a clean connection and filter.
  
  
  =head1 Streaming Request
  
  Normally POE::Filter::HTTPD reads the entire request content into memory
  before returning the HTTP::Request to your code.  In streaming mode, it will
  return the content seprately, as unblessed scalars.  The content may be
  split up into blocks of varying sizes, depending on OS and transport
  constraints.  Your code can distinguish the request object from the content
  blocks using L<Scalar::Util/blessed>.
  
      use Scalar::Util;
      use POE::Wheel::ReadWrite;
      use POE::Filter:HTTPD;
  
      $heap->{wheel} = POE::Wheel::ReadWrite->new( 
                          InputEvent => 'http_input',
                          Filter => POE::Filter::HTTPD->new( Streaming => 1 ),
                          # ....
                  );
  
      sub http_input_handler
      {
          my( $heap, $req_or_data ) = @_[ HEAP, ARG0 ];
          if( blessed $req_or_data ) {
              my $request = $req_or_data;
              if( $request->isa( 'HTTP::Response') ) {
                  # HTTP error
                  $heap->{wheel}->put( $request );
              }
              else {
                  # HTTP request
                  # ....
              }
          }
          else {
              my $data = $req_or_data;
              # ....
          }
      }
  
  You may trivally create a DoS bug if you hold all content in memory but do
  not impose a maximum Content-Length.  An attacker could send
  C<Content-Length: 1099511627776> (aka 1 TB) and keep sending data until all
  your system's memory and swap is filled.
  
  Content-Length has been sanitized by POE::Filter::HTTPD so checking it is trivial :
  
      if( $request->headers( 'Content-Length' ) > 1024*1024 ) {
          my $resp = HTTP::Response->new( RC_REQUEST_ENTITY_TOO_LARGE ), 
                                               "So much content!" ) 
          $heap->{wheel}->put( $resp );
          return;
      }
      
  If you want to handle large amounts of data, you should save the content to a file 
  before processing it.  You still need to check Content-Length or an attacker might
  fill up the partition.
  
      use File::Temp qw(tempfile);
  
      if( blessed $_[ARG0] ) {
          $heap->{request} = $_[ARG0];
          if( $heap->{request}->method eq 'GET' ) {
              handle_get( $heap );
              delete $heap->{request};
              return;
          }
          my( $fh, $file ) = tempfile( "httpd-XXXXXXXX", TMPDIR=>1 );
          $heap->{content_file} = $file;
          $heap->{content_fh} = $fh;
          $heap->{content_size} = 0;
      }
      else {
          return unless $heap->{request};
  
          $heap->{content_size} += length( $_[ARG0] );
          $heap->{content_fh}->print( $_[ARG0] );
          if( $heap->{content_size} >= $heap->{request}->headers( 'content-length' ) ) {
              delete $heap->{content_fh};
              delete $heap->{content_size};
  
              # Now we can parse $heap->{content_file}
              if( $heap->{request}->method eq 'POST' ) {
                  handle_post( $heap );
              }
              else {
                  # error ...
              }
          }
      }
  
      sub handle_post
      {
          my( $heap ) = @_;
          # Now we have to load and parse $heap->{content_file}            
  
          # Next 6 lines make the data available to CGI->init
          local $ENV{REQUEST_METHOD} = 'POST';
          local $CGI::PERLEX = $CGI::PERLEX = "CGI-PerlEx/Fake";
          local $ENV{CONTENT_TYPE} = $heap->{req}->header( 'content-type' );
          local $ENV{CONTENT_LENGTH} = $heap->{req}->header( 'content-length' );
          my $keep = IO::File->new( "<&STDIN" ) or die "Unable to reopen STDIN: $!";
          open STDIN, "<$heap->{content_file}" or die "Reopening STDIN failed: $!";
  
          my $qcgi = CGI->new();
  
          # cleanup
          open STDIN, "<&".$keep->fileno or die "Unable to reopen $keep: $!";
          undef $keep;
          unlink delete $heap->{content_file};
  
          # now use $q as you would normaly
          my $file = $q->upload( 'field_name' );
          
          # ....
      }
  
      sub handle_get
      {
          my( $heap ) = @_;
  
          # 4 lines to get data into CGI->init
          local $ENV{REQUEST_METHOD} = 'GET';
          local $CGI::PERLEX = $CGI::PERLEX = "CGI-PerlEx/Fake";   
          local $ENV{CONTENT_TYPE} = $heap->{req}->header( 'content-type' );
          local $ENV{'QUERY_STRING'} = $heap->{req}->uri->query;
  
          my $q = CGI->new();
  
          # now use $q as you would normaly
          # ....
      }
  
  =head1 Streaming Response
  
  It is possible to use POE::Filter::HTTPD for streaming content, but an
  application can use it to send headers and then switch to
  POE::Filter::Stream.
  
  From the input handler (the InputEvent handler if you're using wheels,
  or the ClientInput handler for POE::Component::Server::TCP):
  
    my $response = HTTP::Response->new(200);
    $response->push_header('Content-type', 'audio/x-mpeg');
    $_[HEAP]{client}->put($response);
    $_[HEAP]{client}->set_output_filter(POE::Filter::Stream->new());
  
  Then the output-flushed handler (FlushEvent for POE::Wheel::ReadWrite,
  or ClientFlushed for POE::Component::Server::TCP) can put() chunks of
  the stream as needed.
  
    my $bytes_read = sysread(
      $_[HEAP]{file_to_stream}, my $buffer = '', 4096
    );
  
    if ($bytes_read) {
      $_[HEAP]{client}->put($buffer);
    }
    else {
      delete $_[HEAP]{file_to_stream};
      $_[KERNEL]->yield("shutdown");
    }
  
  =head1 SEE ALSO
  
  Please see L<POE::Filter> for documentation regarding the base
  interface.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  L<HTTP::Request> and L<HTTP::Response> explain all the wonderful
  things you can do with these classes.
  
  =head1 BUGS
  
  Many aspects of HTTP 1.0 and higher are not supported, such as
  keep-alive.  A simple I/O filter can't support keep-alive, for
  example.  A number of more feature-rich POE HTTP servers are on the
  CPAN.  See
  L<http://search.cpan.org/search?query=POE+http+server&mode=dist>
  
  =head1 AUTHORS & COPYRIGHTS
  
  POE::Filter::HTTPD was contributed by Artur Bergman.  Documentation is
  provided by Rocco Caputo.
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_FILTER_HTTPD

$fatpacked{"POE/Filter/IRC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER_IRC';
  package POE::Filter::IRC;
  BEGIN {
    $POE::Filter::IRC::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Filter::IRC::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use POE::Filter::Stackable;
  use POE::Filter::IRCD;
  use POE::Filter::IRC::Compat;
  
  sub new {
      my ($package, %opts) = @_;
      $opts{lc $_} = delete $opts{$_} for keys %opts;
      return POE::Filter::Stackable->new(
          Filters => [
              POE::Filter::IRCD->new( DEBUG => $opts{debug} ),
              POE::Filter::IRC::Compat->new( DEBUG => $opts{debug} ),
          ],
      );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Filter::IRC -- A POE-based parser for the IRC protocol
  
  =head1 SYNOPSIS
  
   my $filter = POE::Filter::IRC->new();
   my @events = @{ $filter->get( [ @lines ] ) };
  
  =head1 DESCRIPTION
  
  POE::Filter::IRC takes lines of raw IRC input and turns them into weird little
  data structures, suitable for feeding to L<POE::Component::IRC|POE::Component::IRC>.
  They look like this:
  
   { name => 'event name', args => [ some info about the event ] }
  
  This module was long deprecated in L<POE::Component::IRC|POE::Component::IRC>.
  It now uses the same mechanism that that uses to parse IRC text.
  
  =head1 CONSTRUCTOR
  
  =head2 C<new>
  
  Returns a new L<POE::Filter::Stackable|POE::Filter::Stackable> object containing
  a L<POE::Filter::IRCD|POE::Filter::IRCD> object and a
  L<POE::Filter::IRC::Compat|POE::Filter::IRC::Compat> object. This does the same
  job that POE::Filter::IRC used to do.
  
  =head1 METHODS
  
  See the documentation for POE::Filter::IRCD and POE::Filter::IRC::Compat.
  
  =head1 AUTHOR
  
  Dennis C<fimmtiu> Taylor
  
  Refactoring by Chris C<BinGOs> Williams <chris@bingosnet.co.uk>
  
  =head1 SEE ALSO
  
  The documentation for L<POE|POE> and L<POE::Component::IRC|POE::Component::IRC>.
  
  L<POE::Filter::Stackable|POE::Filter::Stackable>
  
  L<POE::Filter::IRCD|POE::Filter::IRCD>
  
  L<POE::Filter::IRC::Compat|POE::Filter::IRC::Compat>
  
  =cut
POE_FILTER_IRC

$fatpacked{"POE/Filter/IRC/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER_IRC_COMPAT';
  package POE::Filter::IRC::Compat;
  BEGIN {
    $POE::Filter::IRC::Compat::AUTHORITY = 'cpan:HINRIK';
  }
  $POE::Filter::IRC::Compat::VERSION = '6.88';
  use strict;
  use warnings FATAL => 'all';
  use Carp;
  use POE::Filter::IRCD;
  use File::Basename qw(fileparse);
  use base qw(POE::Filter);
  
  my %irc_cmds = (
      qr/^\d{3}$/ => sub {
          my ($self, $event, $line) = @_;
          $event->{args}->[0] = _decolon( $line->{prefix} );
          shift @{ $line->{params} };
          if ( $line->{params}->[0] && $line->{params}->[0] =~ /\x20/ ) {
              $event->{args}->[1] = $line->{params}->[0];
          }
          else {
              $event->{args}->[1] = join(' ', ( map { /\x20/ ? ":$_" : $_ } @{ $line->{params} } ) );
          }
          $event->{args}->[2] = $line->{params};
      },
      qr/^cap$/ => sub {
          my ($self, $event, $line) = @_;
  
          for (my $i = 0; ; $i++) {
              last if !defined $line->{params}[$i+1];
              $event->{args}[$i] = $line->{params}[$i+1];
          }
      },
      qr/^notice$/ => sub {
          my ($self, $event, $line) = @_;
  
          if (defined $line->{prefix} && $line->{prefix} =~ /!/) {
              $event->{args} = [
                  _decolon( $line->{prefix} ),
                  [split /,/, $line->{params}->[0]],
                  ($self->{identifymsg}
                      ? _split_idmsg($line->{params}->[1])
                      : $line->{params}->[1]
                  ),
              ];
          }
          else {
              $event->{name} = 'snotice';
              $event->{args} = [
                  $line->{params}->[1],
                  $line->{params}->[0],
                  (defined $line->{prefix} ? _decolon($line->{prefix}) : ()),
              ];
          }
      },
      qr/^privmsg$/ => sub {
          my ($self, $event, $line) = @_;
          if ( grep { index( $line->{params}->[0], $_ ) >= 0 } @{ $self->{chantypes} } ) {
              $event->{args} = [
                  _decolon( $line->{prefix} ),
                  [split /,/, $line->{params}->[0]],
                  ($self->{identifymsg}
                      ? _split_idmsg($line->{params}->[1])
                      : $line->{params}->[1]
                  ),
              ];
              $event->{name} = 'public';
          }
          else {
              $event->{args} = [
                  _decolon( $line->{prefix} ),
                  [split /,/, $line->{params}->[0]],
                  ($self->{identifymsg}
                      ? _split_idmsg($line->{params}->[1])
                      : $line->{params}->[1]
                  ),
              ];
              $event->{name} = 'msg';
          }
      },
      qr/^invite$/ => sub {
          my ($self, $event, $line) = @_;
          shift( @{ $line->{params} } );
          unshift( @{ $line->{params} }, _decolon( $line->{prefix} || '' ) ) if $line->{prefix};
          $event->{args} = $line->{params};
      },
  );
  
  # the magic cookie jar
  my %dcc_types = (
      qr/^(?:CHAT|SEND)$/ => sub {
          my ($nick, $type, $args) = @_;
          my ($file, $addr, $port, $size);
          return if !(($file, $addr, $port, $size) = $args =~ /^(".+"|[^ ]+) +(\d+) +(\d+)(?: +(\d+))?/);
  
          if ($file =~ s/^"//) {
              $file =~ s/"$//;
              $file =~ s/\\"/"/g;
          }
          $file = fileparse($file);
  
          return (
              $port,
              {
                  nick => $nick,
                  type => $type,
                  file => $file,
                  size => $size,
                  addr => $addr,
                  port => $port,
              },
              $file,
              $size,
              $addr,
          );
      },
      qr/^(?:ACCEPT|RESUME)$/ => sub {
          my ($nick, $type, $args) = @_;
          my ($file, $port, $position);
          return if !(($file, $port, $position) = $args =~ /^(".+"|[^ ]+) +(\d+) +(\d+)/);
  
          $file =~ s/^"|"$//g;
          $file = fileparse($file);
  
          return (
              $port,
              {
                  nick => $nick,
                  type => $type,
                  file => $file,
                  size => $position,
                  port => $port,
              },
              $file,
              $position,
          );
      },
  );
  
  sub new {
      my ($package, %self) = @_;
  
      $self{lc $_} = delete $self{$_} for keys %self;
      $self{BUFFER} = [ ];
      $self{_ircd} = POE::Filter::IRCD->new();
      $self{chantypes} = [ '#', '&' ] if ref $self{chantypes} ne 'ARRAY';
  
      return bless \%self, $package;
  }
  
  sub clone {
      my $self = shift;
      my $nself = { };
      $nself->{$_} = $self->{$_} for keys %{ $self };
      $nself->{BUFFER} = [ ];
      return bless $nself, ref $self;
  }
  
  # Set/clear the 'debug' flag.
  sub debug {
      my ($self, $flag) = @_;
      if (defined $flag) {
          $self->{debug} = $flag;
          $self->{_ircd}->debug($flag);
      }
      return $self->{debug};
  }
  
  sub chantypes {
      my ($self, $ref) = @_;
      return if ref $ref ne 'ARRAY' || !@{ $ref };
      $self->{chantypes} = $ref;
      return 1;
  }
  
  sub identifymsg {
      my ($self, $switch) = @_;
      $self->{identifymsg} = $switch;
      return;
  }
  
  sub _split_idmsg {
      my ($line) = @_;
      my ($identified, $msg) = split //, $line, 2;
      $identified = $identified eq '+' ? 1 : 0;
      return $msg, $identified;
  }
  
  sub get_one {
      my ($self) = @_;
      my $line = shift @{ $self->{BUFFER} } or return [ ];
  
      if (ref $line ne 'HASH' || !$line->{command} || !$line->{params}) {
          warn "Received line '$line' that is not IRC protocol\n" if $self->{debug};
          return [ ];
      }
  
      if ($line->{command} =~ /^PRIVMSG|NOTICE$/ && $line->{params}->[1] =~ tr/\001//) {
          return $self->_get_ctcp($line);
      }
  
      my $event = {
          name     => lc $line->{command},
          raw_line => $line->{raw_line},
      };
  
      for my $cmd (keys %irc_cmds) {
          if ($event->{name} =~ $cmd) {
              $irc_cmds{$cmd}->($self, $event, $line);
              return [ $event ];
          }
      }
  
      # default
      unshift( @{ $line->{params} }, _decolon( $line->{prefix} || '' ) ) if $line->{prefix};
      $event->{args} = $line->{params};
      return [ $event ];
  }
  
  sub get_one_start {
      my ($self, $lines) = @_;
      push @{ $self->{BUFFER} }, @$lines;
      return;
  }
  
  sub put {
      my ($self, $lineref) = @_;
      my $quoted = [ ];
      push @$quoted, _ctcp_quote($_) for @$lineref;
      return $quoted;
  }
  
  # Properly CTCP-quotes a message. Whoop.
  sub _ctcp_quote {
      my ($line) = @_;
  
      $line = _low_quote( $line );
      #$line =~ s/\\/\\\\/g;
      $line =~ s/\001/\\a/g;
  
      return "\001$line\001";
  }
  
  # Splits a message into CTCP and text chunks. This is gross. Most of
  # this is also stolen from Net::IRC, but I (fimm) wrote that too, so it's
  # used with permission. ;-)
  sub _ctcp_dequote {
      my ($msg) = @_;
      my (@chunks, $ctcp, $text);
  
      # CHUNG! CHUNG! CHUNG!
  
      if (!defined $msg) {
          croak 'Not enough arguments to POE::Filter::IRC::Compat::_ctcp_dequote';
      }
  
      # Strip out any low-level quoting in the text.
      $msg = _low_dequote( $msg );
  
      # Filter misplaced \001s before processing... (Thanks, tchrist!)
      substr($msg, rindex($msg, "\001"), 1, '\\a')
          if ($msg =~ tr/\001//) % 2 != 0;
  
      return if $msg !~ tr/\001//;
  
      @chunks = split /\001/, $msg;
      shift @chunks if !length $chunks[0]; # FIXME: Is this safe?
  
      for (@chunks) {
          # Dequote unnecessarily quoted chars, and convert escaped \'s and ^A's.
          s/\\([^\\a])/$1/g;
          s/\\\\/\\/g;
          s/\\a/\001/g;
      }
  
      # If the line begins with a control-A, the first chunk is a CTCP
      # message. Otherwise, it starts with text and alternates with CTCP
      # messages. Really stupid protocol.
      if ($msg =~ /^\001/) {
          push @$ctcp, shift @chunks;
      }
  
      while (@chunks) {
          push @$text, shift @chunks;
          push @$ctcp, shift @chunks if @chunks;
      }
  
      return ($ctcp, $text);
  }
  
  sub _decolon {
      my ($line) = @_;
  
      $line =~ s/^://;
      return $line;
  }
  
  ## no critic (Subroutines::ProhibitExcessComplexity)
  sub _get_ctcp {
      my ($self, $line) = @_;
  
      # Is this a CTCP request or reply?
      my $ctcp_type = $line->{command} eq 'PRIVMSG' ? 'ctcp' : 'ctcpreply';
  
      # CAPAP IDENTIFY-MSG is only applied to ACTIONs
      my ($msg, $identified) = ($line->{params}->[1], undef);
      ($msg, $identified) = _split_idmsg($msg) if $self->{identifymsg} && $msg =~ /^.ACTION/;
  
      my $events = [ ];
      my ($ctcp, $text) = _ctcp_dequote($msg);
  
      if (!defined $ctcp) {
          warn "Received malformed CTCP message: $msg\n" if $self->{debug};
          return $events;
      }
  
      my $nick = defined $line->{prefix} ? (split /!/, $line->{prefix})[0] : undef;
  
      # We only process the first CTCP. The only people who send multiple ones
      # are those who are trying to flood our outgoing queue anyway (e.g. by
      # having us reply to 20 VERSION requests at a time).
      my ($name, $args);
      CTCP: for my $string ($ctcp->[0]) {
          if (!(($name, $args) = $string =~ /^(\w+)(?: +(.*))?/)) {
              defined $nick
                  ? do { warn "Received malformed CTCP message from $nick: $string\n" if $self->{debug} }
                  : do { warn "Trying to send malformed CTCP message: $string\n" if $self->{debug} }
              ;
              last CTCP;
          }
  
          if (lc $name eq 'dcc') {
              my ($dcc_type, $rest);
  
              if (!(($dcc_type, $rest) = $args =~ /^(\w+) +(.+)/)) {
                  defined $nick
                      ? do { warn "Received malformed DCC request from $nick: $args\n" if $self->{debug} }
                      : do { warn "Trying to send malformed DCC request: $args\n" if $self->{debug} }
                  ;
                  last CTCP;
  
              }
              $dcc_type = uc $dcc_type;
  
              my ($handler) = grep { $dcc_type =~ /$_/ } keys %dcc_types;
              if (!$handler) {
                  warn "Unhandled DCC $dcc_type request: $rest\n" if $self->{debug};
                  last CTCP;
              }
  
              my @dcc_args = $dcc_types{$handler}->($nick, $dcc_type, $rest);
              if (!@dcc_args) {
                  defined $nick
                      ? do { warn "Received malformed DCC $dcc_type request from $nick: $rest\n" if $self->{debug} }
                      : do { warn "Trying to send malformed DCC $dcc_type request: $rest\n" if $self->{debug} }
                  ;
                  last CTCP;
              }
  
              push @$events, {
                  name => 'dcc_request',
                  args => [
                      $line->{prefix},
                      $dcc_type,
                      @dcc_args,
                  ],
                  raw_line => $line->{raw_line},
              };
          }
          else {
              push @$events, {
                  name => $ctcp_type . '_' . lc $name,
                  args => [
                      $line->{prefix},
                      [split /,/, $line->{params}->[0]],
                      (defined $args ? $args : ''),
                      (defined $identified ? $identified : () ),
                  ],
                  raw_line => $line->{raw_line},
              };
          }
      }
  
      # XXX: I'm not quite sure what this is for, but on FreeNode it adds an
      # extra bogus event and displays a debug message, so I have disabled it.
      # FreeNode precedes PRIVMSG and CTCP ACTION messages with '+' or '-'.
      #if ($text && @$text) {
      #    my $what;
      #    ($what) = $line->{raw_line} =~ /^(:[^ ]+ +\w+ +[^ ]+ +)/
      #        or warn "What the heck? '".$line->{raw_line}."'\n" if $self->{debug};
      #    $text = (defined $what ? $what : '') . ':' . join '', @$text;
      #    $text =~ s/\cP/^P/g;
      #    warn "CTCP: $text\n" if $self->{debug};
      #    push @$events, @{ $self->{_ircd}->get([$text]) };
      #}
  
      return $events;
  }
  
  # Quotes a string in a low-level, protocol-safe, utterly brain-dead
  # fashion. Returns the quoted string.
  sub _low_quote {
      my ($line) = @_;
      my %enquote = ("\012" => 'n', "\015" => 'r', "\0" => '0', "\cP" => "\cP");
  
      if (!defined $line) {
          croak 'Not enough arguments to POE::Filter::IRC::Compat->_low_quote';
      }
  
      if ($line =~ tr/[\012\015\0\cP]//) { # quote \n, \r, ^P, and \0.
          $line =~ s/([\012\015\0\cP])/\cP$enquote{$1}/g;
      }
  
      return $line;
  }
  
  # Does low-level dequoting on CTCP messages. I hate this protocol.
  # Yes, I copied this whole section out of Net::IRC.
  sub _low_dequote {
      my ($line) = @_;
      my %dequote = (n => "\012", r => "\015", 0 => "\0", "\cP" => "\cP");
  
      if (!defined $line) {
          croak 'Not enough arguments to POE::Filter::IRC::Compat->_low_dequote';
      }
  
      # dequote \n, \r, ^P, and \0.
      # Thanks to Abigail (abigail@foad.org) for this clever bit.
      if ($line =~ tr/\cP//) {
          $line =~ s/\cP([nr0\cP])/$dequote{$1}/g;
      }
  
      return $line;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  POE::Filter::IRC::Compat - A filter which converts L<POE::Filter::IRCD|POE::Filter::IRCD>
  output into L<POE::Component::IRC|POE::Component::IRC> events
  
  =head1 SYNOPSIS
  
   my $filter = POE::Filter::IRC::Compat->new();
   my @events = @{ $filter->get( [ @lines ] ) };
   my @msgs = @{ $filter->put( [ @messages ] ) };
  
  =head1 DESCRIPTION
  
  POE::Filter::IRC::Compat is a L<POE::Filter|POE::Filter> that converts
  L<POE::Filter::IRCD|POE::Filter::IRCD> output into the L<POE::Component::IRC|POE::Component::IRC>
  compatible event references. Basically a hack, so I could replace
  L<POE::Filter::IRC|POE::Filter::IRC> with something that was more
  generic.
  
  Among other things, it converts normal text into thoroughly CTCP-quoted
  messages, and transmogrifies CTCP-quoted messages into their normal,
  sane components. Rather what you'd expect a filter to do.
  
  A note: the CTCP protocol sucks bollocks. If I ever meet the fellow who
  came up with it, I'll shave their head and tattoo obscenities on it.
  Just read the "specification" (F<docs/ctcpspec.html> in this distribution)
  and you'll hopefully see what I mean. Quote this, quote that, quote this
  again, all in different and weird ways... and who the hell needs to send
  mixed CTCP and text messages? WTF? It looks like it's practically complexity
  for complexity's sake -- and don't even get me started on the design of the
  DCC protocol! Anyhow, enough ranting. Onto the rest of the docs...
  
  =head1 METHODS
  
  =head2 C<new>
  
  Returns a POE::Filter::IRC::Compat object. Takes no arguments.
  
  =head2 C<clone>
  
  Makes a copy of the filter, and clears the copy's buffer.
  
  =head2 C<get>
  
  Takes an arrayref of L<POE::Filter::IRCD> hashrefs and produces an arrayref of
  L<POE::Component::IRC|POE::Component::IRC> compatible event hashrefs. Yay.
  
  =head2 C<get_one_start>, C<get_one>
  
  These perform a similar function as C<get> but enable the filter to work with
  L<POE::Filter::Stackable|POE::Filter::Stackable>.
  
  =head2 C<put>
  
  Takes an array reference of CTCP messages to be properly quoted. This
  doesn't support CTCPs embedded in normal messages, which is a
  brain-dead hack in the protocol, so do it yourself if you really need
  it. Returns an array reference of the quoted lines for sending.
  
  =head2 C<debug>
  
  Takes an optinal true/false value which enables/disables debugging
  accordingly. Returns the debug status.
  
  =head2 C<chantypes>
  
  Takes an arrayref of possible channel prefix indicators.
  
  =head2 C<identifymsg>
  
  Takes a boolean to turn on/off the support for CAPAB IDENTIFY-MSG.
  
  =head1 AUTHOR
  
  Chris 'BinGOs' Williams
  
  =head1 SEE ALSO
  
  L<POE::Filter::IRCD|POE::Filter::IRCD>
  
  L<POE::Filter|POE::Filter>
  
  L<POE::Filter::Stackable|POE::Filter::Stackable>
  
  =cut
POE_FILTER_IRC_COMPAT

$fatpacked{"POE/Filter/IRCD.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER_IRCD';
  package POE::Filter::IRCD;
  {
    $POE::Filter::IRCD::VERSION = '2.44';
  }
  
  #ABSTRACT: A POE-based parser for the IRC protocol
  
  use strict;
  use warnings;
  use Carp;
  use base qw[POE::Filter];
  
  sub _PUT_LITERAL () { 1 }
  
  # Probably some other stuff should go here.
  
  my $g = {
    space			=> qr/\x20+/o,
    trailing_space	=> qr/\x20*/o,
  };
  
  my $irc_regex = qr/^
    (?:
      \x40                # '@'-prefixed IRCv3.2 messsage tags.
      (\S+)               # [tags] Semi-colon delimited key=value list
      $g->{space}
    )?
    (?:
      \x3a                #  : comes before hand
      (\S+)               #  [prefix]
      $g->{'space'}       #  Followed by a space
    )?                    # but is optional.
    (
      \d{3}|[a-zA-Z]+     #  [command]
    )                     # required.
    (?:
      $g->{'space'}       # Strip leading space off [middle]s
      (                   # [middle]s
        (?:
          [^\x00\x0a\x0d\x20\x3a]
          [^\x00\x0a\x0d\x20]*
        )                 # Match on 1 of these,
        (?:
          $g->{'space'}
          [^\x00\x0a\x0d\x20\x3a]
          [^\x00\x0a\x0d\x20]*
        )*                # then match as many of these as possible
      )
    )?                    # otherwise dont match at all.
    (?:
      $g->{'space'}\x3a   # Strip off leading spacecolon for [trailing]
      ([^\x00\x0a\x0d]*)	# [trailing]
    )?                    # [trailing] is not necessary.
    $g->{'trailing_space'}
  $/x;
  
  sub new {
    my $type = shift;
    croak "$type requires an even number of parameters" if @_ % 2;
    my $buffer = { @_ };
    $buffer->{uc $_} = delete $buffer->{$_} for keys %{ $buffer };
    $buffer->{BUFFER} = [];
    return bless $buffer, $type;
  }
  
  sub debug {
    my $self = shift;
    my $value = shift;
  
    if ( defined $value ) {
  	$self->{DEBUG} = $value;
  	return $self->{DEBUG};
    }
    $self->{DEBUG} = $value;
  }
  
  sub get {
    my ($self, $raw_lines) = @_;
    my $events = [];
  
    foreach my $raw_line (@$raw_lines) {
      warn "->$raw_line \n" if $self->{DEBUG};
      if ( my($tags, $prefix, $command, $middles, $trailing) = $raw_line =~ m/$irc_regex/ ) {
        my $event = { raw_line => $raw_line };
        if ($tags) {
          for my $tag_pair (split /;/, $tags) {
            my ($thistag, $thisval) = split /=/, $tag_pair;
            $event->{tags}->{$thistag} = $thisval
          }
        }
        $event->{'prefix'} = $prefix if $prefix;
        $event->{'command'} = uc $command;
        $event->{'params'} = [] if defined ( $middles ) || defined ( $trailing );
        push @{$event->{'params'}}, (split /$g->{'space'}/, $middles) if defined $middles;
        push @{$event->{'params'}}, $trailing if defined $trailing;
        push @$events, $event;
      }
      else {
        warn "Received line $raw_line that is not IRC protocol\n";
      }
    }
    return $events;
  }
  
  sub get_one_start {
    my ($self, $raw_lines) = @_;
    push @{ $self->{BUFFER} }, $_ for @$raw_lines;
  }
  
  sub get_one {
    my $self = shift;
    my $events = [];
  
    if ( my $raw_line = shift ( @{ $self->{BUFFER} } ) ) {
      warn "->$raw_line \n" if $self->{DEBUG};
      if ( my($tags, $prefix, $command, $middles, $trailing) = $raw_line =~ m/$irc_regex/ ) {
        my $event = { raw_line => $raw_line };
        if ($tags) {
          for my $tag_pair (split /;/, $tags) {
            my ($thistag, $thisval) = split /=/, $tag_pair;
            $event->{tags}->{$thistag} = $thisval
          }
        }
        $event->{'prefix'} = $prefix if $prefix;
        $event->{'command'} = uc $command;
        $event->{'params'} = [] if defined ( $middles ) || defined ( $trailing );
        push @{$event->{'params'}}, (split /$g->{'space'}/, $middles) if defined $middles;
        push @{$event->{'params'}}, $trailing if defined $trailing;
        push @$events, $event;
      }
      else {
        warn "Received line $raw_line that is not IRC protocol\n";
      }
    }
    return $events;
  }
  
  sub get_pending {
    return;
  }
  
  sub put {
    my ($self, $events) = @_;
    my $raw_lines = [];
  
    foreach my $event (@$events) {
      if (ref $event eq 'HASH') {
        my $colonify = ( defined $event->{colonify} ? $event->{colonify} : $self->{COLONIFY} );
        if ( _PUT_LITERAL || _checkargs($event) ) {
          my $raw_line = '';
          if ( ref $event->{tags} eq 'HASH' && keys %{ $event->{tags} } ) {
            $raw_line .= '@';
            my @tags = %{ $event->{tags} };
            while (my ($thistag, $thisval) = splice @tags, 0, 2) {
              $raw_line .= $thistag . ( defined $thisval ? '='.$thisval : '' );
              $raw_line .= ';' if @tags;
            }
            $raw_line .= ' ';
          }
          $raw_line .= (':' . $event->{'prefix'} . ' ') if exists $event->{'prefix'};
          $raw_line .= $event->{'command'};
  	if ( $event->{'params'} and ref $event->{'params'} eq 'ARRAY' ) {
  		my $params = [ @{ $event->{'params'} } ];
  		$raw_line .= ' ';
  		my $param = shift @$params;
  		while (@$params) {
  			$raw_line .= $param . ' ';
  			$param = shift @$params;
  		}
  		$raw_line .= ':' if $param =~ m/\x20/ or $colonify;
  		$raw_line .= $param;
  	}
          push @$raw_lines, $raw_line;
          warn "<-$raw_line \n" if $self->{DEBUG};
        }
        else {
          next;
        }
      }
      else {
        warn __PACKAGE__ . " non hashref passed to put(): \"$event\"\n";
        push @$raw_lines, $event if ref $event eq 'SCALAR';
      }
    }
    return $raw_lines;
  }
  
  sub clone {
    my $self = shift;
    my $nself = { };
    $nself->{$_} = $self->{$_} for keys %{ $self };
    $nself->{BUFFER} = [ ];
    return bless $nself, ref $self;
  }
  
  # This thing is far from correct, dont use it.
  sub _checkargs {
    my $event = shift || return;
    warn("Invalid characters in prefix: " . $event->{'prefix'} . "\n")
      if ($event->{'prefix'} =~ m/[\x00\x0a\x0d\x20]/);
    warn("Undefined command passed.\n")
      unless ($event->{'command'} =~ m/\S/o);
    warn("Invalid command: " . $event->{'command'} . "\n")
      unless ($event->{'command'} =~ m/^(?:[a-zA-Z]+|\d{3})$/o);
    foreach my $middle (@{$event->{'middles'}}) {
      warn("Invalid middle: $middle\n")
        unless ($middle =~ m/^[^\x00\x0a\x0d\x20\x3a][^\x00\x0a\x0d\x20]*$/);
    }
    warn("Invalid trailing: " . $event->{'trailing'} . "\n")
      unless ($event->{'trailing'} =~ m/^[\x00\x0a\x0d]*$/);
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  POE::Filter::IRCD - A POE-based parser for the IRC protocol
  
  =head1 VERSION
  
  version 2.44
  
  =head1 SYNOPSIS
  
      use POE::Filter::IRCD;
  
      my $filter = POE::Filter::IRCD->new( debug => 1, colonify => 0 );
      my $arrayref = $filter->get( [ $hashref ] );
      my $arrayref2 = $filter->put( $arrayref );
  
      use POE qw(Filter::Stackable Filter::Line Filter::IRCD);
  
      my ($filter) = POE::Filter::Stackable->new();
      $filter->push( POE::Filter::Line->new( InputRegexp => '\015?\012', OutputLiteral => "\015\012" ),
  		   POE::Filter::IRCD->new(), );
  
  =head1 DESCRIPTION
  
  POE::Filter::IRCD provides a convenient way of parsing and creating IRC protocol
  lines. It provides the parsing engine for L<POE::Component::Server::IRC> and L<POE::Component::IRC>.
  A standalone version exists as L<Parse::IRC>.
  
  =head1 CONSTRUCTOR
  
  =over
  
  =item C<new>
  
  Creates a new POE::Filter::IRCD object. Takes two optional arguments:
  
    'debug', which will print all lines received to STDERR;
    'colonify', set to 1 to force the filter to always colonify the last param passed in a put(),
                default is 0. See below for more detail.
  
  =back
  
  =head1 METHODS
  
  =over
  
  =item C<get_one_start>
  
  =item C<get_one>
  
  =item C<get_pending>
  
  =item C<get>
  
  Takes an arrayref which is contains lines of IRC formatted input. Returns an arrayref of hashrefs
  which represents the lines. The hashref contains the following fields:
  
    prefix
    command
    params ( this is an arrayref )
    raw_line
  
  For example, if the filter receives the following line, the following hashref is produced:
  
    LINE: ':moo.server.net 001 lamebot :Welcome to the IRC network lamebot'
  
    HASHREF: {
  		prefix   => ':moo.server.net',
  		command  => '001',
  		params   => [ 'lamebot', 'Welcome to the IRC network lamebot' ],
  		raw_line => ':moo.server.net 001 lamebot :Welcome to the IRC network lamebot',
  	   }
  
  =item C<put>
  
  Takes an arrayref containing hashrefs of IRC data and returns an arrayref containing IRC formatted lines.
  Optionally, one can specify 'colonify' to override the global colonification option.
  eg.
  
    $hashref = {
  		command => 'PRIVMSG',
  		prefix => 'FooBar!foobar@foobar.com',
  		params => [ '#foobar', 'boo!' ],
  		colonify => 1, # Override the global colonify option for this record only.
  	      };
  
    $filter->put( [ $hashref ] );
  
  =item C<clone>
  
  Makes a copy of the filter, and clears the copy's buffer.
  
  =item C<debug>
  
  With a true or false argument, enables or disables debug output respectively. Without an argument the behaviour is to toggle the debug status.
  
  =back
  
  =head1 SEE ALSO
  
  L<POE>
  
  L<POE::Filter>
  
  L<POE::Filter::Stackable>
  
  L<POE::Component::Server::IRC>
  
  L<POE::Component::IRC>
  
  L<Parse::IRC>
  
  =head1 AUTHOR
  
  Chris Williams <chris@bingosnet.co.uk>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Chris Williams and Jonathan Steinert.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
POE_FILTER_IRCD

$fatpacked{"POE/Filter/Line.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER_LINE';
  package POE::Filter::Line;
  
  use strict;
  use POE::Filter;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  @ISA = qw(POE::Filter);
  
  use Carp qw(carp croak);
  
  sub DEBUG () { 0 }
  
  sub FRAMING_BUFFER   () { 0 }
  sub INPUT_REGEXP     () { 1 }
  sub OUTPUT_LITERAL   () { 2 }
  sub AUTODETECT_STATE () { 3 }
  sub MAX_LENGTH       () { 4 }
  sub MAX_BUFFER       () { 5 }
  sub FIRST_UNUSED     () { 6 }  # First unused $self offset.
  
  sub AUTO_STATE_DONE   () { 0x00 }
  sub AUTO_STATE_FIRST  () { 0x01 }
  sub AUTO_STATE_SECOND () { 0x02 }
  
  use base 'Exporter';
  our @EXPORT_OK = qw( FIRST_UNUSED );
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
  
    croak "$type requires an even number of parameters" if @_ and @_ & 1;
    my %params = @_;
  
    croak "$type cannot have both Regexp and Literal line endings" if (
      defined $params{Regexp} and defined $params{Literal}
    );
  
    my ($input_regexp, $output_literal);
    my $autodetect = AUTO_STATE_DONE;
  
    # Literal newline for both incoming and outgoing.  Every other known
    # parameter conflicts with this one.
    if (defined $params{Literal}) {
      croak "A defined Literal must have a nonzero length"
        unless defined($params{Literal}) and length($params{Literal});
      $input_regexp   = quotemeta $params{Literal};
      $output_literal = $params{Literal};
      if (
        exists $params{InputLiteral} or # undef means something
        defined $params{InputRegexp} or
        defined $params{OutputLiteral}
      ) {
        croak "$type cannot have Literal with any other parameter";
      }
    }
  
    # Input and output are specified separately, then.
    else {
  
      # Input can be either a literal or a regexp.  The regexp may be
      # compiled or not; we don't rightly care at this point.
      if (exists $params{InputLiteral}) {
        $input_regexp = $params{InputLiteral};
  
        # InputLiteral is defined.  Turn it into a regexp and be done.
        # Otherwise we will autodetect it.
        if (defined($input_regexp) and length($input_regexp)) {
          $input_regexp = quotemeta $input_regexp;
        }
        else {
          $autodetect   = AUTO_STATE_FIRST;
          $input_regexp = '';
        }
  
        croak "$type cannot have both InputLiteral and InputRegexp"
          if defined $params{InputRegexp};
      }
      elsif (defined $params{InputRegexp}) {
        $input_regexp = $params{InputRegexp};
        croak "$type cannot have both InputLiteral and InputRegexp"
          if defined $params{InputLiteral};
      }
      else {
        $input_regexp = "(\\x0D\\x0A?|\\x0A\\x0D?)";
      }
  
      if (defined $params{OutputLiteral}) {
        $output_literal = $params{OutputLiteral};
      }
      else {
        $output_literal = "\x0D\x0A";
      }
    }
  
    my $max_buffer = $type->__param_max( MaxBuffer => 512*1024*1024, \%params );
    my $max_length = $type->__param_max( MaxLength => 64*1024*1024, \%params );
    croak "MaxBuffer is not large enough for MaxLength blocks"
          unless $max_buffer >= $max_length;
  
    delete @params{qw(Literal InputLiteral OutputLiteral InputRegexp MaxLength MaxBuffer)};
    carp("$type ignores unknown parameters: ", join(', ', sort keys %params))
      if scalar keys %params;
  
    my $self = bless [
      '',              # FRAMING_BUFFER
      $input_regexp,   # INPUT_REGEXP
      $output_literal, # OUTPUT_LITERAL
      $autodetect,     # AUTODETECT_STATE
      $max_length,     # MAX_LENGTH
      $max_buffer      # MAX_BUFFER
    ], $type;
  
    DEBUG and warn join ':', @$self;
  
    $self;
  }
  
  
  #------------------------------------------------------------------------------
  # get() is inherited from POE::Filter.
  
  #------------------------------------------------------------------------------
  # 2001-07-27 RCC: Add get_one_start() and get_one() to correct filter
  # changing and make input flow control possible.
  
  sub get_one_start {
    my ($self, $stream) = @_;
  
    DEBUG and do {
      my $temp = join '', @$stream;
      $temp = unpack 'H*', $temp;
      warn "got some raw data: $temp\n";
    };
  
    $self->[FRAMING_BUFFER] .= join '', @$stream;
    die "Framing buffer exceeds the limit"
      if $self->[MAX_BUFFER] < length( $self->[FRAMING_BUFFER] );
  }
  
  # TODO There is a lot of code duplicated here.  What can be done?
  
  sub get_one {
    my $self = shift;
  
    # Process as many newlines an we can find.
    LINE: while (1) {
  
      # Autodetect is done, or it never started.  Parse some buffer!
      unless ($self->[AUTODETECT_STATE]) {
        DEBUG and warn unpack 'H*', $self->[INPUT_REGEXP];
        last LINE
          unless $self->[FRAMING_BUFFER] =~ s/^(.*?)$self->[INPUT_REGEXP]//s;
        DEBUG and warn "got line: <<", unpack('H*', $1), ">>\n";
        my $line = $1;
        die "Next line exceeds maximum line length"
              if length( $line ) > $self->[MAX_LENGTH];
  
        return [ $line ];
      }
  
      # Waiting for the first line ending.  Look for a generic newline.
      if ($self->[AUTODETECT_STATE] & AUTO_STATE_FIRST) {
        last LINE
          unless $self->[FRAMING_BUFFER] =~ s/^(.*?)(\x0D\x0A?|\x0A\x0D?)//;
  
        my $line = $1;
  
        # The newline can be complete under two conditions.  First: If
        # it's two characters.  Second: If there's more data in the
        # framing buffer.  Loop around in case there are more lines.
        if ( (length($2) == 2) or
             (length $self->[FRAMING_BUFFER])
           ) {
          DEBUG and warn "detected complete newline after line: <<$1>>\n";
          $self->[INPUT_REGEXP] = $2;
          $self->[AUTODETECT_STATE] = AUTO_STATE_DONE;
        }
  
        # The regexp has matched a potential partial newline.  Save it,
        # and move to the next state.  There is no more data in the
        # framing buffer, so we're done.
        else {
          DEBUG and warn "detected suspicious newline after line: <<$1>>\n";
          $self->[INPUT_REGEXP] = $2;
          $self->[AUTODETECT_STATE] = AUTO_STATE_SECOND;
        }
        die "Next line exceeds maximum line length"
              if length( $line ) > $self->[MAX_LENGTH];
  
        return [ $line ];
      }
  
      # Waiting for the second line beginning.  Bail out if we don't
      # have anything in the framing buffer.
      if ($self->[AUTODETECT_STATE] & AUTO_STATE_SECOND) {
        return [ ] unless length $self->[FRAMING_BUFFER];
  
        # Test the first character to see if it completes the previous
        # potentially partial newline.
        if (
          substr($self->[FRAMING_BUFFER], 0, 1) eq
          ( $self->[INPUT_REGEXP] eq "\x0D" ? "\x0A" : "\x0D" )
        ) {
  
          # Combine the first character with the previous newline, and
          # discard the newline from the buffer.  This is two statements
          # for backward compatibility.
          DEBUG and warn "completed newline after line: <<$1>>\n";
          $self->[INPUT_REGEXP] .= substr($self->[FRAMING_BUFFER], 0, 1);
          substr($self->[FRAMING_BUFFER], 0, 1) = '';
        }
        elsif (DEBUG) {
          warn "decided prior suspicious newline is okay\n";
        }
  
        # Regardless, whatever is in INPUT_REGEXP is now a complete
        # newline.  End autodetection, post-process the found newline,
        # and loop to see if there are other lines in the buffer.
        $self->[INPUT_REGEXP] = $self->[INPUT_REGEXP];
        $self->[AUTODETECT_STATE] = AUTO_STATE_DONE;
        next LINE;
      }
  
      die "consistency error: AUTODETECT_STATE = $self->[AUTODETECT_STATE]";
    }
  
    return [ ];
  }
  
  #------------------------------------------------------------------------------
  # New behavior.  First translate system newlines ("\n") into whichever
  # newlines are supposed to be sent.  Second, add a trailing newline if
  # one doesn't already exist.  Since the referenced output list is
  # supposed to contain one line per element, we also do a split and
  # join.  Bleah. ... why isn't the code doing what the comment says?
  
  sub put {
    my ($self, $lines) = @_;
  
    my @raw;
    foreach (@$lines) {
      push @raw, $_ . $self->[OUTPUT_LITERAL];
    }
  
    \@raw;
  }
  
  #------------------------------------------------------------------------------
  
  sub get_pending {
    my $self = shift;
    return [ $self->[FRAMING_BUFFER] ] if length $self->[FRAMING_BUFFER];
    return undef;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Filter::Line - serialize and parse terminated records (lines)
  
  =head1 SYNOPSIS
  
    #!perl
  
    use POE qw(Wheel::FollowTail Filter::Line);
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[HEAP]{tailor} = POE::Wheel::FollowTail->new(
            Filename => "/var/log/system.log",
            InputEvent => "got_log_line",
            Filter => POE::Filter::Line->new(),
          );
        },
        got_log_line => sub {
          print "Log: $_[ARG0]\n";
        }
      }
    );
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Filter::Line parses stream data into terminated records.  The
  default parser interprets newlines as the record terminator, and the
  default serializer appends network newlines (CR/LF, or "\x0D\x0A") to
  outbound records.
  
  Record terminators are removed from the data POE::Filter::Line
  returns.
  
  POE::Filter::Line supports a number of other ways to parse lines.
  Constructor parameters may specify literal newlines, regular
  expressions, or that the filter should detect newlines on its own.
  
  =head1 PUBLIC FILTER METHODS
  
  POE::Filter::Line's new() method has some interesting parameters.
  
  =head2 new
  
  new() accepts a list of named parameters.
  
  In all cases, the data interpreted as the record terminator is
  stripped from the data POE::Filter::Line returns.
  
  C<InputLiteral> may be used to parse records that are terminated by
  some literal string.  For example, POE::Filter::Line may be used to
  parse and emit C-style lines, which are terminated with an ASCII NUL:
  
    my $c_line_filter = POE::Filter::Line->new(
      InputLiteral => chr(0),
      OutputLiteral => chr(0),
    );
  
  C<OutputLiteral> allows a filter to put() records with a different
  record terminator than it parses.  This can be useful in applications
  that must translate record terminators.
  
  C<Literal> is a shorthand for the common case where the input and
  output literals are identical.  The previous example may be written
  as:
  
    my $c_line_filter = POE::Filter::Line->new(
      Literal => chr(0),
    );
  
  An application can also allow POE::Filter::Line to figure out which
  newline to use.  This is done by specifying C<InputLiteral> to be
  undef:
  
    my $whichever_line_filter = POE::Filter::Line->new(
      InputLiteral => undef,
      OutputLiteral => "\n",
    );
  
  C<InputRegexp> may be used in place of C<InputLiteral> to recognize
  line terminators based on a regular expression.  In this example,
  input is terminated by two or more consecutive newlines.  On output,
  the paragraph separator is "---" on a line by itself.
  
    my $paragraph_filter = POE::Filter::Line->new(
      InputRegexp => "([\x0D\x0A]{2,})",
      OutputLiteral => "\n---\n",
    );
  
  C<MaxBuffer> sets the maximum amount of data that the filter will hold onto 
  while trying to find a line ending.  Defaults to 512 MB.
  
  C<MaxLength> sets the maximum length of a line.  Defaults to 64 MB.
  
  If either the C<MaxLength> or C<MaxBuffer> constraint is exceeded,
  C<POE::Filter::Line> will throw an exception.
  
  
  =head1 PUBLIC FILTER METHODS
  
  POE::Filter::Line has no additional public methods.
  
  =head1 SUBCLASSING
  
  POE::Filter::Line exports the FIRST_UNUSED constant.  This points to
  the first unused element in the $self array reference.  Subclasses
  should store their own data beginning here, and they should export
  their own FIRST_UNUSED constants to help future subclassers.
  
  =head1 SEE ALSO
  
  Please see L<POE::Filter> for documentation regarding the base
  interface.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 BUGS
  
  The default input newline parser is a regexp that has an unfortunate
  race condition.  First the regular expression:
  
    /(\x0D\x0A?|\x0A\x0D?)/
  
  While it quickly recognizes most forms of newline, it can sometimes
  detect an extra blank line.  This happens when a two-byte newline
  character is broken between two reads.  Consider this situation:
  
    some stream dataCR
    LFother stream data
  
  The regular expression will see the first CR without its corresponding
  LF.  The filter will properly return "some stream data" as a line.
  When the next packet arrives, the leading "LF" will be treated as the
  terminator for a 0-byte line.  The filter will faithfully return this
  empty line.
  
  B<It is advised to specify literal newlines or use the autodetect
  feature in applications where blank lines are significant.>
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_FILTER_LINE

$fatpacked{"POE/Filter/Map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER_MAP';
  # 2001/01/25 shizukesa@pobox.com
  
  package POE::Filter::Map;
  
  use strict;
  use POE::Filter;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  @ISA = qw(POE::Filter);
  
  use Carp qw(croak carp);
  
  sub BUFFER   () { 0 }
  sub CODEGET  () { 1 }
  sub CODEPUT  () { 2 }
  
  sub FIRST_UNUSED     () { 3 }  # First unused $self offset.
  
  use base 'Exporter';
  our @EXPORT_OK = qw( FIRST_UNUSED );
  
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
    croak "$type must be given an even number of parameters" if @_ & 1;
    my %params = @_;
  
    croak "$type requires a Code or both Get and Put parameters" unless (
      defined($params{Code}) or
      (defined($params{Get}) and defined($params{Put}))
    );
    croak "Code element is not a subref"
      unless (defined $params{Code} ? ref $params{Code} eq 'CODE' : 1);
    croak "Get or Put element is not a subref"
      unless ((defined $params{Get} ? (ref $params{Get} eq 'CODE') : 1)
        and   (defined $params{Put} ? (ref $params{Put} eq 'CODE') : 1));
  
    my $get = $params{Code} || $params{Get};
    my $put = $params{Code} || $params{Put};
  
    delete @params{qw(Code Get Put)};
    carp("$type ignores unknown parameters: ", join(', ', sort keys %params))
      if scalar keys %params;
  
  
    my $self = bless [
      [ ],    # BUFFER
      $get,   # CODEGET
      $put,   # CODEPUT
    ], $type;
  }
  
  #------------------------------------------------------------------------------
  # get() is inherited from POE::Filter.
  # clone() is inherited from POE::Filter.
  
  #------------------------------------------------------------------------------
  
  sub put {
    my ($self, $data) = @_;
    [ map { $self->[CODEPUT]->($_) } @$data ];
  }
  
  #------------------------------------------------------------------------------
  # 2001-07-26 RCC: The get_one variant of get() allows Wheel::Xyz to
  # retrieve one filtered record at a time.  This is necessary for
  # filter changing and proper input flow control, even though it's kind
  # of slow.
  
  sub get_one_start {
    my ($self, $stream) = @_;
    push(@{$self->[BUFFER]}, @$stream) if defined $stream;
  }
  
  sub get_one {
    my $self = shift;
  
    return [ ] unless @{$self->[BUFFER]};
    my $next_record = shift @{$self->[BUFFER]};
    return [ map { $self->[CODEGET]->($_) } $next_record ];
  }
  
  #------------------------------------------------------------------------------
  # 2001-07-27 RCC: This filter now tracks state, so get_pending has
  # become useful.
  
  sub get_pending {
    my $self = shift;
    return undef unless @{$self->[BUFFER]};
    [ @{$self->[BUFFER]} ];
  }
  
  #------------------------------------------------------------------------------
  
  sub modify {
    my ($self, %params) = @_;
  
    for (keys %params) {
      (carp("Modify $_ element must be given a coderef") and next) unless (ref $params{$_} eq 'CODE');
      if (lc eq 'code') {
          $self->[CODEGET] = $params{$_};
          $self->[CODEPUT] = $params{$_};
      }
      elsif (lc eq 'put') {
          $self->[CODEPUT] = $params{$_};
      }
      elsif (lc eq 'get') {
          $self->[CODEGET] = $params{$_};
      }
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Filter::Map - transform input and/or output within a filter stack
  
  =head1 SYNOPSIS
  
    #!perl
  
    use POE qw(
      Wheel::FollowTail
      Filter::Line Filter::Map Filter::Stackable
    );
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          my $parse_input_as_lines = POE::Filter::Line->new();
  
          my $redact_some_lines = POE::Filter::Map->new(
            Code => sub {
              my $input = shift;
              $input = "[REDACTED]" unless $input =~ /sudo\[\d+\]/i;
              return $input;
            },
          );
  
          my $filter_stack = POE::Filter::Stackable->new(
            Filters => [
              $parse_input_as_lines, # first on get, last on put
              $redact_some_lines, # first on put, last on get
            ]
          );
  
          $_[HEAP]{tailor} = POE::Wheel::FollowTail->new(
            Filename => "/var/log/system.log",
            InputEvent => "got_log_line",
            Filter => $filter_stack,
          );
        },
        got_log_line => sub {
          print "Log: $_[ARG0]\n";
        }
      }
    );
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Filter::Map transforms data inside the filter stack.  It may be
  used to transform input, output, or both depending on how it is
  constructed.  This filter is named and modeled after Perl's built-in
  map() function.
  
  POE::Filter::Map is designed to be combined with other filters through
  POE::Filter::Stackable.  In the L</SYNOPSIS> example, a filter stack
  is created to parse logs as lines and redact all entries that don't
  pertain to a sudo process.
  
  =head1 PUBLIC FILTER METHODS
  
  In addition to the usual POE::Filter methods, POE::Filter::Map also
  supports the following.
  
  =head2 new
  
  new() constructs a new POE::Filter::Map object.  It must either be
  called with a single Code parameter, or both a Put and a Get
  parameter.  The values for Code, Put and Get are code references that,
  when invoked, return transformed versions of their sole parameters.  A
  Code function will be used for both input and output, while Get and Put
  functions allow input and output to be filtered in different ways.
  
    # Decrypt rot13.
    sub decrypt_rot13 {
      my $encrypted = shift;
      $encrypted =~ tr[a-zA-Z][n-za-mN-ZA-M];
      return $encrypted;
    }
  
    # Encrypt rot13.
    sub encrypt_rot13 {
      my $plaintext = shift;
      $plaintext =~ tr[a-zA-Z][n-za-mN-ZA-M];
      return $plaintext;
    }
  
    # Decrypt rot13 on input, and encrypt it on output.
    my $rot13_transcrypter = POE::Filter::Map->new(
      Get => \&decrypt_rot13,
      Put => \&encrypt_rot13,
    );
  
  Rot13 is symmetric, so the above example can be simplified to use a
  single Code function.
  
    my $rot13_transcrypter = POE::Filter::Map->new(
      Code => sub {
        local $_ = shift;
        tr[a-zA-Z][n-za-mN-ZA-M];
        return $_;
      }
    );
  
  =head2 modify
  
  modify() changes a POE::Filter::Map object's behavior at run-time.  It
  accepts the same parameters as new(), and it replaces the existing
  transforms with new ones.
  
    # Switch to "reverse" encryption for testing.
    $rot13_transcrypter->modify(
      Code => sub { return scalar reverse shift }
    );
  
  =head1 SEE ALSO
  
  L<POE::Filter> for more information about filters in general.
  
  L<POE::Filter::Stackable> for more details on stacking filters.
  
  =head1 BUGS
  
  None known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  The Map filter was contributed by Dieter Pearcey.  Documentation is
  provided by Rocco Caputo.
  
  Please see the L<POE> manpage for more information about authors and
  contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_FILTER_MAP

$fatpacked{"POE/Filter/RecordBlock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER_RECORDBLOCK';
  # 2001/01/25 shizukesa@pobox.com
  
  package POE::Filter::RecordBlock;
  
  use strict;
  use POE::Filter;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  @ISA = qw(POE::Filter);
  
  use Carp qw(croak);
  
  sub BLOCKSIZE () { 0 };
  sub GETBUFFER () { 1 };
  sub PUTBUFFER () { 2 };
  sub CHECKPUT  () { 3 };
  sub FIRST_UNUSED () { 4 }
  
  use base 'Exporter';
  our @EXPORT_OK = qw( FIRST_UNUSED );
  
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
  
    croak "$type must be given an even number of parameters" if @_ & 1;
    my %params = @_;
  
    # Block size
    croak "BlockSize must be greater than 0" unless (
      defined($params{BlockSize}) && ($params{BlockSize} > 0)
    );
    my $block_size = $params{BlockSize};
  
    # check put
    my $check_put = $params{CheckPut};
  
    delete @params{ qw( BlockSize CheckPut ) };
    carp("$type ignores unknown parameters: ", join(', ', sort keys %params))
      if scalar keys %params;
  
    my $self = bless [
      $block_size,        # BLOCKSIZE
      [],                 # GETBUFFER
      [],                 # PUTBUFFER
      $check_put         # CHECKPUT
    ], $type;
  }
  
  sub clone {
    my $self = shift;
    my $clone = bless [
      $self->[0], # BLOCKSIZE
      [],         # GETBUFFER
      [],         # PUTBUFFER
      $self->[3]  # CHECKPUT
    ], ref $self;
    $clone;
  }
  
  #------------------------------------------------------------------------------
  # get() is inherited from POE::Filter.
  
  #------------------------------------------------------------------------------
  # 2001-07-27 RCC: Add get_one_start() and get_one() to correct filter
  # changing and make input flow control possible.
  
  sub get_one_start {
    my ($self, $data) = @_;
    push @{$self->[GETBUFFER]}, @$data;
  }
  
  sub get_one {
    my $self = shift;
  
    return [ ] unless @{$self->[GETBUFFER]} >= $self->[BLOCKSIZE];
    return [ [ splice @{$self->[GETBUFFER]}, 0, $self->[BLOCKSIZE] ] ];
  }
  
  #------------------------------------------------------------------------------
  
  sub put {
    my ($self, $data) = @_;
    my @result;
  
    if ($self->[CHECKPUT]) {
      foreach (@$data) {
        push @{$self->[PUTBUFFER]}, @$_;
      }
      while (@{$self->[PUTBUFFER]} >= $self->[BLOCKSIZE]) {
        push @result, splice @{$self->[PUTBUFFER]}, 0, $self->[BLOCKSIZE];
      }
    }
    else {
      push @result, splice(@{$self->[PUTBUFFER]}, 0);
      foreach (@$data) {
        push @result, @$_;
      }
    }
    \@result;
  }
  
  #------------------------------------------------------------------------------
  
  sub get_pending {
    my $self = shift;
    return undef unless @{$self->[GETBUFFER]};
    return [ @{$self->[GETBUFFER]} ];
  }
  
  #------------------------------------------------------------------------------
  
  sub put_pending {
    my ($self) = @_;
    return undef unless $self->[CHECKPUT];
    return undef unless @{$self->[PUTBUFFER]};
    return [ @{$self->[PUTBUFFER]} ];
  }
  
  #------------------------------------------------------------------------------
  
  sub blocksize {
    my ($self, $size) = @_;
    if (defined($size) && ($size > 0)) {
      $self->[BLOCKSIZE] = $size;
    }
    $self->[BLOCKSIZE];
  }
  
  #------------------------------------------------------------------------------
  
  sub checkput {
    my ($self, $val) = @_;
    if (defined($val)) {
      $self->[CHECKPUT] = $val;
    }
    $self->[CHECKPUT];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Filter::RecordBlock - translate between discrete records and blocks of them
  
  =head1 SYNOPSIS
  
  Hello, dear reader.  This SYNOPSIS does not contain a fully
  functioning sample program because your humble documenter cannot come
  up with a short, reasonable use case for this module.  Please contact
  the maintainer if this module is useful to you.  Otherwise you may wake
  up one morning to discover that it has been deprecated.
  
    $filter = new POE::Filter::RecordBlock( BlockSize => 4 );
    $arrayref_of_arrayrefs = $filter->get($arrayref_of_raw_data);
    $arrayref_of_raw_chunks = $filter->put($arrayref_of_arrayrefs);
    $arrayref_of_raw_chunks = $filter->put($single_arrayref);
    $arrayref_of_leftovers = $filter->get_pending;
    $arrayref_of_leftovers = $filter->put_pending;
  
  =head1 DESCRIPTION
  
  On input, POE::Filter::RecordBlock translates a stream of discrete
  items into a "block" of them.  It does this by collecting items until
  it has BlockSize of them, then returning the lot of them in an array
  reference.
  
  On output, this module flattens array references.
  
  This module may be deprecated in the future.  Please contact the
  maintainer if this module is useful to you.
  
  =head1 PUBLIC FILTER METHODS
  
  In addition to the usual POE::Filter methods, POE::Filter::RecordBlock
  supports the following.
  
  =head2 new
  
  new() takes at least one mandatory argument, BlockSize, which must be
  defined and greater than zero.  new() also accepts a CheckPut Boolean
  parameter that indicates whether put() should check for the proper
  BlockSize before allowing data to be serialized.
  
  Using CheckPut is not recommended, as it enables a write buffer in the
  filter, therefore breaking put() for normal use.
  
  =head2 put_pending
  
  put_pending() returns an arrayref of any records that are waiting to
  be sent.  It is the outbound equivalent of POE::Filter's get_pending()
  accessor.  put_pending() is not part of the canonical POE::Filter API,
  so nothing will use it.  It's up to applications to handle pending
  output, whenever it's appropriate to do so.
  
  =head2 blocksize
  
  blocksize() is an accessor/mutator for POE::Filter::RecordBlock's
  BlockSize value.
  
  =head2 checkput
  
  checkput() is an accessor/mutator for POE::Filter::RecordBlock's
  CheckPut flag.
  
  =head1 SEE ALSO
  
  L<POE::Filter> for more information about filters in general.
  
  L<POE::Filter::Stackable> for more details on stacking filters.
  
  =head1 BUGS
  
  This filter may maintain an output buffer that no other part of POE
  will know about.
  
  This filter implements a highly specialized and seemingly not
  generally useful feature.
  
  Does anyone use this filter?  This filter may be deprecated if nobody
  speaks up.
  
  =head1 AUTHORS & COPYRIGHTS
  
  The RecordBlock filter was contributed by Dieter Pearcey.
  Documentation is provided by Rocco Caputo.
  
  Please see the L<POE> manpage for more information about authors and
  contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_FILTER_RECORDBLOCK

$fatpacked{"POE/Filter/Reference.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER_REFERENCE';
  # Filter::Reference partial copyright 1998 Artur Bergman
  # <artur@vogon-solutions.com>.  Partial copyright 1999 Philip Gwyn.
  
  package POE::Filter::Reference;
  
  use strict;
  use POE::Filter;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  @ISA = qw(POE::Filter);
  
  use Carp qw(carp croak confess);
  
  sub BUFFER    () { 0 }
  sub FREEZE    () { 1 }
  sub THAW      () { 2 }
  sub COMPRESS  () { 3 }
  sub NO_FATALS () { 4 }
  sub MAX_BUFFER () { 5 }
  sub BAD_BUFFER () { 6 }
  sub FIRST_UNUSED   () { 7 }
  
  use base 'Exporter';
  our @EXPORT_OK = qw( FIRST_UNUSED );
  
  my %KNOWN_PARAMS = (
      Compression => 1,
      Serializer  => 1,
      NoFatals    => 1,
      MaxBuffer   => 1 
  );
  
  #------------------------------------------------------------------------------
  # Try to require one of the default freeze/thaw packages.
  use vars qw( $DEF_FREEZER $DEF_FREEZE $DEF_THAW );
  BEGIN {
    local $SIG{'__DIE__'} = 'DEFAULT';
  
    my @packages = qw(Storable FreezeThaw YAML);
    foreach my $package (@packages) {
      eval { require "$package.pm"; import $package (); };
      if ($@) {
        warn $@;
        next;
      }
  
      # Found a good freezer!
      $DEF_FREEZER = $package;
      last;
    }
    die "Filter::Reference requires one of @packages" unless defined $DEF_FREEZER;
  }
  
  # Some processing here
  ($DEF_FREEZE, $DEF_THAW) = _get_methods($DEF_FREEZER);
  
  #------------------------------------------------------------------------------
  # Try to acquire Compress::Zlib at run time.
  
  my $zlib_status = undef;
  sub _include_zlib {
    local $SIG{'__DIE__'} = 'DEFAULT';
  
    unless (defined $zlib_status) {
      eval "use Compress::Zlib qw(compress uncompress)";
      if ($@) {
        $zlib_status = $@;
        eval(
          "sub compress   { @_ }\n" .
          "sub uncompress { @_ }"
        );
      }
      else {
        $zlib_status = '';
      }
    }
  
    $zlib_status;
  }
  
  #------------------------------------------------------------------------------
  
  sub _get_methods {
    my($freezer)=@_;
    my $freeze=$freezer->can('nfreeze') || $freezer->can('freeze');
    my $thaw=$freezer->can('thaw');
    return unless $freeze and $thaw;
    return ($freeze, $thaw);
  }
  
  #------------------------------------------------------------------------------
  
  sub new
  {
    my $type = shift;
  
    # Convert from old style to new style
    # $l == 1
    #     ->new( undef ) => (Serializer => undef)
    #     ->new( $class ) => (Serializer => class)
    # not defined $_[0]
    #     ->new( undef, 1 ) => (Serializer => undef, Compression => 1)
    #     ->new( undef, undef, 1 ) => (Serializer => undef, Compression => undef, NoFatals =>1)
    # $l == 3
    #     ->new( $class, 1, 1 ) => (Serializer => undef, Compression => 1, NoFatals =>1)
    # ($l <= 3 and not $KNOWN_PARAMS{$_[0]})
    #     ->new( $class, 1 ) 
    my %params;
    my $l = scalar @_;
    if( $l == 1 or $l == 3 or not defined $_[0] or 
          ( $l<=3 and not $KNOWN_PARAMS{$_[0]}) ) { 
      if( 'HASH' eq ref $_[0] ) {     # do we 
          %params = %{ $_[0] };
      }
      else {
          %params = ( Serializer  => $_[0],
                      Compression => $_[1],
                      NoFatals    => $_[2]
                    );
      }
    } 
    else {
      croak "$type requires an even number of parameters" if @_ and @_ & 1;
      %params = @_;
    }
  
    my($freeze, $thaw);
    my $freezer = $params{Serializer};
    unless (defined $freezer) {
      # Okay, load the default one!
      $freezer = $DEF_FREEZER;
      $freeze  = $DEF_FREEZE;
      $thaw    = $DEF_THAW;
    }
    else {
      # What did we get?
      if (ref $freezer) {
        # It's an object, create an closure
        my($freezetmp, $thawtmp) = _get_methods($freezer);
        $freeze = sub { $freezetmp->($freezer, @_) };
        $thaw   = sub { $thawtmp->  ($freezer, @_) };
      }
      else {
        # A package name?
        # First, find out if the package has the necessary methods.
        ($freeze, $thaw) = _get_methods($freezer);
  
        # If not, try to reload the module.
        unless ($freeze and $thaw) {
          my $path = $freezer;
          $path =~ s{::}{/}g;
          $path .= '.pm';
  
          # Force a reload if necessary.  This is naive and can leak
          # memory, so we only do it until we get the desired methods.
          delete $INC{$path};
  
          eval {
            local $^W = 0;
            require $path;
            $freezer->import();
          };
  
          carp $@ if $@;
          ($freeze, $thaw) = _get_methods($freezer);
        }
      }
    }
  
    # Now get the methods we want
    carp "$freezer doesn't have a freeze or nfreeze method" unless $freeze;
    carp "$freezer doesn't have a thaw method" unless $thaw;
  
    # Should ->new() return undef() it if fails to find the methods it
    # wants?
    return unless $freeze and $thaw;
  
    # Maximum buffer
    my $max_buffer = $type->__param_max( MaxBuffer => 512*1024*1024, \%params );
  
    # Compression
    my $compression = $params{Compression}||0;
    if ($compression) {
      my $zlib_status = _include_zlib();
      if ($zlib_status ne '') {
        warn "Compress::Zlib load failed with error: $zlib_status\n";
        carp "Filter::Reference compression option ignored";
        $compression = 0;
      }
    }
  
    # No fatals
    my $no_fatals = $params{NoFatals}||0;
  
    delete @params{ keys %KNOWN_PARAMS };
    carp("$type ignores unknown parameters: ", join(', ', sort keys %params))
      if scalar keys %params;
  
    my $self = bless [
      '',              # BUFFER
      $freeze,         # FREEZE
      $thaw,           # THAW
      $compression,    # COMPRESS
      $no_fatals,      # NO_FATALS
      $max_buffer,     # MAX_BUFFER
      ''               # BAD_BUFFER
    ], $type;
    $self;
  }
  
  #------------------------------------------------------------------------------
  
  sub get {
    my ($self, $stream) = @_;
    my @return;
  
    $self->get_one_start($stream);
    while (1) {
      my $next = $self->get_one();
      last unless @$next;
      push @return, @$next;
    }
  
    return \@return;
  }
  
  #------------------------------------------------------------------------------
  # 2001-07-27 RCC: The get_one() variant of get() allows Wheel::Xyz to
  # retrieve one filtered block at a time.  This is necessary for filter
  # changing and proper input flow control.
  
  sub get_one_start {
    my ($self, $stream) = @_;
    $self->[BUFFER] .= join('', @$stream);
    if( $self->[MAX_BUFFER] < length( $self->[BUFFER] ) ) {
      $self->[BAD_BUFFER] = "Framing buffer exceeds the limit";
      die $self->[BAD_BUFFER] unless $self->[NO_FATALS];
    }
  }
  
  sub get_one {
    my $self = shift;
  
    # Need to check lengths in octets, not characters.
    BEGIN { eval { require bytes } and bytes->import; }
  
    if( $self->[BAD_BUFFER] ) {
      my $err = $self->[BAD_BUFFER];
      $self->[BAD_BUFFER] = '';
      return [ $err ];
    }
  
    if (
      $self->[BUFFER] =~ /^(\d+)\0/ and
      length($self->[BUFFER]) >= $1 + length($1) + 1
    ) {
      substr($self->[BUFFER], 0, length($1) + 1) = "";
      my $next_message = substr($self->[BUFFER], 0, $1);
      substr($self->[BUFFER], 0, $1) = "";
      $next_message = uncompress($next_message) if $self->[COMPRESS];
  
      unless ($self->[NO_FATALS]) {
        return [ $self->[THAW]->($next_message) ];
      }
  
      my $thawed = eval { $self->[THAW]->($next_message) };
      return [ "$@" ] if $@;
      return [ $thawed ];
    }
  
    return [ ];
  }
  
  #------------------------------------------------------------------------------
  # freeze one or more references, and return a string representing them
  
  sub put {
    my ($self, $references) = @_;
  
    # Need to check lengths in octets, not characters.
    BEGIN { eval { require bytes } and bytes->import; }
  
    my @raw = map {
      confess "Choking on a non-reference ($_)" unless ref();
      my $frozen = $self->[FREEZE]->($_);
      $frozen = compress($frozen) if $self->[COMPRESS];
      length($frozen) . "\0" . $frozen;
    } @$references;
    \@raw;
  }
  
  #------------------------------------------------------------------------------
  # Return everything we have outstanding.  Do not destroy our framing
  # buffer, though.
  
  sub get_pending {
    my $self = shift;
    return undef unless length $self->[BUFFER];
    return [ $self->[BUFFER] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Filter::Reference - freeze and thaw arbitrary Perl data
  
  =head1 SYNOPSIS
  
    #!perl
  
    use YAML;
    use POE qw(Wheel::ReadWrite Filter::Reference);
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          pipe(my($read, $write)) or die $!;
          $_[HEAP]{io} = POE::Wheel::ReadWrite->new(
            InputHandle => $read,
            OutputHandle => $write,
            Filter => POE::Filter::Reference->new(),
            InputEvent => "got_perl_data",
          );
  
          $_[HEAP]{io}->put(
            { key_1 => 111, key_2 => 222 }
          );
        },
        got_perl_data => sub {
          print "Got data:\n", YAML::Dump($_[ARG0]);
          print "Bye!\n";
          delete $_[HEAP]{io};
        }
      }
    );
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Filter::Reference allows programs to send and receive arbitrary
  Perl data structures without worrying about a line protocol.  Its
  put() method serializes Perl data into a byte stream suitable for
  transmission.  get_one() parses the data structures back out of such a
  stream.
  
  By default, POE::Filter::Reference uses Storable to do its magic.  A
  different serializer may be specified at construction time.
  
  =head1 PUBLIC FILTER METHODS
  
  =head2 new
  
  new() creates and initializes a POE::Filter::Reference object.  It
  accepts a list of named parameters.
  
  =head3 Serializer    
  
  Any class that supports nfreeze() (or freeze()) and thaw() may be used
  as a Serializer.  If a Serializer implements both nfreeze() and
  freeze(), then the "network" (nfreeze) version will be used.
  
  Serializer may be a class name:
  
    # Use Storable explicitly, specified by package name.
    my $filter = POE::Filter::Reference->newer( Serializer=>"Storable" );
  
    # Use YAML instead.  Compress its output, as it may be verbose.
    my $filter = POE::Filter::Reference->new("YAML", 1);
  
  Serializer may also be an object:
  
    # Use an object.
    my $serializer = Data::Serializer::Something->new();
    my $filter = POE::Filter::Reference->newer( Serializer => $serializer );
  
  If Serializer is omitted or undef, the Reference filter will try to
  use Storable, FreezeThaw, and YAML in that order.
  POE::Filter::Reference will die if it cannot find one of these
  serializers, but this rarely happens now that Storable and YAML are
  bundled with Perl.
  
  =head3 Compression
  
  If Compression is true, Compress::Zlib will be called upon to reduce
  the size of serialized data.  It will also decompress the incoming
  stream data.
  
  =head3 MaxBuffer
  
  C<MaxBuffer> sets the maximum amount of data that the filter will hold onto 
  while trying to build a new reference.  Defaults to 512 MB.
  
  =head3 NoFatals
  
  If NoFatals is true, messages will be thawed inside a block eval.  By
  default, however, thaw() is allowed to die normally.  If an error
  occurs while NoFatals is in effect, POE::Filter::Reference will
  return a string containing the contents of $@ at the time the eval
  failed.  So when using NoFatals, it's important to check whether
  input is really a reference:
  
    sub got_reference {
      my $message = $_[ARG0];
      if (ref $message) {
        print "Got data:\n", YAML::Dump($message);
      }
      else {
        warn "Input decode error: $message\n";
      }
    }
  
  
  new() will try to load any classes it needs for L</Compression> or L</Serializer>.
  
  
  =head2 new [SERIALIZER [, COMPRESSION [, NO_FATALS]]]
  
  This is the old constructor synatx.  It does not conform to the normal
  POE::Filter constructor parameter syntax.  Please use the new syntax
  instead.
  
  Calling C<new> like this is equivalent to
  
      POE::Filter::Reference->new( Serializer => SERIALIZER,
                                   Compression => COMPRESSION,
                                   NoFatals  => NO_FATALS );
  
  Please note that if you have a custom serializer class called C<Serializer>
  you will have to update your code to the new syntax.
  
  =head1 SERIALIZER API
  
  Here's what POE::Filter::Reference expects of its serializers.
  
  =head2 thaw SERIALIZED
  
  thaw() is required.  It accepts two parameters: $self and a scalar
  containing a SERIALIZED byte stream representing a single Perl data
  structure.  It returns a reconstituted Perl data structure.
  
    sub thaw {
      my ($self, $stream) = @_;
      my $reference = $self->_deserialization_magic($stream);
      return $reference;
    }
  
  =head2 nfreeze REFERENCE
  
  Either nfreeze() or freeze() is required.  They behave identically,
  except that nfreeze() is guaranteed to be portable across networks and
  between machine architectures.
  
  These freezers accept two parameters: $self and a REFERENCE to Perl
  data.  They return a serialized version of the REFERENCEd data.
  
    sub nfreeze {
      my ($self, $reference) = @_;
      my $stream = $self->_serialization_magic($reference);
      return $stream;
    }
  
  =head2 freeze REFERENCE
  
  freeze() is an alternative form of nfreeze().  It has the same call
  signature as nfreeze(), but it doesn't guarantee that serialized data
  will be portable across machine architectures.
  
  If you must choose between implementing freeze() and nfreeze() for use
  with POE::Filter::Reference, go with nfreeze().
  
  =head1 SEE ALSO
  
  Please see L<POE::Filter> for documentation regarding the base
  interface.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 BUGS
  
  Not so much bugs as caveats:
  
  It's important to use identical serializers on each end of a
  connection.  Even different versions of the same serializer can break
  data in transit.
  
  Most (if not all) serializers will re-bless data at the destination,
  but many of them will not load the necessary classes to make those
  blessings work.  Make sure the same classes and versions are available
  on either end of the wire.
  
  =head1 AUTHORS & COPYRIGHTS
  
  The Reference filter was contributed by Artur Bergman, with changes
  by Philip Gwyn.
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_FILTER_REFERENCE

$fatpacked{"POE/Filter/Stackable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER_STACKABLE';
  # 2001/01/25 shizukesa@pobox.com
  
  # This implements a filter stack, which turns ReadWrite into something
  # very, very interesting.
  
  # 2001-07-26 RCC: I have no idea how to make this support get_one, so
  # I'm not going to right now.
  
  package POE::Filter::Stackable;
  
  use strict;
  use POE::Filter;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  @ISA = qw(POE::Filter);
  
  use Carp qw(croak);
  
  sub FILTERS () { 0 }
  
  sub FIRST_UNUSED () { 1 }  # First unused $self offset.
  
  use base 'Exporter';
  our @EXPORT_OK = qw( FIRST_UNUSED );
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
    croak "$type must be given an even number of parameters" if @_ & 1;
    my %params = @_;
  
    $params{Filters} = [ ] unless defined $params{Filters};
    # Sanity check the filters
    if ( ref $params{Filters} eq 'ARRAY') {
  
      my $self = bless [
        $params{Filters}, # FILTERS
      ], $type;
  
      return $self;
    } else {
      croak "Filters is not an ARRAY reference!";
    }
  }
  
  sub clone {
    my $self = shift;
    my $clone = bless [
      [ ],    # FILTERS
    ], ref $self;
    foreach my $filter (@{$self->[FILTERS]}) {
      push (@{$clone->[FILTERS]}, $filter->clone());
    }
    $clone;
  }
  
  #------------------------------------------------------------------------------
  
  sub get_one_start {
    my ($self, $data) = @_;
    $self->[FILTERS]->[0]->get_one_start($data);
  }
  
  # RCC 2005-06-28: get_one() needs to strobe through all the filters
  # regardless whether there's data to input to each.  This is because a
  # later filter in the chain may produce multiple things from one piece
  # of input.  If we stop even though there's no subsequent input, we
  # may lose something.
  #
  # Keep looping through the filters we manage until get_one() returns a
  # record, or until none of the filters exchange data.
  
  sub get_one {
    my ($self) = @_;
  
    my $return = [ ];
  
    while (!@$return) {
      my $exchanged = 0;
  
      foreach my $filter (@{$self->[FILTERS]}) {
  
        # If we have something to input to the next filter, do that.
        if (@$return) {
          $filter->get_one_start($return);
          $exchanged++;
        }
  
        # Get what we can from the current filter.
        $return = $filter->get_one();
      }
  
      last unless $exchanged;
    }
  
    return $return;
  }
  
  # get() is inherited from POE::Filter.
  
  #------------------------------------------------------------------------------
  
  sub put {
    my ($self, $data) = @_;
    foreach my $filter (reverse @{$self->[FILTERS]}) {
      $data = $filter->put($data);
      last unless @$data;
    }
    $data;
  }
  
  #------------------------------------------------------------------------------
  
  sub get_pending {
    my ($self) = @_;
    my $data;
    for (@{$self->[FILTERS]}) {
      $_->put($data) if $data && @{$data};
      $data = $_->get_pending;
    }
    $data || [];
  }
  
  #------------------------------------------------------------------------------
  
  sub filter_types {
     map { ref($_) } @{$_[0]->[FILTERS]};
  }
  
  #------------------------------------------------------------------------------
  
  sub filters {
    @{$_[0]->[FILTERS]};
  }
  
  #------------------------------------------------------------------------------
  
  sub shift {
    my ($self) = @_;
    my $filter = shift @{$self->[FILTERS]};
    my $pending = $filter->get_pending;
    $self->[FILTERS]->[0]->put( $pending ) if $pending;
    $filter;
  }
  
  #------------------------------------------------------------------------------
  
  sub unshift {
    my ($self, @filters) = @_;
  
    # Sanity check
    foreach my $elem ( @filters ) {
      if ( ! defined $elem or ! UNIVERSAL::isa( $elem, 'POE::Filter' ) ) {
        croak "Filter element is not a POE::Filter instance!";
      }
    }
  
    unshift(@{$self->[FILTERS]}, @filters);
  }
  
  #------------------------------------------------------------------------------
  
  sub push {
    my ($self, @filters) = @_;
  
    # Sanity check
    foreach my $elem ( @filters ) {
      if ( ! defined $elem or ! UNIVERSAL::isa( $elem, 'POE::Filter' ) ) {
        croak "Filter element is not a POE::Filter instance!";
      }
    }
  
    push(@{$self->[FILTERS]}, @filters);
  }
  
  #------------------------------------------------------------------------------
  
  sub pop {
    my ($self) = @_;
    my $filter = pop @{$self->[FILTERS]};
    my $pending = $filter->get_pending;
    $self->[FILTERS]->[-1]->put( $pending ) if $pending;
    $filter;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Filter::Stackable - combine multiple POE::Filter objects
  
  =head1 SYNOPSIS
  
    #!perl
  
    use POE qw(
      Wheel::FollowTail
      Filter::Line Filter::Grep Filter::Stackable
    );
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          my $parse_input_as_lines = POE::Filter::Line->new();
  
          my $select_sudo_log_lines = POE::Filter::Grep->new(
            Put => sub { 1 },
            Get => sub {
              my $input = shift;
              return $input =~ /sudo\[\d+\]/i;
            },
          );
  
          my $filter_stack = POE::Filter::Stackable->new(
            Filters => [
              $parse_input_as_lines, # first on get, last on put
              $select_sudo_log_lines, # first on put, last on get
            ]
          );
  
          $_[HEAP]{tailor} = POE::Wheel::FollowTail->new(
            Filename => "/var/log/system.log",
            InputEvent => "got_log_line",
            Filter => $filter_stack,
          );
        },
        got_log_line => sub {
          print "Log: $_[ARG0]\n";
        }
      }
    );
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Filter::Stackable combines multiple filters together in such a
  way that they appear to be a single filter.  All the usual POE::Filter
  methods work, but data is secretly passed through the stacked filters
  before it is returned.  POE::Wheel objects and stand-alone programs
  need no modifications to work with a filter stack.
  
  In the L</SYNOPSIS>, POE::Filter::Line and POE::Filter::Grep are
  combined into one filter that only returns a particular kind of line.
  This can be more efficient than filtering lines in application space,
  as fewer events may need to be dispatched and handled.
  
  Internally, filters are stored in an array.
  
  Data added by get_one_start() will flow through the filter array in
  increasing index order.  Filter #0 will have first crack at it,
  followed by filter #1 and so.  The get_one() call will return an item
  after it has passed through the last filter.
  
  put() passes data through the filters in descending index order.  Data
  will go through the filter with the highest index first, and put()
  will return the results after data has passed through filter #0.
  
  =head1 PUBLIC FILTER METHODS
  
  In addition to the usual POE::Filter methods, POE::Filter::Stackable
  also supports the following.
  
  =head2 new
  
  By default, new() creates an empty filter stack that behaves like
  POE::Filter::Stream.  It may be given optional parameters to
  initialize the stack with an array of filters.
  
    my $sudo_lines = POE::Filter::Stackable->new(
      Filters => [
        POE::Filter::Line->new(),
        POE::Filter::Grep->new(
          Put => sub { 1 }, # put all items
          Get => sub { shift() =~ /sudo\[\d+\]/i },
        ),
      ]
    );
  
  =head2 pop
  
  Behaves like Perl's built-in pop() for the filter stack.  The
  highest-indexed filter is removed from the stack and returned.  Any
  data remaining in the filter's input buffer is lost, but an
  application may always call L<POE::Filter/get_pending> on the returned
  filter.
  
    my $last_filter = $stackable->pop();
    my $last_buffer = $last_filter->get_pending();
  
  =head2 shift
  
  Behaves like Perl's built-in shift() for the filter stack.  The 0th
  filter is removed from the stack and returned.  Any data remaining in
  the filter's input buffer is passed to the new head of the stack, or
  it is lost if the stack becomes empty.  An application may also call
  L<POE::Filter/get_pending> on the returned filter to examine the
  filter's input buffer.
  
    my $first_filter = $stackable->shift();
    my $first_buffer = $first_filter->get_pending();
  
  =head2 push FILTER[, FILTER]
  
  push() adds one or more new FILTERs to the end of the stack.  The
  newly pushed FILTERs will process input last, and they will handle
  output first.
  
    # Reverse data read through the stack.
    # rot13 encode data sent through the stack.
    $stackable->push(
      POE::Filter::Map->(
        Get => sub { return scalar reverse shift() },
        Put => sub { local $_ = shift(); tr[a-zA-Z][n-za-mN-ZA-M]; $_ },
      )
    );
  
  =head2 unshift FILTER[, FILTER]
  
  unshift() adds one or more new FILTERs to the beginning of the stack.
  The newly unshifted FILTERs will process input first, and they will
  handle output last.
  
  =head2 filters
  
  filters() returns a list of the filters inside the Stackable filter,
  in the stack's native order.
  
  Calling C<<$filter_stack->filters()>> in the L</SYNOPSIS> would return
  a list of two filter objects:
  
    POE::Filter::Line=ARRAY(0x8b5ee0)
    POE::Filter::Grep=ARRAY(0x8b5f7c)
  
  =head2 filter_types
  
  filter_types() returns a list of class names for each filter in the
  stack, in the stack's native order.
  
  Calling C<<$filter_stack->filter_types()>> in the L</SYNOPSIS> would
  return a list of two class names:
  
    POE::FIlter::Line
    POE::Filter::Grep
  
  It could easily be replaced by:
  
    my @filter_types = map { ref } $filter_stack->filters;
  
  =head1 SEE ALSO
  
  L<POE::Filter> for more information about filters in general.
  
  Specific filters, amongst which are:
  L<POE::Filter::Block>,
  L<POE::Filter::Grep>,
  L<POE::Filter::HTTPD>,
  L<POE::Filter::Line>,
  L<POE::Filter::Map>,
  L<POE::Filter::RecordBlock>,
  L<POE::Filter::Reference>,
  L<POE::Filter::Stream>
  
  =head1 BUGS
  
  None currently known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  The Stackable filter was contributed by Dieter Pearcey.  Documentation
  provided by Rocco Caputo.
  
  Please see the L<POE> manpage for more information about authors and
  contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_FILTER_STACKABLE

$fatpacked{"POE/Filter/Stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_FILTER_STREAM';
  package POE::Filter::Stream;
  
  use strict;
  use POE::Filter;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  @ISA = qw(POE::Filter);
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
    my $buffer = '';
    my $self = bless \$buffer, $type;
    $self;
  }
  
  sub clone {
    my $self = shift;
    my $buffer = '';
    my $clone = bless \$buffer, ref $self;
  }
  
  #------------------------------------------------------------------------------
  # get() is inherited from POE::Filter.
  
  #------------------------------------------------------------------------------
  # 2001-07-27 RCC: The get_one() variant of get() allows Wheel::Xyz to
  # retrieve one filtered block at a time.  This is necessary for filter
  # changing and proper input flow control.  Although it's kind of
  # pointless for Stream, but it has to follow the proper interface.
  
  sub get_one_start {
    my ($self, $stream) = @_;
    $$self .= join '', @$stream;
  }
  
  sub get_one {
    my $self = shift;
    return [ ] unless length $$self;
    my $chunk = $$self;
    $$self = '';
    return [ $chunk ];
  }
  
  #------------------------------------------------------------------------------
  
  sub put {
    my ($self, $chunks) = @_;
    [ @$chunks ];
  }
  
  #------------------------------------------------------------------------------
  
  sub get_pending {
    my $self = shift;
    return [ $$self ] if length $$self;
    return undef;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Filter::Stream - a no-op filter that passes data through unchanged
  
  =head1 SYNOPSIS
  
    #!perl
  
    use Term::ReadKey;
    use POE qw(Wheel::ReadWrite Filter::Stream);
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          ReadMode "ultra-raw";
          $_[HEAP]{io} = POE::Wheel::ReadWrite->new(
            InputHandle => \*STDIN,
            OutputHandle => \*STDOUT,
            InputEvent => "got_some_data",
            Filter => POE::Filter::Stream->new(),
          );
        },
        got_some_data => sub {
          $_[HEAP]{io}->put("<$_[ARG0]>");
          delete $_[HEAP]{io} if $_[ARG0] eq "\cC";
        },
        _stop => sub {
          ReadMode "restore";
          print "\n";
        },
      }
    );
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Filter::Stream passes data through without changing it.  It
  follows POE::Filter's API and implements no new functionality.
  
  In the L</SYNOPSIS>, POE::Filter::Stream is used to collect keystrokes
  without any interpretation and display output without any
  embellishments.
  
  =head1 SEE ALSO
  
  L<POE::Filter> for more information about filters in general.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 BUGS
  
  None known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_FILTER_STREAM

$fatpacked{"POE/Kernel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_KERNEL';
  package POE::Kernel;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use POE::Resource::Clock qw( monotime sleep mono2wall wall2mono walltime time );
  
  use POSIX qw(uname);
  use Errno qw(ESRCH EINTR ECHILD EPERM EINVAL EEXIST EAGAIN EWOULDBLOCK);
  use Carp qw(carp croak confess cluck);
  use Sys::Hostname qw(hostname);
  use IO::Handle ();
  use File::Spec ();
  #use Time::HiRes qw(time sleep);
  
  # People expect these to be lexical.
  
  use vars qw($poe_kernel $poe_main_window);
  
  #------------------------------------------------------------------------------
  # A cheezy exporter to avoid using Exporter.
  
  my $queue_class;
  
  BEGIN {
    eval {
      require POE::XS::Queue::Array;
      POE::XS::Queue::Array->import();
      $queue_class = "POE::XS::Queue::Array";
    };
    unless ($queue_class) {
      require POE::Queue::Array;
      POE::Queue::Array->import();
      $queue_class = "POE::Queue::Array";
    }
  }
  
  sub import {
    my ($class, $args) = ($poe_kernel, @_[1..$#_]);
    my $package = caller();
  
    croak "POE::Kernel expects its arguments in a hash ref"
      if ($args && ref($args) ne 'HASH');
  
    {
      no strict 'refs';
      *{ $package . '::poe_kernel'      } = \$poe_kernel;
      *{ $package . '::poe_main_window' } = \$poe_main_window;
    }
  
    # Extract the import arguments we're interested in here.
  
    my $loop = delete $args->{loop} || $ENV{POE_EVENT_LOOP};
  
    # Don't accept unknown/mistyped arguments.
  
    my @unknown = sort keys %$args;
    croak "Unknown POE::Kernel import arguments: @unknown" if @unknown;
  
    # Now do things with them.
  
    unless (UNIVERSAL::can('POE::Kernel', 'poe_kernel_loop')) {
      if (defined $loop) {
        $loop =~ s/^(POE::)?(XS::)?(Loop::)?//;
        if (defined $2) {
          $loop = "POE::XS::Loop::$loop";
        }
        else {
          $loop = "POE::Loop::$loop";
        }
      }
      _test_loop($loop);
      # Bootstrap the kernel.  This is inherited from a time when multiple
      # kernels could be present in the same Perl process.
      POE::Kernel->new() if UNIVERSAL::can('POE::Kernel', 'poe_kernel_loop');
    }
  }
  
  #------------------------------------------------------------------------------
  # Perform some optional setup.
  
  BEGIN {
    local $SIG{'__DIE__'} = 'DEFAULT';
  
    {
      no strict 'refs';
      if ($^O eq 'MSWin32') {
          *{ __PACKAGE__ . '::RUNNING_IN_HELL' } = sub { 1 };
      } else {
          *{ __PACKAGE__ . '::RUNNING_IN_HELL' } = sub { 0 };
      }
    }
  }
  
  BEGIN {
    # The entire BEGIN block is a no-strict-refs zone.
  
    no strict 'refs';
  
    # Set up a constant that lets the user deactivate automatic
    # exception handling.
  
    unless (defined &CATCH_EXCEPTIONS) {
      my $catch_exceptions = (
        (exists $ENV{POE_CATCH_EXCEPTIONS})
        ? $ENV{POE_CATCH_EXCEPTIONS}
        : 1
      );
  
      if ($catch_exceptions) {
        *CATCH_EXCEPTIONS = sub () { 1 };
      }
      else {
        *CATCH_EXCEPTIONS = sub () { 0 };
      }
    }
  
    unless (defined &CHILD_POLLING_INTERVAL) {
      # That's one second, not a true value.
      *CHILD_POLLING_INTERVAL = sub () { 1 };
    }
  
    unless (defined &USE_SIGCHLD) {
      # Perl >= 5.7.3 has safe signals support
      # perlipc.pod#Deferred_Signals_(Safe_Signals)
      # We decided to target 5.8.1 just to be safe :)
      if ( $] >= 5.008001 and not RUNNING_IN_HELL ) {
        *USE_SIGCHLD = sub () { 1 };
      } else {
        *USE_SIGCHLD = sub () { 0 };
      }
    }
  
    unless (defined &USE_SIGNAL_PIPE) {
      my $use_signal_pipe;
      if ( exists $ENV{POE_USE_SIGNAL_PIPE} ) {
        $use_signal_pipe = $ENV{POE_USE_SIGNAL_PIPE};
      }
  
      if (RUNNING_IN_HELL) {
        if ($use_signal_pipe) {
          _warn(
            "Sorry, disabling USE_SIGNAL_PIPE on $^O.\n",
            "Programs are reported to hang when it's enabled.\n",
          );
        }
  
        # Must be defined to supersede the default.
        $use_signal_pipe = 0;
      }
  
      if ($use_signal_pipe or not defined $use_signal_pipe) {
        *USE_SIGNAL_PIPE = sub () { 1 };
      }
      else {
        *USE_SIGNAL_PIPE = sub () { 0 };
      }
    }
  }
  
  #==============================================================================
  # Globals, or at least package-scoped things.  Data structures were
  # moved into lexicals in 0.1201.
  
  # A reference to the currently active session.  Used throughout the
  # functions that act on the current session.
  my $kr_active_session;
  my $kr_active_event;
  my $kr_active_event_type;
  
  # Needs to be lexical so that POE::Resource::Events can see it
  # change.  TODO - Something better?  Maybe we call a method in
  # POE::Resource::Events to trigger the exception there?
  use vars qw($kr_exception);
  
  # The Kernel's master queue.
  my $kr_queue;
  
  # The current PID, to detect when it changes
  my $kr_pid;
  
  # Filehandle activity modes.  They are often used as list indexes.
  sub MODE_RD () { 0 }  # read
  sub MODE_WR () { 1 }  # write
  sub MODE_EX () { 2 }  # exception/expedite
  
  #------------------------------------------------------------------------------
  # Kernel structure.  This is the root of a large data tree.  Dumping
  # $poe_kernel with Data::Dumper or something will show most of the
  # data that POE keeps track of.  The exceptions to this are private
  # storage in some of the leaf objects, such as POE::Wheel.  All its
  # members are described in detail further on.
  
  my $kr_id_seq = 0;
  
  sub KR_SESSIONS          () {  0 } # [ \%kr_sessions,
  sub KR_FILENOS           () {  1 } #   \%kr_filenos,
  sub KR_SIGNALS           () {  2 } #   \%kr_signals,
  sub KR_ALIASES           () {  3 } #   \%kr_aliases,
  sub KR_ACTIVE_SESSION    () {  4 } #   \$kr_active_session,
  sub KR_QUEUE             () {  5 } #   \$kr_queue,
  sub KR_ID                () {  6 } #   $unique_kernel_id,
  sub KR_SESSION_IDS       () {  7 } #   \%kr_session_ids,
  sub KR_SID_SEQ           () {  8 } #   \$kr_sid_seq,
  sub KR_EXTRA_REFS        () {  9 } #   \$kr_extra_refs,
  sub KR_SIZE              () { 10 } #   XXX UNUSED ???
  sub KR_RUN               () { 11 } #   \$kr_run_warning
  sub KR_ACTIVE_EVENT      () { 12 } #   \$kr_active_event
  sub KR_PIDS              () { 13 } #   \%kr_pids_to_events
  sub KR_ACTIVE_EVENT_TYPE () { 14 } #   \$kr_active_event_type
                                     # ]
  
  # This flag indicates that POE::Kernel's run() method was called.
  # It's used to warn about forgetting $poe_kernel->run().
  
  sub KR_RUN_CALLED  () { 0x01 }  # $kernel->run() called
  sub KR_RUN_SESSION () { 0x02 }  # sessions created
  sub KR_RUN_DONE    () { 0x04 }  # run returned
  my $kr_run_warning = 0;
  
  #------------------------------------------------------------------------------
  # Events themselves.
  
  sub EV_SESSION    () { 0 }  # [ $destination_session,
  sub EV_SOURCE     () { 1 }  #   $sender_session,
  sub EV_NAME       () { 2 }  #   $event_name,
  sub EV_TYPE       () { 3 }  #   $event_type,
  sub EV_ARGS       () { 4 }  #   \@event_parameters_arg0_etc,
                              #
                              #   (These fields go towards the end
                              #   because they are optional in some
                              #   cases.  TODO: Is this still true?)
                              #
  sub EV_OWNER_FILE () { 5 }  #   $caller_filename_where_enqueued,
  sub EV_OWNER_LINE () { 6 }  #   $caller_line_where_enqueued,
  sub EV_FROMSTATE  () { 7 }  #   $fromstate
  sub EV_SEQ        () { 8 }  #   Maintained by POE::Queue (unique event ID)
  sub EV_WALLTIME   () { 9 }  #   Walltime when event was created (for alarms)
  sub EV_DELTA      () { 10 } #   Seconds past walltime for event (for alarms)
                              # ]
  
  # These are the names of POE's internal events.  They're in constants
  # so we don't mistype them again.
  
  sub EN_CHILD  () { '_child'           }
  sub EN_GC     () { '_garbage_collect' }
  sub EN_PARENT () { '_parent'          }
  sub EN_SCPOLL () { '_sigchld_poll'    }
  sub EN_SIGNAL () { '_signal'          }
  sub EN_START  () { '_start'           }
  sub EN_STOP   () { '_stop'            }
  
  # These are POE's event classes (types).  They often shadow the event
  # names themselves, but they can encompass a large group of events.
  # For example, ET_ALARM describes anything enqueued as by an alarm
  # call.  Types are preferred over names because bitmask tests are
  # faster than string equality tests.
  
  sub ET_POST   () { 0x0001 }  # User events (posted, yielded).
  sub ET_CALL   () { 0x0002 }  # User events that weren't enqueued.
  sub ET_START  () { 0x0004 }  # _start
  sub ET_STOP   () { 0x0008 }  # _stop
  sub ET_SIGNAL () { 0x0010 }  # _signal
  sub ET_GC     () { 0x0020 }  # _garbage_collect
  sub ET_PARENT () { 0x0040 }  # _parent
  sub ET_CHILD  () { 0x0080 }  # _child
  sub ET_SCPOLL () { 0x0100 }  # _sigchild_poll
  sub ET_ALARM  () { 0x0200 }  # Alarm events.
  sub ET_SELECT () { 0x0400 }  # File activity events.
  sub ET_SIGCLD () { 0x0800 }  # sig_child() events.
  
  # A mask for all events generated by/for users.
  sub ET_MASK_USER () { ~(ET_GC | ET_SCPOLL) }
  
  # A mask for all events that are delayed by a dispatch time.
  sub ET_MASK_DELAYED () { ET_ALARM | ET_SCPOLL }
  
  # Temporary signal subtypes, used during signal dispatch semantics
  # deprecation and reformation.
  
  sub ET_SIGNAL_RECURSIVE () { 0x2000 }  # Explicitly requested signal.
  
  # A hash of reserved names.  It's used to test whether someone is
  # trying to use an internal event directly.
  
  my %poes_own_events = (
    +EN_CHILD  => 1,
    +EN_GC     => 1,
    +EN_PARENT => 1,
    +EN_SCPOLL => 1,
    +EN_SIGNAL => 1,
    +EN_START  => 1,
    +EN_STOP   => 1,
    +EN_STAT   => 1,
  );
  
  # These are ways a child may come or go.
  # TODO - It would be useful to split 'lose' into two types.  One to
  # indicate that the child has stopped, and one to indicate that it was
  # given away.
  
  sub CHILD_GAIN   () { 'gain'   }  # The session was inherited from another.
  sub CHILD_LOSE   () { 'lose'   }  # The session is no longer this one's child.
  sub CHILD_CREATE () { 'create' }  # The session was created as a child of this.
  
  # Argument offsets for different types of internally generated events.
  # TODO Exporting (EXPORT_OK) these would let people stop depending on
  # positions for them.
  
  sub EA_SEL_HANDLE () { 0 }
  sub EA_SEL_MODE   () { 1 }
  sub EA_SEL_ARGS   () { 2 }
  
  #------------------------------------------------------------------------------
  # Debugging and configuration constants.
  
  # Shorthand for defining a trace constant.
  sub _define_trace {
    no strict 'refs';
    foreach my $name (@_) {
      next if defined *{"TRACE_$name"}{CODE};
      my $trace_value = &TRACE_DEFAULT;
      my $trace_name  = "TRACE_$name";
      *$trace_name = sub () { $trace_value };
    }
  }
  
  # Debugging flags for subsystems.  They're done as double evals here
  # so that someone may define them before using POE::Kernel (or POE),
  # and the pre-defined value will take precedence over the defaults
  # here.
  
  my $trace_file_handle;
  
  BEGIN {
    # Shorthand for defining an assert constant.
    sub _define_assert {
      no strict 'refs';
      foreach my $name (@_) {
        next if defined *{"ASSERT_$name"}{CODE};
        my $assert_value = &ASSERT_DEFAULT;
        my $assert_name  = "ASSERT_$name";
        *$assert_name = sub () { $assert_value };
      }
    }
  
    # Assimilate POE_TRACE_* and POE_ASSERT_* environment variables.
    # Environment variables override everything else.
    while (my ($var, $val) = each %ENV) {
      next unless $var =~ /^POE_([A-Z_]+)$/;
  
      my $const = $1;
  
      next unless $const =~ /^(?:TRACE|ASSERT)_/ or do { no strict 'refs'; defined &$const };
  
      # Copy so we don't hurt our environment.
      my $value = $val;
      ($value) = ($value =~ /^([-\@\w.]+)$/); # Untaint per rt.cpan.org 81550
      $value =~ tr['"][]d;
      $value = 0 + $value if $value =~ /^\s*-?\d+(?:\.\d+)?\s*$/;
  
      no strict 'refs';
      local $^W = 0;
      local $SIG{__WARN__} = sub { }; # redefine
      *$const = sub () { $value };
    }
  
    # TRACE_FILENAME is special.
    {
      no strict 'refs';
      my $trace_filename = TRACE_FILENAME() if defined &TRACE_FILENAME;
      if (defined $trace_filename) {
        open $trace_file_handle, ">$trace_filename"
          or die "can't open trace file `$trace_filename': $!";
        CORE::select((CORE::select($trace_file_handle), $| = 1)[0]);
      }
    }
    # TRACE_DEFAULT changes the default value for other TRACE_*
    # constants.  Since define_trace() uses TRACE_DEFAULT internally, it
    # can't be used to define TRACE_DEFAULT itself.
  
    defined &TRACE_DEFAULT or *TRACE_DEFAULT = sub () { 0 };
  
    _define_trace qw(
      EVENTS FILES PROFILE REFCNT RETVALS SESSIONS SIGNALS STATISTICS
    );
  
    # See the notes for TRACE_DEFAULT, except read ASSERT and assert
    # where you see TRACE and trace.
  
    defined &ASSERT_DEFAULT or *ASSERT_DEFAULT = sub () { 0 };
  
    _define_assert qw(DATA EVENTS FILES RETVALS USAGE);
  }
  
  # An "idle" POE::Kernel may still have events enqueued.  These events
  # regulate polling for signals, profiling, and perhaps other aspects of
  # POE::Kernel's internal workings.
  #
  # XXX - There must be a better mechanism.
  #
  my $idle_queue_size;
  
  sub _idle_queue_grow   { $idle_queue_size++;   }
  sub _idle_queue_shrink { $idle_queue_size--;   }
  sub _idle_queue_size   { $idle_queue_size;     }
  sub _idle_queue_reset  { $idle_queue_size = 0; }
  
  #------------------------------------------------------------------------------
  # Helpers to carp, croak, confess, cluck, warn and die with whatever
  # trace file we're using today.  _trap is reserved for internal
  # errors.
  
  sub _trap {
    local $Carp::CarpLevel = $Carp::CarpLevel + 1;
    local *STDERR = $trace_file_handle || *STDERR;
  
    confess(
      "=== $$ === Please address any warnings or errors above this message,\n",
      "=== $$ === and try again.  If there are no previous messages, or they\n",
      "=== $$ === are from within POE, then please mail them along with the\n",
      "=== $$ === following information to bug-POE\@rt.cpan.org:\n",
      "---\n@_\n-----\n"
    );
  }
  
  sub _croak {
    local $Carp::CarpLevel = $Carp::CarpLevel + 1;
    local *STDERR = $trace_file_handle || *STDERR;
    my $message = join("", @_);
    $message =~ s/^/=== $$ === /mg;
    croak $message;
  }
  
  sub _confess {
    local $Carp::CarpLevel = $Carp::CarpLevel + 1;
    local *STDERR = $trace_file_handle || *STDERR;
    my $message = join("", @_);
    $message =~ s/^/=== $$ === /mg;
    confess $message;
  }
  
  sub _cluck {
    local $Carp::CarpLevel = $Carp::CarpLevel + 1;
    local *STDERR = $trace_file_handle || *STDERR;
    my $message = join("", @_);
    $message =~ s/^/=== $$ === /mg;
    cluck $message;
  }
  
  sub _carp {
    local $Carp::CarpLevel = $Carp::CarpLevel + 1;
    local *STDERR = $trace_file_handle || *STDERR;
    my $message = join("", @_);
    $message =~ s/^/=== $$ === /mg;
    carp $message;
  }
  
  sub _warn {
    my ($package, $file, $line) = caller();
    my $message = join("", @_);
    $message .= " at $file line $line\n" unless $message =~ /\n$/;
    $message =~ s/^/=== $$ === /mg;
    warn $message;
  }
  
  sub _die {
    my ($package, $file, $line) = caller();
    my $message = join("", @_);
    $message .= " at $file line $line\n" unless $message =~ /\n$/;
    $message =~ s/^/=== $$ === /mg;
    local *STDERR = $trace_file_handle || *STDERR;
    die $message;
  }
  
  #------------------------------------------------------------------------------
  # Adapt POE::Kernel's personality to whichever event loop is present.
  
  sub _find_loop {
    my ($mod) = @_;
  
    foreach my $dir (@INC) {
      return 1 if (-r "$dir/$mod");
    }
    return 0;
  }
  
  sub _load_loop {
    my $loop = shift;
  
    *poe_kernel_loop = sub { return "$loop" };
  
    # Modules can die with "not really dying" if they've loaded
    # something else.  This exception prevents the rest of the
    # originally used module from being parsed, so the module it's
    # handed off to takes over.
    eval "require $loop";
    if ($@ and $@ !~ /not really dying/) {
      die(
        "*\n",
        "* POE can't use $loop:\n",
        "* $@\n",
        "*\n",
      );
    }
  }
  
  sub _test_loop {
    my $used_first = shift;
    local $SIG{__DIE__};
  
    # First see if someone wants to load a POE::Loop or XS version
    # explicitly.
    if (defined $used_first) {
      _load_loop($used_first);
      return;
    }
  
    foreach my $file (keys %INC) {
      next if (substr ($file, -3) ne '.pm');
      my @split_dirs = File::Spec->splitdir($file);
  
      # Create a module name by replacing the path separators with
      # underscores and removing ".pm"
      my $module = join("_", @split_dirs);
      substr($module, -3) = "";
  
      # Skip the module name if it isn't legal.
      next if $module =~ /[^\w\.]/;
  
      # Try for the XS version first.  If it fails, try the plain
      # version.  If that fails, we're up a creek.
      $module = "POE/XS/Loop/$module.pm";
      unless (_find_loop($module)) {
        $module =~ s|XS/||;
        next unless (_find_loop($module));
      }
  
      if (defined $used_first and $used_first ne $module) {
        die(
          "*\n",
          "* POE can't use multiple event loops at once.\n",
          "* You used $used_first and $module.\n",
          "* Specify the loop you want as an argument to POE\n",
          "*  use POE qw(Loop::Select);\n",
          "* or;\n",
          "*  use POE::Kernel { loop => 'Select' };\n",
          "*\n",
        );
      }
  
      $used_first = $module;
    }
  
    # No loop found.  Default to our internal select() loop.
    unless (defined $used_first) {
      $used_first = "POE/XS/Loop/Select.pm";
      unless (_find_loop($used_first)) {
        $used_first =~ s/XS\///;
      }
    }
  
    substr($used_first, -3) = "";
    $used_first =~ s|/|::|g;
    _load_loop($used_first);
  }
  
  #------------------------------------------------------------------------------
  # Include resource modules here.  Later, when we have the option of XS
  # versions, we'll adapt this to include them if they're available.
  
  use POE::Resources;
  
  ###############################################################################
  # Helpers.
  
  ### Resolve $whatever into a session reference, trying every method we
  ### can until something succeeds.
  
  sub _resolve_session {
    my ($self, $whatever) = @_;
    my $session;
  
    # Resolve against sessions.
    $session = $self->_data_ses_resolve($whatever);
    return $session if defined $session;
  
    # Resolve against IDs.
    $session = $self->_data_sid_resolve($whatever);
    return $session if defined $session;
  
    # Resolve against aliases.
    $session = $self->_data_alias_resolve($whatever);
    return $session if defined $session;
  
    # Resolve against the Kernel itself.  Use "eq" instead of "==" here
    # because $whatever is often a string.
    return $whatever if $whatever eq $self;
  
    # We don't know what it is.
    return undef;
  }
  
  ### Test whether POE has become idle.
  
  sub _test_if_kernel_is_idle {
    my $self = shift;
  
    if (TRACE_REFCNT) {
      _warn(
        "<rc> ,----- Kernel Activity -----\n",
        "<rc> | Events : ", $kr_queue->get_item_count(),
        " (vs. idle size = ", $idle_queue_size, ")\n",
        "<rc> | Files  : ", $self->_data_handle_count(), "\n",
        "<rc> | Extra  : ", $self->_data_extref_count(), "\n",
        "<rc> | Procs  : ", $self->_data_sig_kernel_awaits_pids(), "\n",
        "<rc> | Sess   : ", $self->_data_ses_count(), "\n",
        "<rc> `---------------------------\n",
        "<rc> ..."
       );
    }
  
    if( ASSERT_DATA ) {
      if( $kr_pid != $$ ) {
        _trap(
          "New process detected. " .
          "You must call ->has_forked() in the child process."
        );
      }
    }
  
    # Not yet idle, or SO idle that there's nothing to receive the
    # event.  Try to order these from most to least likely to be true so
    # that the tests short-circuit quickly.
  
    return if (
      $kr_queue->get_item_count() > $idle_queue_size or
      $self->_data_handle_count() or
      $self->_data_extref_count() or
      $self->_data_sig_kernel_awaits_pids() or
      !$self->_data_ses_count()
    );
  
    $self->_data_ev_enqueue(
      $self, $self, EN_SIGNAL, ET_SIGNAL, [ 'IDLE' ],
      __FILE__, __LINE__, undef
    );
  }
  
  ### Explain why a session could not be resolved.
  
  sub _explain_resolve_failure {
    my ($self, $whatever, $nonfatal) = @_;
    local $Carp::CarpLevel = 2;
  
    if (ASSERT_DATA and !$nonfatal) {
      _trap "<dt> Cannot resolve ``$whatever'' into a session reference";
    }
  
    $! = ESRCH;
    TRACE_RETVALS  and _carp "<rv> session not resolved: $!";
    ASSERT_RETVALS and _carp "<rv> session not resolved: $!";
  }
  
  ### Explain why a function is returning unsuccessfully.
  
  sub _explain_return {
    my ($self, $message) = @_;
    local $Carp::CarpLevel = 2;
  
    ASSERT_RETVALS and _confess "<rv> $message";
    TRACE_RETVALS  and _carp    "<rv> $message";
  }
  
  ### Explain how the user made a mistake calling a function.
  
  sub _explain_usage {
    my ($self, $message) = @_;
    local $Carp::CarpLevel = 2;
  
    ASSERT_USAGE   and _confess "<us> $message";
    ASSERT_RETVALS and _confess "<rv> $message";
    TRACE_RETVALS  and _carp    "<rv> $message";
  }
  
  #==============================================================================
  # SIGNALS
  #==============================================================================
  
  #------------------------------------------------------------------------------
  # Register or remove signals.
  
  # Public interface for adding or removing signal handlers.
  
  sub sig {
    my ($self, $signal, $event_name, @args) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call sig() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined signal in sig()" unless defined $signal;
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved assigning it to a signal"
      ) if defined($event_name) and exists($poes_own_events{$event_name});
    };
  
    if (defined $event_name) {
      $self->_data_sig_add($kr_active_session, $signal, $event_name, \@args);
    }
    else {
      $self->_data_sig_remove($kr_active_session->ID, $signal);
    }
  }
  
  # Public interface for posting signal events.
  # TODO - Like post(), signal() should return
  
  sub signal {
    my ($self, $dest_session, $signal, @etc) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> undefined destination in signal()"
        unless defined $dest_session;
      _confess "<us> undefined signal in signal()" unless defined $signal;
    };
  
    my $session = $self->_resolve_session($dest_session);
    unless (defined $session) {
      $self->_explain_resolve_failure($dest_session);
      return;
    }
  
    $self->_data_ev_enqueue(
      $session, $kr_active_session,
      EN_SIGNAL, ET_SIGNAL, [ $signal, @etc ],
      (caller)[1,2], $kr_active_event
    );
    return 1;
  }
  
  # Public interface for flagging signals as handled.  This will replace
  # the handlers' return values as an implicit flag.  Returns undef so
  # it may be used as the last function in an event handler.
  
  sub sig_handled {
    my $self = $poe_kernel;
    $self->_data_sig_handled();
  
    if ($kr_active_event eq EN_SIGNAL) {
      _die(
        ",----- DEPRECATION ERROR -----\n",
        "| ", $self->_data_alias_loggable($kr_active_session->ID), ":\n",
        "| handled a _signal event.  You must register a handler with sig().\n",
        "`-----------------------------\n",
      );
    }
  }
  
  # Attach a window or widget's destroy/closure to the UIDESTROY signal.
  
  sub signal_ui_destroy {
    my ($self, $window) = @_;
    $self->loop_attach_uidestroy($window);
  }
  
  # Handle child PIDs being reaped.  Added 2006-09-15.
  
  sub sig_child {
    my ($self, $pid, $event_name, @args) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call sig_chld() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined process ID in sig_chld()" unless defined $pid;
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved assigning it to a signal"
      ) if defined($event_name) and exists($poes_own_events{$event_name});
    };
  
    if (defined $event_name) {
      $self->_data_sig_pid_watch($kr_active_session, $pid, $event_name, \@args);
    }
    elsif ($self->_data_sig_pids_is_ses_watching($kr_active_session->ID, $pid)) {
      $self->_data_sig_pid_ignore($kr_active_session->ID, $pid);
    }
  }
  
  #==============================================================================
  # KERNEL
  #==============================================================================
  
  sub new {
    my $type = shift;
  
    # Prevent multiple instances, no matter how many times it's called.
    # This is a backward-compatibility enhancement for programs that
    # have used versions prior to 0.06.  It also provides a convenient
    # single entry point into the entirety of POE's state: point a
    # Dumper module at it, and you'll see a hideous tree of knowledge.
    # Be careful, though.  Its apples bite back.
    unless (defined $poe_kernel) {
  
      # Create our master queue.
      $kr_queue = $queue_class->new();
  
      # Remember the PID
      $kr_pid = $$;
  
      # TODO - Should KR_ACTIVE_SESSIONS and KR_ACTIVE_EVENT be handled
      # by POE::Resource::Sessions?
      # TODO - Should the subsystems be split off into separate real
      # objects, such as KR_QUEUE is?
  
      my $self = $poe_kernel = bless [
        undef,                  # KR_SESSIONS - from POE::Resource::Sessions
        undef,                  # KR_FILENOS - from POE::Resource::FileHandles
        undef,                  # KR_SIGNALS - from POE::Resource::Signals
        undef,                  # KR_ALIASES - from POE::Resource::Aliases
        \$kr_active_session,    # KR_ACTIVE_SESSION
        $kr_queue,              # KR_QUEUE - reference to an object
        undef,                  # KR_ID
        undef,                  # KR_SESSION_IDS - from POE::Resource::SIDS
        undef,                  # KR_SID_SEQ - from POE::Resource::SIDS
        undef,                  # KR_EXTRA_REFS
        undef,                  # KR_SIZE
        \$kr_run_warning,       # KR_RUN
        \$kr_active_event,      # KR_ACTIVE_EVENT
        undef,                  # KR_PIDS
        \$kr_active_event_type, # KR_ACTIVE_EVENT_TYPE
      ], $type;
  
      POE::Resources->load();
  
      $self->_recalc_id();
      $self->_data_sid_set($self->[KR_ID], $self);
  
      # Initialize subsystems.  The order is important.
  
      # We need events before sessions, and the kernel's session before
      # it can start polling for signals.
      $self->_data_ev_initialize($kr_queue);
      $self->_initialize_kernel_session();
      $self->_data_sig_initialize();
      $self->_data_alias_initialize();
  
      # These other subsystems don't have strange interactions.
      $self->_data_handle_initialize($kr_queue);
  
      _idle_queue_reset();
    }
  
    # Return the global instance.
    $poe_kernel;
  }
  
  sub CLONE {
    _data_ses_clone();
  }
  
  #------------------------------------------------------------------------------
  # Send an event to a session right now.  Used by _disp_select to
  # expedite select() events, and used by run() to deliver posted events
  # from the queue.
  
  # Dispatch an event to its session.  A lot of work goes on here.
  
  sub _dummy_sigdie_handler { 1 }
  
  sub _dispatch_signal_event {
    my (
      $self,
      $session, $source_session, $event, $type, $etc,
      $file, $line, $fromstate, $priority, $seq
    ) = @_;
  
    # TODO - Regrettably, duplicate checking code in:
    # _dispatch_signal_event(), _dispatch_event().
  
    if (ASSERT_EVENTS) {
      _confess "<ev> undefined dest session" unless defined $session;
      _confess "<ev> undefined source session" unless defined $source_session;
    };
  
    if (TRACE_EVENTS) {
      my $log_session = $session;
      $log_session =  $self->_data_alias_loggable($session->ID) unless (
        $type & ET_START
      );
      my $string_etc = join(" ", map { defined() ? $_ : "(undef)" } @$etc);
      _warn(
        "<ev> Dispatching event $seq ``$event'' ($string_etc) from ",
        $self->_data_alias_loggable($source_session->ID), " to $log_session"
      );
    }
  
    my $signal = $etc->[0];
  
    if (TRACE_SIGNALS) {
      _warn(
        "<sg> dispatching ET_SIGNAL ($signal) to ",
        $self->_data_alias_loggable($session->ID)
      );
    }
  
    # Step 1a: Reset the handled-signal flags.
  
    local @POE::Kernel::kr_signaled_sessions;
    local $POE::Kernel::kr_signal_total_handled;
    local $POE::Kernel::kr_signal_type;
  
    $self->_data_sig_reset_handled($signal);
  
    # Step 1b: Collect a list of sessions to receive the signal.
  
    my @touched_sessions = ($session);
    my $touched_index = 0;
    while ($touched_index < @touched_sessions) {
      my $next_target = $touched_sessions[$touched_index]->ID;
      push @touched_sessions, $self->_data_ses_get_children($next_target);
      $touched_index++;
    }
  
    # Step 1c: The DIE signal propagates up through parents, too.
  
    if ($signal eq "DIE") {
      my $next_target = $self->_data_ses_get_parent($session->ID);
      while (defined($next_target) and $next_target != $self) {
        unshift @touched_sessions, $next_target;
        $next_target = $self->_data_ses_get_parent($next_target->ID);
      }
    }
  
    # Step 2: Propagate the signal to the explicit watchers in the
    # child tree.  Ensure the full tree is touched regardless
    # whether there are explicit watchers.
  
    if ($self->_data_sig_explicitly_watched($signal)) {
      my %signal_watchers = $self->_data_sig_watchers($signal);
  
      $touched_index = @touched_sessions;
      while ($touched_index--) {
        my $target_session = $touched_sessions[$touched_index];
        $self->_data_sig_touched_session($target_session);
  
        my $target_sid = $target_session->ID;
        next unless exists $signal_watchers{$target_sid};
        my ($target_event, $target_etc) = @{$signal_watchers{$target_sid}};
  
        if (TRACE_SIGNALS) {
          _warn(
            "<sg> propagating explicit signal $target_event ($signal) ",
            "(@$target_etc) to ", $self->_data_alias_loggable($target_sid)
          );
        }
  
        # ET_SIGNAL_RECURSIVE is used here to avoid repropagating
        # the signal ad nauseam.
        $self->_dispatch_event(
          $target_session, $self,
          $target_event, ET_SIGNAL_RECURSIVE, [ @$etc, @$target_etc ],
          $file, $line, $fromstate, monotime(), -__LINE__
        );
      }
    }
    else {
      $touched_index = @touched_sessions;
      while ($touched_index--) {
        $self->_data_sig_touched_session($touched_sessions[$touched_index]);
      }
    }
  
    # Step 3: Check to see if the signal was handled.
  
    $self->_data_sig_free_terminated_sessions();
  
    # If the signal was SIGDIE, then propagate the exception.
  
    my $handled_session_count = (_data_sig_handled_status())[0];
    if ($signal eq "DIE" and !$handled_session_count) {
      $kr_exception = $etc->[1]{error_str};
    }
  
    # Signal completely dispatched.  Thanks for flying!
    return;
  }
  
  sub _dispatch_event {
    my (
      $self,
      $session, $source_session, $event, $type, $etc,
      $file, $line, $fromstate, $priority, $seq
    ) = @_;
  
    if (ASSERT_EVENTS) {
      _confess "<ev> undefined dest session" unless defined $session;
      _confess "<ev> undefined source session" unless defined $source_session;
    };
  
    if (TRACE_EVENTS) {
      my $log_session = $session;
      $log_session =  $self->_data_alias_loggable($session->ID) unless (
        $type & ET_START
      );
      my $string_etc = join(" ", map { defined() ? $_ : "(undef)" } @$etc);
      _warn(
        "<ev> Dispatching event $seq ``$event'' ($string_etc) from ",
        $self->_data_alias_loggable($source_session->ID), " to $log_session"
      );
    }
  
    ### Pre-dispatch processing.
  
    # Some sessions don't do anything in _start and expect their
    # creators to provide a start-up event.  This means we can't
    # &_collect_garbage at _start time.  Instead, an ET_GC event is
    # posted as part of session allocation.  Simply dispatching it
    # will trigger a GC sweep.
  
    return 0 if $type & ET_GC;
  
    # Preprocess signals.  This is where _signal is translated into
    # its registered handler's event name, if there is one.
  
    if (TRACE_EVENTS) {
      _warn(
      "<ev> dispatching event $seq ``$event'' to ",
        $self->_data_alias_loggable($session->ID)
      );
      if ($event eq EN_SIGNAL) {
        _warn("<ev>     signal($etc->[0])");
      }
    }
  
    # Prepare to call the appropriate handler.  Push the current active
    # session on Perl's call stack.
  
    my ($hold_active_session, $hold_active_event, $hold_active_event_type) = (
      $kr_active_session, $kr_active_event, $kr_active_event_type
    );
    (
      $kr_active_session, $kr_active_event, $kr_active_event_type
    ) = ($session, $event, $type);
  
    # We only care about the return value and calling context if it's
    # ET_CALL.
  
    my $return;
    my $wantarray = wantarray();
  
    confess 'please report this stacktrace to bug-poe@rt.cpan.org' unless (
      defined $session
    );
  
    # Quiet SIGDIE if it's DEFAULT.  If it's something special, then
    # someone had better know what they're doing.
  
    my $old_sig_die = $SIG{__DIE__};
    $SIG{__DIE__} = \&_dummy_sigdie_handler if (
      not defined $old_sig_die or $old_sig_die eq 'DEFAULT'
    );
  
    eval {
      if ($wantarray) {
        $return = [
          $session->_invoke_state(
            $source_session, $event, $etc, $file, $line, $fromstate
          )
        ];
      }
      elsif (defined $wantarray) {
        $return = $session->_invoke_state(
          $source_session, $event, $etc, $file, $line, $fromstate
        );
      }
      else {
        $session->_invoke_state(
          $source_session, $event, $etc, $file, $line, $fromstate
        );
      }
    };
  
    # An exception happened?
    # It was intially thrown under the $SIG{__DIE__} conditions that the
    # user wanted.  Any formatting, logging, etc. is already done.
  
    if (ref($@) or $@ ne '') {
      if (CATCH_EXCEPTIONS) {
        if (TRACE_EVENTS) {
          _warn(
            "<ev> exception occurred in $event when invoked on ",
            $self->_data_alias_loggable($session->ID)
          );
        }
  
        # Exceptions in _stop are rethrown unconditionally.
        # We can't enqueue them--the session is about to go away.
        # Also if the active session has been forced back to $self via
        # POE::Kernel->stop().
        if ($type & ET_STOP or $kr_active_session eq $self) {
          # Propagate the exception up to the safe rethrow point.
          $kr_exception = $@;
        }
        else {
          $self->_data_ev_enqueue(
            $session, $self, EN_SIGNAL, ET_SIGNAL, [
              'DIE' => {
                source_session => $source_session,
                dest_session => $session,
                event => $event,
                file => $file,
                line => $line,
                from_state => $fromstate,
                error_str => $@,
              },
            ], __FILE__, __LINE__, undef
          );
        }
      }
      else {
        # Propagate the exception up to the safe rethrow point.
        $kr_exception = $@;
      }
    }
  
    # Global $sig{__DIE__} changed?  For shame!
    # TODO - This warning is only needed if a SIGDIE handler is active.
    # TODO - Likewise, setting a SIGDIE with a __DIE__ handler in play
    # will be tricky or impossible.  There should be some message.
  
    if (
      (not defined $old_sig_die or $old_sig_die eq 'DEFAULT') and
      $SIG{__DIE__} ne \&_dummy_sigdie_handler
    ) {
      _warn(
        "<sg> Event handler redefined global __DIE__ signal handler.\n",
        "<sg> This may conflict with CATCH_EXCEPTIONS handling.\n",
        "<sg> If global redefinition is necessary, do it in global code.\n",
      );
  
      $SIG{__DIE__} = $old_sig_die;
    }
  
    # Clear out the event arguments list, in case there are POE-ish
    # things in it. This allows them to destruct happily before we set
    # the current session back.
  
    @$etc = ( );
  
    # Stringify the handler's return value if it belongs in the POE
    # namespace.  $return's scope exists beyond the post-dispatch
    # processing, which includes POE's garbage collection.  The scope
    # bleed was known to break determinism in surprising ways.
  
    if (defined $return and substr(ref($return), 0, 5) eq 'POE::') {
      $return = "$return";
    }
  
    # Pop the active session and event, now that they're no longer
    # active.
  
    ($kr_active_session, $kr_active_event, $kr_active_event_type) = (
      $hold_active_session, $hold_active_event, $hold_active_event_type
    );
  
    if (TRACE_EVENTS) {
      my $string_ret = $return;
      $string_ret = "undef" unless defined $string_ret;
      _warn("<ev> event $seq ``$event'' returns ($string_ret)\n");
    }
  
    # Return doesn't matter unless ET_CALL, ET_START or ET_STOP.
    return unless $type & (ET_CALL | ET_START | ET_STOP);
  
    # Return what the handler did.  This is used for call().
    return( $wantarray ? @$return : $return );
  }
  
  #------------------------------------------------------------------------------
  # POE's main loop!  Now with Tk and Event support!
  
  # Do pre-run start-up.  Initialize the event loop, and allocate a
  # session structure to represent the Kernel.
  
  sub _initialize_kernel_session {
    my $self = shift;
  
    $self->loop_initialize();
  
    $kr_exception = undef;
    $kr_active_session = $self;
    $self->_data_ses_allocate($self, $self->[KR_ID], undef);
  }
  
  # Do post-run cleanup.
  
  sub _finalize_kernel {
    my $self = shift;
  
    # Disable signal watching since there's now no place for them to go.
    foreach ($self->_data_sig_get_safe_signals()) {
      $self->loop_ignore_signal($_);
    }
  
    # Remove the kernel session's signal watcher.
    $self->_data_sig_remove($self->ID, "IDLE");
  
    # The main loop is done, no matter which event library ran it.
    # sig before loop so that it clears the signal_pipe file handler
    $self->_data_sig_finalize();
    $self->loop_finalize();
    $self->_data_extref_finalize();
    $self->_data_sid_finalize();
    $self->_data_alias_finalize();
    $self->_data_handle_finalize();
    $self->_data_ev_finalize();
    $self->_data_ses_finalize();
  }
  
  sub run_while {
    my ($self, $scalar_ref) = ($poe_kernel, @_[1..$#_]);
    1 while $$scalar_ref and $self->run_one_timeslice();
  }
  
  sub run_one_timeslice {
    my $self = $poe_kernel;
  
    unless ($self->_data_ses_count()) {
      $self->_finalize_kernel();
      $kr_run_warning |= KR_RUN_DONE;
      $kr_exception and $self->_rethrow_kr_exception();
      return;
    }
  
    $self->loop_do_timeslice();
    $kr_exception and $self->_rethrow_kr_exception();
  
    return 1;
  }
  
  sub run {
    # So run() can be called as a class method.
    POE::Kernel->new unless defined $poe_kernel;
    my $self = $poe_kernel;
  
    # Flag that run() was called.
    $kr_run_warning |= KR_RUN_CALLED;
  
    # TODO is this check expensive? ( do people run() more than 1 time? )
    if( $kr_pid != $$ ) {
      if ( ASSERT_USAGE ) {
        _warn "Detected a fork, automatically calling ->has_forked()";
      }
      $self->has_forked;
    }
  
    # Don't run the loop if we have no sessions
    # Loop::Event will blow up, so we're doing this sanity check
    if ( $self->_data_ses_count() == 0 ) {
      # Emit noise only if we are under debug mode
      if ( ASSERT_DATA ) {
        _warn("Not running the event loop because we have no sessions!\n");
      }
    } else {
      # All signals must be explicitly watched now.  We do it here because
      # it's too early in initialize_kernel_session.
      $self->_data_sig_add($self, "IDLE", EN_SIGNAL);
  
      # Run the loop!
      $self->loop_run();
  
      # Cleanup
      $self->_finalize_kernel();
    }
  
    # Clean up afterwards.
    $kr_run_warning |= KR_RUN_DONE;
  
    $kr_exception and $self->_rethrow_kr_exception();
  }
  
  sub _rethrow_kr_exception {
    my $self = shift;
  
    # It's quite common to see people wrap POE::Kernel->run() in an eval
    # block and start things again if an exception is caught.
    #
    # This little lexical dance is actually important.  It allows
    # $kr_exception to be cleared if the die() is caught.
  
    my $exception = $kr_exception;
    $kr_exception = undef;
  
    # The die is cast.
    die $exception;
  }
  
  # Stops the kernel cold.  XXX Experimental!
  # No events happen as a result of this, all structures are cleaned up
  # except the kernel's.  Even the current session and POE::Kernel are
  # cleaned up, which may introduce inconsistencies in the current
  # session... as _dispatch_event() attempts to clean up for a defunct
  # session.
  
  sub stop {
    # So stop() can be called as a class method.
    my $self = $poe_kernel;
  
    # May be called when the kernel's already stopped.  Avoid problems
    # trying to find child sessions when the kernel isn't registered.
    if ($self->_data_ses_exists($self->ID)) {
      my @children = ($self);
      foreach my $session (@children) {
        push @children, $self->_data_ses_get_children($session->ID);
      }
  
      # Don't stop believin'.  Nor the POE::Kernel singleton.
      shift @children;
  
      # Walk backwards to avoid inconsistency errors.
      foreach my $session (reverse @children) {
        $self->_data_ses_free($session->ID);
      }
    }
  
    # Roll back whether sessions were started.
    $kr_run_warning &= ~KR_RUN_SESSION;
  
    # So new sessions will not be child of the current defunct session.
    $kr_active_session = $self;
  
    # The GC mark list may prevent sessions from DESTROYing.
    # Clean it up.
    $self->_data_ses_gc_sweep();
  
    # Running stop() is recommended in a POE::Wheel::Run coderef
    # Program, before setting up for the next POE::Kernel->run().  When
    # the PID has changed, imply _data_sig_has_forked() during stop().
  
    $poe_kernel->has_forked() if $kr_pid != $$;
  
    # TODO - If we're polling for signals, then the reset gets it wrong.
    # The reset doesn't count sigchld polling.  If we must put this
    # back, it MUST account for all internal events currently in play,
    # or the child process will stall if it reruns POE::Kernel's loop.
    #_idle_queue_reset();
  
    return;
  }
  
  # Less invasive form of ->stop() + ->run()
  sub has_forked {
    if( $kr_pid == $$ ) {
      if ( ASSERT_USAGE ) {
        _warn "You should only call ->has_forked() from the child process.";
      }
      return;
    }
  
    # So has_forked() can be called as a class method.
    my $self = $poe_kernel;
  
    $kr_pid = $$;
    $self->_recalc_id();
  
    # reset some stuff for the signals
    $poe_kernel->_data_sig_has_forked;
  }
  
  #------------------------------------------------------------------------------
  
  sub DESTROY {
    my $self = shift;
  
    # Warn that a session never had the opportunity to run if one was
    # created but run() was never called.
  
    unless ($kr_run_warning & KR_RUN_CALLED) {
      if ($kr_run_warning & KR_RUN_SESSION) {
        _warn(
          "Sessions were started, but POE::Kernel's run() method was never\n",
          "called to execute them.  This usually happens because an error\n",
          "occurred before POE::Kernel->run() could be called.  Please fix\n",
          "any errors above this notice, and be sure that POE::Kernel->run()\n",
          "is called.  See documentation for POE::Kernel's run() method for\n",
          "another way to disable this warning.\n",
        );
      }
    }
  }
  
  #------------------------------------------------------------------------------
  # _invoke_state is what _dispatch_event calls to dispatch a transition
  # event.  This is the kernel's _invoke_state so it can receive events.
  # These are mostly signals, which are propagated down in
  # _dispatch_event.
  
  sub _invoke_state {
    my ($self, $source_session, $event, $etc) = @_;
  
    # This is an event loop to poll for child processes without needing
    # to catch SIGCHLD.
  
    if ($event eq EN_SCPOLL) {
      $self->_data_sig_handle_poll_event($etc->[0]);
    }
  
    # A signal was posted.  Because signals propagate depth-first, this
    # _invoke_state is called last in the dispatch.  If the signal was
    # SIGIDLE, then post a SIGZOMBIE if the main queue is still idle.
  
    elsif ($event eq EN_SIGNAL) {
      if ($etc->[0] eq 'IDLE') {
        unless (
          $kr_queue->get_item_count() > $idle_queue_size or
          $self->_data_handle_count()
        ) {
          $self->_data_ev_enqueue(
            $self, $self, EN_SIGNAL, ET_SIGNAL, [ 'ZOMBIE' ],
            __FILE__, __LINE__, undef
          );
        }
      }
    }
  
    return 0;
  }
  
  #==============================================================================
  # SESSIONS
  #==============================================================================
  
  # Dispatch _start to a session, allocating it in the kernel's data
  # structures as a side effect.
  
  sub session_alloc {
    my ($self, $session, @args) = ($poe_kernel, @_[1..$#_]);
  
    # If we already returned, then we must reinitialize.  This is so
    # $poe_kernel->run() will work correctly more than once.
    if ($kr_run_warning & KR_RUN_DONE) {
      $kr_run_warning &= ~KR_RUN_DONE;
      $self->_initialize_kernel_session();
      $self->_data_sig_initialize();
    }
  
    if (ASSERT_DATA) {
      if (defined $session->ID) {
        _trap(
          "<ss> ", $self->_data_alias_loggable($session->ID),
          " already allocated\a"
        );
      }
    }
  
    # Register that a session was created.
    $kr_run_warning |= KR_RUN_SESSION;
  
    # Allocate the session's data structure.  This must be done before
    # we dispatch anything regarding the new session.
    my $new_sid = $self->_data_sid_allocate();
    $session->_set_id($new_sid);
    $self->_data_ses_allocate($session, $new_sid, $kr_active_session->ID);
  
    my $loggable = $self->_data_alias_loggable($new_sid);
  
    # Tell the new session that it has been created.  Catch the _start
    # state's return value so we can pass it to the parent with the
    # _child create.
    #
    # TODO - Void the context if the parent has no _child handler?
  
    my $return = $self->_dispatch_event(
      $session, $kr_active_session,
      EN_START, ET_START, \@args,
      __FILE__, __LINE__, undef, monotime(), -__LINE__
    );
  
    unless($self->_data_ses_exists($new_sid)) {
      if(TRACE_SESSIONS) {
        _warn("<ss> ", $loggable, " disappeared during ", EN_START);
      }
      return $return;
    }
  
    # If the child has not detached itself---that is, if its parent is
    # the currently active session---then notify the parent with a
    # _child create event.  Otherwise skip it, since we'd otherwise
    # throw a create without a lose.
    $self->_dispatch_event(
      $self->_data_ses_get_parent($session->ID), $self,
      EN_CHILD, ET_CHILD, [ CHILD_CREATE, $session, $return ],
      __FILE__, __LINE__, undef, monotime(), -__LINE__
    );
  
    unless ($self->_data_ses_exists($new_sid)) {
      if (TRACE_SESSIONS) {
        _warn("<ss> ", $loggable, " disappeared during ", EN_CHILD, " dispatch");
      }
      return $return;
    }
  
    # Enqueue a delayed garbage-collection event so the session has time
    # to do its thing before it goes.
    $self->_data_ev_enqueue(
      $session, $session, EN_GC, ET_GC, [],
      __FILE__, __LINE__, undef
    );
  }
  
  # Detach a session from its parent.  This breaks the parent/child
  # relationship between the current session and its parent.  Basically,
  # the current session is given to the Kernel session.  Unlike with
  # _stop, the current session's children follow their parent.
  
  sub detach_myself {
    my $self = $poe_kernel;
  
    if (ASSERT_USAGE) {
      _confess "<us> must call detach_myself() from a running session"
        if $kr_active_session == $self;
    }
  
    # Can't detach from the kernel.
    if ($self->_data_ses_get_parent($kr_active_session->ID) == $self) {
      $! = EPERM;
      return;
    }
  
    my $old_parent = $self->_data_ses_get_parent($kr_active_session->ID);
  
    # Tell the old parent session that the child is departing.
    # But not if the active event is ET_START, since that would generate
    # a CHILD_LOSE without a CHILD_CREATE.
    $self->_dispatch_event(
      $old_parent, $self,
      EN_CHILD, ET_CHILD, [ CHILD_LOSE, $kr_active_session, undef ],
      (caller)[1,2], undef, monotime(), -__LINE__
    )
    unless $kr_active_event_type & ET_START;
  
    # Tell the new parent (kernel) that it's gaining a child.
    # (Actually it doesn't care, so we don't do that here, but this is
    # where the code would go if it ever does in the future.)
  
    # Tell the current session that its parentage is changing.
    $self->_dispatch_event(
      $kr_active_session, $self,
      EN_PARENT, ET_PARENT, [ $old_parent, $self ],
      (caller)[1,2], undef, monotime(), -__LINE__
    );
  
    $self->_data_ses_move_child($kr_active_session->ID, $self->ID);
  
    # Success!
    return 1;
  }
  
  # Detach a child from this, the parent.  The session being detached
  # must be a child of the current session.
  
  sub detach_child {
    my ($self, $child) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call detach_child() from a running session"
        if $kr_active_session == $self;
    }
  
    my $child_session = $self->_resolve_session($child);
    unless (defined $child_session) {
      $self->_explain_resolve_failure($child);
      return;
    }
  
    # Can't detach if it belongs to the kernel.  TODO We shouldn't need
    # to check for this.
    if ($kr_active_session == $self) {
      $! = EPERM;
      return;
    }
  
    # Can't detach if it's not a child of the current session.
    unless (
      $self->_data_ses_is_child($kr_active_session->ID, $child_session->ID)
    ) {
      $! = EPERM;
      return;
    }
  
    # Tell the current session that the child is departing.
    $self->_dispatch_event(
      $kr_active_session, $self,
      EN_CHILD, ET_CHILD, [ CHILD_LOSE, $child_session, undef ],
      (caller)[1,2], undef, monotime(), -__LINE__
    );
  
    # Tell the new parent (kernel) that it's gaining a child.
    # (Actually it doesn't care, so we don't do that here, but this is
    # where the code would go if it ever does in the future.)
  
    # Tell the child session that its parentage is changing.
    $self->_dispatch_event(
      $child_session, $self,
      EN_PARENT, ET_PARENT, [ $kr_active_session, $self ],
      (caller)[1,2], undef, monotime(), -__LINE__
    );
  
    $self->_data_ses_move_child($child_session->ID, $self->ID);
  
    # Success!
    return 1;
  }
  
  ### Helpful accessors.
  
  sub get_active_session {
    return $kr_active_session;
  }
  
  sub get_active_event {
    return $kr_active_event;
  }
  
  # FIXME - Should this exist?
  sub get_event_count {
    return $kr_queue->get_item_count();
  }
  
  # FIXME - Should this exist?
  sub get_next_event_time {
    return $kr_queue->get_next_priority();
  }
  
  #==============================================================================
  # EVENTS
  #==============================================================================
  
  #------------------------------------------------------------------------------
  # Post an event to the queue.
  
  sub post {
    my ($self, $dest_session, $event_name, @etc) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> destination is undefined in post()"
        unless defined $dest_session;
      _confess "<us> event is undefined in post()" unless defined $event_name;
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved by posting it"
      ) if exists $poes_own_events{$event_name};
    };
  
    # Attempt to resolve the destination session reference against
    # various things.
  
    my $session = $self->_resolve_session($dest_session);
    unless (defined $session) {
      $self->_explain_resolve_failure($dest_session);
      return;
    }
  
    # Enqueue the event for "now", which simulates FIFO in our
    # time-ordered queue.
  
    $self->_data_ev_enqueue(
      $session, $kr_active_session, $event_name, ET_POST, \@etc,
      (caller)[1,2], $kr_active_event
    );
    return 1;
  }
  
  #------------------------------------------------------------------------------
  # Post an event to the queue for the current session.
  
  sub yield {
    my ($self, $event_name, @etc) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call yield() from a running session"
        if $kr_active_session == $self;
      _confess "<us> event name is undefined in yield()"
        unless defined $event_name;
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved by yielding it"
      ) if exists $poes_own_events{$event_name};
    };
  
    $self->_data_ev_enqueue(
      $kr_active_session, $kr_active_session, $event_name, ET_POST, \@etc,
      (caller)[1,2], $kr_active_event
    );
  
    undef;
  }
  
  #------------------------------------------------------------------------------
  # Call an event handler directly.
  
  sub call {
    my ($self, $dest_session, $event_name, @etc) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> destination is undefined in call()"
        unless defined $dest_session;
      _confess "<us> event is undefined in call()" unless defined $event_name;
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved by calling it"
      ) if exists $poes_own_events{$event_name};
    };
  
    # Attempt to resolve the destination session reference against
    # various things.
  
    my $session = $self->_resolve_session($dest_session);
    unless (defined $session) {
      $self->_explain_resolve_failure($dest_session);
      return;
    }
  
    # Dispatch the event right now, bypassing the queue altogether.
    # This tends to be a Bad Thing to Do.
  
    # TODO The difference between synchronous and asynchronous events
    # should be made more clear in the documentation, so that people
    # have a tendency not to abuse them.  I discovered in xws that
    # mixing the two types makes it harder than necessary to write
    # deterministic programs, but the difficulty can be ameliorated if
    # programmers set some base rules and stick to them.
  
    if (wantarray) {
      my @return_value = (
        ($session == $kr_active_session)
        ? $session->_invoke_state(
          $session, $event_name, \@etc, (caller)[1,2],
          $kr_active_event
        )
        : $self->_dispatch_event(
          $session, $kr_active_session,
          $event_name, ET_CALL, \@etc,
          (caller)[1,2], $kr_active_event, monotime(), -__LINE__
        )
      );
  
      $kr_exception and $self->_rethrow_kr_exception();
  
      $! = 0;
      return @return_value;
    }
  
    if (defined wantarray) {
      my $return_value = (
        $session == $kr_active_session
        ? $session->_invoke_state(
          $session, $event_name, \@etc, (caller)[1,2],
          $kr_active_event
        )
        : $self->_dispatch_event(
          $session, $kr_active_session,
          $event_name, ET_CALL, \@etc,
          (caller)[1,2], $kr_active_event, monotime(), -__LINE__
        )
      );
  
      $kr_exception and $self->_rethrow_kr_exception();
  
      $! = 0;
      return $return_value;
    }
  
    if ($session == $kr_active_session) {
      $session->_invoke_state(
        $session, $event_name, \@etc, (caller)[1,2],
        $kr_active_event
      );
    }
    else {
      $self->_dispatch_event(
        $session, $kr_active_session,
        $event_name, ET_CALL, \@etc,
        (caller)[1,2], $kr_active_event, monotime(), -__LINE__
      );
    }
  
    $kr_exception and $self->_rethrow_kr_exception();
  
    $! = 0;
    return;
  }
  
  #==============================================================================
  # DELAYED EVENTS
  #==============================================================================
  
  sub alarm {
    my ($self, $event_name, $time, @etc) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call alarm() from a running session"
        if $kr_active_session == $self;
      _confess "<us> event name is undefined in alarm()"
        unless defined $event_name;
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved by setting an alarm for it"
      ) if exists $poes_own_events{$event_name};
    };
  
    unless (defined $event_name) {
      $self->_explain_return("invalid parameter to alarm() call");
      return EINVAL;
    }
  
    $self->_data_ev_clear_alarm_by_name($kr_active_session->ID(), $event_name);
  
    # Add the new alarm if it includes a time.  Calling _data_ev_enqueue
    # directly is faster than calling alarm_set to enqueue it.
    if (defined $time) {
      $self->_data_ev_enqueue
        ( $kr_active_session, $kr_active_session,
          $event_name, ET_ALARM, [ @etc ],
          (caller)[1,2], $kr_active_event, $time,
        );
    }
    else {
      # The event queue has become empty?  Stop the time watcher.
      $self->loop_pause_time_watcher() unless $kr_queue->get_item_count();
    }
  
    return 0;
  }
  
  # Add an alarm without clobbering previous alarms of the same name.
  sub alarm_add {
    my ($self, $event_name, $time, @etc) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call alarm_add() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined event name in alarm_add()"
        unless defined $event_name;
      _confess "<us> undefined time in alarm_add()" unless defined $time;
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved by adding an alarm for it"
      ) if exists $poes_own_events{$event_name};
    };
  
    unless (defined $event_name and defined $time) {
      $self->_explain_return("invalid parameter to alarm_add() call");
      return EINVAL;
    }
  
    $self->_data_ev_enqueue
      ( $kr_active_session, $kr_active_session,
        $event_name, ET_ALARM, [ @etc ],
        (caller)[1,2], $kr_active_event, $time,
      );
  
    return 0;
  }
  
  # Add a delay, which is like an alarm relative to the current time.
  sub delay {
    my ($self, $event_name, $delay, @etc) = ($poe_kernel, @_[1..$#_]);
    my $pri = monotime();
  
    if (ASSERT_USAGE) {
      _confess "<us> must call delay() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined event name in delay()" unless defined $event_name;
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved by setting a delay for it"
      ) if exists $poes_own_events{$event_name};
    };
  
    unless (defined $event_name) {
      $self->_explain_return("invalid parameter to delay() call");
      return EINVAL;
    }
  
    if (defined $delay) {
      $self->_data_ev_clear_alarm_by_name($kr_active_session->ID(), $event_name);
  
      # Add the new alarm if it includes a time.  Calling _data_ev_enqueue
      # directly is faster than calling alarm_set to enqueue it.
      $self->_data_ev_enqueue
        ( $kr_active_session, $kr_active_session,
          $event_name, ET_ALARM, [ @etc ],
          (caller)[1,2], $kr_active_event, undef, $delay, $pri+$delay
        );
    }
    else {
      $self->alarm($event_name);
    }
  
    return 0;
  }
  
  # Add a delay without clobbering previous delays of the same name.
  sub delay_add {
    my ($self, $event_name, $delay, @etc) = ($poe_kernel, @_[1..$#_]);
    my $pri = monotime();
  
    if (ASSERT_USAGE) {
      _confess "<us> must call delay_add() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined event name in delay_add()"
        unless defined $event_name;
      _confess "<us> undefined time in delay_add()" unless defined $delay;
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved by adding a delay for it"
      ) if exists $poes_own_events{$event_name};
    };
  
    unless (defined $event_name and defined $delay) {
      $self->_explain_return("invalid parameter to delay_add() call");
      return EINVAL;
    }
  
    $self->_data_ev_enqueue
      ( $kr_active_session, $kr_active_session,
        $event_name, ET_ALARM, [ @etc ],
        (caller)[1,2], $kr_active_event, undef, $delay, $pri+$delay
      );
  
    return 0;
  }
  
  #------------------------------------------------------------------------------
  # New style alarms.
  
  # Set an alarm.  This does more *and* less than plain alarm().  It
  # only sets alarms (that's the less part), but it also returns an
  # alarm ID (that's the more part).
  
  sub alarm_set {
    my ($self, $event_name, $time, @etc) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call alarm_set() from a running session"
        if $kr_active_session == $self;
    }
  
    unless (defined $event_name) {
      $self->_explain_usage("undefined event name in alarm_set()");
      $! = EINVAL;
      return;
    }
  
    unless (defined $time) {
      $self->_explain_usage("undefined time in alarm_set()");
      $! = EINVAL;
      return;
    }
  
    if (ASSERT_USAGE) {
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved by setting an alarm for it"
      ) if exists $poes_own_events{$event_name};
    }
  
    return $self->_data_ev_enqueue
      ( $kr_active_session, $kr_active_session, $event_name, ET_ALARM, [ @etc ],
        (caller)[1,2], $kr_active_event, $time,
      );
  }
  
  # Remove an alarm by its ID.  TODO Now that alarms and events have
  # been recombined, this will remove an event by its ID.  However,
  # nothing returns an event ID, so nobody knows what to remove.
  
  sub alarm_remove {
    my ($self, $alarm_id) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call alarm_remove() from a running session"
        if $kr_active_session == $self;
    }
  
    unless (defined $alarm_id) {
      $self->_explain_usage("undefined alarm id in alarm_remove()");
      $! = EINVAL;
      return;
    }
  
    my ($time, $event) =
      $self->_data_ev_clear_alarm_by_id($kr_active_session->ID(), $alarm_id);
    return unless defined $time;
  
    # In a list context, return the alarm that was removed.  In a scalar
    # context, return a reference to the alarm that was removed.  In a
    # void context, return nothing.  Either way this returns a defined
    # value when someone needs something useful from it.
  
    return unless defined wantarray;
    return ( $event->[EV_NAME], $time, $event->[EV_ARGS] ) if wantarray;
    return [ $event->[EV_NAME], $time, $event->[EV_ARGS] ];
  }
  
  # Move an alarm to a new time.  This virtually removes the alarm and
  # re-adds it somewhere else.  In reality, adjust_priority() is
  # optimized for this sort of thing.
  
  sub alarm_adjust {
    my ($self, $alarm_id, $delta) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call alarm_adjust() from a running session"
        if $kr_active_session == $self;
    }
  
    unless (defined $alarm_id) {
      $self->_explain_usage("undefined alarm id in alarm_adjust()");
      $! = EINVAL;
      return;
    }
  
    unless (defined $delta) {
      $self->_explain_usage("undefined alarm delta in alarm_adjust()");
      $! = EINVAL;
      return;
    }
  
    my $my_alarm = sub {
      $_[0]->[EV_SESSION] == $kr_active_session;
    };
    
    return $self->_data_ev_adjust( $alarm_id, $my_alarm, undef, $delta );
  }
  
  # A convenient function for setting alarms relative to now.  It also
  # uses whichever time() POE::Kernel can find, which may be
  # Time::HiRes'.
  
  sub delay_set {
    # Always always always grab time() ASAP, so that the eventual
    # time we set the delay for is as close as possible to the time
    # at which they ASKED for the delay, not when we actually set it.
    my $t = walltime();
    my $pri = monotime();
  
    # And now continue as normal
    my ($self, $event_name, $seconds, @etc) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call delay_set() from a running session"
        if $kr_active_session == $self;
    }
  
    unless (defined $event_name) {
      $self->_explain_usage("undefined event name in delay_set()");
      $! = EINVAL;
      return;
    }
  
    if (ASSERT_USAGE) {
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved by setting a delay for it"
      ) if exists $poes_own_events{$event_name};
    }
  
    unless (defined $seconds) {
      $self->_explain_usage("undefined seconds in delay_set()");
      $! = EINVAL;
      return;
    }
  
    return $self->_data_ev_enqueue
      ( $kr_active_session, $kr_active_session, $event_name, ET_ALARM, [ @etc ],
        (caller)[1,2], $kr_active_event, $t, $seconds, $pri+$seconds
      );
  }
  
  # Move a delay to a new offset from time().  As with alarm_adjust(),
  # this is optimized internally for this sort of activity.
  
  sub delay_adjust {
    # Always always always grab time() ASAP, so that the eventual
    # time we set the delay for is as close as possible to the time
    # at which they ASKED for the delay, not when we actually set it.
    my $t = walltime();
    my $pri = monotime();
  
    # And now continue as normal
    my ($self, $alarm_id, $seconds) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call delay_adjust() from a running session"
        if $kr_active_session == $self;
    }
  
    unless (defined $alarm_id) {
      $self->_explain_usage("undefined delay id in delay_adjust()");
      $! = EINVAL;
      return;
    }
  
    unless (defined $seconds) {
      $self->_explain_usage("undefined delay seconds in delay_adjust()");
      $! = EINVAL;
      return;
    }
  
    my $my_delay = sub {
      $_[0]->[EV_SESSION] == $kr_active_session;
    };
  
    if (TRACE_EVENTS) {
      _warn("<ev> adjusted event $alarm_id by $seconds seconds from $t");
    }
  
    return $self->_data_ev_set($alarm_id, $my_delay, $t, $pri, $seconds );
  }
  
  # Remove all alarms for the current session.
  
  sub alarm_remove_all {
    my $self = $poe_kernel;
  
    if (ASSERT_USAGE) {
      _confess "<us> must call alarm_remove_all() from a running session"
        if $kr_active_session == $self;
    }
  
    # This should never happen, actually.
    _trap "unknown session in alarm_remove_all call" unless (
      $self->_data_ses_exists($kr_active_session->ID)
    );
  
    # Free every alarm owned by the session.  This code is ripped off
    # from the _stop code to flush everything.
  
    my @removed = $self->_data_ev_clear_alarm_by_session(
      $kr_active_session->ID()
    );
  
    return unless defined wantarray;
    return @removed if wantarray;
    return \@removed;
  }
  
  #==============================================================================
  # SELECTS
  #==============================================================================
  
  sub _internal_select {
    my ($self, $session, $handle, $event_name, $mode, $args) = @_;
  
    # If an event is included, then we're defining a filehandle watcher.
  
    if ($event_name) {
      $self->_data_handle_add($handle, $mode, $session, $event_name, $args);
    }
    else {
      $self->_data_handle_remove($handle, $mode, $session->ID);
    }
  }
  
  # A higher-level select() that manipulates read, write and expedite
  # selects together.
  
  sub select {
    my ($self, $handle, $event_r, $event_w, $event_e, @args) = (
      $poe_kernel, @_[1..$#_]
    );
  
    if (ASSERT_USAGE) {
      _confess "<us> must call select() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined filehandle in select()" unless defined $handle;
      _confess "<us> invalid filehandle in select()"
        unless defined fileno($handle);
      foreach ($event_r, $event_w, $event_e) {
        next unless defined $_;
        _carp(
          "<us> The '$_' event is one of POE's own.  Its " .
          "effect cannot be achieved by setting a file watcher to it"
        ) if exists($poes_own_events{$_});
      }
    }
  
    $self->_internal_select(
      $kr_active_session, $handle, $event_r, MODE_RD, \@args
    );
    $self->_internal_select(
      $kr_active_session, $handle, $event_w, MODE_WR, \@args
    );
    $self->_internal_select(
      $kr_active_session, $handle, $event_e, MODE_EX, \@args
    );
    return 0;
  }
  
  # Only manipulate the read select.
  sub select_read {
    my ($self, $handle, $event_name, @args) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call select_read() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined filehandle in select_read()"
        unless defined $handle;
      _confess "<us> invalid filehandle in select_read()"
        unless defined fileno($handle);
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved by setting a file watcher to it"
      ) if defined($event_name) and exists($poes_own_events{$event_name});
    };
  
    $self->_internal_select(
      $kr_active_session, $handle, $event_name, MODE_RD, \@args
    );
    return 0;
  }
  
  # Only manipulate the write select.
  sub select_write {
    my ($self, $handle, $event_name, @args) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call select_write() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined filehandle in select_write()"
        unless defined $handle;
      _confess "<us> invalid filehandle in select_write()"
        unless defined fileno($handle);
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved by setting a file watcher to it"
      ) if defined($event_name) and exists($poes_own_events{$event_name});
    };
  
    $self->_internal_select(
      $kr_active_session, $handle, $event_name, MODE_WR, \@args
    );
    return 0;
  }
  
  # Only manipulate the expedite select.
  sub select_expedite {
    my ($self, $handle, $event_name, @args) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call select_expedite() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined filehandle in select_expedite()"
        unless defined $handle;
      _confess "<us> invalid filehandle in select_expedite()"
        unless defined fileno($handle);
      _carp(
        "<us> The '$event_name' event is one of POE's own.  Its " .
        "effect cannot be achieved by setting a file watcher to it"
      ) if defined($event_name) and exists($poes_own_events{$event_name});
    };
  
    $self->_internal_select(
      $kr_active_session, $handle, $event_name, MODE_EX, \@args
    );
    return 0;
  }
  
  # Turn off a handle's write mode bit without doing
  # garbage-collection things.
  sub select_pause_write {
    my ($self, $handle) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call select_pause_write() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined filehandle in select_pause_write()"
        unless defined $handle;
      _confess "<us> invalid filehandle in select_pause_write()"
        unless defined fileno($handle);
    };
  
    return 0 unless $self->_data_handle_is_good($handle, MODE_WR);
  
    $self->_data_handle_pause($handle, MODE_WR);
  
    return 1;
  }
  
  # Turn on a handle's write mode bit without doing garbage-collection
  # things.
  sub select_resume_write {
    my ($self, $handle) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call select_resume_write() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined filehandle in select_resume_write()"
        unless defined $handle;
      _confess "<us> invalid filehandle in select_resume_write()"
        unless defined fileno($handle);
    };
  
    return 0 unless $self->_data_handle_is_good($handle, MODE_WR);
  
    $self->_data_handle_resume($handle, MODE_WR);
  
    return 1;
  }
  
  # Turn off a handle's read mode bit without doing garbage-collection
  # things.
  sub select_pause_read {
    my ($self, $handle) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call select_pause_read() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined filehandle in select_pause_read()"
        unless defined $handle;
      _confess "<us> invalid filehandle in select_pause_read()"
        unless defined fileno($handle);
    };
  
    return 0 unless $self->_data_handle_is_good($handle, MODE_RD);
  
    $self->_data_handle_pause($handle, MODE_RD);
  
    return 1;
  }
  
  # Turn on a handle's read mode bit without doing garbage-collection
  # things.
  sub select_resume_read {
    my ($self, $handle) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> must call select_resume_read() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined filehandle in select_resume_read()"
        unless defined $handle;
      _confess "<us> invalid filehandle in select_resume_read()"
        unless defined fileno($handle);
    };
  
    return 0 unless $self->_data_handle_is_good($handle, MODE_RD);
  
    $self->_data_handle_resume($handle, MODE_RD);
  
    return 1;
  }
  
  #==============================================================================
  # Aliases: These functions expose the internal alias accessors with
  # extra fun parameter/return value checking.
  #==============================================================================
  
  ### Set an alias in the current session.
  
  sub alias_set {
    my ($self, $name) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> undefined alias in alias_set()" unless defined $name;
    };
  
    # Don't overwrite another session's alias.
    my $existing_session = $self->_data_alias_resolve($name);
    if (defined $existing_session) {
      if ($existing_session != $kr_active_session) {
        $self->_explain_usage("alias '$name' is in use by another session");
        return EEXIST;
      }
      return 0;
    }
  
    $self->_data_alias_add($kr_active_session, $name);
    return 0;
  }
  
  ### Remove an alias from the current session.
  
  sub alias_remove {
    my ($self, $name) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> undefined alias in alias_remove()" unless defined $name;
    };
  
    my $existing_session = $self->_data_alias_resolve($name);
  
    unless (defined $existing_session) {
      $self->_explain_usage("alias '$name' does not exist");
      return ESRCH;
    }
  
    if ($existing_session != $kr_active_session) {
      $self->_explain_usage("alias '$name' does not belong to current session");
      return EPERM;
    }
  
    $self->_data_alias_remove($kr_active_session, $name);
    return 0;
  }
  
  ### Resolve an alias into a session.
  
  sub alias_resolve {
    my ($self, $name) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> undefined alias in alias_resolve()" unless defined $name;
    };
  
    return $self->_resolve_session($name);
  }
  
  ### List the aliases for a given session.
  
  sub alias_list {
    my ($self, $search_session) = ($poe_kernel, @_[1..$#_]);
    my $session =
      $self->_resolve_session($search_session || $kr_active_session);
  
    unless (defined $session) {
      $self->_explain_resolve_failure($search_session, "nonfatal");
      return;
    }
  
    # Return whatever can be found.
    my @alias_list = $self->_data_alias_list($session->ID);
    return wantarray() ? @alias_list : $alias_list[0];
  }
  
  #==============================================================================
  # Kernel and Session IDs
  #==============================================================================
  
  # Return the Kernel's "unique" ID.  There's only so much uniqueness
  # available; machines on separate private 10/8 networks may have
  # identical kernel IDs.  The chances of a collision are vanishingly
  # small.
  
  # The Kernel and Session IDs are based on Philip Gwyn's code.  I hope
  # he still can recognize it.
  
  sub _recalc_id {
    my $self = shift;
  
    my $old_id = $self->[KR_ID];
  
    my $hostname = eval { (uname)[1] };
    $hostname = hostname() unless defined $hostname;
  
    my $new_id = $self->[KR_ID] = join(
      "-", $hostname,
      map { unpack "H*", $_ }
      map { pack "N", $_ }
      (monotime(), $$, ++$kr_id_seq)
    );
  
    if (defined $old_id) {
      $self->_data_sig_relocate_kernel_id($old_id, $new_id);
      $self->_data_ses_relocate_kernel_id($old_id, $new_id);
      $self->_data_sid_relocate_kernel_id($old_id, $new_id);
      $self->_data_handle_relocate_kernel_id($old_id, $new_id);
      $self->_data_ev_relocate_kernel_id($old_id, $new_id);
      $self->_data_alias_relocate_kernel_id($old_id, $new_id);
    }
  }
  
  sub ID { $poe_kernel->[KR_ID] }
  
  # Resolve an ID to a session reference.  This function is virtually
  # moot now that _resolve_session does it too.  This explicit call will
  # be faster, though, so it's kept for things that can benefit from it.
  
  sub ID_id_to_session {
    my ($self, $id) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> undefined ID in ID_id_to_session()" unless defined $id;
    };
  
    my $session = $self->_data_sid_resolve($id);
    return $session if defined $session;
  
    $self->_explain_return("ID does not exist");
    $! = ESRCH;
    return;
  }
  
  # Resolve a session reference to its corresponding ID.
  
  sub ID_session_to_id {
    my ($self, $session) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> undefined session in ID_session_to_id()"
        unless defined $session;
    };
  
    my $id = $self->_data_ses_resolve_to_id($session);
    if (defined $id) {
      $! = 0;
      return $id;
    }
  
    $self->_explain_return("session ($session) does not exist");
    $! = ESRCH;
    return;
  }
  
  #==============================================================================
  # Extra reference counts, to keep sessions alive when things occur.
  # They take session IDs because they may be called from resources at
  # times where the session reference is otherwise unknown.
  #==============================================================================
  
  sub refcount_increment {
    my ($self, $session_id, $tag) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> undefined session ID in refcount_increment()"
        unless defined $session_id;
      _confess "<us> undefined reference count tag in refcount_increment()"
        unless defined $tag;
    };
  
    unless ($self->_data_ses_exists($session_id)) {
      $self->_explain_return("session id $session_id does not exist");
      $! = ESRCH;
      return;
    }
  
    my $refcount = $self->_data_extref_inc($session_id, $tag);
    # TODO trace it here
    return $refcount;
  }
  
  sub refcount_decrement {
    my ($self, $session_id, $tag) = ($poe_kernel, @_[1..$#_]);
  
    if (ASSERT_USAGE) {
      _confess "<us> undefined session ID in refcount_decrement()"
        unless defined $session_id;
      _confess "<us> undefined reference count tag in refcount_decrement()"
        unless defined $tag;
    };
  
    unless ($self->_data_ses_exists($session_id)) {
      $self->_explain_return("session id $session_id does not exist");
      $! = ESRCH;
      return;
    }
  
    my $refcount = $self->_data_extref_dec($session_id, $tag);
  
    # TODO trace it here
    return $refcount;
  }
  
  #==============================================================================
  # HANDLERS
  #==============================================================================
  
  # Add or remove event handlers from sessions.
  sub state {
    my ($self, $event, $state_code, $state_alias) = ($poe_kernel, @_[1..$#_]);
    $state_alias = $event unless defined $state_alias;
  
    if (ASSERT_USAGE) {
      _confess "<us> must call state() from a running session"
        if $kr_active_session == $self;
      _confess "<us> undefined event name in state()" unless defined $event;
      _confess "<us> can't call state() outside a session" if (
        $kr_active_session == $self
      );
    };
  
    if (
      (ref($kr_active_session) ne '') &&
      (ref($kr_active_session) ne 'POE::Kernel')
    ) {
      $kr_active_session->_register_state($event, $state_code, $state_alias);
      return 0;
    }
  
    # TODO A terminal signal (such as UIDESTROY) kills a session.  The
    # Kernel deallocates the session, which cascades destruction to its
    # HEAP.  That triggers a Wheel's destruction, which calls
    # $kernel->state() to remove a state from the session.  The session,
    # though, is already gone.  If TRACE_RETVALS and/or ASSERT_RETVALS
    # is set, this causes a warning or fatal error.
  
    $self->_explain_return("session ($kr_active_session) does not exist");
    return ESRCH;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Kernel - an event-based application kernel in Perl
  
  =head1 SYNOPSIS
  
    use POE; # auto-includes POE::Kernel and POE::Session
  
    POE::Session->create(
      inline_states => {
        _start => sub { $_[KERNEL]->yield("next") },
        next   => sub {
          print "tick...\n";
          $_[KERNEL]->delay(next => 1);
        },
      },
    );
  
    POE::Kernel->run();
    exit;
  
  In the spirit of Perl, there are a lot of other ways to use POE.
  
  =head1 DESCRIPTION
  
  POE::Kernel is the heart of POE.  It provides the lowest-level
  features: non-blocking multiplexed I/O, timers, and signal watchers
  are the most significant.  Everything else is built upon this
  foundation.
  
  POE::Kernel is not an event loop in itself.  For that it uses one of
  several available POE::Loop interface modules.  See CPAN for modules
  in the POE::Loop namespace.
  
  POE's documentation assumes the reader understands the @_ offset
  constants (KERNEL, HEAP, ARG0, etc.).  The curious or confused reader
  will find more detailed explanation in L<POE::Session>.
  
  =head1 USING POE
  
  =head2 Literally Using POE
  
  POE.pm is little more than a class loader.  It implements some magic
  to cut down on the setup work.
  
  Parameters to C<use POE> are not treated as normal imports.  Rather,
  they're abbreviated modules to be included along with POE.
  
    use POE qw(Component::Client::TCP).
  
  As you can see, the leading "POE::" can be omitted this way.
  
  POE.pm also includes POE::Kernel and POE::Session by default.  These
  two modules are used by nearly all POE-based programs.  So the above
  example is actually the equivalent of:
  
    use POE;
    use POE::Kernel;
    use POE::Session;
    use POE::Component::Client::TCP;
  
  =head2 Using POE::Kernel
  
  POE::Kernel needs to know which event loop you want to use.  This is
  supported in three different ways:
  
  The first way is to use an event loop module before using POE::Kernel
  (or POE, which loads POE::Kernel for you):
  
    use Tk; # or one of several others
    use POE::Kernel.
  
  POE::Kernel scans the list of modules already loaded, and it loads an
  appropriate POE::Loop adapter if it finds a known event loop.
  
  The next way is to explicitly load the POE::Loop class you want:
  
    use POE qw(Loop::Gtk);
  
  Finally POE::Kernel's C<import()> supports more programmer-friendly
  configuration:
  
    use POE::Kernel { loop => "Gtk" };
    use POE::Session;
  
  =head2 Anatomy of a POE-Based Application
  
  Programs using POE work like any other.  They load required modules,
  perform some setup, run some code, and eventually exit.  Halting
  Problem notwithstanding.
  
  A POE-based application loads some modules, sets up one or more
  sessions, runs the code in those sessions, and eventually exits.
  
    use POE;
    POE::Session->create( ... map events to code here ... );
    POE::Kernel->run();
    exit;
  
  =head2 POE::Kernel singleton
  
  The POE::Kernel is a singleton object; there can be only one POE::Kernel
  instance within a process.  This allows many object methods to also be
  package methods.
  
  =head2 Sessions
  
  POE implements isolated compartments called I<sessions>.  Sessions play
  the role of tasks or threads within POE.  POE::Kernel acts as POE's
  task scheduler, doling out timeslices to each session by invoking
  callbacks within them.
  
  Callbacks are not preemptive.  As long as one is running, no others
  will be dispatched.  This is known as I<cooperative> multitasking.
  Each session must cooperate by returning to the central dispatching
  kernel.
  
  Cooperative multitasking vastly simplifies data sharing, since no two
  pieces of code may alter data at once.
  
  A session may also take exclusive control of a program's time, if
  necessary, by simply not returning in a timely fashion.  It's even
  possible to write completely blocking programs that use POE as a state
  machine rather than a cooperative dispatcher.
  
  Every POE-based application needs at least one session.  Code cannot
  run I<within POE> without being a part of some session.  Likewise, a
  threaded program always has a "thread zero".
  
  Sessions in POE::Kernel should not be confused with
  L<POE::Session|POE::Session> even though the two are inextricably
  associated.  POE::Session adapts POE::Kernel's dispatcher to a
  particular calling convention.  Other POE::Session classes exist on
  the CPAN.  Some radically alter the way event handlers are called.
  L<http://search.cpan.org/search?query=poe+session>.
  
  =head2 Resources
  
  Resources are events and things which may create new events, such as
  timers, I/O watchers, and even other sessions.
  
  POE::Kernel tracks resources on behalf of its active sessions.  It
  generates events corresponding to these resources' activity, notifying
  sessions when it's time to do things.
  
  The conversation goes something like this:
  
    Session: Be a dear, Kernel, and let me know when someone clicks on
             this widget.  Thanks so much!
  
    [TIME PASSES]  [SFX: MOUSE CLICK]
  
    Kernel: Right, then.  Someone's clicked on your widget.
            Here you go.
  
  Furthermore, since the Kernel keeps track of everything sessions do,
  it knows when a session has run out of tasks to perform.  When this
  happens, the Kernel emits a C<_stop> event at the dead session so it
  can clean up and shutdown.
  
    Kernel: Please switch off the lights and lock up; it's time to go.
  
  Likewise, if a session stops on its own and there still are opened
  resource watchers, the Kernel knows about them and cleans them up on
  the session's behalf.  POE excels at long-running services because it
  so meticulously tracks and cleans up resources.
  
  POE::Resources and the POE::Resource classes implement each kind of
  resource, which are summarized here and covered in greater detail
  later.
  
  =over 2
  
  =item Events.
  
  An event is a message to a sessions.  Posting an event keeps both the
  sender and the receiver alive until after the event has been
  dispatched.  This is only guaranteed if both the sender and receiver
  are in the same process.  Inter-Kernel message passing add-ons may
  have other guarantees.  Please see their documentation for details.
  
  The rationale is that the event is in play, so the receiver must
  remain active for it to be dispatched.  The sender remains alive in
  case the receiver would like to send back a response.
  
  Posted events cannot be preemptively canceled.  They tend to be
  short-lived in practice, so this generally isn't an issue.
  
  =item Timers.
  
  Timers allow an application to send a message to the future. Once set,
  a timer will keep the destination session active until it goes off and
  the resulting event is dispatched.
  
  =item Aliases.
  
  Session aliases are an application-controlled way of addressing a
  session.  Aliases act as passive event watchers.  As long as a session
  has an alias, some other session may send events to that session by
  that name.  Aliases keep sessions alive as long as a process has
  active sessions.
  
  If the only sessions remaining are being kept alive solely by their
  aliases, POE::Kernel will send them a terminal L</IDLE> signal.  In
  most cases this will terminate the remaining sessions and allow the
  program to exit.  If the sessions remain in memory without waking up
  on the C<IDLE> signal, POE::Kernel sends them a non-maskable L</ZOMBIE>
  signal.  They are then forcibly removed, and the program will finally
  exit.
  
  =item I/O watchers.
  
  A session will remain active as long as a session is paying attention
  to some external data source or sink. See
  L<select_read|"select_read FILE_HANDLE [, EVENT_NAME [, ADDITIONAL_PARAMETERS] ]">
  and
  L<select_write|"select_write FILE_HANDLE [, EVENT_NAME [, ADDITIONAL_PARAMETERS] ]">.
  
  =item Child sessions.
  
  A session acting as a parent of one or more other sessions will remain
  active until all the child sessions stop.  This may be bypassed by
  detaching the children from the parent.
  
  =item Child processes.
  
  Child process are watched by sig_child().  The sig_child() watcher
  will keep the watching session active until the child process has been
  reaped by POE::Kernel and the resulting event has been dispatched.
  
  All other signal watchers, including using L</sig> to watch for
  C<CHLD>, do not keep their sessions active.  If you need a session to
  remain active when it's only watching for signals, have it set an
  alias or one of its own public reference counters.
  
  =item Public reference counters.
  
  A session will remain active as long as it has one or more nonzero
  public (or external) reference counter.
  
  =back
  
  =head2 Session Lifespans
  
  "Session" as a term is somewhat overloaded.  There are two related
  concepts that share the name.  First there is the class POE::Session,
  and objects created with it or related classes.  Second there is a
  data structure within POE::Kernel that tracks the POE::Session objects
  in play and the various resources owned by each.
  
  The way POE's garbage collector works is that a session object gives
  itself to POE::Kernel at creation time.  The Kernel then holds onto
  that object as long as resources exist that require the session to
  remain alive.  When all of these resources are destroyed or released,
  the session object has nothing left to trigger activity.  POE::Kernel
  notifies the object it's through, and cleans up its internal session
  context.  The session object is released, and self-destructs in the
  normal Perlish fashion.
  
  Sessions may be stopped even if they have active resources.  For
  example, a session may fail to handle a terminal signal.  In this
  case, POE::Kernel forces the session to stop, and all resources
  associated with the session are preemptively released.
  
  =head2 Events
  
  An event is a message that is sent from one part of the POE
  application to another.  An event consists of the event's name,
  optional event-specific parameters and OOB information.  An event may
  be sent from the kernel, from a wheel or from a session.
  
  An application creates an event with L</post>, L</yield>, L</call> or
  even L</signal>.  POE::Kernel creates events in response external
  stimulus (signals, select, etc).
  
  =head3 Event Handlers
  
  An event is handled by a function called an I<event handler>, which is
  some code that is designated to be called when a particular event is
  dispatched.  See L</Event Handler Management> and L<POE::Session>.
  
  The term I<state> is often used in place of I<event handler>,
  especially when treating sessions as event driven state machines.
  
  Handlers are always called in scalar context for asynchronous events
  (i.e. via post()).  Synchronous events, invoked with call(), are
  handled in the same context that call() was called.
  
  Event handlers may not directly return references to objects in the
  "POE" namespace.  POE::Kernel will stringify these references to
  prevent timing issues with certain objects' destruction.  For example,
  this error handler would cause errors because a deleted wheel would
  not be destructed when one might think:
  
    sub handle_error {
      warn "Got an error";
      delete $_[HEAP]{wheel};
    }
  
  The delete() call returns the deleted wheel member, which is then
  returned implicitly by handle_error().
  
  =head2 Using POE with Other Event Loops
  
  POE::Kernel supports any number of event loops.  Two are included in
  the base distribution.  Historically, POE included other loops but they
  were moved into a separate distribution.  You can find them and other
  loops on the CPAN.
  
  POE's public interfaces remain the same regardless of the event loop
  being used.  Since most graphical toolkits include some form of event
  loop, back-end code should be portable to all of them.
  
  POE's cooperation with other event loops lets POE be embedded into
  other software.  The common underlying event loop drives both the
  application and POE.  For example, by using POE::Loop::Glib, one can
  embed POE into Vim, irssi, and so on.  Application scripts can then
  take advantage of POE::Component::Client::HTTP (and everything else)
  to do large-scale work without blocking the rest of the program.
  
  Because this is Perl, there are multiple ways to load an alternate
  event loop.  The simplest way is to load the event loop before loading
  POE::Kernel.
  
    use Gtk;
    use POE;
  
  Remember that POE loads POE::Kernel internally.
  
  POE::Kernel examines the modules loaded before it and detects that
  L<Gtk> has been loaded.  If L<POE::Loop::Gtk|POE::Loop::Gtk> is
  available, POE loads and hooks it into POE::Kernel automatically.
  
  It's less mysterious to load the appropriate L<POE::Loop|POE::Loop>
  class directly. Their names follow the format
  C<POE::Loop::$loop_module_name>, where C<$loop_module_name> is the
  name of the event loop module after each C<::> has been substituted
  with an underscore. It can be abbreviated using POE's loader magic.
  
    use POE qw( Loop::Event_Lib );
  
  POE also recognizes XS loops, they reside in the
  C<POE::XS::Loop::$loop_module_name> namespace.  Using them may give
  you a performance improvement on your platform, as the eventloop
  are some of the hottest code in the system.  As always, benchmark
  your application against various loops to see which one is best for
  your workload and platform.
  
    use POE qw( XS::Loop::EPoll );
  
  Please don't load the loop modules directly, because POE will not have
  a chance to initialize it's internal structures yet. Code written like
  this will throw errors on startup. It might look like a bug in POE, but
  it's just the way POE is designed.
  
    use POE::Loop::IO_Poll;
    use POE;
  
  POE::Kernel also supports configuration directives on its own C<use>
  line.  A loop explicitly specified this way will override the search
  logic.
  
    use POE::Kernel { loop => "Glib" };
  
  Finally, one may specify the loop class by setting the POE::Loop or
  POE::XS:Loop class name in the POE_EVENT_LOOP environment variable.
  This mechanism was added for tests that need to specify the loop from
  a distance.
  
    BEGIN { $ENV{POE_EVENT_LOOP} = "POE::XS::Loop::Poll" }
    use POE;
  
  Of course this may also be set from your shell:
  
    % export POE_EVENT_LOOP='POE::XS::Loop::Poll'
    % make test
  
  Many external event loops support their own callback mechanisms.
  L<POE::Session|POE::Session>'s L<"postback()"|POE::Session/postback>
  and L<"callback()"|POE::Session/callback> methods return plain Perl
  code references that will generate POE events when called.
  Applications can pass these code references to event loops for use as
  callbacks.
  
  POE's distribution includes two event loop interfaces.  CPAN holds
  several more:
  
  =head3 POE::Loop::Select (bundled)
  
  By default POE uses its select() based loop to drive its event system.
  This is perhaps the least efficient loop, but it is also the most
  portable.  POE optimizes for correctness above all.
  
  =head3 POE::Loop::IO_Poll (bundled)
  
  The L<IO::Poll|IO::Poll> event loop provides an alternative that
  theoretically scales better than select().
  
  =head3 POE::Loop::Event (separate distribution)
  
  This event loop provides interoperability with other modules that use
  L<Event>.  It may also provide a performance boost because L<Event> is
  written in a compiled language.  Unfortunately, this makes L<Event>
  less portable than Perl's built-in select().
  
  =head3 POE::Loop::Gtk (separate distribution)
  
  This event loop allows programs to work under the L<Gtk> graphical
  toolkit.
  
  =head3 POE::Loop::Tk (separate distribution)
  
  This event loop allows programs to work under the L<Tk> graphical
  toolkit.  Tk has some restrictions that require POE to behave oddly.
  
  Tk's event loop will not run unless one or more widgets are created.
  POE must therefore create such a widget before it can run. POE::Kernel
  exports $poe_main_window so that the application developer may use the
  widget (which is a L<MainWindow|Tk::MainWindow>), since POE doesn't
  need it other than for dispatching events.
  
  Creating and using a different MainWindow often has an undesired
  outcome.
  
  =head3 POE::Loop::EV (separate distribution)
  
  L<POE::Loop::EV> allows POE-based programs to use the EV event library
  with little or no change.
  
  =head3 POE::Loop::Glib (separate distribution)
  
  L<POE::Loop::Glib> allows POE-based programs to use Glib with little
  or no change.  It also supports embedding POE-based programs into
  applications that already use Glib.  For example, we have heard that
  POE has successfully embedded into vim, irssi and xchat via this loop.
  
  =head3 POE::Loop::Kqueue (separate distribution)
  
  L<POE::Loop::Kqueue> allows POE-based programs to transparently use
  the BSD kqueue event library on operating systems that support it.
  
  =head3 POE::Loop::Prima (separate distribution)
  
  L<POE::Loop::Prima> allows POE-based programs to use Prima's event
  loop with little or no change.  It allows POE libraries to be used
  within Prima applications.
  
  =head3 POE::Loop::Wx (separate distribution)
  
  L<POE::Loop::Wx> allows POE-based programs to use Wx's event loop with
  little or no change.  It allows POE libraries to be used within Wx
  applications, such as Padre.
  
  =head3 POE::XS::Loop::EPoll (separate distribution)
  
  L<POE::XS::Loop::EPoll> allows POE components to transparently use the
  EPoll event library on operating systems that support it.
  
  =head3 POE::XS::Loop::Poll (separate distribution)
  
  L<POE::XS::Loop::Poll> is a higher-performance C-based libpoll event
  loop.  It replaces some of POE's hot Perl code with C for better
  performance.
  
  =head3 Other Event Loops (separate distributions)
  
  POE may be extended to handle other event loops.  Developers are
  invited to work with us to support their favorite loops.
  
  =head1 PUBLIC METHODS
  
  POE::Kernel encapsulates a lot of features.  The documentation for
  each set of features is grouped by purpose.
  
  =head2 Kernel Management and Accessors
  
  =head3 ID
  
  ID() currently returns POE::Kernel's unique identifier.  Every
  Kernel instance is assigned a globally unique ID at birth.
  has_forked() alters the ID so that each forked process has a unique
  one, too.
  
    % perl -wl -MPOE -e 'print $poe_kernel->ID'
    macbookpoe.local-4d5305de-0000e6b8-00000001
  
  The content of these IDs may change from time to time.  Your code
  should not depend upon the current format.
  
  B<Deprecation Warning 2011-02-09>
  
  Your code should not depend upon ID() remaining unique.  The
  uniqueness will be removed in a future release of POE.  If you require
  unique IDs, please see one of the fine GUID and/or UUID modules on the
  CPAN:
  
    http://search.cpan.org/search?query=GUID&mode=dist
    http://search.cpan.org/search?query=UUID&mode=dist
  
  POE doesn't require globally or universally unique kernel IDs.  The
  creation and maintenance of these IDs adds overhead to POE::Kernel's
  has_forked() method.  Other modules do it better, upon demand, without
  incurring overhead for those who don't need them.
  
  =head3 run
  
  run() runs POE::Kernel's event dispatcher.  It will not return until
  all sessions have ended.  run() is a class method so a POE::Kernel
  reference is not needed to start a program's execution.
  
    use POE;
    POE::Session->create( ... ); # one or more
    POE::Kernel->run();          # set them all running
    exit;
  
  POE implements the Reactor pattern at its core.  Events are dispatched
  to functions and methods through callbacks.  The code behind run()
  waits for and dispatches events.
  
  run() will not return until every session has ended.  This includes
  sessions that were created while run() was running.
  
  POE::Kernel will print a strong message if a program creates sessions
  but fails to call run().  Prior to this warning, we received tons of
  bug reports along the lines of "my POE program isn't doing anything".
  It turned out that people forgot to start an event dispatcher, so
  events were never dispatched.
  
  If the lack of a run() call is deliberate, perhaps because some other
  event loop already has control, you can avoid the message by calling
  it before creating a session.  run() at that point will initialize POE
  and return immediately.  POE::Kernel will be satisfied that run() was
  called, although POE will not have actually taken control of the event
  loop.
  
    use POE;
    POE::Kernel->run(); # silence the warning
    POE::Session->create( ... );
    exit;
  
  Note, however, that this varies from one event loop to another.  If a
  particular POE::Loop implementation doesn't support it, that's
  probably a bug.  Please file a bug report with the owner of the
  relevant POE::Loop module.
  
  =head3 run_one_timeslice
  
  run_one_timeslice() dispatches any events that are due to be
  delivered.  These events include timers that are due, asynchronous
  messages that need to be delivered, signals that require handling, and
  notifications for files with pending I/O.  Do not rely too much on
  event ordering.  run_one_timeslice() is defined by the underlying
  event loop, and its timing may vary.
  
  run() is implemented similar to
  
    run_one_timeslice() while $session_count > 0;
  
  run_one_timeslice() can be used to keep running POE::Kernel's
  dispatcher while emulating blocking behavior.  The pattern is
  implemented with a flag that is set when some asynchronous event
  occurs.  A loop calls run_one_timeslice() until that flag is set.  For
  example:
  
    my $done = 0;
  
    sub handle_some_event {
      $done = 1;
    }
  
    $kernel->run_one_timeslice() while not $done;
  
  Do be careful.  The above example will spin if POE::Kernel is done but
  $done is never set.  The loop will never be done, even though there's
  nothing left that will set $done.
  
  =head3 run_while SCALAR_REF
  
  run_while() is an B<experimental> version of run_one_timeslice() that
  will only return when there are no more active sessions, or the value
  of the referenced scalar becomes false.
  
  Here's a version of the run_one_timeslice() example using run_while()
  instead:
  
    my $job_count = 3;
  
    sub handle_some_event {
      $job_count--;
    }
  
    $kernel->run_while(\$job_count);
  
  =head3 has_forked
  
      my $pid = fork();
      die "Unable to fork" unless defined $pid;
      unless( $pid ) {
          $poe_kernel->has_forked;
      }
   
  Inform the kernel that it is now running in a new process.  This allows the
  kernel to reset some internal data to adjust to the new situation.
  
  has_forked() must be called in the child process if you wish to run the same
  kernel.  However, if you want the child process to have new kernel, you must
  call L</stop> instead.
  
  B<Note:> POE's internals will detect if a fork occurred before C<run()> and will
  call C<has_forked()> automatically. If you are unsure whether you need to call it
  or not, please enable L</ASSERT_USAGE> and POE will emit a warning if it's necessary.
  
  =head3 stop
  
  stop() causes POE::Kernel->run() to return early.  It does this by
  emptying the event queue, freeing all used resources, and stopping
  every active session.  stop() is not meant to be used lightly.
  Proceed with caution.
  
  Caveats:
  
  The session that calls stop() will not be fully DESTROYed until it
  returns.  Invoking an event handler in the session requires a
  reference to that session, and weak references are prohibited in POE
  for backward compatibility reasons, so it makes sense that the last
  session won't be garbage collected right away.
  
  Sessions are not notified about their destruction.  If anything relies
  on _stop being delivered, it will break and/or leak memory.
  
  stop() is still considered experimental.  It was added to improve fork()
  support for L<POE::Wheel::Run|POE::Wheel::Run>.  If it proves unfixably
  problematic, it will be removed without much notice.
  
  stop() is advanced magic.  Programmers who think they need it are
  invited to become familiar with its source.
  
  See L<POE::Wheel::Run/Running POE::Kernel in the Child> for an example
  of how to use this facility.
  
  =head2 Asynchronous Messages (FIFO Events)
  
  Asynchronous messages are events that are dispatched in the order in
  which they were enqueued (the first one in is the first one out,
  otherwise known as first-in/first-out, or FIFO order).  These methods
  enqueue new messages for delivery.  The act of enqueuing a message
  keeps the sender alive at least until the message is delivered.
  
  =head3 post DESTINATION, EVENT_NAME [, PARAMETER_LIST]
  
  post() enqueues a message to be dispatched to a particular DESTINATION
  session.  The message will be handled by the code associated with
  EVENT_NAME.  If a PARAMETER_LIST is included, its values will also be
  passed along.
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[KERNEL]->post( $_[SESSION], "event_name", 0 );
        },
        event_name => sub {
          print "$_[ARG0]\n";
          $_[KERNEL]->post( $_[SESSION], "event_name", $_[ARG0] + 1 );
        },
      }
    );
  
  post() returns a Boolean value indicating whether the message was
  successfully enqueued.  If post() returns false, $! is set to explain
  the failure:
  
  ESRCH ("No such process") - The DESTINATION session did not exist at
  the time post() was called.
  
  =head3 yield EVENT_NAME [, PARAMETER_LIST]
  
  yield() is a shortcut for post() where the destination session is the
  same as the sender.  This example is equivalent to the one for post():
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[KERNEL]->yield( "event_name", 0 );
        },
        event_name => sub {
          print "$_[ARG0]\n";
          $_[KERNEL]->yield( "event_name", $_[ARG0] + 1 );
        },
      }
    );
  
  As with post(), yield() returns right away, and the enqueued
  EVENT_NAME is dispatched later.  This may be confusing if you're
  already familiar with threading.
  
  yield() should always succeed, so it does not return a meaningful
  value.
  
  =head2 Synchronous Messages
  
  It is sometimes necessary for code to be invoked right away.  For
  example, some resources must be serviced right away, or they'll
  faithfully continue reporting their readiness.  These reports would
  appear as a stream of duplicate events.  Synchronous events can also
  prevent data from going stale between the time an event is enqueued
  and the time it's delivered.
  
  Synchronous event handlers preempt POE's event queue, so they should
  perform simple tasks of limited duration.  Synchronous events that
  need to do more than just service a resource should pass the
  resource's information to an asynchronous handler.  Otherwise
  synchronous operations will occur out of order in relation to
  asynchronous events.  It's very easy to have race conditions or break
  causality this way, so try to avoid it unless you're okay with the
  consequences.
  
  POE provides these ways to call message handlers right away.
  
  =head3 call DESTINATION, EVENT_NAME [, PARAMETER_LIST]
  
  call()'s semantics are nearly identical to post()'s.  call() invokes a
  DESTINATION's handler associated with an EVENT_NAME.  An optional
  PARAMETER_LIST will be passed along to the message's handler.  The
  difference, however, is that the handler will be invoked immediately,
  even before call() returns.
  
  call() returns the value returned by the EVENT_NAME handler.  It can
  do this because the handler is invoked before call() returns.  call()
  can therefore be used as an accessor, although there are better ways
  to accomplish simple accessor behavior.
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          print "Got: ", $_[KERNEL]->call($_[SESSION], "do_now"), "\n";
        },
        do_now => sub {
          return "some value";
        }
      }
    );
  
  The L<POE::Wheel|POE::Wheel> classes uses call() to synchronously deliver I/O
  notifications.  This avoids a host of race conditions.
  
  call() may fail in the same way and for the same reasons as post().
  On failure, $! is set to some nonzero value indicating why.  Since
  call() may return undef as a matter of course, it's recommended that
  $! be checked for the error condition as well as the explanation.
  
  ESRCH ("No such process") - The DESTINATION session did not exist at
  the time post() was called.
  
  =head2 Timer Events (Delayed Messages)
  
  It's often useful to wait for a certain time or until a certain amount
  of time has passed.  POE supports this with events that are deferred
  until either an absolute time ("alarms") or until a certain duration
  of time has elapsed ("delays").
  
  Timer interfaces are further divided into two groups.  One group identifies
  timers by the names of their associated events.  Another group identifies
  timers by a unique identifier returned by the timer constructors.
  Technically, the two are both name-based, but the "identifier-based" timers
  provide a second, more specific handle to identify individual timers.
  
  Timers may only be set up for the current session.  This design was
  modeled after alarm() and SIGALRM, which only affect the current UNIX
  process.  Each session has a separate namespace for timer names.
  Timer methods called in one session cannot affect the timers in
  another.  As you may have noticed, quite a lot of POE's API is
  designed to prevent sessions from interfering with each other.
  
  The best way to simulate deferred inter-session messages is to send an
  immediate message that causes the destination to set a timer.  The
  destination's timer then defers the action requested of it.  This way
  is preferred because the time spent communicating the request between
  sessions may not be trivial, especially if the sessions are separated
  by a network.  The destination can determine how much time remains on
  the requested timer and adjust its wait time accordingly.
  
  =head3 Name-Based Timers
  
  Name-based timers are identified by the event names used to set them.
  It is possible for different sessions to use the same timer event names,
  since each session is a separate compartment with its own timer namespace.
  It is possible for a session to have multiple timers for a given event,
  but results may be surprising.  Be careful to use the right timer methods.
  
  The name-based timer methods are alarm(), alarm_add(), delay(), and
  delay_add().
  
  =head4 alarm EVENT_NAME [, EPOCH_TIME [, PARAMETER_LIST] ]
  
  alarm() clears all existing timers in the current session with the
  same EVENT_NAME.  It then sets a new timer, named EVENT_NAME, that
  will fire EVENT_NAME at the current session when EPOCH_TIME has been
  reached.  An optional PARAMETER_LIST may be passed along to the
  timer's handler.
  
  Omitting the EPOCH_TIME and subsequent parameters causes alarm() to
  clear the EVENT_NAME timers in the current session without setting a
  new one.
  
  EPOCH_TIME is the UNIX epoch time.  You know, seconds since midnight,
  1970-01-01.  POE uses Time::HiRes::time(), which allows EPOCH_TIME to
  be (or include) fractional seconds.
  
  POE supports fractional seconds, but accuracy falls off steeply after
  1/100 second.  Mileage will vary depending on your CPU speed and your
  OS time resolution.
  
  Be sure to use Time::HiRes::time() rather than Perl's built-in time()
  if sub-second accuracy matters at all.  The built-in time() returns
  floor(Time::HiRes::time()), which is nearly always some fraction of a
  second in the past.  For example the high-resolution time might be
  1200941422.89996.  At that same instant, time() would be 1200941422.
  An alarm for time() + 0.5 would be 0.39996 seconds in the past, so it
  would be dispatched immediately (if not sooner).
  
  POE's event queue is time-ordered, so a timer due before time() will
  be delivered ahead of other events but not before timers with even
  earlier due times.  Therefore an alarm() with an EPOCH_TIME before
  time() jumps ahead of the queue.
  
  All timers are implemented identically internally, regardless of how
  they are set.  alarm() will therefore blithely clear timers set by
  other means.
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[KERNEL]->alarm( tick => time() + 1, 0 );
        },
        tick => sub {
          print "tick $_[ARG0]\n";
          $_[KERNEL]->alarm( tock => time() + 1, $_[ARG0] + 1 );
        },
        tock => sub {
          print "tock $_[ARG0]\n";
          $_[KERNEL]->alarm( tick => time() + 1, $_[ARG0] + 1 );
        },
      }
    );
  
  alarm() returns 0 on success or a true value on failure.  Usually
  EINVAL to signal an invalid parameter, such as an undefined
  EVENT_NAME.
  
  =head4 alarm_add EVENT_NAME, EPOCH_TIME [, PARAMETER_LIST]
  
  alarm_add() is used to add a new alarm timer named EVENT_NAME without
  clearing existing timers.  EPOCH_TIME is a required parameter.
  Otherwise the semantics are identical to alarm().
  
  A program may use alarm_add() without first using alarm().
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[KERNEL]->alarm_add( tick => time() + 1.0, 1_000_000 );
          $_[KERNEL]->alarm_add( tick => time() + 1.5, 2_000_000 );
        },
        tick => sub {
          print "tick $_[ARG0]\n";
          $_[KERNEL]->alarm_add( tock => time() + 1, $_[ARG0] + 1 );
        },
        tock => sub {
          print "tock $_[ARG0]\n";
          $_[KERNEL]->alarm_add( tick => time() + 1, $_[ARG0] + 1 );
        },
      }
    );
  
  alarm_add() returns 0 on success or EINVAL if EVENT_NAME or EPOCH_TIME
  is undefined.
  
  =head4 delay EVENT_NAME [, DURATION_SECONDS [, PARAMETER_LIST] ]
  
  delay() clears all existing timers in the current session with the
  same EVENT_NAME.  It then sets a new timer, named EVENT_NAME, that
  will fire EVENT_NAME at the current session when DURATION_SECONDS have
  elapsed from "now".  An optional PARAMETER_LIST may be passed along to
  the timer's handler.
  
  Omitting the DURATION_SECONDS and subsequent parameters causes delay()
  to clear the EVENT_NAME timers in the current session without setting
  a new one.
  
  DURATION_SECONDS may be or include fractional seconds.  As with all of
  POE's timers, accuracy falls off steeply after 1/100 second.  Mileage
  will vary depending on your CPU speed and your OS time resolution.
  
  POE's event queue is time-ordered, so a timer due before time() will
  be delivered ahead of other events but not before timers with even
  earlier due times.  Therefore a delay () with a zero or negative
  DURATION_SECONDS jumps ahead of the queue.
  
  delay() may be considered a shorthand form of alarm(), but there are
  subtle differences in timing issues.  This code is roughly equivalent
  to the alarm() example.
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[KERNEL]->delay( tick => 1, 0 );
        },
        tick => sub {
          print "tick $_[ARG0]\n";
          $_[KERNEL]->delay( tock => 1, $_[ARG0] + 1 );
        },
        tock => sub {
          print "tock $_[ARG0]\n";
          $_[KERNEL]->delay( tick => 1, $_[ARG0] + 1 );
        },
      }
    );
  
  delay() returns 0 on success or a reason for failure: EINVAL if
  EVENT_NAME is undefined.
  
  =head4 delay_add EVENT_NAME, DURATION_SECONDS [, PARAMETER_LIST]
  
  delay_add() is used to add a new delay timer named EVENT_NAME without
  clearing existing timers.  DURATION_SECONDS is a required parameter.
  Otherwise the semantics are identical to delay().
  
  A program may use delay_add() without first using delay().
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[KERNEL]->delay_add( tick => 1.0, 1_000_000 );
          $_[KERNEL]->delay_add( tick => 1.5, 2_000_000 );
        },
        tick => sub {
          print "tick $_[ARG0]\n";
          $_[KERNEL]->delay_add( tock => 1, $_[ARG0] + 1 );
        },
        tock => sub {
          print "tock $_[ARG0]\n";
          $_[KERNEL]->delay_add( tick => 1, $_[ARG0] + 1 );
        },
      }
    );
  
  delay_add() returns 0 on success or EINVAL if EVENT_NAME or EPOCH_TIME
  is undefined.
  
  =head3 Identifier-Based Timers
  
  A second way to manage timers is through identifiers.  Setting an
  alarm or delay with the "identifier" methods allows a program to
  manipulate several timers with the same name in the same session.  As
  covered in alarm() and delay() however, it's possible to mix named and
  identified timer calls, but the consequences may not always be
  expected.
  
  =head4 alarm_set EVENT_NAME, EPOCH_TIME [, PARAMETER_LIST]
  
  alarm_set() sets an alarm, returning a unique identifier that can be
  used to adjust or remove the alarm later.  Unlike alarm(), it does not
  first clear existing timers with the same EVENT_NAME.  Otherwise the
  semantics are identical to alarm().
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[HEAP]{alarm_id} = $_[KERNEL]->alarm_set(
            party => time() + 1999
          );
          $_[KERNEL]->delay(raid => 1);
        },
        raid => sub {
          $_[KERNEL]->alarm_remove( delete $_[HEAP]{alarm_id} );
        },
      }
    );
  
  alarm_set() returns false if it fails and sets $! with the
  explanation.  $! will be EINVAL if EVENT_NAME or TIME is undefined.
  
  =head4 alarm_adjust ALARM_ID, DELTA_SECONDS
  
  alarm_adjust() adjusts an existing timer's due time by DELTA_SECONDS,
  which may be positive or negative.  It may even be zero, but that's
  not as useful.  On success, it returns the timer's new due time since
  the start of the UNIX epoch.
  
  It's possible to alarm_adjust() timers created by delay_set() as well
  as alarm_set().
  
  This example moves an alarm's due time ten seconds earlier.
  
    use POSIX qw(strftime);
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[HEAP]{alarm_id} = $_[KERNEL]->alarm_set(
            party => time() + 1999
          );
          $_[KERNEL]->delay(postpone => 1);
        },
        postpone => sub {
          my $new_time = $_[KERNEL]->alarm_adjust(
            $_[HEAP]{alarm_id}, -10
          );
          print(
            "Now we're gonna party like it's ",
            strftime("%F %T", gmtime($new_time)), "\n"
          );
        },
      }
    );
  
  alarm_adjust() returns Boolean false if it fails, setting $! to the
  reason why.  $! may be EINVAL if ALARM_ID or DELTA_SECONDS are
  undefined.  It may be ESRCH if ALARM_ID no longer refers to a pending
  timer.  $! may also contain EPERM if ALARM_ID is valid but belongs to
  a different session.
  
  =head4 alarm_remove ALARM_ID
  
  alarm_remove() removes the alarm identified by ALARM_ID.  ALARM_ID
  comes from a previous alarm_set() or delay_set() call.
  
  Upon success, alarm_remove() returns something true based on its
  context.  In a list context, it returns three things: The removed
  alarm's event name, the UNIX time it was due to go off, and a
  reference to the PARAMETER_LIST (if any) assigned to the timer when it
  was created.  If necessary, the timer can be re-set with this
  information.
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[HEAP]{alarm_id} = $_[KERNEL]->alarm_set(
            party => time() + 1999
          );
          $_[KERNEL]->delay(raid => 1);
        },
        raid => sub {
          my ($name, $time, $param) = $_[KERNEL]->alarm_remove(
            $_[HEAP]{alarm_id}
          );
          print(
            "Removed alarm for event $name due at $time with @$param\n"
          );
  
          # Or reset it, if you'd like.  Possibly after modification.
          $_[KERNEL]->alarm_set($name, $time, @$param);
        },
      }
    );
  
  In a scalar context, it returns a reference to a list of the three
  things above.
  
    # Remove and reset an alarm.
    my $alarm_info = $_[KERNEL]->alarm_remove( $alarm_id );
    my $new_id = $_[KERNEL]->alarm_set(
      $alarm_info[0], $alarm_info[1], @{$alarm_info[2]}
    );
  
  Upon failure, however, alarm_remove() returns a Boolean false value
  and sets $! with the reason why the call failed:
  
  EINVAL ("Invalid argument") indicates a problem with one or more
  parameters, usually an undefined ALARM_ID.
  
  ESRCH ("No such process") indicates that ALARM_ID did not refer to a
  pending alarm.
  
  EPERM ("Operation not permitted").  A session cannot remove an alarm
  it does not own.
  
  =head4 alarm_remove_all
  
  alarm_remove_all() removes all the pending timers for the current
  session, regardless of creation method or type.  This method takes no
  arguments.  It returns information about the alarms that were removed,
  either as a list of alarms or a list reference depending whether
  alarm_remove_all() is called in scalar or list context.
  
  Each removed alarm's information is identical to the format explained
  in alarm_remove().
  
    sub some_event_handler {
      my @removed_alarms = $_[KERNEL]->alarm_remove_all();
      foreach my $alarm (@removed_alarms) {
        my ($name, $time, $param) = @$alarm;
        ...;
      }
    }
  
  =head4 delay_set EVENT_NAME, DURATION_SECONDS [, PARAMETER_LIST]
  
  delay_set() sets a timer for DURATION_SECONDS in the future.  The
  timer will be dispatched to the code associated with EVENT_NAME in the
  current session.  An optional PARAMETER_LIST will be passed through to
  the handler.  It returns the same sort of things that alarm_set()
  does.
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[KERNEL]->delay_set("later", 5, "hello", "world");
        },
        later => sub {
          print "@_[ARG0..#$_]\n";
        }
      }
    );
  
  =head4 delay_adjust ALARM_ID, SECONDS_FROM_NOW
  
  delay_adjust() changes a timer's due time to be SECONDS_FROM_NOW.
  It's useful for refreshing watchdog- or timeout-style timers.  On
  success it returns the new absolute UNIX time the timer will be due.
  
  It's possible for delay_adjust() to adjust timers created by
  alarm_set() as well as delay_set().
  
    use POSIX qw(strftime);
  
    POE::Session->create(
      inline_states => {
        # Setup.
        # ... omitted.
  
        got_input => sub {
          my $new_time = $_[KERNEL]->delay_adjust(
            $_[HEAP]{input_timeout}, 60
          );
          print(
            "Refreshed the input timeout.  Next may occur at ",
            strftime("%F %T", gmtime($new_time)), "\n"
          );
        },
      }
    );
  
  On failure it returns Boolean false and sets $! to a reason for the
  failure.  See the explanation of $! for alarm_adjust().
  
  =head4 delay_remove is not needed
  
  There is no delay_remove().  Timers are all identical internally, so
  alarm_remove() will work with timer IDs returned by delay_set().
  
  =head4 delay_remove_all is not needed
  
  There is no delay_remove_all().  Timers are all identical internally,
  so alarm_remove_all() clears them all regardless how they were
  created.
  
  =head3 Comparison
  
  Below is a table to help compare the various delayed message-sending methods
  
    +-----------+------------------+---------------------+------------+
    |           | time argument    | clears other events | returns on |
    | method    | passed to method | of the same name    | success    |
    +-----------+------------------+---------------------+------------+
    | delay_set | seconds from now | N                   | alarm_id   |
    | delay     | seconds from now | Y                   | 0 (false)  |
    | alarm_set | unix epoch time  | N                   | alarm_id   |
    | alarm     | unix epoch time  | Y                   | 0 (false)  |
    +-----------+------------------+---------------------+------------+
  
  =head2 Session Identifiers (IDs and Aliases)
  
  A session may be referred to by its object references (either blessed
  or stringified), a session ID, or one or more symbolic names we call
  aliases.
  
  Every session is represented by an object, so session references are
  fairly straightforward.  POE::Kernel may reference these objects.  For
  instance, post() may use $_[SENDER] as a destination:
  
    POE::Session->create(
      inline_states => {
        _start => sub { $_[KERNEL]->alias_set("echoer") },
        ping => sub {
          $_[KERNEL]->post( $_[SENDER], "pong", @_[ARG0..$#_] );
        }
      }
    );
  
  POE also recognized stringified Session objects for convenience and as
  a form of weak reference.  Here $_[SENDER] is wrapped in quotes to
  stringify it:
  
    POE::Session->create(
      inline_states => {
        _start => sub { $_[KERNEL]->alias_set("echoer") },
        ping => sub {
          $_[KERNEL]->post( "$_[SENDER]", "pong", @_[ARG0..$#_] );
        }
      }
    );
  
  Every session is assigned a unique ID at creation time.  No two active
  sessions will have the same ID, but IDs may be reused over time.  The
  combination of a kernel ID and a session ID should be sufficient as a
  global unique identifier.
  
    POE::Session->create(
      inline_states => {
        _start => sub { $_[KERNEL]->alias_set("echoer") },
        ping => sub {
          $_[KERNEL]->delay(
            pong_later => rand(5), $_[SENDER]->ID, @_[ARG0..$#_]
          );
        },
        pong_later => sub {
          $_[KERNEL]->post( $_[ARG0], "pong", @_[ARG1..$#_] );
        }
      }
    );
  
  Kernels also maintain a global session namespace or dictionary from which
  may be used to map a symbolic aliases to a session. Once an alias is mapping
  has been created, that alias may be used to refer to the session wherever a
  session may be specified.
  
  In the previous examples, each echoer service has set an "echoer"
  alias.  Another session can post a ping request to the echoer session
  by using that alias rather than a session object or ID.  For example:
  
    POE::Session->create(
      inline_states => {
        _start => sub { $_[KERNEL]->post(echoer => ping => "whee!" ) },
        pong => sub { print "@_[ARG0..$#_]\n" }
      }
    );
  
  A session with an alias will not stop until all other activity has stopped.
  Aliases are treated as a kind of event watcher.  Events come from active
  sessions.  Aliases therefore become useless when there are no active
  sessions left.  Rather than leaving the program running in a "zombie" state,
  POE detects this deadlock condition and triggers a cleanup.  See
  L</Signal Classes> for more information.
  
  =head3 alias_set ALIAS
  
  alias_set() maps an ALIAS in POE::Kernel's dictionary to the
  current session. The ALIAS may then be used nearly everywhere a session
  reference, stringified reference, or ID is expected.
  
  Sessions may have more than one alias.  Each alias must be defined in
  a separate alias_set() call.  A single alias may not refer to more
  than one session.
  
  Multiple alias examples are above.
  
  alias_set() returns 0 on success, or a nonzero failure indicator:
  EEXIST ("File exists") indicates that the alias is already assigned to
  to a different session.
  
  =head3 alias_remove ALIAS
  
  alias_remove() removes an ALIAS for the current session from
  POE::Kernel's dictionary.  The ALIAS will no longer refer to the
  current session.  This does not negatively affect events already
  posted to POE's queue.  Alias resolution occurs at post() time, not at
  delivery time.
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[KERNEL]->alias_set("short_window");
          $_[KERNEL]->delay(close_window => 1);
        },
        close_window => {
          $_[KERNEL]->alias_remove("short_window");
        }
      }
    );
  
  alias_remove() returns 0 on success or a nonzero failure code:  ESRCH
  ("No such process") indicates that the ALIAS is not currently in
  POE::Kernel's dictionary.  EPERM ("Operation not permitted") means
  that the current session may not remove the ALIAS because it is in use
  by some other session.
  
  =head3 alias_resolve ALIAS
  
  alias_resolve() returns a session reference corresponding to a given
  ALIAS.  Actually, the ALIAS may be a stringified session reference, a
  session ID, or an alias previously registered by alias_set().
  
  One use for alias_resolve() is to detect whether another session has
  gone away:
  
    unless (defined $_[KERNEL]->alias_resolve("Elvis")) {
      print "Elvis has left the building.\n";
    }
  
  As previously mentioned, alias_resolve() returns a session reference
  or undef on failure.  Failure also sets $! to ESRCH ("No such
  process") when the ALIAS is not currently in POE::Kernel's.
  
  =head3 alias_list [SESSION_REFERENCE]
  
  alias_list() returns a list of aliases associated with a specific
  SESSION, or with the current session if SESSION is omitted.
  alias_list() returns an empty list if the requested SESSION has no
  aliases.
  
  SESSION may be a session reference (blessed or stringified), a session
  ID, or a session alias.
  
    POE::Session->create(
      inline_states => {
        $_[KERNEL]->alias_set("mi");
        print(
          "The names I call myself: ",
          join(", ", $_[KERNEL]->alias_list()),
          "\n"
        );
      }
    );
  
  =head3 ID_id_to_session SESSION_ID
  
  ID_id_to_session() translates a session ID into a session reference.
  It's a special-purpose subset of alias_resolve(), so it's a little
  faster and somewhat less flexible.
  
    unless (defined $_[KERNEL]->ID_id_to_session($session_id)) {
      print "Session $session_id doesn't exist.\n";
    }
  
  ID_id_to_session() returns undef if a lookup failed.  $! will be set
  to ESRCH ("No such process").
  
  =head3 ID_session_to_id SESSION_REFERENCE
  
  ID_session_to_id() converts a blessed or stringified SESSION_REFERENCE
  into a session ID.  It's more practical for stringified references, as
  programs can call the POE::Session ID() method on the blessed ones.
  These statements are equivalent:
  
    $id = $_[SENDER]->ID();
    $id = $_[KERNEL]->ID_session_to_id($_[SENDER]);
    $id = $_[KERNEL]->ID_session_to_id("$_[SENDER]");
  
  As with other POE::Kernel lookup methods, ID_session_to_id() returns
  undef on failure, setting $! to ESRCH ("No such process").
  
  =head2 I/O Watchers (Selects)
  
  No event system would be complete without the ability to
  asynchronously watch for I/O events.  POE::Kernel implements the
  lowest level watchers, which are called "selects" because they were
  historically implemented using Perl's built-in select(2) function.
  
  Applications handle I/O readiness events by performing some activity
  on the underlying filehandle.  Read-readiness might be handled by
  reading from the handle.  Write-readiness by writing to it.
  
  All I/O watcher events include two parameters.  C<ARG0> contains the
  handle that is ready for work.  C<ARG1> contains an integer describing
  what's ready.
  
    sub handle_io {
      my ($handle, $mode) = @_[ARG0, ARG1];
      print "File $handle is ready for ";
      if ($mode == 0) {
        print "reading";
      }
      elsif ($mode == 1) {
        print "writing";
      }
      elsif ($mode == 2) {
        print "out-of-band reading";
      }
      else {
        die "unknown mode $mode";
      }
      print "\n";
      # ... do something here
    }
  
  The remaining parameters, C<@_[ARG2..$%_]>, contain additional
  parameters that were passed to the POE::Kernel method that created the
  watcher.
  
  POE::Kernel conditions filehandles to be 8-bit clean and non-blocking.
  Programs that need them conditioned differently should set them up
  after starting POE I/O watchers. If you are running a Perl older than
  5.8.1 and is using tied filehandles, you need to set non-blocking mode
  yourself as L<IO::Handle> does not work well.
  See L<https://rt.cpan.org/Ticket/Display.html?id=67545> for more info.
  
  I/O watchers will prevent sessions from stopping.
  
  =head3 select_read FILE_HANDLE [, EVENT_NAME [, ADDITIONAL_PARAMETERS] ]
  
  select_read() starts or stops the current session from watching for
  incoming data on a given FILE_HANDLE.  The watcher is started if
  EVENT_NAME is specified, or stopped if it's not.
  ADDITIONAL_PARAMETERS, if specified, will be passed to the EVENT_NAME
  handler as C<@_[ARG2..$#_]>.
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[HEAP]{socket} = IO::Socket::INET->new(
            PeerAddr => "localhost",
            PeerPort => 25,
          );
          $_[KERNEL]->select_read( $_[HEAP]{socket}, "got_input" );
          $_[KERNEL]->delay(timed_out => 1);
        },
        got_input => sub {
          my $socket = $_[ARG0];
          while (sysread($socket, my $buf = "", 8192)) {
            print $buf;
          }
        },
        timed_out => sub {
          $_[KERNEL]->select_read( delete $_[HEAP]{socket} );
        },
      }
    );
  
  select_read() does not return anything significant.
  
  =head3 select_write FILE_HANDLE [, EVENT_NAME [, ADDITIONAL_PARAMETERS] ]
  
  select_write() follows the same semantics as select_read(), but it
  starts or stops a watcher that looks for write-readiness.  That is,
  when EVENT_NAME is delivered, it means that FILE_HANDLE is ready to be
  written to.
  
  select_write() does not return anything significant.
  
  =head3 select_expedite FILE_HANDLE [, EVENT_NAME [, ADDITIONAL_PARAMETERS] ]
  
  select_expedite() does the same sort of thing as select_read() and
  select_write(), but it watches a FILE_HANDLE for out-of-band data
  ready to be input from a FILE_HANDLE.  Hardly anybody uses this, but
  it exists for completeness' sake.
  
  An EVENT_NAME event will be delivered whenever the FILE_HANDLE can be
  read from out-of-band.  Out-of-band data is considered "expedited"
  because it is often ahead of a socket's normal data.
  
  select_expedite() does not return anything significant.
  
  =head3 select_pause_read FILE_HANDLE
  
  select_pause_read() is a lightweight way to pause a FILE_HANDLE input
  watcher without performing all the bookkeeping of a select_read().
  It's used with select_resume_read() to implement input flow control.
  
  Input that occurs on FILE_HANDLE will backlog in the operating system
  buffers until select_resume_read() is called.
  
  A side effect of bypassing the select_read() bookkeeping is that a
  paused FILE_HANDLE will not prematurely stop the current session.
  
  select_pause_read() does not return anything significant.
  
  =head3 select_resume_read FILE_HANDLE
  
  select_resume_read() resumes a FILE_HANDLE input watcher that was
  previously paused by select_pause_read().  See select_pause_read() for
  more discussion on lightweight input flow control.
  
  Data backlogged in the operating system due to a select_pause_read()
  call will become available after select_resume_read() is called.
  
  select_resume_read() does not return anything significant.
  
  =head3 select_pause_write FILE_HANDLE
  
  select_pause_write() pauses a FILE_HANDLE output watcher the same way
  select_pause_read() does for input.  Please see select_pause_read()
  for further discussion.
  
  =head3 select_resume_write FILE_HANDLE
  
  select_resume_write() resumes a FILE_HANDLE output watcher the same
  way that select_resume_read() does for input.  See
  select_resume_read() for further discussion.
  
  =head3 select FILE_HANDLE [, EV_READ [, EV_WRITE [, EV_EXPEDITE [, ARGS] ] ] ]
  
  POE::Kernel's select() method sets or clears a FILE_HANDLE's read,
  write and expedite watchers at once.  It's a little more expensive
  than calling select_read(), select_write() and select_expedite()
  manually, but it's significantly more convenient.
  
  Defined event names enable their corresponding watchers, and undefined
  event names disable them.  This turns off all the watchers for a
  FILE_HANDLE:
  
    sub stop_io {
      $_[KERNEL]->select( $_[HEAP]{file_handle} );
    }
  
  This statement:
  
    $_[KERNEL]->select( $file_handle, undef, "write_event", undef, @stuff );
  
  is equivalent to:
  
    $_[KERNEL]->select_read( $file_handle );
    $_[KERNEL]->select_write( $file_handle, "write_event", @stuff );
    $_[KERNEL]->select_expedite( $file_handle );
  
  POE::Kernel's select() should not be confused with Perl's built-in
  select() function.
  
  As with the other I/O watcher methods, select() does not return a
  meaningful value.
  
  =head2 Session Management
  
  Sessions are dynamic.  They may be created and destroyed during a
  program's lifespan.  When a session is created, it becomes the "child"
  of the current session.  The creator -- the current session -- becomes
  its "parent" session.  This is loosely modeled after UNIX processes.
  
  The most common session management is done by creating new sessions
  and allowing them to eventually stop.
  
  Every session has a parent, even the very first session created.
  Sessions without obvious parents are children of the program's
  POE::Kernel instance.
  
  Child sessions will keep their parents active.  See L</Session
  Lifespans> for more about why sessions stay alive.
  
  The parent/child relationship tree also governs the way many signals
  are dispatched.  See L</Common Signal Dispatching> for more
  information on that.
  
  =head3 Session Management Events (_start, _stop, _parent, _child)
  
  POE::Kernel provides four session management events: _start, _stop,
  _parent and _child.  They are invoked synchronously whenever a session
  is newly created or just about to be destroyed.
  
  =over 2
  
  =item _start
  
  _start should be familiar by now.  POE dispatches the _start event to
  initialize a session after it has been registered under POE::Kernel.
  What is not readily apparent, however, is that it is invoked before
  the L<POE::Session|POE::Session> constructor returns.
  
  Within the _start handler, the event's sender is the session that
  created the new session.  Otherwise known as the new session's
  I<parent>.  Sessions created before POE::Kernel->run() is called will
  be descendents of the program's POE::Kernel singleton.
  
  The _start handler's return value is passed to the parent session in a
  _child event, along with the notification that the parent's new child
  was created successfully.  See the discussion of _child for more
  details.
  
    POE::Session->create(
      inline_states => { _start=> \&_start },
      args => [ $some, $args ]
    );
  
    sub _start {
      my ( $some, $args ) = @_[ ARG0, ARG1 ];
      # ....
    }
  
  =item _stop
  
  _stop is a little more mysterious.  POE calls a _stop handler when a
  session is irrevocably about to be destroyed.  Part of session
  destruction is the forcible reclamation of its resources (events,
  timers, message events, etc.) so it's not possible to post() a message
  from _stop's handler.  A program is free to try, but the event will be
  destroyed before it has a chance to be dispatched.
  
  the _stop handler's return value is passed to the parent's _child
  event.  See _child for more details.
  
  _stop is usually invoked when a session has no further reason to live,
  although signals may cause them to stop sooner.
  
  The corresponding _child handler is invoked synchronously just after
  _stop returns.
  
  =item _parent
  
  _parent is used to notify a child session when its parent has changed.
  This usually happens when a session is first created.  It can also
  happen when a child session is detached from its parent. See
  L<detach_child|/"detach_child CHILD_SESSION"> and L</detach_myself>.
  
  _parent's ARG0 contains the session's previous parent, and ARG1
  contains its new parent.
  
    sub _parent {
      my ( $old_parent, $new_parent ) = @_[ ARG0, ARG1 ];
      print(
        "Session ", $_[SESSION]->ID,
        " parent changed from session ", $old_parent->ID,
        " to session ", $new_parent->ID,
        "\n"
      );
    }
  
  =item _child
  
  _child notifies one session when a child session has been created,
  destroyed, or reassigned to or from another parent.  It's usually
  dispatched when sessions are created or destroyed.  It can also happen
  when a session is detached from its parent.
  
  _child includes some information in the "arguments" portion of @_.
  Typically ARG0, ARG1 and ARG2, but these may be overridden by a
  different POE::Session class:
  
  ARG0 contains a string describing what has happened to the child.  The
  string may be 'create' (the child session has been created), 'gain'
  (the child has been given by another session), or 'lose' (the child
  session has stopped or been given away).
  
  In all cases, ARG1 contains a reference to the child session.
  
  In the 'create' case, ARG2 holds the value returned by the child
  session's _start handler.  Likewise, ARG2 holds the _stop handler's
  return value for the 'lose' case.
  
    sub _child {
      my( $reason, $child ) = @_[ ARG0, ARG1 ];
      if( $reason eq 'create' ) {
        my $retval = $_[ ARG2 ];
      }
      # ...
    }
  
  =back
  
  The events are delivered in specific orders.
  
  =head4 When a new session is created:
  
  =over 4
  
  =item 1
  
  The session's constructor is called.
  
  =item 2
  
  The session is put into play.  That is, POE::Kernel
  enters the session into its bookkeeping.
  
  =item 3
  
  The new session receives _start.
  
  =item 4
  
  The parent session receives _child ('create'), the new
  session reference, and the new session's _start's return value.
  
  =item 5
  
  The session's constructor returns.
  
  =back
  
  =head4 When an old session stops:
  
  =over 4
  
  =item 1
  
  If the session has children of its
  own, they are given to the session's parent.  This triggers one or
  more _child ('gain') events in the parent, and a _parent in each
  child.
  
  =item 2
  
  Once divested of its children, the stopping session
  receives a _stop event.
  
  =item 3
  
  The stopped session's parent receives a
  _child ('lose') event with the departing child's reference and _stop
  handler's return value.
  
  =item 4
  
  The stopped session is removed from play,
  as are all its remaining resources.
  
  =item 5
  
  The parent session is checked
  for idleness.  If so, garbage collection will commence on it, and it
  too will be stopped
  
  =back
  
  =head4 When a session is detached from its parent:
  
  =over 4
  
  =item 1
  
  The parent session of
  the session being detached is notified with a _child ('lose') event.
  The _stop handler's return value is undef since the child is not
  actually stopping.
  
  =item 2
  
  The detached session is notified with a _parent event that its new parent is
  POE::Kernel itself.
  
  =item 3
  
  POE::Kernel's bookkeeping data is adjusted to reflect the change of
  parentage.
  
  =item 4
  
  The old parent session is checked for idleness.  If so, garbage collection
  will commence on it, and it too will be stopped
  
  =back
  
  =head3 Session Management Methods
  
  These methods allow sessions to be detached from their parents in the
  rare cases where the parent/child relationship gets in the way.
  
  =head4 detach_child CHILD_SESSION
  
  detach_child() detaches a particular CHILD_SESSION from the current
  session.  On success, the CHILD_SESSION will become a child of the
  POE::Kernel instance, and detach_child() will return true.  On failure
  however, detach_child() returns false and sets $! to explain the
  nature of the failure:
  
  =over 4
  
  =item ESRCH ("No such process").
  
  The CHILD_SESSION is not a valid session.
  
  =item EPERM ("Operation not permitted").
  
  The CHILD_SESSION exists, but it is not a child of the current session.
  
  =back
  
  detach_child() will generate L</_parent> and/or L</_child> events to the
  appropriate sessions.  See L<Session Management Events|/Session Management> for a detailed
  explanation of these events.  See
  L<above|/"When a session is detached from its parent:">
  for the order the events are generated.
  
  =head4 detach_myself
  
  detach_myself() detaches the current session from its current parent.
  The new parent will be the running POE::Kernel instance.  It returns
  true on success.  On failure it returns false and sets C<$!> to
  explain the nature of the failure:
  
  =over 4
  
  =item EPERM ("Operation not permitted").
  
  The current session is already a
  child of POE::Kernel, so it may not be detached.
  
  =back
  
  detach_child() will generate L</_parent> and/or L</_child> events to the
  appropriate sessions.  See L<Session Management Events|/Session Management> for a detailed
  explanation of these events.  See
  L<above|/"When a session is detached from its parent:">
  for the order the events are generated.
  
  =head2 Signals
  
  POE::Kernel provides methods through which a program can register
  interest in signals that come along, can deliver its own signals
  without resorting to system calls, and can indicate that signals have
  been handled so that default behaviors are not necessary.
  
  Signals are I<action at a distance> by nature, and their implementation
  requires widespread synchronization between sessions (and reentrancy
  in the dispatcher, but that's an implementation detail).  Perfecting
  the semantics has proven difficult, but POE tries to do the Right
  Thing whenever possible.
  
  POE does not register %SIG handlers for signals until sig() is called
  to watch for them.  Therefore a signal's default behavior occurs for
  unhandled signals.  That is, SIGINT will gracelessly stop a program,
  SIGWINCH will do nothing, SIGTSTP will pause a program, and so on.
  
  =head3 Signal Classes
  
  There are three signal classes.  Each class defines a default behavior
  for the signal and whether the default can be overridden.  They are:
  
  =head4 Benign, advisory, or informative signals
  
  These are three names for the same signal class.  Signals in this class
  notify a session of an event but do not terminate the session if they are
  not handled.
  
  It is possible for an application to create its own benign signals.  See
  L</signal> below.
  
  =head4 Terminal signals
  
  Terminal signals will kill sessions if they are not handled by a
  L</sig_handled>() call.  The OS signals that usually kill or dump a process
  are considered terminal in POE, but they never trigger a coredump.  These
  are: HUP, INT, QUIT and TERM.
  
  There are two terminal signals created by and used within POE:
  
  =over
  
  =item DIE
  
  C<DIE> notifies sessions that a Perl exception has occurred.  See
  L</"Exception Handling"> for details.
  
  =item IDLE
  
  The C<IDLE> signal is used to notify leftover sessions that a
  program has run out of things to do.
  
  =back
  
  =head4 Nonmaskable signals
  
  Nonmaskable signals are terminal regardless whether sig_handled() is
  called.  The term comes from "NMI", the non-maskable CPU interrupt
  usually generated by an unrecoverable hardware exception.
  
  Sessions that receive a non-maskable signal will unavoidably stop.  POE
  implements two non-maskable signals:
  
  =over
  
  =item ZOMBIE
  
  This non-maskable signal is fired if a program has received an C<IDLE> signal
  but neither restarted nor exited.  The program has become a zombie (that is,
  it's neither dead nor alive, and only exists to consume braaaains ...er...
  memory).  The C<ZOMBIE> signal acts like a cricket bat to the head,
  bringing the zombie down, for good.
  
  =item UIDESTROY
  
  This non-maskable signal indicates that a program's user
  interface has been closed, and the program should take the user's hint
  and buzz off as well.  It's usually generated when a particular GUI
  widget is closed.
  
  =back
  
  =head3 Common Signal Dispatching
  
  Most signals are not dispatched to a single session.  POE's session
  lineage (parents and children) form a sort of family tree.  When a
  signal is sent to a session, it first passes through any children (and
  grandchildren, and so on) that are also interested in the signal.
  
  In the case of terminal signals, if any of the sessions a signal passes
  through calls L</sig_handled>(), then the signal is considered taken care
  of.  However if none of them do, then the entire session tree rooted at the
  destination session is terminated.  For example, consider this tree of
  sessions:
  
    POE::Kernel
      Session 2
        Session 4
        Session 5
      Session 3
        Session 6
        Session 7
  
  POE::Kernel is the parent of sessions 2 and 3.  Session 2 is the
  parent of sessions 4 and 5.  And session 3 is the parent of 6 and 7.
  
  A signal sent to Session 2 may also be dispatched to session 4 and 5
  because they are 2's children.  Sessions 4 and 5 will only receive the
  signal if they have registered the appropriate watcher.  If the signal is
  terminal, and none of the signal watchers in sessions 2, 4 and 5 called
  C<sig_handled()>, all 3 sessions will be terminated.
  
  The program's POE::Kernel instance is considered to be a session for
  the purpose of signal dispatch.  So any signal sent to POE::Kernel
  will propagate through every interested session in the entire program.
  This is in fact how OS signals are handled: A global signal handler is
  registered to forward the signal to POE::Kernel.
  
  =head3 Signal Semantics
  
  All signals come with the signal name in ARG0.  The signal name is as
  it appears in %SIG, with one exception: Child process signals are
  always "CHLD" even if the current operating system recognizes them as
  "CLD".
  
  Certain signals have special semantics:
  
  =head4 SIGCHLD
  
  =head4 SIGCLD
  
  Both C<SIGCHLD> and C<SIGCLD> indicate that a child process has exited
  or been terminated by some signal.  The actual signal name varies
  between operating systems, but POE uses C<CHLD> regardless.
  
  Interest in C<SIGCHLD> is registered using the L</sig_child> method.
  The L</sig>() method also works, but it's not as nice.
  
  The C<SIGCHLD> event includes three parameters:
  
  =over
  
  =item ARG0
  
  C<ARG0> contains the string 'CHLD' (even if the OS calls it SIGCLD,
  SIGMONKEY, or something else).
  
  =item ARG1
  
  C<ARG1> contains the process ID of the finished child process.
  
  =item ARG2
  
  And C<ARG2> holds the value of C<$?> for the finished process.
  
  =back
  
  Example:
  
    sub sig_CHLD {
      my( $name, $PID, $exit_val ) = @_[ ARG0, ARG1, ARG2 ];
      # ...
    }
  
  =head4 SIGPIPE
  
  SIGPIPE is rarely used since POE provides events that do the same
  thing.  Nevertheless SIGPIPE is supported if you need it.  Unlike most
  events, however, SIGPIPE is dispatched directly to the active session
  when it's caught.  Barring race conditions, the active session should
  be the one that caused the OS to send the signal in the first place.
  
  The SIGPIPE signal will still propagate to child sessions.
  
  ARG0 is "PIPE".  There is no other information associated with this
  signal.
  
  =head4 SIGWINCH
  
  Window resizes can generate a large number of signals very quickly.
  This may not be a problem when using perl 5.8.0 or later, but earlier
  versions may not take kindly to such abuse.  You have been warned.
  
  ARG0 is "WINCH".  There is no other information associated with this
  signal.
  
  =head3 Exception Handling
  
  POE::Kernel provides only one form of exception handling: the
  C<DIE> signal.
  
  When exception handling is enabled (the default), POE::Kernel wraps state
  invocation in C<eval{}>.  If the event handler raises an exception, generally
  with C<die>, POE::Kernel will dispatch a C<DIE> signal to the event's
  destination session.
  
  C<ARG0> is the signal name, C<DIE>.
  
  C<ARG1> is a hashref describing the exception:
  
  =over
  
  =item error_str
  
  The text of the exception.  In other words, C<$@>.
  
  =item dest_session
  
  Session object of the state that the raised the exception.  In other words,
  C<$_[SESSION]> in the function that died.
  
  =item event
  
  Name of the event that died.
  
  =item source_session
  
  Session object that sent the original event.
  That is, C<$_[SENDER]> in the function that died.
  
  =item from_state
  
  State from which the original event was sent.
  That is, C<$_[CALLER_STATE]> in the function that died.
  
  =item file
  
  Name of the file the event was sent from.
  That is, C<$_[CALLER_FILE]> in the function that died.
  
  =item line
  
  Line number the event was sent from.
  That is, C<$_[CALLER_LINE]> in the function that died.
  
  =back
  
  I<Note that the preceding discussion assumes you are using
  L<POE::Session|POE::Session>'s call semantics.>
  
  Note that the C<DIE> signal is sent to the session that raised the
  exception, not the session that sent the event that caused the exception to
  be raised.
  
    sub _start {
      $poe_kernel->sig( DIE => 'sig_DIE' );
      $poe_kernel->yield( 'some_event' );
    }
  
    sub some_event {
      die "I didn't like that!";
    }
  
    sub sig_DIE {
      my( $sig, $ex ) = @_[ ARG0, ARG1 ];
      # $sig is 'DIE'
      # $ex is the exception hash
      warn "$$: error in $ex->{event}: $ex->{error_str}";
      $poe_kernel->sig_handled();
  
      # Send the signal to session that sent the original event.
      if( $ex->{source_session} ne $_[SESSION] ) {
        $poe_kernel->signal( $ex->{source_session}, 'DIE', $sig, $ex );
      }
    }
  
  POE::Kernel's built-in exception handling can be disabled by setting
  the C<POE::Kernel::CATCH_EXCEPTIONS> constant to zero.  As with other
  compile-time configuration constants, it must be set before
  POE::Kernel is compiled:
  
    BEGIN {
      package POE::Kernel;
      use constant CATCH_EXCEPTIONS => 0;
    }
    use POE;
  
  or
  
    sub POE::Kernel::CATCH_EXCEPTIONS () { 0 }
    use POE;
  
  =head2 Signal Watcher Methods
  
  And finally the methods themselves.
  
  =head3 sig SIGNAL_NAME [, EVENT_NAME [, LIST] ]
  
  sig() registers or unregisters an EVENT_NAME event for a particular
  SIGNAL_NAME, with an optional LIST of parameters that will be passed
  to the signal's handler---after any data that comes wit the signal.
  
  If EVENT_NAME is defined, the signal handler is registered.  Otherwise
  it's unregistered.  
  
  Each session can register only one handler per SIGNAL_NAME.
  Subsequent registrations will replace previous ones.  Multiple
  sessions may however watch the same signal.
  
  SIGNAL_NAMEs are generally the same as members of C<%SIG>, with two
  exceptions.  First, C<CLD> is an alias for C<CHLD> (although see
  L</sig_child>).  And second, it's possible to send and handle signals
  created by the application and have no basis in the operating system.
  
    sub handle_start {
      $_[KERNEL]->sig( INT => "event_ui_shutdown" );
      $_[KERNEL]->sig( bat => "holy_searchlight_batman" );
      $_[KERNEL]->sig( signal => "main_screen_turn_on" );
    }
  
  The operating system may never be able to generate the last two
  signals, but a POE session can by using POE::Kernel's
  L</signal>() method.
  
  Later on the session may decide not to handle the signals:
  
    sub handle_ui_shutdown {
      $_[KERNEL]->sig( "INT" );
      $_[KERNEL]->sig( "bat" );
      $_[KERNEL]->sig( "signal" );
    }
  
  More than one session may register interest in the same signal, and a
  session may clear its own signal watchers without affecting those in
  other sessions.
  
  sig() does not return a meaningful value.
  
  =head3 sig_child PROCESS_ID [, EVENT_NAME [, LIST] ]
  
  sig_child() is a convenient way to deliver an EVENT_NAME event when a
  particular PROCESS_ID has exited.  An optional LIST of parameters will
  be passed to the signal handler after the waitpid() information.
  
  The watcher can be cleared at any time by calling sig_child() with
  just the PROCESS_ID.
  
  A session may register as many sig_child() handlers as necessary, but
  a session may only have one per PROCESS_ID.
  
  sig_child() watchers are one-shot.  They automatically unregister
  themselves once the EVENT_NAME has been delivered.  There's no point
  in continuing to watch for a signal that will never come again.  Other
  signal handlers persist until they are cleared.
  
  sig_child() watchers keep a session alive for as long as they are
  active.  This is unique among POE's signal watchers.
  
  Programs that wish to reliably reap child processes should be sure to
  call sig_child() before returning from the event handler that forked
  the process.  Otherwise POE::Kernel may have an opportunity to call
  waitpid() before an appropriate event watcher has been registered.
  
  Programs that reap processes with waitpid() must clear POE's watchers
  for the same process IDs, otherwise POE will wait indefinitely for
  processes that never send signals.
  
  sig_child() does not return a meaningful value.
  
    sub forked_parent {
      my( $heap, $pid, $details ) = @_[ HEAP, ARG0, ARG1 ];
      $poe_kernel->sig_child( $pid, 'sig_child', $details );
    }
  
    sub sig_child {
      my( $heap, $sig, $pid, $exit_val, $details ) = @_[ HEAP, ARG0..ARG3 ];
      my $details = delete $heap->{ $pid };
      warn "$$: Child $pid exited"
      # .... also, $details has been passed from forked_parent()
      # through sig_child()
    }
  
  =head3 sig_handled
  
  sig_handled() informs POE::Kernel that the currently dispatched signal has
  been handled by the currently active session. If the signal is terminal, the
  sig_handled() call prevents POE::Kernel from stopping the sessions that
  received the signal.
  
  A single signal may be dispatched to several sessions.  Only one needs
  to call sig_handled() to prevent the entire group from being stopped.
  If none of them call it, however, then they are all stopped together.
  
  sig_handled() does not return a meaningful value.
  
    sub _start {
      $_[KERNEL]->sig( INT => 'sig_INT' );
    }
  
    sub sig_INT {
      warn "$$ SIGINT";
      $_[KERNEL]->sig_handled();
    }
  
  =head3 signal SESSION, SIGNAL_NAME [, ARGS_LIST]
  
  signal() posts a SIGNAL_NAME signal to a specific SESSION with an
  optional ARGS_LIST that will be passed to every interested handler.  As
  mentioned elsewhere, the signal may be delivered to SESSION's
  children, grandchildren, and so on.  And if SESSION is the POE::Kernel
  itself, then all interested sessions will receive the signal.
  
  It is possible to send a signal in POE that doesn't exist in the
  operating system.  signal() places the signal directly into POE's
  event queue as if they came from the operating system, but they are
  not limited to signals recognized by kill().  POE uses a few of these
  fictitious signals for its own global notifications.
  
  For example:
  
    sub some_event_handler {
      # Turn on all main screens.
      $_[KERNEL]->signal( $_[KERNEL], "signal" );
    }
  
  signal() returns true on success.  On failure, it returns false after
  setting $! to explain the nature of the failure:
  
  =over
  
  =item ESRCH ("No such process")
  
  The SESSION does not exist.
  
  =back
  
  Because all sessions are a child of POE::Kernel, sending a signal to
  the kernel will propagate the signal to all sessions.  This is a cheap
  form of I<multicast>.
  
    $_[KERNEL]->signal( $_[KERNEL], 'shutdown' );
  
  =head3 signal_ui_destroy WIDGET_OBJECT
  
  signal_ui_destroy() associates the destruction of a particular
  WIDGET_OBJECT with the complete destruction of the program's user
  interface.  When the WIDGET_OBJECT destructs, POE::Kernel issues the
  non-maskable UIDESTROY signal, which quickly triggers mass destruction
  of all active sessions.  POE::Kernel->run() returns shortly
  thereafter.
  
    sub setup_ui {
      $_[HEAP]{main_widget} = Gtk->new("toplevel");
      # ... populate the main widget here ...
      $_[KERNEL]->signal_ui_destroy( $_[HEAP]{main_widget} );
    }
  
  Detecting widget destruction is specific to each toolkit.
  
  =head2 Event Handler Management
  
  Event handler management methods let sessions hot swap their event
  handlers at run time. For example, the L<POE::Wheel|POE::Wheel>
  objects use state() to dynamically mix their own event handlers into
  the sessions that create them.
  
  These methods only affect the current session; it would be rude to
  change another session's handlers.
  
  There is only one method in this group.  Since it may be called in
  several different ways, it may be easier to understand if each is
  documented separately.
  
  =head3 state EVENT_NAME [, CODE_REFERNCE]
  
  state() sets or removes a handler for EVENT_NAME in the current
  session.  The function referred to by CODE_REFERENCE will be called
  whenever EVENT_NAME events are dispatched to the current session.  If
  CODE_REFERENCE is omitted, the handler for EVENT_NAME will be removed.
  
  A session may only have one handler for a given EVENT_NAME.
  Subsequent attempts to set an EVENT_NAME handler will replace earlier
  handlers with the same name.
  
    # Stop paying attention to input.  Say goodbye, and
    # trigger a socket close when the message is sent.
    sub send_final_response {
      $_[HEAP]{wheel}->put("KTHXBYE");
      $_[KERNEL]->state( 'on_client_input' );
      $_[KERNEL]->state( on_flush => \&close_connection );
    }
  
  =head3 state EVENT_NAME [, OBJECT_REFERENCE [, OBJECT_METHOD_NAME] ]
  
  Set or remove a handler for EVENT_NAME in the current session.  If an
  OBJECT_REFERENCE is given, that object will handle the event.  An
  optional OBJECT_METHOD_NAME may be provided.  If the method name is
  not given, POE will look for a method matching the EVENT_NAME instead.
  If the OBJECT_REFERENCE is omitted, the handler for EVENT_NAME will be
  removed.
  
  A session may only have one handler for a given EVENT_NAME.
  Subsequent attempts to set an EVENT_NAME handler will replace earlier
  handlers with the same name.
  
    $_[KERNEL]->state( 'some_event', $self );
    $_[KERNEL]->state( 'other_event', $self, 'other_method' );
  
  =head3 state EVENT_NAME [, CLASS_NAME [, CLASS_METHOD_NAME] ]
  
  This form of state() call is virtually identical to that of the object
  form.
  
  Set or remove a handler for EVENT_NAME in the current session.  If an
  CLASS_NAME is given, that class will handle the event.  An optional
  CLASS_METHOD_NAME may be provided.  If the method name is not given,
  POE will look for a method matching the EVENT_NAME instead.  If the
  CLASS_NAME is omitted, the handler for EVENT_NAME will be removed.
  
  A session may only have one handler for a given EVENT_NAME.
  Subsequent attempts to set an EVENT_NAME handler will replace earlier
  handlers with the same name.
  
    $_[KERNEL]->state( 'some_event', __PACKAGE__ );
    $_[KERNEL]->state( 'other_event', __PACKAGE__, 'other_method' );
  
  =head2 Public Reference Counters
  
  The methods in this section manipulate reference counters on the
  current session or another session.
  
  Each session has a namespace for user-manipulated reference counters.
  These namespaces are associated with the target SESSION_ID for the
  reference counter methods, not the caller.  Nothing currently prevents
  one session from decrementing a reference counter that was incremented
  by another, but this behavior is not guaranteed to remain.  For now,
  it's up to the users of these methods to choose obscure counter names
  to avoid conflicts.
  
  Reference counting is a big part of POE's magic.  Various objects
  (mainly event watchers and components) hold references to the sessions
  that own them.  L</Session Lifespans> explains the concept in more
  detail.
  
  The ability to keep a session alive is sometimes useful in an application or
  library.  For example, a component may hold a public reference to another
  session while it processes a request from that session.  In doing so, the
  component guarantees that the requester is still around when a response is
  eventually ready.  Keeping a reference to the session's object is not
  enough.  POE::Kernel has its own internal reference counting mechanism.
  
  =head3 refcount_increment SESSION_ID, COUNTER_NAME
  
  refcount_increment() increases the value of the COUNTER_NAME reference
  counter for the session identified by a SESSION_ID.  To discourage the
  use of session references, the refcount_increment() target session
  must be specified by its session ID.
  
  The target session will not stop until the value of any and all of its
  COUNTER_NAME reference counters are zero.  (Actually, it may stop in
  some cases, such as failing to handle a terminal signal.)
  
  Negative reference counters are legal.  They still must be incremented
  back to zero before a session is eligible for stopping.
  
    sub handle_request {
      # Among other things, hold a reference count on the sender.
      $_[KERNEL]->refcount_increment( $_[SENDER]->ID, "pending request");
      $_[HEAP]{requesters}{$request_id} = $_[SENDER]->ID;
    }
  
  For this to work, the session needs a way to remember the
  $_[SENDER]->ID for a given request.  Customarily the session generates
  a request ID and uses that to track the request until it is fulfilled.
  
  refcount_increment() returns the resulting reference count (which may
  be zero) on success.  On failure, it returns undef and sets $! to be
  the reason for the error.
  
  ESRCH: The SESSION_ID does not refer to a currently active session.
  
  =head3 refcount_decrement SESSION_ID, COUNTER_NAME
  
  refcount_decrement() reduces the value of the COUNTER_NAME reference
  counter for the session identified by a SESSION_ID.  It is the
  counterpoint for refcount_increment().  Please see
  refcount_increment() for more context.
  
    sub finally_send_response {
      # Among other things, release the reference count for the
      # requester.
      my $requester_id = delete $_[HEAP]{requesters}{$request_id};
      $_[KERNEL]->refcount_decrement( $requester_id, "pending request");
    }
  
  The requester's $_[SENDER]->ID is remembered and removed from the heap
  (lest there be memory leaks).  It's used to decrement the reference
  counter that was incremented at the start of the request.
  
  refcount_decrement() returns the resulting reference count (which may
  be zero) on success.  On failure, it returns undef, and $! will be set
  to the reason for the failure:
  
  ESRCH: The SESSION_ID does not refer to a currently active session.
  
  It is not possible to discover currently active public references.  See
  L<POE::API::Peek>.
  
  =head2 Kernel State Accessors
  
  POE::Kernel provides a few accessors into its massive brain so that
  library developers may have convenient access to necessary data
  without relying on their callers to provide it.
  
  These accessors expose ways to break session encapsulation.  Please
  use them sparingly and carefully.
  
  =head3 get_active_session
  
  get_active_session() returns a reference to the session that is
  currently running, or a reference to the program's POE::Kernel
  instance if no session is running at that moment.  The value is
  equivalent to L<POE::Session|POE::Session>'s C<$_[SESSION]>.
  
  This method was added for libraries that need C<$_[SESSION]> but don't
  want to include it as a parameter in their APIs.
  
    sub some_housekeeping {
      my( $self ) = @_;
      my $session = $poe_kernel->get_active_session;
      # do some housekeeping on $session
    }
  
  =head3 get_active_event
  
  get_active_event() returns the name of the event currently being
  dispatched.  It returns an empty string when called outside event
  dispatch.  The value is equivalent to L<POE::Session|POE::Session>'s
  C<$_[STATE]>.
  
    sub waypoint {
      my( $message ) = @_;
      my $event = $poe_kernel->get_active_event;
      print STDERR "$$:$event:$mesage\n";
    }
  
  =head3 get_event_count
  
  get_event_count() returns the number of events pending in POE's event
  queue.  It is exposed for L<POE::Loop|POE::Loop> class authors.  It
  may be deprecated in the future.
  
  =head3 get_next_event_time
  
  get_next_event_time() returns the time the next event is due, in a
  form compatible with the UNIX time() function.  It is exposed for
  L<POE::Loop|POE::Loop> class authors.  It may be deprecated in the future.
  
  =head3 poe_kernel_loop
  
  poe_kernel_loop() returns the name of the POE::Loop class that is used
  to detect and dispatch events.
  
  =head2 Session Helper Methods
  
  The methods in this group expose features for L<POE::Session|POE::Session>
  class authors.
  
  =head3 session_alloc SESSION_OBJECT [, START_ARGS]
  
  session_alloc() allocates a session context within POE::Kernel for a
  newly created SESSION_OBJECT.  A list of optional START_ARGS will be
  passed to the session as part of the L</_start> event.
  
  The SESSION_OBJECT is expected to follow a subset of POE::Session's
  interface.
  
  There is no session_free().  POE::Kernel determines when the session
  should stop and performs the necessary cleanup after dispatching _stop
  to the session.
  
  =head2 Miscellaneous Methods
  
  We don't know where to classify the methods in this section.
  
  =head3 new
  
  It is not necessary to call POE::Kernel's new() method.  Doing so will
  return the program's singleton POE::Kernel object, however.
  
  =head1 PUBLIC EXPORTED VARIABLES
  
  POE::Kernel exports two variables for your coding enjoyment:
  C<$poe_kernel> and C<$poe_main_window>.  POE::Kernel is implicitly
  used by POE itself, so using POE gets you POE::Kernel (and its
  exports) for free.
  
  In more detail:
  
  =head2 $poe_kernel
  
  C<$poe_kernel> contains a reference to the process' POE::Kernel singleton
  instance. It's mainly used for accessing POE::Kernel methods from places
  where C<$_[KERNEL]> is not available.  It's most commonly used in helper
  libraries.
  
  =head2 $poe_main_window
  
  $poe_main_window is used by graphical toolkits that require at least
  one widget to be created before their event loops are usable.  This is
  currently only Tk.
  
  L<POE::Loop::Tk|POE::Loop::Tk> creates a main window to satisfy Tk's
  event loop.  The window is given to the application since POE has no
  other use for it.
  
  C<$poe_main_window> is undefined in toolkits that don't require a
  widget to dispatch events.
  
  On a related note, POE will shut down if the widget in
  C<$poe_main_window> is destroyed.  This can be changed with
  POE::Kernel's L</signal_ui_destroy> method.
  
  =head1 DEBUGGING POE AND PROGRAMS USING IT
  
  POE includes quite a lot of debugging code, in the form of both fatal
  assertions and run-time traces.  They may be enabled at compile time,
  but there is no way to toggle them at run-time.  This was done to
  avoid run-time penalties in programs where debugging is not necessary.
  That is, in most production cases.
  
  Traces are verbose reminders of what's going on within POE.  Each is
  prefixed with a four-character field describing the POE subsystem that
  generated it.
  
  Assertions (asserts) are quiet but deadly, both in performance (they
  cause a significant run-time performance hit) and because they cause
  fatal errors when triggered.
  
  The assertions and traces are useful for developing programs with POE,
  but they were originally added to debug POE itself.
  
  Each assertion and tracing group is enabled by setting a constant in
  the POE::Kernel namespace to a true value.
  
    BEGIN {
      package POE::Kernel;
      use constant ASSERT_DEFAULT => 1;
    }
    use POE;
  
  Or the old-fashioned (and more concise) "constant subroutine" method.
  This doesn't need the C<BEGIN{}> block since subroutine definitions are
  done at compile time.
  
    sub POE::Kernel::ASSERT_DEFAULT () { 1 }
    use POE;
  
  The switches must be defined as constants before POE::Kernel is first
  loaded.  Otherwise Perl's compiler will not see the constants when first
  compiling POE::Kernel, and the features will not be properly enabled.
  
  Assertions and traces may also be enabled by setting shell environment
  variables.  The environment variables are named after the POE::Kernel
  constants with a "POE_" prefix.
  
    POE_ASSERT_DEFAULT=1 POE_TRACE_DEFAULT=1 ./my_poe_program
  
  In alphabetical order:
  
  =head2 ASSERT_DATA
  
  ASSERT_DATA enables run-time data integrity checks within POE::Kernel
  and the classes that mix into it.  POE::Kernel tracks a lot of
  cross-referenced data, and this group of assertions ensures that it's
  consistent.
  
  Prefix: <dt>
  
  Environment variable: POE_ASSERT_DATA
  
  =head2 ASSERT_DEFAULT
  
  ASSERT_DEFAULT specifies the default value for assertions that are not
  explicitly enabled or disabled.  This is a quick and reliable way to
  make sure all assertions are on.
  
  No assertion uses ASSERT_DEFAULT directly, and this assertion flag has
  no corresponding output prefix.
  
  Turn on all assertions except ASSERT_EVENTS:
  
    sub POE::Kernel::ASSERT_DEFAULT () { 1 }
    sub POE::Kernel::ASSERT_EVENTS  () { 0 }
    use POE::Kernel;
  
  Prefix: (none)
  
  Environment variable: POE_ASSERT_DEFAULT
  
  =head2 ASSERT_EVENTS
  
  ASSERT_EVENTS mainly checks for attempts to dispatch events to
  sessions that don't exist.  This assertion can assist in the debugging
  of strange, silent cases where event handlers are not called.
  
  Prefix: <ev>
  
  Environment variable: POE_ASSERT_EVENTS
  
  =head2 ASSERT_FILES
  
  ASSERT_FILES enables some run-time checks in POE's filehandle watchers
  and the code that manages them.
  
  Prefix: <fh>
  
  Environment variable: POE_ASSERT_FILES
  
  =head2 ASSERT_RETVALS
  
  ASSERT_RETVALS upgrades failure codes from POE::Kernel's methods from
  advisory return values to fatal errors.  Most programmers don't check
  the values these methods return, so ASSERT_RETVALS is a quick way to
  validate one's assumption that all is correct.
  
  Prefix: <rv>
  
  Environment variable: POE_ASSERT_RETVALS
  
  =head2 ASSERT_USAGE
  
  ASSERT_USAGE is the counterpoint to ASSERT_RETVALS.  It enables
  run-time checks that the parameters to POE::Kernel's methods are
  correct.  It's a quick (but not foolproof) way to verify a program's
  use of POE.
  
  Prefix: <us>
  
  Environment variable: POE_ASSERT_USAGE
  
  =head2 TRACE_DEFAULT
  
  TRACE_DEFAULT specifies the default value for traces that are not
  explicitly enabled or disabled.  This is a quick and reliable way to
  ensure your program generates copious output on the file named in
  TRACE_FILENAME or STDERR by default.
  
  To enable all traces except a few noisier ones:
  
    sub POE::Kernel::TRACE_DEFAULT () { 1 }
    sub POE::Kernel::TRACE_EVENTS  () { 0 }
    use POE::Kernel;
  
  Prefix: (none)
  
  Environment variable: POE_TRACE_DEFAULT
  
  =head2 TRACE_DESTROY
  
  TRACE_DESTROY causes every POE::Session object to dump the contents of
  its C<$_[HEAP]> when Perl destroys it.  This trace was added to help
  developers find memory leaks in their programs.
  
  Prefix: A line that reads "----- Session $self Leak Check -----".
  
  Environment variable: POE_TRACE_DESTROY
  
  =head2 TRACE_EVENTS
  
  TRACE_EVENTS enables messages pertaining to POE's event queue's
  activities: when events are enqueued, dispatched or discarded, and
  more.  It's great for determining where events go and when.
  Understandably this is one of POE's more verbose traces.
  
  Prefix: <ev>
  
  Environment variable: POE_TRACE_EVENTS
  
  =head2 TRACE_FILENAME
  
  TRACE_FILENAME specifies the name of a file where POE's tracing and
  assertion messages should go.  It's useful if you want the messages
  but have other plans for STDERR, which is where the messages go by
  default.
  
  POE's tests use this so the trace and assertion code can be
  instrumented during testing without spewing all over the terminal.
  
  Prefix: (none)
  
  Environment variable: POE_TRACE_FILENAME
  
  =head2 TRACE_FILES
  
  TRACE_FILES enables or disables traces in POE's filehandle watchers and
  the L<POE::Loop|POE::Loop> class that implements the lowest-level filehandle
  multiplexing.  This may be useful when tracking down strange behavior
  related to filehandles.
  
  Prefix: <fh>
  
  Environment variable: POE_TRACE_FILES
  
  =head2 TRACE_REFCNT
  
  TRACE_REFCNT governs whether POE::Kernel will trace sessions'
  reference counts.  As discussed in L</"Session Lifespans">, POE does a
  lot of reference counting, and the current state of a session's
  reference counts determines whether the session lives or dies.  It's
  common for developers to wonder why a session stops too early or
  remains active too long.  TRACE_REFCNT can help explain why.
  
  Prefix: <rc>
  
  Environment variable: POE_TRACE_REFCNT
  
  =head2 TRACE_RETVALS
  
  TRACE_RETVALS can enable carping whenever a POE::Kernel method is
  about to fail.  It's a non-fatal but noisier form of
  ASSERT_RETVALS.
  
  Prefix: <rv>
  
  Environment variable: POE_TRACE_RETVALS
  
  =head2 TRACE_SESSIONS
  
  TRACE_SESSIONS enables trace messages that pertain to session
  management.  Notice will be given when sessions are created or
  destroyed, and when the parent or child status of a session changes.
  
  Prefix: <ss>
  
  Environment variable: POE_TRACE_SESSIONS
  
  =head2 TRACE_SIGNALS
  
  TRACE_SIGNALS turns on (or off) traces in POE's signal handling
  subsystem.  Signal dispatch is one of POE's more complex parts, and
  the trace messages may help application developers understand signal
  propagation and timing.
  
  Prefix: <sg>
  
  Environment variable: POE_TRACE_SIGNALS
  
  =head2 USE_SIGCHLD
  
  Whether to use C<$SIG{CHLD}> or to poll at an interval.
  
  This flag is enabled by default on Perl >= 5.8.1 as it has support
  for "safe signals". Please see L<perlipc> for the gory details.
  
  You might want to disable this if you are running a version of Perl that
  is known to have bad signal handling, or if anything hijacks C<$SIG{CHLD}>.
  One module that is known to do this is L<Apache>.
  
  Enabling this flag will cause child reaping to happen almost
  immediately, as opposed to once per L</CHILD_POLLING_INTERVAL>.
  
  =head2 CHILD_POLLING_INTERVAL
  
  The interval at which C<wait> is called to determine if child
  processes need to be reaped and the C<CHLD> signal emulated.
  
  Defaults to 1 second.
  
  =head2 USE_SIGNAL_PIPE
  
  The only safe way to handle signals is to implement a shared-nothing
  model.  POE builds a I<signal pipe> that communicates between the
  signal handlers and the POE kernel loop in a safe and atomic manner.
  The signal pipe is implemented with L<POE::Pipe::OneWay>, using a
  C<pipe> conduit on Unix.  Unfortunately, the signal pipe is not compatible
  with Windows and is not used on that platform.
  
  If you wish to revert to the previous unsafe signal behaviour, you
  must set C<USE_SIGNAL_PIPE> to 0, or the environment variable
  C<POE_USE_SIGNAL_PIPE>.
  
  =head2 CATCH_EXCEPTIONS
  
  Whether or not POE should run event handler code in an eval { } and
  deliver the C<DIE> signal on errors.
  
  See L</"Exception Handling">.
  
  =head1 ENVIRONMENT VARIABLES FOR TESTING
  
  POE's tests are lovely, dark and deep.  These environment variables
  allow testers to take roads less traveled.
  
  =head2 POE_DANTIC
  
  Windows and Perls built for it tend to be poor at doing UNIXy things,
  although they do try.  POE being very UNIXy itself must skip a lot of
  Windows tests.  The POE_DANTIC environment variable will, when true,
  enable all these tests.  It's intended to be used from time to time to
  see whether Windows has improved in some area.
  
  =head1 SEE ALSO
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 BUGS
  
  =over
  
  =item *
  
  There is no mechanism in place to prevent external reference count
  names from clashing.
  
  =item *
  
  There is no mechanism to catch exceptions generated in another session.
  
  =back
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - More practical examples.
  # TODO - Test the examples.
  # TODO - Edit.
POE_KERNEL

$fatpacked{"POE/Loop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_LOOP';
  package POE::Loop;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Loop - documentation for POE's event loop bridge interface
  
  =head1 SYNOPSIS
  
    $kernel->loop_initialize();
    $kernel->loop_finalize();
    $kernel->loop_do_timeslice();
    $kernel->loop_run();
    $kernel->loop_halt();
  
    $kernel->loop_watch_signal($signal_name);
    $kernel->loop_ignore_signal($signal_name);
    $kernel->loop_attach_uidestroy($gui_window);
  
    $kernel->loop_resume_time_watcher($next_time);
    $kernel->loop_reset_time_watcher($next_time);
    $kernel->loop_pause_time_watcher();
  
    $kernel->loop_watch_filehandle($handle, $mode);
    $kernel->loop_ignore_filehandle($handle, $mode);
    $kernel->loop_pause_filehandle($handle, $mode);
    $kernel->loop_resume_filehandle($handle, $mode);
  
  =head1 DESCRIPTION
  
  POE::Loop is a virtual base class that defines a standard event loop
  interface.  POE::Loop subclasses mix into POE::Kernel and implement
  the features needed to manage underlying event loops in a consistent
  fashion.  This documentation covers the interface, which is shared by
  all subclasses.
  
  As POE::Kernel loads, it searches through %INC for event loop modules.
  POE::Kernel loads the most appropriate POE::Loop subclass for the
  event loop it finds.  The subclass slots its methods into POE::Kernel,
  completing the class at load time.  POE and POE::Kernel provide ways
  to state the desired event loop in case the auto-detection makes a
  mistake or the developer prefers to be explicit.  See
  L<POE::Kernel/"Using POE with Other Event Loops"> for instructions on
  how to actually use POE with other event loops, event loop naming
  conventions, and other details.
  
  POE::Loop subclasses exist for many of the event loops Perl supports:
  select(), IO::Poll, WxWindows, EV, Glib, Event, and so on.  See CPAN
  for a full list.
  
  =head1 GENERAL NOTES
  
  As previously noted, POE::Loop subclasses provide additional methods
  to POE::Kernel and are not proper objects in themselves.
  
  Each POE::Loop subclass first defines its own namespace and version
  within it.  This way CPAN and other things can track its version.
  They then switch to the POE::Kernel package to define their additional
  methods.
  
  POE::Loop is designed as a mix-in class because Perl imposed a
  performance penalty for method inheritance at the time the class was
  designed.  This could be changed in the future, but it will require
  cascaded changes in several other classes.
  
  Here is a skeleton of a POE::Loop subclass:
  
    use strict;
  
    # YourToolkit bridge for POE::Kernel;
  
    package POE::Loop::YourToolkit;
  
    use vars qw($VERSION);
    $VERSION = '1.000'; # NOTE - Should be #.### (three decimal places)
  
    package POE::Kernel;
  
    # Define private lexical data here.
    # Implement the POE::Loop interface here.
  
    1;
  
    __END__
  
    =head1 NAME
  
    ... documentation goes here ...
  
    =cut
  
  =head1 PUBLIC INTERFACE
  
  POE::Loop's public interface is divided into four parts:
  administrative methods, signal handler methods, time management
  methods, and filehandle watcher methods.  Each group and its members
  will be described in detail shortly.
  
  POE::Loop subclasses use lexical variables to keep track of things.
  Exact implementation is left up to the subclass' author.
  POE::Loop::Select keeps its bit vectors for select() calls in
  class-scoped (static) lexical variables.  POE::Loop::Gtk tracks a
  single time watcher and multiple file watchers there.
  
  Bridges often employ private methods as callbacks from their event
  loops.  The Event, Gtk, and Tk bridges do this.  Private callback
  names should begin with "_loop_" to avoid colliding with other
  methods.
  
  Developers should look at existing bridges to get a feel for things.
  The C<-m> flag for perldoc will show a module in its entirety.
  
    perldoc -m POE::Loop::Select
    perldoc -m POE::Loop::Gtk
    ...
  
  =head2 Administrative Methods
  
  These methods initialize and finalize an event loop, run the loop to
  process events, and halt it.
  
  =head3 loop_initialize
  
  Initialize the event loop.  Graphical toolkits especially need some
  sort of init() call or sequence to set up.  For example, Tk requires a
  widget to be created before any events will be processed, and the
  program's user interface will be considered destroyed if that widget
  is closed.
  
    sub loop_initialize {
      my $self = shift;
  
      $poe_main_window = Tk::MainWindow->new();
      die "could not create a main Tk window" unless defined $poe_main_window;
      $self->signal_ui_destroy($poe_main_window);
    }
  
  POE::Loop::Select initializes its select() bit vectors.
  
    sub loop_initialize {
      @loop_vectors = ( '', '', '' );
      vec($loop_vectors[MODE_RD], 0, 1) = 0;
      vec($loop_vectors[MODE_WR], 0, 1) = 0;
      vec($loop_vectors[MODE_EX], 0, 1) = 0;
    }
  
  =head3 loop_finalize
  
  Finalize the event loop.  Most event loops do not require anything
  here since they have already stopped by the time loop_finalize() is
  called.  However, this is a good place to check that a bridge has not
  leaked memory or data.  This example comes from POE::Loop::Event.
  
    sub loop_finalize {
      my $self = shift;
  
      foreach my $fd (0..$#fileno_watcher) {
        next unless defined $fileno_watcher[$fd];
        foreach my $mode (MODE_RD, MODE_WR, MODE_EX) {
          POE::Kernel::_warn(
            "Mode $mode watcher for fileno $fd is defined during loop finalize"
          ) if defined $fileno_watcher[$fd]->[$mode];
        }
      }
  
      $self->loop_ignore_all_signals();
    }
  
  =head3 loop_do_timeslice
  
  Wait for time to pass or new events to occur, and dispatch any events
  that become due.  If the underlying event loop does this through
  callbacks, then loop_do_timeslice() will either provide minimal glue
  or do nothing.
  
  For example, loop_do_timeslice() for POE::Loop::Select sets up and
  calls select().  If any files or other resources become active, it
  enqueues events for them.  Finally, it triggers dispatch for any
  events are due.
  
  On the other hand, the Gtk event loop handles all this, so
  loop_do_timeslice() is empty for the Gtk bridge.
  
  A sample loop_do_timeslice() implementation is not presented here
  because it would either be quite large or empty.  See each
  POE::Loop::IO_Poll or Select for large ones.  Event and Gtk are empty.
  
  The bridges for Poll and Select for large ones.  The ones for Event
  and Gtk are empty, and Tk's (in POE::Loop::TkCommon) is rather small.
  
  =head3 loop_run
  
  Run an event loop until POE has no more sessions to handle events.
  This method tends to be quite small, and it is often implemented in
  terms of loop_do_timeslice().  For example, POE::Loop::IO_Poll
  implements it:
  
    sub loop_run {
      my $self = shift;
      while ($self->_data_ses_count()) {
        $self->loop_do_timeslice();
      }
    }
  
  This method is even more trivial when an event loop handles it.  This
  is from the Gtk bridge:
  
    sub loop_run {
      unless (defined $_watcher_timer) {
        $_watcher_timer = Gtk->idle_add(\&_loop_resume_timer);
      }
      Gtk->main;
    }
  
  =head3 loop_halt
  
  loop_halt() does what it says: It halts POE's underlying event loop.
  It tends to be either trivial for external event loops or empty for
  ones that are implemented in the bridge itself (IO_Poll, Select).
  
  For example, the loop_run() method in the Poll bridge exits when
  sessions have run out, so its loop_halt() method is empty:
  
    sub loop_halt {
      # does nothing
    }
  
  Gtk, however, needs to be stopped because it does not know when POE is
  done.
  
    sub loop_halt {
      Gtk->main_quit();
    }
  
  =head2 Signal Management Methods
  
  These methods enable and disable signal watchers.  They are used by
  POE::Resource::Signals to manage an event loop's signal watchers.
  
  Most event loops use Perl's %SIG to watch for signals.  This is so
  common that POE::Loop::PerlSignals implements the interface on behalf
  of other subclasses.
  
  =head3 loop_watch_signal SIGNAL_NAME
  
  Watch for a given SIGNAL_NAME.  SIGNAL_NAME is the version found in
  %SIG, which tends to be the operating signal's name with the leading
  "SIG" removed.
  
  POE::Loop::PerlSignals' implementation adds callbacks to %SIG except
  for CHLD/CLD, which begins a waitpid() polling loop instead.
  
  As of this writing, all of the POE::Loop subclasses register their
  signal handlers through POE::Loop::PerlSignals.
  
  There are three types of signal handlers:
  
  CHLD/CLD handlers, when managed by the bridges themselves, poll for
  exited children.  POE::Kernel does most of this, but
  loop_watch_signal() still needs to start the process.
  
  PIPE handlers.  The PIPE signal event must be sent to the session that
  is active when the signal occurred.
  
  Everything else.  Signal events for everything else are sent to
  POE::Kernel, where they are distributed to every session.
  
  The loop_watch_signal() methods tends to be very long, so an example
  is not presented here.  The Event and Select bridges have good
  examples, though.
  
  =head3 loop_ignore_signal SIGNAL_NAME
  
  Stop watching SIGNAL_NAME.  POE::Loop::PerlSignals does this by
  resetting the %SIG for the SIGNAL_NAME to a sane value.
  
  $SIG{CHLD} is left alone so as to avoid interfering with system() and
  other things.
  
  SIGPIPE is generally harmless since POE generates events for this
  condition.  Therefore $SIG{PIPE} is set to "IGNORE" when it's not
  being handled.
  
  All other signal handlers default to "DEFAULT" when not in use.
  
  =head3 loop_attach_uidestroy WIDGET
  
  POE, when used with a graphical toolkit, should shut down when the
  user interface is closed.  loop_attach_uidestroy() is used to shut
  down POE when a particular WIDGET is destroyed.
  
  The shutdown is done by firing a UIDESTROY signal when the WIDGET's
  closure or destruction callback is invoked.  UIDESTROY guarantees the
  program will shut down by virtue of being terminal and non-maskable.
  
  loop_attach_uidestroy() is only meaningful in POE::Loop subclasses
  that tie into user interfaces.  All other subclasses leave the method
  empty.
  
  Here's Gtk's:
  
    sub loop_attach_uidestroy {
      my ($self, $window) = @_;
      $window->signal_connect(
        delete_event => sub {
          if ($self->_data_ses_count()) {
            $self->_dispatch_event(
              $self, $self,
              EN_SIGNAL, ET_SIGNAL, [ 'UIDESTROY' ],
              __FILE__, __LINE__, undef, monotime(), -__LINE__
            );
          }
          return 0;
        }
      );
    }
  
  =head2 Alarm and Time Management Methods
  
  These methods enable and disable a time watcher or alarm in the
  underlying event loop.  POE only requires one, which is reused or
  re-created as necessary.
  
  Most event loops trigger callbacks when time has passed.  It is the
  bridge's responsibility to register and unregister a callback as
  needed.  When invoked, the callback should dispatch events that have
  become due and possibly set up a new callback for the next event to be
  dispatched.
  
  The time management methods may accept NEXT_EVENT_TIME.  This is the
  time the next event will become due, in UNIX epoch time.
  NEXT_EVENT_TIME is a real number and may have sub-second accuracy.  It
  is the bridge's responsibility to convert this value into something
  the underlying event loop requires.
  
  =head3 loop_resume_time_watcher NEXT_EVENT_TIME
  
  Resume an already active time watcher.  It is used with
  loop_pause_time_watcher() to provide less expensive timer toggling for
  frequent use cases.  As mentioned above, NEXT_EVENT_TIME is in UNIX
  epoch time and may have sub-second accuracy.
  
  loop_resume_time_watcher() is used by bridges that set them watchers
  in the underlying event loop.  For example, POE::Loop::Gtk implements
  it this way:
  
    sub loop_resume_time_watcher {
      my ($self, $next_time) = @_;
      $next_time -= time();
      $next_time *= 1000;
      $next_time = 0 if $next_time < 0;
      $_watcher_timer = Gtk->timeout_add(
        $next_time, \&_loop_event_callback
      );
    }
  
  This method is usually empty in bridges that implement their own event
  loops.
  
  =head3 loop_reset_time_watcher NEXT_EVENT_TIME
  
  Reset a time watcher, often by stopping or destroying an existing one
  and creating a new one in its place.  It is often a wrapper for
  loop_resume_time_watcher() that first destroys an existing watcher.
  For example, POE::Loop::Gkt's implementation:
  
    sub loop_reset_time_watcher {
      my ($self, $next_time) = @_;
      Gtk->timeout_remove($_watcher_timer);
      undef $_watcher_timer;
      $self->loop_resume_time_watcher($next_time);
    }
  
  =head3 loop_pause_time_watcher
  
  Pause a time watcher without destroying it, if the underlying event
  loop supports such a thing.  POE::Loop::Event does support it:
  
    sub loop_pause_time_watcher {
      $_watcher_timer or return;
      $_watcher_timer->stop();
    }
  
  =head2 File Activity Management Methods
  
  These methods enable and disable file activity watchers.  There are
  four methods: loop_watch_filehandle(), loop_ignore_filehandle(),
  loop_pause_filehandle(), and loop_resume_filehandle().  The "pause"
  and "resume" methods are lightweight versions of "ignore" and "watch",
  respectively.
  
  All the methods take the same two parameters: a file HANDLE and a file
  access MODE.  Modes may be MODE_RD, MODE_WR, or MODE_EX.  These
  constants are defined by POE::Kernel and correspond to the semantics
  of POE::Kernel's select_read(), select_write(), and select_expedite()
  methods.
  
  POE calls MODE_EX "expedited" because it often signals that a file is
  ready for out-of-band information.  Not all event loops handle
  MODE_EX.  For example, Tk:
  
    sub loop_watch_filehandle {
      my ($self, $handle, $mode) = @_;
      my $fileno = fileno($handle);
  
      my $tk_mode;
      if ($mode == MODE_RD) {
        $tk_mode = 'readable';
      }
      elsif ($mode == MODE_WR) {
        $tk_mode = 'writable';
      }
      else {
        # The Tk documentation implies by omission that expedited
        # filehandles aren't, uh, handled.  This is part 1 of 2.
        confess "Tk does not support expedited filehandles";
      }
  
      # ... rest omitted ....
    }
  
  =head3 loop_watch_filehandle FILE_HANDLE, IO_MODE
  
  Watch a FILE_HANDLE for activity in a given IO_MODE.  Depending on the
  underlying event loop, a watcher or callback will be registered for
  the FILE_HANDLE.  Activity in the specified IO_MODE (read, write, or
  out of band) will trigger emission of the proper event in application
  space.
  
  POE::Loop::Select sets the fileno()'s bit in the proper select() bit
  vector.  It also keeps track of which file descriptors are active.
  
    sub loop_watch_filehandle {
      my ($self, $handle, $mode) = @_;
      my $fileno = fileno($handle);
      vec($loop_vectors[$mode], $fileno, 1) = 1;
      $loop_filenos{$fileno} |= (1<<$mode);
    }
  
  =head3 loop_ignore_filehandle FILE_HANDLE, IO_MODE
  
  Stop watching the FILE_HANDLE in a given IO_MODE.  Stops (and possibly
  destroys) an event watcher corresponding to the FILE_HANDLE and
  IO_MODE.
  
  POE::Loop::IO_Poll's loop_ignore_filehandle() manages descriptor/mode
  bits for its _poll() method here.  It also performs some cleanup if a
  descriptor is no longer being watched after this ignore call.
  
    sub loop_ignore_filehandle {
      my ($self, $handle, $mode) = @_;
      my $fileno = fileno($handle);
  
      my $type = mode_to_poll($mode);
      my $current = $poll_fd_masks{$fileno} || 0;
      my $new = $current & ~$type;
  
      if (TRACE_FILES) {
        POE::Kernel::_warn(
          sprintf(
            "<fh> Ignore $fileno: " .
            ": Current mask: 0x%02X - removing 0x%02X = 0x%02X\n",
            $current, $type, $new
          )
        );
      }
  
      if ($new) {
        $poll_fd_masks{$fileno} = $new;
      }
      else {
        delete $poll_fd_masks{$fileno};
      }
    }
  
  =head3 loop_pause_filehandle FILE_HANDLE, IO_MODE
  
  This is a lightweight form of loop_ignore_filehandle().  It is used
  along with loop_resume_filehandle() to temporarily toggle a watcher's
  state for a FILE_HANDLE in a particular IO_MODE.
  
  Some event loops, such as Event.pm, support their file watchers being
  disabled and re-enabled without the need to destroy and re-create
  the watcher objects.
  
    sub loop_pause_filehandle {
      my ($self, $handle, $mode) = @_;
      my $fileno = fileno($handle);
      $fileno_watcher[$fileno]->[$mode]->stop();
    }
  
  By comparison, Event's loop_ignore_filehandle() method cancels and
  destroys the watcher object.
  
    sub loop_ignore_filehandle {
      my ($self, $handle, $mode) = @_;
      my $fileno = fileno($handle);
      if (defined $fileno_watcher[$fileno]->[$mode]) {
        $fileno_watcher[$fileno]->[$mode]->cancel();
        undef $fileno_watcher[$fileno]->[$mode];
      }
    }
  
  Ignoring and re-creating watchers is relatively expensive, so
  POE::Kernel's select_pause_read() and select_resume_read() methods
  (and the corresponding ones for write and expedite) use the faster
  versions.
  
  =head3 loop_resume_filehandle FILE_HANDLE, IO_MODE
  
  This is a lightweight form of loop_watch_filehandle().  It is used
  along with loop_pause_filehandle() to temporarily toggle a watcher's
  state for a FILE_HANDLE in a particular IO_MODE.
  
  =head1 HOW POE FINDS EVENT LOOP BRIDGES
  
  This is a rehash of L<POE::Kernel/"Using POE with Other Event Loops">.
  
  Firstly, if a POE::Loop subclass is manually loaded before
  POE::Kernel, then that will be used.  End of story.
  
  If one isn't, POE::Kernel searches for an external event loop module
  in %INC.  For each module in %INC, corresponding POE::XS::Loop and
  POE::Loop subclasses are tried.
  
  For example, if IO::Poll is loaded, POE::Kernel tries
  
    use POE::XS::Loop::IO_Poll;
    use POE::Loop::IO_Poll;
  
  This is relatively expensive, but it ensures that POE::Kernel can find
  new POE::Loop subclasses without defining them in a central registry.
  
  POE::Loop::Select is the fallback event loop.  It's loaded if no other
  event loop can be found in %INC.
  
  It can't be repeated often enough that event loops must be loaded
  before POE::Kernel.  Otherwise they will not be present in %INC, and
  POE::Kernel will not detect them.
  
  =head1 SEE ALSO
  
  L<POE>, L<POE::Loop::Event>, L<POE::Loop::Gtk>, L<POE::Loop::IO_Poll>,
  L<POE::Loop::Select>, L<POE::Loop::Tk>.
  
  L<POE::Test::Loops> is POE's event loop tests released as a separate,
  reusable distribution.  POE::Loop authors are encouraged to use the
  tests for their own distributions.
  
  =for comment
  TODO - Link to CPAN for POE::Loop modules.
  
  =head1 BUGS
  
  None known.
  
  =for comment
  TODO - Link to POE bug queue.
  
  =head1 AUTHORS & LICENSING
  
  Please see L<POE> for more information about authors, contributors,
  and POE's licensing.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_LOOP

$fatpacked{"POE/Loop/IO_Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_LOOP_IO_POLL';
  # IO::Poll event loop bridge for POE::Kernel.  The theory is that this
  # will be faster for large scale applications.  This file is
  # contributed by Matt Sergeant (baud).
  
  # Empty package to appease perl.
  package POE::Loop::IO_Poll;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  # Include common signal handling.
  use POE::Loop::PerlSignals;
  
  # Everything plugs into POE::Kernel;
  package POE::Kernel;
  
  =for poe_tests
  
  sub skip_tests {
    return "IO::Poll is not 100% compatible with $^O" if (
      $^O eq "MSWin32" and not $ENV{POE_DANTIC}
    );
    return "IO::Poll tests require the IO::Poll module" if (
      do { eval "use IO::Poll"; $@ }
    );
  }
  
  =cut
  
  use strict;
  
  # Be sure we're using a contemporary version of IO::Poll.  There were
  # issues with certain versions of IO::Poll prior to 0.05.  The latest
  # version is 0.01, however.
  use IO::Poll 0.01;
  
  # Hand off to POE::Loop::Select if we're running under ActivePerl.
  BEGIN {
    if ($^O eq "MSWin32" and not $ENV{POE_DANTIC}) {
      warn "IO::Poll is defective on $^O.  Falling back to IO::Select.\n";
      require POE::Loop::Select;
      POE::Loop::Select->import();
      die "not really dying";
    }
  }
  
  use Errno qw(EINPROGRESS EWOULDBLOCK EINTR);
  
  use IO::Poll qw(
    POLLRDNORM POLLWRNORM POLLRDBAND POLLERR POLLHUP POLLNVAL
  );
  
  # Many systems' IO::Poll don't define POLLRDNORM.
  # Usually upgrading IO::Poll helps.
  BEGIN {
    my $x = eval { POLLRDNORM };
    if ($@ or not defined $x) {
      warn(
        "Your IO::Poll doesn't define POLLRDNORM.  Falling back to IO::Select.\n"
      );
      require POE::Loop::Select;
      POE::Loop::Select->import();
      die "not really dying";
    }
  }
  
  my %poll_fd_masks;
  
  # Allow $^T to change without affecting our internals.
  my $start_time = monotime();
  
  #------------------------------------------------------------------------------
  # Loop construction and destruction.
  
  sub loop_initialize {
    my $self = shift;
    %poll_fd_masks = ();
  }
  
  sub loop_finalize {
    my $self = shift;
    $self->loop_ignore_all_signals();
  }
  
  #------------------------------------------------------------------------------
  # Signal handler maintenance functions.
  
  sub loop_attach_uidestroy {
    # does nothing
  }
  
  #------------------------------------------------------------------------------
  # Maintain time watchers.  For this loop, we simply save the next
  # event time in a scalar.  loop_do_timeslice() will use the saved
  # value.  A "paused" time watcher is just a timeout for some future
  # time.
  
  my $_next_event_time = monotime();
  
  sub loop_resume_time_watcher {
    $_next_event_time = $_[1];
  }
  
  sub loop_reset_time_watcher {
    $_next_event_time = $_[1];
  }
  
  sub loop_pause_time_watcher {
    $_next_event_time = monotime() + 3600;
  }
  
  # A static function; not some object method.
  
  sub mode_to_poll {
    return POLLRDNORM if $_[0] == MODE_RD;
    return POLLWRNORM if $_[0] == MODE_WR;
    return POLLRDBAND if $_[0] == MODE_EX;
    croak "unknown I/O mode $_[0]";
  }
  
  #------------------------------------------------------------------------------
  # Maintain filehandle watchers.
  
  sub loop_watch_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);
  
    my $type = mode_to_poll($mode);
    my $current = $poll_fd_masks{$fileno} || 0;
    my $new = $current | $type;
  
    if (TRACE_FILES) {
      POE::Kernel::_warn(
        sprintf(
          "<fh> Watch $fileno: " .
          "Current mask: 0x%02X - including 0x%02X = 0x%02X\n",
          $current, $type, $new
        )
      );
    }
  
    $poll_fd_masks{$fileno} = $new;
  }
  
  sub loop_ignore_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);
  
    my $type = mode_to_poll($mode);
    my $current = $poll_fd_masks{$fileno} || 0;
    my $new = $current & ~$type;
  
    if (TRACE_FILES) {
      POE::Kernel::_warn(
        sprintf(
          "<fh> Ignore $fileno: " .
          ": Current mask: 0x%02X - removing 0x%02X = 0x%02X\n",
          $current, $type, $new
        )
      );
    }
  
    if ($new) {
      $poll_fd_masks{$fileno} = $new;
    }
    else {
      delete $poll_fd_masks{$fileno};
    }
  }
  
  sub loop_pause_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);
  
    my $type = mode_to_poll($mode);
    my $current = $poll_fd_masks{$fileno} || 0;
    my $new = $current & ~$type;
  
    if (TRACE_FILES) {
      POE::Kernel::_warn(
        sprintf(
          "<fh> Pause $fileno: " .
          ": Current mask: 0x%02X - removing 0x%02X = 0x%02X\n",
          $current, $type, $new
        )
      );
    }
  
    if ($new) {
      $poll_fd_masks{$fileno} = $new;
    }
    else {
      delete $poll_fd_masks{$fileno};
    }
  }
  
  sub loop_resume_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);
  
    my $type = mode_to_poll($mode);
    my $current = $poll_fd_masks{$fileno} || 0;
    my $new = $current | $type;
  
    if (TRACE_FILES) {
      POE::Kernel::_warn(
        sprintf(
          "<fh> Resume $fileno: " .
          "Current mask: 0x%02X - including 0x%02X = 0x%02X\n",
          $current, $type, $new
        )
      );
    }
  
    $poll_fd_masks{$fileno} = $new;
  }
  
  #------------------------------------------------------------------------------
  # The event loop itself.
  
  sub loop_do_timeslice {
    my $self = shift;
  
    # Check for a hung kernel.
    $self->_test_if_kernel_is_idle();
  
    # Set the poll timeout based on current queue conditions.  If there
    # are FIFO events, then the poll timeout is zero and move on.
    # Otherwise set the poll timeout until the next pending event, if
    # there are any.  If nothing is waiting, set the timeout for some
    # constant number of seconds.
  
    my $timeout = $_next_event_time;
  
    my $now = monotime();
    if (defined $timeout) {
      $timeout -= $now;
      $timeout = 0 if $timeout < 0;
    }
    else {
      die "shouldn't happen" if ASSERT_DATA;
      $timeout = 3600;
    }
  
    if (TRACE_EVENTS) {
      POE::Kernel::_warn(
        '<ev> Kernel::run() iterating.  ' .
        sprintf(
          "now(%.4f) timeout(%.4f) then(%.4f)\n",
          $now-$start_time, $timeout, ($now-$start_time)+$timeout
         )
      );
    }
  
    if (TRACE_FILES) {
      foreach (sort { $a<=>$b} keys %poll_fd_masks) {
        my @types;
        push @types, "plain-file"        if -f;
        push @types, "directory"         if -d;
        push @types, "symlink"           if -l;
        push @types, "pipe"              if -p;
        push @types, "socket"            if -S;
        push @types, "block-special"     if -b;
        push @types, "character-special" if -c;
        push @types, "tty"               if -t;
        my @modes;
        my $flags = $poll_fd_masks{$_};
        push @modes, 'r' if $flags & (POLLRDNORM | POLLHUP | POLLERR);
        push @modes, 'w' if $flags & (POLLWRNORM | POLLHUP | POLLERR);
        push @modes, 'x' if $flags & (POLLRDBAND | POLLHUP | POLLERR);
        POE::Kernel::_warn(
          "<fh> file descriptor $_ = modes(@modes) types(@types)\n"
        );
      }
    }
  
    # Avoid looking at filehandles if we don't need to.
    # TODO The added code to make this sleep is non-optimal.  There is a
    # way to do this in fewer tests.
  
    if (scalar keys %poll_fd_masks) {
  
      # There are filehandles to poll, so do so.
  
      # Check filehandles, or wait for a period of time to elapse.
      my $hits = IO::Poll::_poll($timeout * 1000, my @results = %poll_fd_masks);
  
      if (ASSERT_FILES) {
        if ($hits < 0) {
          POE::Kernel::_trap("<fh> poll returned $hits (error): $!")
            unless ( ($! == EINPROGRESS) or
                     ($! == EWOULDBLOCK) or
                     ($! == EINTR) or
                     ($! == 0)      # SIGNAL_PIPE strangeness
                   );
        }
      }
  
      if (TRACE_FILES) {
        if ($hits > 0) {
          POE::Kernel::_warn "<fh> poll hits = $hits\n";
        }
        elsif ($hits == 0) {
          POE::Kernel::_warn "<fh> poll timed out...\n";
        }
      }
  
      # If poll has seen filehandle activity, then gather up the
      # active filehandles and synchronously dispatch events to the
      # appropriate handlers.
  
      if ($hits > 0) {
  
        # This is where they're gathered.
  
        my (@rd_ready, @wr_ready, @ex_ready);
        my %poll_fd_results = @results;
        while (my ($fd, $got_mask) = each %poll_fd_results) {
          next unless $got_mask;
  
          my $watch_mask = $poll_fd_masks{$fd};
          if (
            $watch_mask & POLLRDNORM and
            $got_mask & (POLLRDNORM | POLLHUP | POLLERR | POLLNVAL)
          ) {
            if (TRACE_FILES) {
              POE::Kernel::_warn "<fh> enqueuing read for fileno $fd";
            }
  
            push @rd_ready, $fd;
          }
  
          if (
            $watch_mask & POLLWRNORM and
            $got_mask & (POLLWRNORM | POLLHUP | POLLERR | POLLNVAL)
          ) {
            if (TRACE_FILES) {
              POE::Kernel::_warn "<fh> enqueuing write for fileno $fd";
            }
  
            push @wr_ready, $fd;
          }
  
          if (
            $watch_mask & POLLRDBAND and
            $got_mask & (POLLRDBAND | POLLHUP | POLLERR | POLLNVAL)
          ) {
            if (TRACE_FILES) {
              POE::Kernel::_warn "<fh> enqueuing expedite for fileno $fd";
            }
  
            push @ex_ready, $fd;
          }
        }
  
        @rd_ready and $self->_data_handle_enqueue_ready(MODE_RD, @rd_ready);
        @wr_ready and $self->_data_handle_enqueue_ready(MODE_WR, @wr_ready);
        @ex_ready and $self->_data_handle_enqueue_ready(MODE_EX, @ex_ready);
      }
    }
    elsif ($timeout) {
  
      # No filehandles to poll on.  Try to sleep instead.  Use sleep()
      # itself on MSWin32.  Use a dummy four-argument select() everywhere
      # else.
  
      if ($^O eq 'MSWin32') {
        sleep($timeout);
      }
      else {
        CORE::select(undef, undef, undef, $timeout);
      }
    }
  
    # Dispatch whatever events are due.
    $self->_data_ev_dispatch_due();
  }
  
  ### Run for as long as there are sessions to service.
  
  sub loop_run {
    my $self = shift;
    while ($self->_data_ses_count()) {
      $self->loop_do_timeslice();
    }
  }
  
  sub loop_halt {
    # does nothing
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Loop::IO_Poll - a bridge that allows POE to be driven by IO::Poll
  
  =head1 SYNOPSIS
  
  See L<POE::Loop>.
  
  =head1 DESCRIPTION
  
  POE::Loop::IO_Poll implements the interface documented in L<POE::Loop>.
  Therefore it has no documentation of its own.  Please see L<POE::Loop>
  for more details.
  
  =head1 SEE ALSO
  
  L<POE>, L<POE::Loop>, L<IO::Poll>, L<POE::Loop::PerlSignals>
  
  =head1 AUTHORS & LICENSING
  
  Please see L<POE> for more information about authors, contributors,
  and POE's licensing.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_LOOP_IO_POLL

$fatpacked{"POE/Loop/PerlSignals.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_LOOP_PERLSIGNALS';
  # Plain Perl signal handling is something shared by several event
  # loops.  The invariant code has moved out here so that each loop may
  # use it without reinventing it.  This will save maintenance and
  # shrink the distribution.  Yay!
  
  package POE::Loop::PerlSignals;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  # Everything plugs into POE::Kernel.
  package POE::Kernel;
  
  use strict;
  use POE::Kernel;
  
  # Flag so we know which signals are watched.  Used to reset those
  # signals during finalization.
  my %signal_watched;
  
  #------------------------------------------------------------------------------
  # Signal handlers/callbacks.
  
  sub _loop_signal_handler_generic {
    if( USE_SIGNAL_PIPE ) {
      POE::Kernel->_data_sig_pipe_send( $_[0] );
    }
    else {
      _loop_signal_handler_generic_bottom( $_[0] );
    }
  }
  
  sub _loop_signal_handler_generic_bottom {
    if (TRACE_SIGNALS) {
      POE::Kernel::_warn "<sg> Enqueuing generic SIG$_[0] event";
    }
  
    $poe_kernel->_data_ev_enqueue(
      $poe_kernel, $poe_kernel, EN_SIGNAL, ET_SIGNAL, [ $_[0] ],
      __FILE__, __LINE__, undef
    );
    $SIG{$_[0]} = \&_loop_signal_handler_generic;
  }
  
  ##
  
  sub _loop_signal_handler_pipe {
    if( USE_SIGNAL_PIPE ) {
      POE::Kernel->_data_sig_pipe_send( $_[0] );
    }
    else {
      _loop_signal_handler_pipe_bottom( $_[0] );
    }
  }
  
  sub _loop_signal_handler_pipe_bottom {
    if (TRACE_SIGNALS) {
      POE::Kernel::_warn "<sg> Enqueuing PIPE-like SIG$_[0] event";
    }
  
    $poe_kernel->_data_ev_enqueue(
      $poe_kernel, $poe_kernel, EN_SIGNAL, ET_SIGNAL, [ $_[0] ],
      __FILE__, __LINE__, undef
    );
    $SIG{$_[0]} = \&_loop_signal_handler_pipe;
  }
  
  ## only used under USE_SIGCHLD
  
  sub _loop_signal_handler_chld {
    if( USE_SIGNAL_PIPE ) {
      POE::Kernel->_data_sig_pipe_send( 'CHLD' );
    }
    else {
      _loop_signal_handler_chld_bottom( $_[0] );
    }
  }
  
  sub _loop_signal_handler_chld_bottom {
    if (TRACE_SIGNALS) {
      POE::Kernel::_warn "<sg> Enqueuing CHLD-like SIG$_[0] event";
    }
  
    $poe_kernel->_data_sig_enqueue_poll_event($_[0]);
  }
  
  #------------------------------------------------------------------------------
  # Signal handler maintenance functions.
  
  sub loop_watch_signal {
    my ($self, $signal) = @_;
  
    $signal_watched{$signal} = 1;
  
    # Child process has stopped.
    if ($signal eq 'CHLD' or $signal eq 'CLD') {
      if ( USE_SIGCHLD ) {
        # Poll once for signals.  Will set the signal handler when done.
        # It would be more efficient to set $SIG{$signal} here and reap
        # processes, but that would synchronously set the signal
        # handler, and subsequent system() calls within the callback
        # could fail with a -1 return value.  The polling event defers
        # the setup until the current callback returns.
        $self->_data_sig_enqueue_poll_event($signal);
      } else {
        # We should never twiddle $SIG{CH?LD} under POE, unless we want to
        # override system() and friends. --hachi
        # $SIG{$signal} = "DEFAULT";
        $self->_data_sig_begin_polling($signal);
      }
      return;
    }
  
    # Broken pipe.
    if ($signal eq 'PIPE') {
      $SIG{$signal} = \&_loop_signal_handler_pipe;
      return;
    }
  
    # Everything else.
    $SIG{$signal} = \&_loop_signal_handler_generic;
  }
  
  sub loop_ignore_signal {
    my ($self, $signal) = @_;
  
    delete $signal_watched{$signal};
  
    if ($signal eq 'CHLD' or $signal eq 'CLD') {
      if ( USE_SIGCHLD ) {
        if ($self->_data_sig_kernel_awaits_pids()) {
          # We need SIGCHLD to stay around after shutdown, so that
          # child processes may be reaped and kr_child_procs=0
          if (TRACE_SIGNALS) {
            POE::Kernel::_warn "<sg> Keeping SIG$signal anyway!";
          }
          return;
        }
      } else {
        $self->_data_sig_cease_polling();
        # We should never twiddle $SIG{CH?LD} under poe, unless we want to
        # override system() and friends. --hachi
        # $SIG{$signal} = "IGNORE";
        return;
      }
    }
  
    delete $signal_watched{$signal};
  
    my $state = 'DEFAULT';
    if ($signal eq 'PIPE') {
      $state = "IGNORE";
    }
  
    if (TRACE_SIGNALS) {
      POE::Kernel::_warn "<sg> $state SIG$signal";
    }
    $SIG{$signal} = $state;
  }
  
  sub loop_ignore_all_signals {
    my $self = shift;
    foreach my $signal (keys %signal_watched) {
      $self->loop_ignore_signal($signal);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Loop::PerlSignals - common signal handling routines for POE::Loop bridges
  
  =head1 SYNOPSIS
  
  See L<POE::Loop>.
  
  =head1 DESCRIPTION
  
  POE::Loop::PerlSignals implements common code to handle signals for
  many different event loops.  Most loops don't handle signals natively,
  so this code has been abstracted into a reusable mix-in module.
  
  POE::Loop::PerlSignals follows POE::Loop's public interface for signal
  handling.  Therefore, please see L<POE::Loop> for more details.
  
  =head1 SEE ALSO
  
  L<POE>, L<POE::Loop>
  
  =head1 AUTHORS & LICENSING
  
  Please see L<POE> for more information about authors, contributors,
  and POE's licensing.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_LOOP_PERLSIGNALS

$fatpacked{"POE/Loop/Select.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_LOOP_SELECT';
  # Select loop bridge for POE::Kernel.
  
  # Empty package to appease perl.
  package POE::Loop::Select;
  
  use strict;
  
  # Include common signal handling.
  use POE::Loop::PerlSignals;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  =for poe_tests
  
  sub skip_tests { return }
  
  =cut
  
  # Everything plugs into POE::Kernel.
  package POE::Kernel;
  
  use strict;
  use Errno qw(EINPROGRESS EWOULDBLOCK EINTR);
  
  # select() vectors.  They're stored in an array so that the MODE_*
  # offsets can refer to them.  This saves some code at the expense of
  # clock cycles.
  #
  # [ $select_read_bit_vector,    (MODE_RD)
  #   $select_write_bit_vector,   (MODE_WR)
  #   $select_expedite_bit_vector (MODE_EX)
  # ];
  my @loop_vectors = ("", "", "");
  
  # A record of the file descriptors we are actively watching.
  my %loop_filenos;
  
  # Allow $^T to change without affecting our internals.
  my $start_time = monotime();
  
  #------------------------------------------------------------------------------
  # Loop construction and destruction.
  
  sub loop_initialize {
    my $self = shift;
  
    # Initialize the vectors as vectors.
    @loop_vectors = ( '', '', '' );
    vec($loop_vectors[MODE_RD], 0, 1) = 0;
    vec($loop_vectors[MODE_WR], 0, 1) = 0;
    vec($loop_vectors[MODE_EX], 0, 1) = 0;
  }
  
  sub loop_finalize {
    my $self = shift;
  
    # This is "clever" in that it relies on each symbol on the left to
    # be stringified by the => operator.
    my %kernel_modes = (
      MODE_RD => MODE_RD,
      MODE_WR => MODE_WR,
      MODE_EX => MODE_EX,
    );
  
    while (my ($mode_name, $mode_offset) = each(%kernel_modes)) {
      my $bits = unpack('b*', $loop_vectors[$mode_offset]);
      if (index($bits, '1') >= 0) {
        POE::Kernel::_warn "<rc> LOOP VECTOR LEAK: $mode_name = $bits\a\n";
      }
    }
  
    $self->loop_ignore_all_signals();
  }
  
  #------------------------------------------------------------------------------
  # Signal handler maintenance functions.
  
  sub loop_attach_uidestroy {
    # does nothing
  }
  
  #------------------------------------------------------------------------------
  # Maintain time watchers.  For this loop, we simply save the next
  # event time in a scalar.  loop_do_timeslice() will use the saved
  # value.  A "paused" time watcher is just a timeout for some future
  # time.
  
  my $_next_event_time = monotime();
  
  sub loop_resume_time_watcher {
    $_next_event_time = $_[1];
  }
  
  sub loop_reset_time_watcher {
    $_next_event_time = $_[1];
  }
  
  sub loop_pause_time_watcher {
    $_next_event_time = monotime() + 3600;
  }
  
  #------------------------------------------------------------------------------
  # Maintain filehandle watchers.
  
  sub loop_watch_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);
  
    vec($loop_vectors[$mode], $fileno, 1) = 1;
    $loop_filenos{$fileno} |= (1<<$mode);
  }
  
  sub loop_ignore_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);
  
    vec($loop_vectors[$mode], $fileno, 1) = 0;
    delete $loop_filenos{$fileno} unless (
      $loop_filenos{$fileno} and $loop_filenos{$fileno} &= ~(1<<$mode)
    );
  }
  
  sub loop_pause_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);
  
    vec($loop_vectors[$mode], $fileno, 1) = 0;
    delete $loop_filenos{$fileno} unless (
      $loop_filenos{$fileno} and $loop_filenos{$fileno} &= ~(1<<$mode)
    );
  }
  
  sub loop_resume_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);
  
    vec($loop_vectors[$mode], $fileno, 1) = 1;
    $loop_filenos{$fileno} |= (1<<$mode);
  }
  
  #------------------------------------------------------------------------------
  # The event loop itself.
  
  sub loop_do_timeslice {
    my $self = shift;
  
    # Check for a hung kernel.
    $self->_test_if_kernel_is_idle();
  
    # Set the select timeout based on current queue conditions.  If
    # there are FIFO events, then the timeout is zero to poll select and
    # move on.  Otherwise set the select timeout until the next pending
    # event, if there are any.  If nothing is waiting, set the timeout
    # for some constant number of seconds.
  
    my $timeout = $_next_event_time;
  
    my $now = monotime();
    if (defined $timeout) {
      $timeout -= $now;
      $timeout = 0 if $timeout < 0;
  
      # Very large timeouts can trigger EINVAL on Mac OSX.
      $timeout = 3600 if $timeout > 3600;
    }
    else {
      die "shouldn't happen" if ASSERT_DATA;
      $timeout = 3600;
    }
  
    # Tracing is relatively expensive, but it's not for live systems.
    # We can get away with it being after the timeout calculation.
    if (TRACE_EVENTS) {
      POE::Kernel::_warn(
        '<ev> Kernel::run() iterating.  ' .
        sprintf(
          "now(%.4f) timeout(%.4f) then(%.4f)\n",
          $now - $start_time, $timeout, ($now - $start_time) + $timeout
        )
      );
    }
  
    if (TRACE_FILES) {
      POE::Kernel::_warn(
        "<fh> ,----- SELECT BITS IN -----\n",
        "<fh> | READ    : ", unpack('b*', $loop_vectors[MODE_RD]), "\n",
        "<fh> | WRITE   : ", unpack('b*', $loop_vectors[MODE_WR]), "\n",
        "<fh> | EXPEDITE: ", unpack('b*', $loop_vectors[MODE_EX]), "\n",
        "<fh> `--------------------------\n"
      );
    }
  
    # Avoid looking at filehandles if we don't need to.
    # TODO The added code to make this sleep is non-optimal.  There is a
    # way to do this in fewer tests.
  
    if (scalar keys %loop_filenos) {
      # There are filehandles to poll, so do so.
  
      # Check filehandles, or wait for a period of time to elapse.
      my $hits = CORE::select(
        my $rout = $loop_vectors[MODE_RD],
        my $wout = $loop_vectors[MODE_WR],
        my $eout = $loop_vectors[MODE_EX],
        $timeout,
      );
  
      if (ASSERT_FILES) {
        if (
          $hits < 0 and
          $! != EINPROGRESS and
          $! != EWOULDBLOCK and
          $! != EINTR and
          $! != 0                   # this is caused by SIGNAL_PIPE
        ) {
          POE::Kernel::_trap("<fh> select error: $! (hits=$hits)");
        }
      }
  
      if (TRACE_FILES) {
        if ($hits > 0) {
          POE::Kernel::_warn "<fh> select hits = $hits\n";
        }
        elsif ($hits == 0) {
          POE::Kernel::_warn "<fh> select timed out...\n";
        }
        POE::Kernel::_warn(
          "<fh> ,----- SELECT BITS OUT -----\n",
          "<fh> | READ    : ", unpack('b*', $rout), "\n",
          "<fh> | WRITE   : ", unpack('b*', $wout), "\n",
          "<fh> | EXPEDITE: ", unpack('b*', $eout), "\n",
          "<fh> `---------------------------\n"
        );
      }
  
      # If select has seen filehandle activity, then gather up the
      # active filehandles and synchronously dispatch events to the
      # appropriate handlers.
  
      if ($hits > 0) {
  
        # This is where they're gathered.  It's a variant on a neat
        # hack Silmaril came up with.
  
        my (@rd_selects, @wr_selects, @ex_selects);
        foreach (keys %loop_filenos) {
          push(@rd_selects, $_) if vec($rout, $_, 1);
          push(@wr_selects, $_) if vec($wout, $_, 1);
          push(@ex_selects, $_) if vec($eout, $_, 1);
        }
  
        if (TRACE_FILES) {
          if (@rd_selects) {
            POE::Kernel::_warn(
              "<fh> found pending rd selects: ",
              join( ', ', sort { $a <=> $b } @rd_selects ),
              "\n"
            );
          }
          if (@wr_selects) {
            POE::Kernel::_warn(
              "<sl> found pending wr selects: ",
              join( ', ', sort { $a <=> $b } @wr_selects ),
              "\n"
            );
          }
          if (@ex_selects) {
            POE::Kernel::_warn(
              "<sl> found pending ex selects: ",
              join( ', ', sort { $a <=> $b } @ex_selects ),
              "\n"
            );
          }
        }
  
        if (ASSERT_FILES) {
          unless (@rd_selects or @wr_selects or @ex_selects) {
            POE::Kernel::_trap(
              "<fh> found no selects, with $hits hits from select???\n"
            );
          }
        }
  
        # Enqueue the gathered selects, and flag them as temporarily
        # paused.  They'll resume after dispatch.
  
        @rd_selects and $self->_data_handle_enqueue_ready(MODE_RD, @rd_selects);
        @wr_selects and $self->_data_handle_enqueue_ready(MODE_WR, @wr_selects);
        @ex_selects and $self->_data_handle_enqueue_ready(MODE_EX, @ex_selects);
      }
    }
    elsif ($timeout) {
      # No filehandles to select on.  Four-argument select() fails on
      # MSWin32 with all undef bitmasks.  Use sleep() there instead.
  
      # Not unconditionally the Time::HiRes microsleep because
      # Time::HiRes may not be installed.  This is only an issue until
      # we can require versions of Perl that include Time::HiRes.
      if ($^O eq 'MSWin32') {
        sleep($timeout);
      }
      else {
        CORE::select(undef, undef, undef, $timeout);
      }
    }
  
    # Dispatch whatever events are due.
    $self->_data_ev_dispatch_due();
  }
  
  sub loop_run {
    my $self = shift;
  
    # Run for as long as there are sessions to service.
    while ($self->_data_ses_count()) {
      $self->loop_do_timeslice();
    }
  }
  
  sub loop_halt {
    # does nothing
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Loop::Select - a bridge that allows POE to be driven by select(2)
  
  =head1 SYNOPSIS
  
  See L<POE::Loop>.
  
  =head1 DESCRIPTION
  
  POE::Loop::Select implements the interface documented in L<POE::Loop>.
  Therefore it has no documentation of its own.  Please see L<POE::Loop>
  for more details.
  
  =head1 SEE ALSO
  
  L<POE>, L<POE::Loop>, L<select>, L<POE::Loop::PerlSignals>.
  
  =head1 AUTHORS & LICENSING
  
  Please see L<POE> for more information about authors, contributors,
  and POE's licensing.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_LOOP_SELECT

$fatpacked{"POE/NFA.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_NFA';
  package POE::NFA;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw(carp croak);
  
  sub SPAWN_INLINES       () { 'inline_states' }
  sub SPAWN_OBJECTS       () { 'object_states' }
  sub SPAWN_PACKAGES      () { 'package_states' }
  sub SPAWN_OPTIONS       () { 'options' }
  sub SPAWN_RUNSTATE      () { 'runstate' }
  
  sub OPT_TRACE           () { 'trace' }
  sub OPT_DEBUG           () { 'debug' }
  sub OPT_DEFAULT         () { 'default' }
  sub OPT_IMMEDIATE       () { 'immediate' }
  
  sub EN_DEFAULT          () { '_default' }
  sub EN_START            () { '_start' }
  sub EN_STOP             () { '_stop' }
  sub EN_SIGNAL           () { '_signal' }
  
  sub NFA_EN_GOTO_STATE   () { 'poe_nfa_goto_state' }
  sub NFA_EN_POP_STATE    () { 'poe_nfa_pop_state' }
  sub NFA_EN_PUSH_STATE   () { 'poe_nfa_push_state' }
  sub NFA_EN_STOP         () { 'poe_nfa_stop' }
  
  sub SELF_RUNSTATE       () { 0 }
  sub SELF_OPTIONS        () { 1 }
  sub SELF_STATES         () { 2 }
  sub SELF_ID             () { 3 }
  sub SELF_CURRENT        () { 4 }
  sub SELF_STATE_STACK    () { 5 }
  sub SELF_INTERNALS      () { 6 }
  sub SELF_CURRENT_NAME   () { 7 }
  sub SELF_IS_IN_INTERNAL () { 8 }
  
  sub STACK_STATE         () { 0 }
  sub STACK_EVENT         () { 1 }
  
  #------------------------------------------------------------------------------
  
  # Shorthand for defining a trace constant.
  
  sub _define_trace {
    no strict 'refs';
  
    local $^W = 0;
  
    foreach my $name (@_) {
      next if defined *{"TRACE_$name"}{CODE};
      if (defined *{"POE::Kernel::TRACE_$name"}{CODE}) {
        eval(
          "sub TRACE_$name () { " .
          *{"POE::Kernel::TRACE_$name"}{CODE}->() .
          "}"
        );
        die if $@;
      }
      else {
        eval "sub TRACE_$name () { TRACE_DEFAULT }";
        die if $@;
      }
    }
  }
  
  #------------------------------------------------------------------------------
  
  BEGIN {
  
    # ASSERT_DEFAULT changes the default value for other ASSERT_*
    # constants.  It inherits POE::Kernel's ASSERT_DEFAULT value, if
    # it's present.
  
    unless (defined &ASSERT_DEFAULT) {
      if (defined &POE::Kernel::ASSERT_DEFAULT) {
        eval( "sub ASSERT_DEFAULT () { " . &POE::Kernel::ASSERT_DEFAULT . " }" );
      }
      else {
        eval 'sub ASSERT_DEFAULT () { 0 }';
      }
    };
  
    # TRACE_DEFAULT changes the default value for other TRACE_*
    # constants.  It inherits POE::Kernel's TRACE_DEFAULT value, if
    # it's present.
  
    unless (defined &TRACE_DEFAULT) {
      if (defined &POE::Kernel::TRACE_DEFAULT) {
        eval( "sub TRACE_DEFAULT () { " . &POE::Kernel::TRACE_DEFAULT . " }" );
      }
      else {
        eval 'sub TRACE_DEFAULT () { 0 }';
      }
    };
  
    _define_trace("DESTROY");
  }
  
  #------------------------------------------------------------------------------
  # Export constants into calling packages.  This is evil; perhaps
  # EXPORT_OK instead?  The parameters NFA has in common with SESSION
  # (and other sessions) must be kept at the same offsets as each-other.
  
  sub OBJECT      () {  0 }
  sub MACHINE     () {  1 }
  sub KERNEL      () {  2 }
  sub RUNSTATE    () {  3 }
  sub EVENT       () {  4 }
  sub SENDER      () {  5 }
  sub STATE       () {  6 }
  sub CALLER_FILE () {  7 }
  sub CALLER_LINE () {  8 }
  sub CALLER_STATE () {  9 }
  sub ARG0        () { 10 }
  sub ARG1        () { 11 }
  sub ARG2        () { 12 }
  sub ARG3        () { 13 }
  sub ARG4        () { 14 }
  sub ARG5        () { 15 }
  sub ARG6        () { 16 }
  sub ARG7        () { 17 }
  sub ARG8        () { 18 }
  sub ARG9        () { 19 }
  
  sub import {
    my $package = caller();
    no strict 'refs';
    *{ $package . '::OBJECT'   } = \&OBJECT;
    *{ $package . '::MACHINE'  } = \&MACHINE;
    *{ $package . '::KERNEL'   } = \&KERNEL;
    *{ $package . '::RUNSTATE' } = \&RUNSTATE;
    *{ $package . '::EVENT'    } = \&EVENT;
    *{ $package . '::SENDER'   } = \&SENDER;
    *{ $package . '::STATE'    } = \&STATE;
    *{ $package . '::ARG0'     } = \&ARG0;
    *{ $package . '::ARG1'     } = \&ARG1;
    *{ $package . '::ARG2'     } = \&ARG2;
    *{ $package . '::ARG3'     } = \&ARG3;
    *{ $package . '::ARG4'     } = \&ARG4;
    *{ $package . '::ARG5'     } = \&ARG5;
    *{ $package . '::ARG6'     } = \&ARG6;
    *{ $package . '::ARG7'     } = \&ARG7;
    *{ $package . '::ARG8'     } = \&ARG8;
    *{ $package . '::ARG9'     } = \&ARG9;
  }
  
  #------------------------------------------------------------------------------
  # Spawn a new state machine.
  
  sub _add_ref_states {
    my ($states, $refs) = @_;
  
    foreach my $state (keys %$refs) {
      $states->{$state} = {};
  
      my $data = $refs->{$state};
      croak "the data for state '$state' should be an array" unless (
        ref $data eq 'ARRAY'
      );
      croak "the array for state '$state' has an odd number of elements" if (
        @$data & 1
      );
  
      while (my ($ref, $events) = splice(@$data, 0, 2)) {
        if (ref $events eq 'ARRAY') {
          foreach my $event (@$events) {
            $states->{$state}->{$event} = [ $ref, $event ];
          }
        }
        elsif (ref $events eq 'HASH') {
          foreach my $event (keys %$events) {
            my $method = $events->{$event};
            $states->{$state}->{$event} = [ $ref, $method ];
          }
        }
        else {
          croak "events with '$ref' for state '$state' " .
          "need to be a hash or array ref";
        }
      }
    }
  }
  
  sub spawn {
    my ($type, @params) = @_;
    my @args;
  
    # We treat the parameter list strictly as a hash.  Rather than dying
    # here with a Perl error, we'll catch it and blame it on the user.
  
    croak "odd number of events/handlers (missing one or the other?)"
      if @params & 1;
    my %params = @params;
  
    croak "$type requires a working Kernel"
      unless defined $POE::Kernel::poe_kernel;
  
    # Options are optional.
    my $options = delete $params{+SPAWN_OPTIONS};
    $options = { } unless defined $options;
  
    # States are required.
    croak(
      "$type constructor requires at least one of the following parameters: " .
      join (", ", SPAWN_INLINES, SPAWN_OBJECTS, SPAWN_PACKAGES)
    ) unless (
      exists $params{+SPAWN_INLINES} or
      exists $params{+SPAWN_OBJECTS} or
      exists $params{+SPAWN_PACKAGES}
    );
  
    my $states = delete($params{+SPAWN_INLINES}) || {};
  
    if (exists $params{+SPAWN_OBJECTS}) {
      my $objects = delete $params{+SPAWN_OBJECTS};
      _add_ref_states($states, $objects);
    }
  
    if (exists $params{+SPAWN_PACKAGES}) {
      my $packages = delete $params{+SPAWN_PACKAGES};
      _add_ref_states($states, $packages);
    }
  
    my $runstate = delete($params{+SPAWN_RUNSTATE}) || {};
  
    # These are unknown.
    croak(
      "$type constructor does not recognize these parameter names: ",
      join(', ', sort(keys(%params)))
    ) if keys %params;
  
    # Build me.
    my $self = bless [
      $runstate,  # SELF_RUNSTATE
      $options,   # SELF_OPTIONS
      $states,    # SELF_STATES
      undef,      # SELF_ID
      undef,      # SELF_CURRENT
      [ ],        # SELF_STATE_STACK
      { },        # SELF_INTERNALS
      '(undef)',  # SELF_CURRENT_NAME
      0,          # SELF_IS_IN_INTERNAL
    ], $type;
  
    # Register the machine with the POE kernel.
    $POE::Kernel::poe_kernel->session_alloc($self);
  
    # Return it for immediate reuse.
    return $self;
  }
  
  #------------------------------------------------------------------------------
  # Another good inheritance candidate.
  
  sub DESTROY {
    my $self = shift;
  
    # NFA's data structures are destroyed through Perl's usual garbage
    # collection.  TRACE_DESTROY here just shows what's in the session
    # before the destruction finishes.
  
    TRACE_DESTROY and do {
      POE::Kernel::_warn(
        "----- NFA $self Leak Check -----\n",
        "-- Namespace (HEAP):\n"
      );
      foreach (sort keys (%{$self->[SELF_RUNSTATE]})) {
        POE::Kernel::_warn("   $_ = ", $self->[SELF_RUNSTATE]->{$_}, "\n");
      }
      POE::Kernel::_warn("-- Options:\n");
      foreach (sort keys (%{$self->[SELF_OPTIONS]})) {
        POE::Kernel::_warn("   $_ = ", $self->[SELF_OPTIONS]->{$_}, "\n");
      }
      POE::Kernel::_warn("-- States:\n");
      foreach (sort keys (%{$self->[SELF_STATES]})) {
        POE::Kernel::_warn("   $_ = ", $self->[SELF_STATES]->{$_}, "\n");
      }
    };
  }
  
  #------------------------------------------------------------------------------
  
  sub _invoke_state {
    my ($self, $sender, $event, $args, $file, $line, $fromstate) = @_;
  
    # Trace the state invocation if tracing is enabled.
  
    if ($self->[SELF_OPTIONS]->{+OPT_TRACE}) {
      POE::Kernel::_warn(
        $POE::Kernel::poe_kernel->ID_session_to_id($self), " -> $event\n"
      );
    }
  
    # Discard troublesome things.
    return if $event eq EN_START;
    return if $event eq EN_STOP;
  
    # Stop request has come through the queue.  Shut us down.
    if ($event eq NFA_EN_STOP) {
      $POE::Kernel::poe_kernel->_data_ses_stop($self->ID);
      return;
    }
  
    # Make a state transition.
    if ($event eq NFA_EN_GOTO_STATE) {
      my ($new_state, $enter_event, @enter_args) = @$args;
  
      # Make sure the new state exists.
      POE::Kernel::_die(
        $POE::Kernel::poe_kernel->ID_session_to_id($self),
        " tried to enter nonexistent state '$new_state'\n"
      )
      unless exists $self->[SELF_STATES]->{$new_state};
  
      # If an enter event was specified, make sure that exists too.
      POE::Kernel::_die(
        $POE::Kernel::poe_kernel->ID_session_to_id($self),
        " tried to invoke nonexistent enter event '$enter_event' ",
        "in state '$new_state'\n"
      )
      unless (
        not defined $enter_event or
        ( length $enter_event and
          exists $self->[SELF_STATES]->{$new_state}->{$enter_event}
        )
      );
  
      # Invoke the current state's leave event, if one exists.
      $self->_invoke_state( $self, 'leave', [], undef, undef, undef )
        if exists $self->[SELF_CURRENT]->{leave};
  
      # Enter the new state.
      $self->[SELF_CURRENT]      = $self->[SELF_STATES]->{$new_state};
      $self->[SELF_CURRENT_NAME] = $new_state;
  
      # Invoke the new state's enter event, if requested.
      $self->_invoke_state(
        $self, $enter_event, \@enter_args, undef, undef, undef
      ) if defined $enter_event;
  
      return undef;
    }
  
    # Push a state transition.
    if ($event eq NFA_EN_PUSH_STATE) {
  
      my @args = @$args;
      push(
        @{$self->[SELF_STATE_STACK]},
        [ $self->[SELF_CURRENT_NAME], # STACK_STATE
          shift(@args),               # STACK_EVENT
        ]
      );
      $self->_invoke_state(
        $self, NFA_EN_GOTO_STATE, \@args, undef, undef, undef
      );
  
      return undef;
    }
  
    # Pop a state transition.
    if ($event eq NFA_EN_POP_STATE) {
  
      POE::Kernel::_die(
        $POE::Kernel::poe_kernel->ID_session_to_id($self),
        " tried to pop a state from an empty stack\n"
      )
      unless @{ $self->[SELF_STATE_STACK] };
  
      my ($previous_state, $previous_event) = @{
        pop @{ $self->[SELF_STATE_STACK] }
      };
      $self->_invoke_state(
        $self, NFA_EN_GOTO_STATE,
        [ $previous_state, $previous_event, @$args ],
        undef, undef, undef
      );
  
      return undef;
    }
  
    # Stop.
  
    # Try to find the event handler in the current state or the internal
    # event handlers used by wheels and the like.
    my ( $handler, $is_in_internal );
  
    if (exists $self->[SELF_CURRENT]->{$event}) {
      $handler = $self->[SELF_CURRENT]->{$event};
    }
  
    elsif (exists $self->[SELF_INTERNALS]->{$event}) {
      $handler = $self->[SELF_INTERNALS]->{$event};
      $is_in_internal = ++$self->[SELF_IS_IN_INTERNAL];
    }
  
    # If it wasn't found in either of those, then check for _default in
    # the current state.
    elsif (exists $self->[SELF_CURRENT]->{+EN_DEFAULT}) {
      # If we get this far, then there's a _default event to redirect
      # the event to.  Trace the redirection.
      if ($self->[SELF_OPTIONS]->{+OPT_TRACE}) {
        POE::Kernel::_warn(
          $POE::Kernel::poe_kernel->ID_session_to_id($self),
          " -> $event redirected to EN_DEFAULT in state ",
          "'$self->[SELF_CURRENT_NAME]'\n"
        );
      }
  
      $handler = $self->[SELF_CURRENT]->{+EN_DEFAULT};
  
      # Transform the parameters for _default.  ARG1 and beyond are
      # copied so they can't be altered at a distance.
      $args  = [ $event, [@$args] ];
      $event = EN_DEFAULT;
    }
  
    # No external event handler, no internal event handler, and no
    # external _default handler.  This is a grievous error, and now we
    # must die.
    elsif ($event ne EN_SIGNAL) {
      POE::Kernel::_die(
        "a '$event' event was sent from $file at $line to session ",
        $POE::Kernel::poe_kernel->ID_session_to_id($self),
        ", but session ", $POE::Kernel::poe_kernel->ID_session_to_id($self),
        " has neither a handler for it nor one for _default ",
        "in its current state, '$self->[SELF_CURRENT_NAME]'\n"
      );
    }
  
    # Inline event handlers are invoked this way.
  
    my $return;
    if (ref($handler) eq 'CODE') {
      $return = $handler->(
        undef,                      # OBJECT
        $self,                      # MACHINE
        $POE::Kernel::poe_kernel,   # KERNEL
        $self->[SELF_RUNSTATE],     # RUNSTATE
        $event,                     # EVENT
        $sender,                    # SENDER
        $self->[SELF_CURRENT_NAME], # STATE
        $file,                      # CALLER_FILE_NAME
        $line,                      # CALLER_FILE_LINE
        $fromstate,                 # CALLER_STATE
        @$args                      # ARG0..
      );
    }
  
    # Package and object handlers are invoked this way.
  
    else {
      my ($object, $method) = @$handler;
      $return = $object->$method(   # OBJECT (package, implied)
        $self,                      # MACHINE
        $POE::Kernel::poe_kernel,   # KERNEL
        $self->[SELF_RUNSTATE],     # RUNSTATE
        $event,                     # EVENT
        $sender,                    # SENDER
        $self->[SELF_CURRENT_NAME], # STATE
        $file,                      # CALLER_FILE_NAME
        $line,                      # CALLER_FILE_LINE
        $fromstate,                 # CALLER_STATE
        @$args                      # ARG0..
      );
    }
  
    $self->[SELF_IS_IN_INTERNAL]-- if $is_in_internal;
  
    return $return;
  }
  
  #------------------------------------------------------------------------------
  # Add, remove or replace event handlers in the session.  This is going
  # to be tricky since wheels need this but the event handlers can't be
  # limited to a single state.  I think they'll go in a hidden internal
  # state, or something.
  
  sub _register_state {
    my ($self, $name, $handler, $method) = @_;
    $method = $name unless defined $method;
  
    # Deprecate _signal.
    if ($name eq EN_SIGNAL) {
  
      # Report the problem outside POE.
      my $caller_level = 0;
      local $Carp::CarpLevel = 1;
      while ( (caller $caller_level)[0] =~ /^POE::/ ) {
        $caller_level++;
        $Carp::CarpLevel++;
      }
  
      croak(
        ",----- DEPRECATION ERROR -----\n",
        "| The _signal event is deprecated.  Please use sig() to register\n",
        "| an explicit signal handler instead.\n",
        "`-----------------------------\n",
      );
    }
    # There is a handler, so try to define the state.  This replaces an
    # existing state.
  
    if ($handler) {
  
      # Coderef handlers are inline states.
  
      if (ref($handler) eq 'CODE') {
        POE::Kernel::_carp(
          "redefining handler for event($name) for session(",
          $POE::Kernel::poe_kernel->ID_session_to_id($self), ")"
        )
        if (
          $self->[SELF_OPTIONS]->{+OPT_DEBUG} and
          (exists $self->[SELF_INTERNALS]->{$name})
        );
        $self->[SELF_INTERNALS]->{$name} = $handler;
      }
  
      # Non-coderef handlers may be package or object states.  See if
      # the method belongs to the handler.
  
      elsif ($handler->can($method)) {
        POE::Kernel::_carp(
          "redefining handler for event($name) for session(",
          $POE::Kernel::poe_kernel->ID_session_to_id($self), ")"
        )
        if (
          $self->[SELF_OPTIONS]->{+OPT_DEBUG} &&
          (exists $self->[SELF_INTERNALS]->{$name})
        );
        $self->[SELF_INTERNALS]->{$name} = [ $handler, $method ];
      }
  
      # Something's wrong.  This code also seems wrong, since
      # ref($handler) can't be 'CODE'.
  
      else {
        if (
          (ref($handler) eq 'CODE') and
          $self->[SELF_OPTIONS]->{+OPT_TRACE}
        ) {
          POE::Kernel::_carp(
            $self->fetch_id(),
            " : handler for event($name) is not a proper ref - not registered"
          )
        }
        else {
          unless ($handler->can($method)) {
            if (length ref($handler)) {
              croak "object $handler does not have a '$method' method"
            }
            else {
              croak "package $handler does not have a '$method' method";
            }
          }
        }
      }
    }
  
    # No handler.  Delete the state!
  
    else {
      delete $self->[SELF_INTERNALS]->{$name};
    }
  }
  
  #------------------------------------------------------------------------------
  # Return the session's ID.  This is a thunk into POE::Kernel, where
  # the session ID really lies.  This is a good inheritance candidate.
  
  sub _set_id {
    my ($self, $id) = @_;
    $self->[SELF_ID] = $id;
  }
  
  sub ID {
    return shift()->[SELF_ID];
  }
  
  #------------------------------------------------------------------------------
  # Return the session's current state's name.
  
  sub get_current_state {
    my $self = shift;
    return $self->[SELF_CURRENT_NAME];
  }
  
  #------------------------------------------------------------------------------
  
  # Fetch the session's run state.  In rare cases, libraries may need to
  # break encapsulation this way, probably also using
  # $kernel->get_current_session as an accessory to the crime.
  
  sub get_runstate {
    my $self = shift;
    return $self->[SELF_RUNSTATE];
  }
  
  #------------------------------------------------------------------------------
  # Set or fetch session options.  This is virtually identical to
  # POE::Session and a good inheritance candidate.
  
  sub option {
    my $self = shift;
    my %return_values;
  
    # Options are set in pairs.
  
    while (@_ >= 2) {
      my ($flag, $value) = splice(@_, 0, 2);
      $flag = lc($flag);
  
      # If the value is defined, then set the option.
  
      if (defined $value) {
  
        # Change some handy values into boolean representations.  This
        # clobbers the user's original values for the sake of DWIM-ism.
  
        ($value = 1) if ($value =~ /^(on|yes|true)$/i);
        ($value = 0) if ($value =~ /^(no|off|false)$/i);
  
        $return_values{$flag} = $self->[SELF_OPTIONS]->{$flag};
        $self->[SELF_OPTIONS]->{$flag} = $value;
      }
  
      # Remove the option if the value is undefined.
  
      else {
        $return_values{$flag} = delete $self->[SELF_OPTIONS]->{$flag};
      }
    }
  
    # If only one option is left, then there's no value to set, so we
    # fetch its value.
  
    if (@_) {
      my $flag = lc(shift);
      $return_values{$flag} = (
        exists($self->[SELF_OPTIONS]->{$flag})
        ? $self->[SELF_OPTIONS]->{$flag}
        : undef
      );
    }
  
    # If only one option was set or fetched, then return it as a scalar.
    # Otherwise return it as a hash of option names and values.
  
    my @return_keys = keys(%return_values);
    if (@return_keys == 1) {
      return $return_values{$return_keys[0]};
    }
    else {
      return \%return_values;
    }
  }
  
  #------------------------------------------------------------------------------
  # This stuff is identical to the stuff in POE::Session.  Good
  # inheritance candidate.
  
  # Create an anonymous sub that, when called, posts an event back to a
  # session.  This is highly experimental code to support Tk widgets and
  # maybe Event callbacks.  There's no guarantee that this code works
  # yet, nor is there one that it'll be here in the next version.
  
  # This maps postback references (stringified; blessing, and thus
  # refcount, removed) to parent session IDs.  Members are set when
  # postbacks are created, and postbacks' DESTROY methods use it to
  # perform the necessary cleanup when they go away.  Thanks to njt for
  # steering me right on this one.
  
  my %postback_parent_id;
  
  # I assume that when the postback owner loses all reference to it,
  # they are done posting things back to us.  That's when the postback's
  # DESTROY is triggered, and referential integrity is maintained.
  
  sub POE::NFA::Postback::DESTROY {
    my $self = shift;
    my $parent_id = delete $postback_parent_id{$self};
    $POE::Kernel::poe_kernel->refcount_decrement( $parent_id, 'postback' );
  }
  
  # Tune postbacks depending on variations in toolkit behavior.
  
  BEGIN {
    # Tk blesses its callbacks internally, so we need to wrap our
    # blessed callbacks in unblessed ones.  Otherwise our postback's
    # DESTROY method probably won't be called.
    if (exists $INC{'Tk.pm'}) {
      eval 'sub USING_TK () { 1 }';
    }
    else {
      eval 'sub USING_TK () { 0 }';
    }
  };
  
  # Create a postback closure, maintaining referential integrity in the
  # process.  The next step is to give it to something that expects to
  # be handed a callback.
  
  sub postback {
    my ($self, $event, @etc) = @_;
    my $id = $POE::Kernel::poe_kernel->ID_session_to_id(shift);
  
    my $postback = bless sub {
      $POE::Kernel::poe_kernel->post( $id, $event, [ @etc ], [ @_ ] );
      return 0;
    }, 'POE::NFA::Postback';
  
    $postback_parent_id{$postback} = $id;
    $POE::Kernel::poe_kernel->refcount_increment( $id, 'postback' );
  
    # Tk blesses its callbacks, so we must present one that isn't
    # blessed.  Otherwise Tk's blessing would divert our DESTROY call to
    # its own, and that's not right.
  
    return sub { $postback->(@_) } if USING_TK;
    return $postback;
  }
  
  # Create a synchronous callback closure.  The return value will be
  # passed to whatever is handed the callback.
  #
  # TODO - Should callbacks hold reference counts like postbacks do?
  
  sub callback {
    my ($self, $event, @etc) = @_;
    my $id = $POE::Kernel::poe_kernel->ID_session_to_id($self);
  
    my $callback = sub {
      return $POE::Kernel::poe_kernel->call( $id, $event, [ @etc ], [ @_ ] );
    };
  
    $callback;
  }
  
  #==============================================================================
  # New methods.
  
  sub goto_state {
    my ($self, $new_state, $entry_event, @entry_args) = @_;
    if (defined $self->[SELF_CURRENT] && !$self->[SELF_OPTIONS]->{+OPT_IMMEDIATE}) {
      $POE::Kernel::poe_kernel->post(
        $self, NFA_EN_GOTO_STATE,
        $new_state, $entry_event, @entry_args
      );
    }
    else {
      $POE::Kernel::poe_kernel->call(
        $self, NFA_EN_GOTO_STATE,
        $new_state, $entry_event, @entry_args
      );
    }
  }
  
  sub stop {
    my $self = shift;
    $POE::Kernel::poe_kernel->post( $self, NFA_EN_STOP );
  }
  
  sub call_state {
    my ($self, $return_event, $new_state, $entry_event, @entry_args) = @_;
    if ($self->[SELF_OPTIONS]->{+OPT_IMMEDIATE}) {
      $POE::Kernel::poe_kernel->call(
        $self, NFA_EN_PUSH_STATE,
        $return_event,
        $new_state, $entry_event, @entry_args
      );
    }
    else {
      $POE::Kernel::poe_kernel->post(
        $self, NFA_EN_PUSH_STATE,
        $return_event,
        $new_state, $entry_event, @entry_args
      );
    }
  }
  
  sub return_state {
    my ($self, @entry_args) = @_;
    if ($self->[SELF_OPTIONS]->{+OPT_IMMEDIATE}) {
      $POE::Kernel::poe_kernel->call( $self, NFA_EN_POP_STATE, @entry_args );
    }
    else {
      $POE::Kernel::poe_kernel->post( $self, NFA_EN_POP_STATE, @entry_args );
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::NFA - an event-driven state machine (nondeterministic finite automaton)
  
  =head1 SYNOPSIS
  
    use POE::Kernel;
    use POE::NFA;
    use POE::Wheel::ReadLine;
  
    # Spawn an NFA and enter its initial state.
    POE::NFA->spawn(
      inline_states => {
        initial => {
          setup => \&setup_stuff,
        },
        state_login => {
          on_entry => \&login_prompt,
          on_input => \&save_login,
        },
        state_password => {
          on_entry => \&password_prompt,
          on_input => \&check_password,
        },
        state_cmd => {
          on_entry => \&command_prompt,
          on_input => \&handle_command,
        },
      },
    )->goto_state(initial => "setup");
  
    POE::Kernel->run();
    exit;
  
    sub setup_stuff {
      $_[RUNSTATE]{io} = POE::Wheel::ReadLine->new(
        InputEvent => 'on_input',
      );
      $_[MACHINE]->goto_state(state_login => "on_entry");
    }
  
    sub login_prompt { $_[RUNSTATE]{io}->get('Login: '); }
  
    sub save_login {
      $_[RUNSTATE]{login} = $_[ARG0];
      $_[MACHINE]->goto_state(state_password => "on_entry");
    }
  
    sub password_prompt { $_[RUNSTATE]{io}->get('Password: '); }
  
    sub check_password {
      if ($_[RUNSTATE]{login} eq $_[ARG0]) {
        $_[MACHINE]->goto_state(state_cmd => "on_entry");
      }
      else {
        $_[MACHINE]->goto_state(state_login => "on_entry");
      }
    }
  
    sub command_prompt { $_[RUNSTATE]{io}->get('Cmd: '); }
  
    sub handle_command {
      $_[RUNSTATE]{io}->put("  <<$_[ARG0]>>");
      if ($_[ARG0] =~ /^(?:quit|stop|exit|halt|bye)$/i) {
        $_[RUNSTATE]{io}->put('Bye!');
        $_[MACHINE]->stop();
      }
      else {
        $_[MACHINE]->goto_state(state_cmd => "on_entry");
      }
    }
  
  =head1 DESCRIPTION
  
  POE::NFA implements a different kind of POE session: A
  non-deterministic finite automaton.  Let's break that down.
  
  A finite automaton is a state machine with a bounded number of states
  and transitions.  Technically, POE::NFA objects may modify themselves
  at run time, so they aren't really "finite".  Run-time modification
  isn't currently supported by the API, so plausible deniability is
  maintained!
  
  Deterministic state machines are ones where all possible transitions
  are known at compile time.  POE::NFA is "non-deterministic" because
  transitions may change based on run-time conditions.
  
  But more simply, POE::NFA is like POE::Session but with banks of event
  handlers that may be swapped according to the session's run-time state.
  Consider the SYNOPSIS example, which has "on_entry" and "on_input"
  handlers that do different things depending on the run-time state.
  POE::Wheel::ReadLine throws "on_input", but different things happen
  depending whether the session is in its "login", "password" or
  "command" state.
  
  POE::NFA borrows heavily from POE::Session, so this document will only
  discuss the differences.  Please see L<POE::Session> for things which
  are similar.
  
  =head1 PUBLIC METHODS
  
  This document mainly focuses on the differences from POE::Session.
  
  =head2 get_current_state
  
  Each machine state has a name.  get_current_state() returns the name
  of the machine's current state.  get_current_state() is mainly used to
  retrieve the state of some other machine.  It's easier (and faster) to
  use C<$_[STATE]> in a machine's own event handlers.
  
  =head2 get_runstate
  
  get_runstate() returns the machine's current runstate.  Runstates are
  equivalent to POE::Session HEAPs, so this method does pretty much the
  same as POE::Session's get_heap().  It's easier (and faster) to use
  C<$_[RUNSTATE]> in a machine's own event handlers, however.
  
  =head2 spawn STATE_NAME => HANDLERS_HASHREF[, ...]
  
  spawn() is POE::NFA's constructor.  The name reflects the idea that
  new state machines are spawned like threads or processes rather than
  instantiated like objects.
  
  The machine itself is defined as a list of state names and hashes that
  map events to handlers within each state.
  
    my %states = (
      state_1 => {
        event_1 => \&handler_1,
        event_2 => \&handler_2,
      },
      state_2 => {
        event_1 => \&handler_3,
        event_2 => \&handler_4,
      },
    );
  
  A single event may be handled by many states.  The proper handler will
  be called depending on the machine's current state.  For example, if
  C<event_1> is dispatched while the machine is in C<state_2>, then
  handler_3() will be called to handle the event.  The state -> event ->
  handler map looks like this:
  
    $machine{state_2}{event_1} = \&handler_3;
  
  Instead of C<inline_states>, C<object_states> or C<package_states> may
  be used. These map the events of a state to an object or package method
  respectively.
  
    object_states => {
      state_1 => [
        $object_1 => [qw(event_1 event_2)],
      ],
      state_2 => [
        $object_2 => {
          event_1 => method_1,
          event_2 => method_2,
        }
      ]
    }
  
  In the example above, in the case of C<event_1> coming in while the machine
  is in C<state_1>, method C<event_1> will be called on $object_1. If the
  machine is in C<state_2>, method C<method_1> will be called on $object_2.
  
  C<package_states> is very similar, but instead of using an $object, you
  pass in a C<Package::Name>
  
  The C<runstate> parameter allows C<RUNSTATE> to be initialized differently
  at instantiation time. C<RUNSTATE>, like heaps, are usually anonymous hashrefs,
  but C<runstate> may set them to be array references or even objects.
  
  State transitions are not necessarily executed immediately by default.  Rather,
  they are placed in POEs event queue behind any currently pending events.
  Enabling the C<immediate> option causes state transitions to occur immediately,
  regardless of any queued events.
  
  =head2 goto_state NEW_STATE[, ENTRY_EVENT[, EVENT_ARGS]]
  
  goto_state() puts the machine into a new state.  If an ENTRY_EVENT is
  specified, then that event will be dispatched after the machine enters
  the new state.  EVENT_ARGS, if included, will be passed to the entry
  event's handler via C<ARG0..$#_>.
  
    # Switch to the next state.
    $_[MACHINE]->goto_state( 'next_state' );
  
    # Switch to the next state, and call a specific entry point.
    $_[MACHINE]->goto_state( 'next_state', 'entry_event' );
  
    # Switch to the next state; call an entry point with some values.
    $_[MACHINE]->goto_state( 'next_state', 'entry_event', @parameters );
  
  =head2 stop
  
  stop() forces a machine to stop.  The machine will also stop
  gracefully if it runs out of things to do, just like POE::Session.
  
  stop() is heavy-handed.  It will force resources to be cleaned up.
  However, circular references in the machine's C<RUNSTATE> are not
  POE's responsibility and may cause memory leaks.
  
    $_[MACHINE]->stop();
  
  =head2 call_state RETURN_EVENT, NEW_STATE[, ENTRY_EVENT[, EVENT_ARGS]]
  
  call_state() is similar to goto_state(), but it pushes the current
  state on a stack.  At some later point, a handler can call
  return_state() to pop the call stack and return the machine to its old
  state.  At that point, a C<RETURN_EVENT> will be posted to notify the
  old state of the return.
  
    $machine->call_state( 'return_here', 'new_state', 'entry_event' );
  
  As with goto_state(), C<ENTRY_EVENT> is the event that will be emitted
  once the machine enters its new state.  C<ENTRY_ARGS> are parameters
  passed to the C<ENTRY_EVENT> handler via C<ARG0..$#_>.
  
  =head2 return_state [RETURN_ARGS]
  
  return_state() returns to the most recent state in which call_state()
  was invoked.  If the preceding call_state() included a return event
  then its handler will be invoked along with some optional
  C<RETURN_ARGS>.  The C<RETURN_ARGS> will be passed to the return
  handler via C<ARG0..$#_>.
  
    $_[MACHINE]->return_state( 'success', @success_values );
  
  =head2 Methods that match POE::Session
  
  The following methods behave identically to the ones in POE::Session.
  
  =over 2
  
  =item ID
  
  =item option
  
  =item postback
  
  =item callback
  
  =back
  
  =head2 About new() and create()
  
  POE::NFA's constructor is spawn(), not new() or create().
  
  =head1 PREDEFINED EVENT FIELDS
  
  POE::NFA's predefined event fields are the same as POE::Session's with
  the following three exceptions.
  
  =head2 MACHINE
  
  C<MACHINE> is equivalent to Session's C<SESSION> field.  It holds a
  reference to the current state machine, and is useful for calling
  its methods.
  
  See POE::Session's C<SESSION> field for more information.
  
    $_[MACHINE]->goto_state( $next_state, $next_state_entry_event );
  
  =head2 RUNSTATE
  
  C<RUNSTATE> is equivalent to Session's C<HEAP> field.  It holds an
  anonymous hash reference which POE is guaranteed not to touch.  Data
  stored in C<RUNSTATE> will persist between handler invocations.
  
  =head2 STATE
  
  C<STATE> contains the name of the machine's current state.  It is not
  equivalent to anything from POE::Session.
  
  =head2 EVENT
  
  C<EVENT> is equivalent to Session's C<STATE> field.  It holds the name
  of the event which invoked the current handler.  See POE::Session's
  C<STATE> field for more information.
  
  =head1 PREDEFINED EVENT NAMES
  
  POE::NFA defines four events of its own.  These events are used
  internally and may not be overridden by application code.
  
  See POE::Session's "PREDEFINED EVENT NAMES" section for more
  information about other predefined events.
  
  The events are: C<poe_nfa_goto_state>, C<poe_nfa_push_state>,
  C<poe_nfa_pop_state>, C<poe_nfa_stop>.
  
  Yes, all the internal events begin with "poe_nfa_".  More may be
  forthcoming, but they will always begin the same way.  Therefore
  please do not define events beginning with "poe_nfa_".
  
  =head1 SEE ALSO
  
  Many of POE::NFA's features are taken directly from POE::Session.
  Please see L<POE::Session> for more information.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 BUGS
  
  See POE::Session's documentation.
  
  POE::NFA is not as feature-complete as POE::Session.  Your feedback is
  appreciated.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_NFA

$fatpacked{"POE/Pipe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_PIPE';
  # Deprecation notice: Read the documentation.
  
  package POE::Pipe;
  
  use warnings;
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use IO::Pipely;
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Pipe - Deprecated and replaced with delegates to IO::Pipely.
  
  =head1 SYNOPSIS
  
  See L<IO::Pipely>.
  
  =head1 DESCRIPTION
  
  On June 29, 2012, POE::Pipe and its subclasses, POE::Pipe::OneWay and
  POE::Pipe::TwoWay were released to CPAN as IO::Pipely.  The POE::Pipe
  family of modules remained unchanged in POE's distribution.
  
  On August 18, 2013, POE::Pipe and its subclasses were gutted.  Their
  implementations were replaced with delegates to IO::Pipely.  All tests
  pass, although the delegates add slight overhead.  The documentation
  was replaced by this deprecation schedule.
  
  A mandatory deprecation warning is scheduled to be released after
  September 2014.  POE will begin using IO::Pipely directly.  This
  documentation will be updated to schedule the next deprecation step.
  
  The mandatory warning will become a mandatory error a year or so
  later.  Ideally this will occur in August 2015, but it may be delayed
  due to POE's release schedule.  This documentation will be updated to
  schedule the final deprecation step.
  
  Finally, in August 2016 or later, POE::Pipe and its subclasses will be
  removed from POE's distribution altogether.  Users will have had at
  least four years to update their code.  That seems fair.
  
  =head1 SEE ALSO
  
  L<IO::Pipely>
  
  =head1 AUTHOR & COPYRIGHT
  
  The POE::Pipe is copyright 2001-2013 by Rocco Caputo.  All rights
  reserved.  POE::Pipe is free software; you may redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_PIPE

$fatpacked{"POE/Pipe/OneWay.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_PIPE_ONEWAY';
  # Deprecation notice: Read POE::Pipe's documentation.
  
  package POE::Pipe::OneWay;
  
  use warnings;
  use strict;
  
  use base qw( POE::Pipe );
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use IO::Pipely qw(pipely);
  
  sub new {
    my ($class, $conduit_type) = @_;
    return pipely(
      debug => 0,
      type  => $conduit_type,
    );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Pipe::OneWay - Deprecated and replaced with delegates to IO::Pipely.
  
  =head1 SYNOPSIS
  
  See L<POE::Pipe> and L<IO::Pipely>.
  
  =head1 DESCRIPTION
  
  This module is deprecated.  L<IO::Pipely> was released to CPAN as its
  replacement.  Please see L<POE::Pipe> for details, including the
  deprecation schedule.
  
  =head1 SEE ALSO
  
  L<POE::Pipe> and L<IO::Pipely>.
  
  =head1 AUTHOR & COPYRIGHT
  
  POE::Pipe::OneWay is copyright 2001-2013 by Rocco Caputo.  All rights
  reserved.  POE::Pipe::OneWay is free software; you may redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_PIPE_ONEWAY

$fatpacked{"POE/Pipe/TwoWay.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_PIPE_TWOWAY';
  # Deprecation notice: Read POE::Pipe's documentation.
  
  package POE::Pipe::TwoWay;
  
  use warnings;
  use strict;
  
  use base qw( POE::Pipe );
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use IO::Pipely qw(socketpairly);
  
  sub new {
    my ($class, $conduit_type) = @_;
  
    return socketpairly(
      debug => 0,
      type => $conduit_type,
    );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Pipe::TwoWay - Deprecated and replaced with delegates to IO::Pipely.
  
  =head1 SYNOPSIS
  
  See L<POE::Pipe> and L<IO::Pipely>.
  
  =head1 DESCRIPTION
  
  This module is deprecated.  L<IO::Pipely> was released to CPAN as its
  replacement.  Please see L<POE::Pipe> for details, including the
  deprecation schedule.
  
  =head1 SEE ALSO
  
  L<POE::Pipe> and L<IO::Pipely>.
  
  =head1 AUTHOR & COPYRIGHT
  
  POE::Pipe::TwoWay is copyright 2001-2013 by Rocco Caputo.  All rights
  reserved.  POE::Pipe::TwoWay is free software; you may redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_PIPE_TWOWAY

$fatpacked{"POE/Queue.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_QUEUE';
  package POE::Queue;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw(croak);
  
  sub new {
    my $type = shift;
    croak "$type is a virtual base class and not meant to be used directly";
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Queue - a flexible, generic priority queue API
  
  =head1 SYNOPSIS
  
  POE::Queue specifies additional methods not illustrated here.
  
    #!perl
  
    use warnings;
    use strict;
    use POE::Queue::Array;
  
    my $pqa = POE::Queue::Array->new();
  
    # Enqueue a few items.
  
    foreach my $priority (505, 404, 303, 202, 101) {
      $pqa->enqueue($priority, "payload $priority");
    }
  
    # Dequeue until the queue is drained.
  
    while (1) {
      my ($priority, $queue_id, $payload) = $pqa->dequeue_next();
      last unless defined $priority;
  
      print(
        "dequeued id($queue_id) ",
        "priority($priority) ",
        "payload($payload)\n",
      );
    }
  
  Sample output:
  
    dequeued id(5) priority(101) payload(payload 101)
    dequeued id(4) priority(202) payload(payload 202)
    dequeued id(3) priority(303) payload(payload 303)
    dequeued id(2) priority(404) payload(payload 404)
    dequeued id(1) priority(505) payload(payload 505)
  
  =head1 DESCRIPTION
  
  Priority queues may be implemented a number of ways, but they tend to
  behave similar to lists that are kept in order by some kind of
  "priority".  Enqueued items are stored such that the "next" item to be
  retrieved is the one with the highest priority.  Subsequent fetches
  return the next lowest priority, and so on, until the queue is
  emptied.
  
  Priority queues (also known as priority heaps) attempt to do this
  while consuming the fewest resources.  Go read about it!  It's
  fascinating stuff!
  
  =head2 POE::Queue Items
  
  POE::Queue items consist of three fields: A priority, a unique ID
  assigned at enqueue time, and a payload.  The priority and payload are
  specified by the caller, and the unique ID is generated by POE::Queue
  when an item is enqueued.
  
  POE::Queue imposes two limitations on priorities: Priorities must be
  numeric, and lower numbers indicate higher priorities.  Aside from
  that, POE::Queue doesn't care what the numbers mean.
  
  Unique IDs are handles into the queue.  POE::Queue generates and
  returns them as new items are enqueued.  Some methods manipulate
  items, and they take IDs to identify the items to alter.
  
  Item payloads are arbitrary application data.  POE::Queue does not
  examine or alter payloads itself.  Any methods that need to examine
  payloads will accept a filter function. Filter functions examine
  payloads so POE::Queue need not.
  
  =head1 Public Methods
  
  POE::Queue is an API specification.  Subclasses like
  L<POE::Queue::Array> provide actual implementations.
  
  =head2 new
  
  Creates a new priority queue.  Returns a reference to the queue.
  
    my $queue = POE::Queue::Array->new();
  
  =head2 enqueue PRIORITY, PAYLOAD
  
  Enqueues a PAYLOAD, which can be just about anything that will fit
  into a Perl scalar, at a particular PRIORITY level.  enqueue() returns
  a unique ID which can be used to manipulate the payload or its
  priority directly.
  
  Following the UNIX tradition, lower priority numbers indicate higher
  priorities.  The payload with the lowest priority number will be
  dequeued first.  If two payloads have the same PRIORITY, then they
  will be dequeued in the order in which they were enqueued.
  
  In this example, a queue is used to manage a number of alarms.  The
  "next" alarm will be the one due soonest.
  
    my $payload_id = $queue->enqueue($alarm_time, [ "stuff" ]);
  
  =head2 dequeue_next
  
  Removes the next item from the queue, returning it as three fields:
  priority, ID and payload.
  
  The "next" item is the one with the lowest priority number.  If
  multiple items exist with the same priority, dequeue_next() will
  return the one that was given the priority first.
  
    ITEM: while (1) {
      my ($priority, $id, $payload) = $queue->dequeue_next();
      last ITEM unless defined $priority;
      ...;
    }
  
  =head2 get_next_priority
  
  Returns the priority of the item at the head of the queue.  This is
  the lowest numeric priority in the queue.
  
  get_next_priority() can be useful for checking the queue to see if
  it's time to dequeue some items.  In this case, the queue manages
  multiple alarms, and there's nothing to do if the next alarm isn't due
  yet.
  
    ALARM: while (1) {
      my $next_alarm_time = $queue->get_next_priority();
      last ALARM unless defined $next_alarm_time;
  
      if ($next_alarm_time - time() > 0) {
        sleep($next_alarm_time - time());
      }
  
      my ($priority, $id, $payload) = $queue->dequeue_next();
      ...;
    }
  
  =head2 get_item_count
  
  Returns the number of items in the queue.  It's another way to tell
  whether the queue has been fully drained.  Here's an alternative
  version of the example for get_next_priority().
  
    ALARM: while ($queue->get_item_count()) {
      my $next_alarm_time = $queue->get_next_priority();
      if ($next_alarm_time - time() > 0) {
        sleep($next_alarm_time - time());
      }
  
      my ($priority, $id, $payload) = $queue->dequeue_next();
      ...;
    }
  
  =head2 remove_item ITEM_ID, FILTER_FUNCTION
  
  Removes a single item by its ID, but only if a FILTER_FUNCTION
  approves of the item's payload.
  
  If a payload is found with the given ITEM_ID, it is passed to
  FILTER_FUNCTION for examination.  If FILTER_FUNCTION returns true, the
  item is removed from the queue and is returned as three fields.
  
    my ($priority, $id, $payload) = $queue->remove_item(
      $target_id, \&monkeys
    );
  
    sub monkeys {
      my $payload = shift;
      $payload->{type} eq "monkey";
    }
  
  The returned $priority will be undef on failure, and $! will be set to
  the reason why the item couldn't be removed.  That will be ESRCH if
  the ITEM_ID was not found in the queue, or EPERM if the filter
  function returned false.
  
  =head2 remove_items FILTER_FUNCTION [, MAX_ITEM_COUNT ]
  
  Removes and returns items from the queue that match a FILTER_FUNCTION.
  remove_items() will return immediately if MAX_ITEM_COUNT items is
  specified and that many items have been removed from the queue.
  MAX_ITEM_COUNT is a bit of optimization if the application knows in
  advance how many items will match the FILTER_FUNCTION.
  
  Returns a list of items that were removed.  Each item is an array
  reference containing a priority, item ID, and payload.  Returns
  nothing if FILTER_FUNCTION matched nothing.
  
    # Remove up to 12 monkeys.
    my @monkeys = $queue->remove_items(\&monkeys, 12);
    foreach my $monkey (@monkeys) {
      my ($priority, $id, $payload) = @$monkey;
      print(
        "Removed monkey:\n",
        "  priority = $priority\n",
        "  queue id = $id\n",
        "  payload  = $payload\n",
      );
    }
  
  There is no guarantee which items will be removed if MAX_ITEM_COUNT is
  specified too low.
  
  =head2 peek_items FILTER_FUNCTION [, MAX_ITEM_COUNT ]
  
  peek_items() returns up to MAX_ITEM_COUNT items that match a given
  FILTER_FUNCTION without removing them from the queue.
  
    my @entire_queue = $queue->peek_items(sub { 1 });
    foreach my $item (@entire_queue) {
      my ($priority, $id, $payload) = @$item;
      print(
        "Item:\n",
        "  priority = $priority\n",
        "  queue id = $id\n",
        "  payload  = $payload\n",
      );
    }
  
  =head2 adjust_priority ITEM_ID, FILTER_FUNCTION, DELTA
  
  Changes the priority of an item by DELTA.  The item is identified by
  its ITEM_ID, and the change will only happen if the item's payload
  satisfies a FILTER_FUNCTION.  Returns the new priority, which is the
  previous priority + DELTA.  DELTA may be negative.
  
    my $new_priority = $queue->adjust_priority(
      $item_id, \&one_of_mine, 100
    );
  
    sub one_of_mine {
      my $payload = shift;
      return $payload->{owner} == $me;
    }
  
  Returns undef if the item's priority could not be adjusted, and sets
  $! to explain why: ESRCH means that the ITEM_ID could not be found,
  and EPERM means that the FILTER_FUNCTION was not satisfied.
  
  =head2 set_priority ITEM_ID, FILTER_FUNCTION, ABSOLUTE_PRIORITY
  
  Sets an item's priority to a new ABSOLUTE_PRIORITY.  The item is
  identified by its ITEM_ID, and the change will only be allowed to
  happen if the item's payload satisfies a FILTER_FUNCTION.  Returns the
  new priority, which should match ABSOLUTE_PRIORITY.
  
  Returns undef if the item's priority could not be set, and sets $! to
  explain why: ESRCH means that the ITEM_ID could not be found, and
  EPERM means that the FILTER_FUNCTION was not satisfied.
  
    my $new_priority = $queue->set_priority(
      $item_id, \&one_of_mine, time() + 60
    );
  
    unless (defined $new_priority) {
      die "one of our submarines is missing: $item_id" if $! == ESRCH;
      die "set_priority disallowed for item $item_id" if $! == EPERM;
      die $!;
    }
  
    sub one_of_mine {
      $_[0]{owner} == $me;
    }
  
  =head1 SEE ALSO
  
  L<POE>, L<POE::Queue::Array>
  
  =head1 BUGS
  
  None known.
  
  =for comment
  TODO - Should set_priority return the old priority instead of the new
  one?
  
  =for comment
  TODO - Rename and repackage as its own distribution.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors, contributors,
  and POE's licensing.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_QUEUE

$fatpacked{"POE/Queue/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_QUEUE_ARRAY';
  # Copyrights and documentation are at the end.
  
  package POE::Queue::Array;
  
  use strict;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  @ISA = qw(POE::Queue);
  
  use Errno qw(ESRCH EPERM);
  use Carp qw(confess);
  
  sub DEBUG () { 0 }
  
  ### Helpful offsets.
  
  sub ITEM_PRIORITY () { 0 }
  sub ITEM_ID       () { 1 }
  sub ITEM_PAYLOAD  () { 2 }
  
  sub import {
    my $package = caller();
    no strict 'refs';
    *{ $package . '::ITEM_PRIORITY' } = \&ITEM_PRIORITY;
    *{ $package . '::ITEM_ID'       } = \&ITEM_ID;
    *{ $package . '::ITEM_PAYLOAD'  } = \&ITEM_PAYLOAD;
  }
  
  # Item IDs are unique across all queues.
  
  my $queue_seq = 0;
  my %item_priority;
  
  ### A very simple constructor.
  
  sub new {
    bless [], shift();
  }
  
  ### Add an item to the queue.  Returns the new item's ID.
  
  sub enqueue {
    my ($self, $priority, $payload) = @_;
  
    # Get the next item ID.  This clever loop will hang indefinitely if
    # you ever run out of integers to store things under.  Map the ID to
    # its due time for search-by-ID functions.
  
    my $item_id;
    1 while exists $item_priority{$item_id = ++$queue_seq};
    $item_priority{$item_id} = $priority;
  
    my $item_to_enqueue = [
      $priority, # ITEM_PRIORITY
      $item_id,  # ITEM_ID
      $payload,  # ITEM_PAYLOAD
    ];
  
    # Special case: No items in the queue.  The queue IS the item.
    unless (@$self) {
      $self->[0] = $item_to_enqueue;
      DEBUG and warn $self->_dump_splice(0);
      return $item_id;
    }
  
    # Special case: The new item belongs at the end of the queue.
    if ($priority >= $self->[-1]->[ITEM_PRIORITY]) {
      push @$self, $item_to_enqueue;
      DEBUG and warn $self->_dump_splice(@$self-1);
      return $item_id;
    }
  
    # Special case: The new item belongs at the head of the queue.
    if ($priority < $self->[0]->[ITEM_PRIORITY]) {
      unshift @$self, $item_to_enqueue;
      DEBUG and warn $self->_dump_splice(0);
      return $item_id;
    }
  
    # Special case: There are only two items in the queue.  This item
    # naturally belongs between them.
    if (@$self == 2) {
      splice @$self, 1, 0, $item_to_enqueue;
      DEBUG and warn $self->_dump_splice(1);
      return $item_id;
    }
  
    # And finally we have a nontrivial queue.  Insert the item using a
    # binary seek.
  
    $self->_insert_item(0, $#$self, $priority, $item_to_enqueue);
    return $item_id;
  }
  
  ### Dequeue the next thing from the queue.  Returns an empty list if
  ### the queue is empty.  There are different flavors of this
  ### operation.
  
  sub dequeue_next {
    my $self = shift;
  
    return unless @$self;
    my ($priority, $id, $stuff) = @{shift @$self};
    delete $item_priority{$id};
    return ($priority, $id, $stuff);
  }
  
  ### Return the next item's priority, undef if the queue is empty.
  # This is POE's most-called method.  We could greatly benefit from
  # finding ways to reduce the number of calls.
  
  sub get_next_priority {
    # This is Ton Hospel's optimization.
    # He measured a 4% improvement by avoiding $self.
    return (shift->[0] || return undef)->[ITEM_PRIORITY];
  }
  
  ### Return the number of items currently in the queue.
  
  sub get_item_count {
    return scalar @{$_[0]};
  }
  
  ### Internal method to insert an item using a binary seek and splice.
  ### We accept the bounds as parameters because the alarm adjustment
  ### functions may also use it.
  
  sub _insert_item {
    my ($self, $lower, $upper, $priority, $item) = @_;
  
    while (1) {
      my $midpoint = ($upper + $lower) >> 1;
  
      # Upper and lower bounds crossed.  Insert at the lower point.
      if ($upper < $lower) {
        splice @$self, $lower, 0, $item;
        DEBUG and warn $self->_dump_splice($lower);
        return;
      }
  
      # We're looking for a priority lower than the one at the midpoint.
      # Set the new upper point to just before the midpoint.
      if ($priority < $self->[$midpoint]->[ITEM_PRIORITY]) {
        $upper = $midpoint - 1;
        next;
      }
  
      # We're looking for a priority greater or equal to the one at the
      # midpoint.  The new lower bound is just after the midpoint.
      $lower = $midpoint + 1;
    }
  }
  
  ### Internal method to find a queue item by its priority and ID.  We
  ### assume the priority and ID have been verified already, so the item
  ### must exist.  Returns the index of the item that matches the
  ### priority/ID pair.
  
  sub _find_item {
    my ($self, $id, $priority) = @_;
  
    # Use a binary seek.
  
    my $upper = $#$self; # Last index of @$self.
    my $lower = 0;
    while (1) {
      my $midpoint = ($upper + $lower) >> 1;
  
      # Upper and lower bounds crossed.  The lower point is aimed at an
      # element with a priority higher than our target.
      last if $upper < $lower;
  
      # We're looking for a priority lower than the one at the midpoint.
      # Set the new upper point to just before the midpoint.
      if ($priority < $self->[$midpoint]->[ITEM_PRIORITY]) {
        $upper = $midpoint - 1;
        next;
      }
  
      # We're looking for a priority greater or equal to the one at the
      # midpoint.  The new lower bound is just after the midpoint.
      $lower = $midpoint + 1;
    }
  
    # The lower index is pointing to an element with a priority higher
    # than our target.  Scan backwards until we find the item with the
    # target ID.
    while ($lower-- >= 0) {
      return $lower if $self->[$lower]->[ITEM_ID] == $id;
    }
  
    die "should never get here... maybe the queue is out of order";
  }
  
  ### Remove an item by its ID.  Takes a coderef filter, too, for
  ### examining the payload to be sure it really wants to leave.  Sets
  ### $! and returns undef on failure.
  
  sub remove_item {
    my ($self, $id, $filter) = @_;
  
    my $priority = $item_priority{$id};
    unless (defined $priority) {
      $! = ESRCH;
      return;
    }
  
    # Find that darn item.
    my $item_index = $self->_find_item($id, $priority);
  
    # Test the item against the filter.
    unless ($filter->($self->[$item_index]->[ITEM_PAYLOAD])) {
      $! = EPERM;
      return;
    }
  
    # Remove the item, and return it.
    delete $item_priority{$id};
    return @{splice @$self, $item_index, 1};
  }
  
  ### Remove items matching a filter.  Regrettably, this must scan the
  ### entire queue.  An optional count limits the number of items to
  ### remove, and it may shorten execution times.  Returns a list of
  ### references to priority/id/payload lists.  This is intended to
  ### return all the items matching the filter, and the function's
  ### behavior is undefined when $count is less than the number of
  ### matching items.
  
  sub remove_items {
    my ($self, $filter, $count) = @_;
    $count = @$self unless $count;
  
    my @items;
    my $i = @$self;
    while ($i--) {
      if ($filter->($self->[$i]->[ITEM_PAYLOAD])) {
        my $removed_item = splice(@$self, $i, 1);
        delete $item_priority{$removed_item->[ITEM_ID]};
        unshift @items, $removed_item;
        last unless --$count;
      }
    }
  
    return @items;
  }
  
  ### Adjust the priority of an item by a relative amount.  Adds $delta
  ### to the priority of the $id'd object (if it matches $filter), and
  ### moves it in the queue.
  
  sub adjust_priority {
    my ($self, $id, $filter, $delta) = @_;
  
    my $old_priority = $item_priority{$id};
    unless (defined $old_priority) {
      $! = ESRCH;
      return;
    }
  
    # Find that darn item.
    my $item_index = $self->_find_item($id, $old_priority);
  
    # Test the item against the filter.
    unless ($filter->($self->[$item_index]->[ITEM_PAYLOAD])) {
      $! = EPERM;
      return;
    }
  
    # Nothing to do if the delta is zero.
    # TODO Actually we may need to ensure that the item is moved to the
    # end of its current priority bucket, since it should have "moved".
    return $self->[$item_index]->[ITEM_PRIORITY] unless $delta;
  
    # Remove the item, and adjust its priority.
    my $item = splice(@$self, $item_index, 1);
    my $new_priority = $item->[ITEM_PRIORITY] += $delta;
    $item_priority{$id} = $new_priority;
  
    $self->_reinsert_item($new_priority, $delta, $item_index, $item);
  }
  
  ### Set the priority to a specific amount.  Replaces the item's
  ### priority with $new_priority (if it matches $filter), and moves it
  ### to the new location in the queue.
  
  sub set_priority {
    my ($self, $id, $filter, $new_priority) = @_;
  
    my $old_priority = $item_priority{$id};
    unless (defined $old_priority) {
      $! = ESRCH;
      return;
    }
  
    # Nothing to do if the old and new priorities match.
    # TODO Actually we may need to ensure that the item is moved to the
    # end of its current priority bucket, since it should have "moved".
    return $new_priority if $new_priority == $old_priority;
  
    # Find that darn item.
    my $item_index = $self->_find_item($id, $old_priority);
  
    # Test the item against the filter.
    unless ($filter->($self->[$item_index]->[ITEM_PAYLOAD])) {
      $! = EPERM;
      return;
    }
  
    # Remove the item, and calculate the delta.
    my $item = splice(@$self, $item_index, 1);
    my $delta = $new_priority - $old_priority;
    $item->[ITEM_PRIORITY] = $item_priority{$id} = $new_priority;
  
    $self->_reinsert_item($new_priority, $delta, $item_index, $item);
  }
  
  ### Sanity-check the results of an item insert.  Verify that it
  ### belongs where it was put.  Only called during debugging.
  
  sub _dump_splice {
    my ($self, $index) = @_;
    my @return;
    my $at = $self->[$index]->[ITEM_PRIORITY];
    if ($index > 0) {
      my $before = $self->[$index-1]->[ITEM_PRIORITY];
      push @return, "before($before)";
      confess "out of order: $before should be < $at" if $before > $at;
    }
    push @return, "at($at)";
    if ($index < $#$self) {
      my $after = $self->[$index+1]->[ITEM_PRIORITY];
      push @return, "after($after)";
      my @priorities = map {$_->[ITEM_PRIORITY]} @$self;
      confess "out of order: $at should be < $after (@priorities)" if (
        $at >= $after
      );
    }
    return "@return";
  }
  
  ### Reinsert an item into the queue.  It has just been removed by
  ### adjust_priority() or set_priority() and needs to be replaced.
  ### This tries to be clever by not doing more work than necessary.
  
  sub _reinsert_item {
    my ($self, $new_priority, $delta, $item_index, $item) = @_;
  
    # Now insert it back.
    # The special cases are duplicates from enqueue().  We use the delta
    # (direction) of the move and the old item index to narrow down the
    # subsequent nontrivial insert if none of the special cases apply.
  
    # Special case: No events in the queue.  The queue IS the item.
    unless (@$self) {
      $self->[0] = $item;
      DEBUG and warn $self->_dump_splice(0);
      return $new_priority;
    }
  
    # Special case: The item belongs at the end of the queue.
    if ($new_priority >= $self->[-1]->[ITEM_PRIORITY]) {
      push @$self, $item;
      DEBUG and warn $self->_dump_splice(@$self-1);
      return $new_priority;
    }
  
    # Special case: The item belongs at the head of the queue.
    if ($new_priority < $self->[0]->[ITEM_PRIORITY]) {
      unshift @$self, $item;
      DEBUG and warn $self->_dump_splice(0);
      return $new_priority;
    }
  
    # Special case: There are only two items in the queue.  This item
    # naturally belongs between them.
  
    if (@$self == 2) {
      splice @$self, 1, 0, $item;
      DEBUG and warn $self->_dump_splice(1);
      return $new_priority;
    }
  
    # The item has moved towards an end of the queue, but there are a
    # lot of items into which it may be inserted.  We'll binary seek.
  
    my ($upper, $lower);
    if ($delta > 0) {
      $upper = $#$self; # Last index in @$self.
      $lower = $item_index;
    }
    else {
      $upper = $item_index;
      $lower = 0;
    }
  
    $self->_insert_item($lower, $upper, $new_priority, $item);
    return $new_priority;
  }
  
  ### Peek at items that match a filter.  Returns a list of payloads
  ### that match the supplied coderef.
  
  sub peek_items {
    my ($self, $filter, $count) = @_;
    $count = @$self unless $count;
  
    my @items;
    my $i = @$self;
    while ($i--) {
      if ($filter->($self->[$i]->[ITEM_PAYLOAD])) {
        unshift @items, $self->[$i];
        last unless --$count;
      }
    }
  
    return @items;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Queue::Array - a high-performance array-based priority queue
  
  =head1 SYNOPSIS
  
  See L<POE::Queue>.
  
  =head1 DESCRIPTION
  
  This class is an implementation of the abstract POE::Queue interface.
  As such, its documentation may be found in L<POE::Queue>.
  
  POE::Queue::Array implements a priority queue using Perl arrays,
  splice, and copious application of cleverness.
  
  Despite its name, POE::Queue::Array may be used as a stand-alone
  priority queue without the rest of POE.
  
  =head1 SEE ALSO
  
  L<POE>, L<POE::Queue>
  
  =head1 BUGS
  
  None currently known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors, contributors,
  and POE's licensing.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_QUEUE_ARRAY

$fatpacked{"POE/Resource.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_RESOURCE';
  package POE::Resource;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Resource - internal resource managers for POE::Kernel
  
  =head1 SYNOPSIS
  
  Varies, although most POE::Resource subclasses do not have public
  APIs.
  
  =head1 DESCRIPTION
  
  POE manages several types of information internally.  Its Resource
  classes are mix-ins designed to manage those types of information
  behind tidy, mostly private interfaces.  This was done to facilitate
  testing and a conversion to C without the need to port POE::Kernel all
  at once.
  
  POE::Resource subclasses are generally different from one another, but
  there are some similarities to note.
  
  Every resource should have an initializer and finalizer method.
  Initializers set up initial data and link resources into POE::Kernel.
  Finalizers clean up any remaining data and verify that each resource
  subsystem was left in a consistent state.
  
  One common theme in resource implementations is that they don't need
  to perform much error checking, if any.  Resource methods are used
  internally by POE::Kernel and/or POE::API classes, so it's up to them
  to ensure correct usage.
  
  Resource methods follow the naming convention _data_???_activity,
  where ??? is an abbreviation for the type of resource it belongs to:
  
    POE::Resource::Events      _data_ev_initialize
    POE::Resource::FileHandles _data_handle_initialize
    POE::Resource::Signals     _data_sig_initialize
  
  Finalizer methods end in "_finalize".
  
    _data_ev_finalize
    _data_handle_finalize
    _data_sig_finalize
  
  Finalizers return true if a resource shut down cleanly, or false if
  there were inconsistencies or leaks during end-of-run checking.  The
  t/res/*.t tests rely on these return values.
  
  =head1 SEE ALSO
  
  L<POE::Resource::Aliases>,
  L<POE::Resource::Events>,
  L<POE::Resource::Extrefs>,
  L<POE::Resource::FileHandles>,
  L<POE::Resource::SIDs>,
  L<POE::Resource::Sessions>,
  L<POE::Resource::Signals>
  
  Also see L<POE::Kernel/Resources> for public information about POE
  resources.
  
  =head1 BUGS
  
  None known.
  
  =head1 AUTHORS & LICENSING
  
  Please see L<POE> for more information about its authors,
  contributors, and licensing.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_RESOURCE

$fatpacked{"POE/Resource/Aliases.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_RESOURCE_ALIASES';
  # Manage the POE::Kernel data structures necessary to keep track of
  # session aliases.
  
  package POE::Resource::Aliases;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  # These methods are folded into POE::Kernel;
  package POE::Kernel;
  
  use strict;
  
  ### The table of session aliases, and the sessions they refer to.
  
  my %kr_aliases;
  #  ( $alias => $session_ref,
  #    ...,
  #  );
  
  my %kr_ses_to_alias;
  #  ( $session_id =>
  #    { $alias => $session_ref,
  #      ...,
  #    },
  #    ...,
  #  );
  
  sub _data_alias_initialize {
    $poe_kernel->[KR_ALIASES] = \%kr_aliases;
  }
  
  sub _data_alias_relocate_kernel_id {
    my ($self, $old_id, $new_id) = @_;
    return unless exists $kr_ses_to_alias{$old_id};
    $kr_ses_to_alias{$new_id} = delete $kr_ses_to_alias{$old_id};
  }
  
  ### End-run leak checking.  Returns true if finalization was ok, or
  ### false if it failed.
  
  sub _data_alias_finalize {
    my $finalized_ok = 1;
    while (my ($alias, $ses) = each(%kr_aliases)) {
      _warn "!!! Leaked alias: $alias = $ses\n";
      $finalized_ok = 0;
    }
    while (my ($ses_id, $alias_rec) = each(%kr_ses_to_alias)) {
      my @aliases = keys(%$alias_rec);
      _warn "!!! Leaked alias cross-reference: $ses_id (@aliases)\n";
      $finalized_ok = 0;
    }
    return $finalized_ok;
  }
  
  # Add an alias to a session.
  #
  # TODO This has a potential problem: setting the same alias twice on a
  # session will increase the session's reference count twice.  Removing
  # the alias will only decrement it once.  That potentially causes
  # reference counts that never go away.  The public interface for this
  # function, alias_set(), does not allow this to occur.  We should add
  # a test to make sure it never does.
  #
  # TODO It is possible to add aliases to sessions that do not exist.
  # The public alias_set() function prevents this from happening.
  
  sub _data_alias_add {
    my ($self, $session, $alias) = @_;
  #  _warn( "Session ", $session->ID, " is alias $alias\n" );
    $self->_data_ses_refcount_inc($session->ID);
    $kr_aliases{$alias} = $session;
    $kr_ses_to_alias{$session->ID}->{$alias} = $session;
  }
  
  # Remove an alias from a session.
  #
  # TODO Happily allows the removal of aliases from sessions that don't
  # exist.  This will cause problems with reference counting.
  
  sub _data_alias_remove {
    my ($self, $session, $alias) = @_;
  #  _warn( "Session ", $session->ID, " was alias $alias\n" );
    delete $kr_aliases{$alias};
    delete $kr_ses_to_alias{$session->ID}->{$alias};
    $self->_data_ses_refcount_dec($session->ID);
  }
  
  ### Clear all the aliases from a session.
  
  sub _data_alias_clear_session {
    my ($self, $sid) = @_;
    return unless exists $kr_ses_to_alias{$sid}; # avoid autoviv
    while (my ($alias, $ses_ref) = each %{$kr_ses_to_alias{$sid}}) {
      $self->_data_alias_remove($ses_ref, $alias);
    }
    delete $kr_ses_to_alias{$sid};
  }
  
  ### Resolve an alias.  Just an alias.
  
  sub _data_alias_resolve {
    my ($self, $alias) = @_;
    return undef unless exists $kr_aliases{$alias};
    return $kr_aliases{$alias};
  }
  
  ### Return a list of aliases for a session.
  
  sub _data_alias_list {
    my ($self, $sid) = @_;
    return () unless exists $kr_ses_to_alias{$sid};
    return sort keys %{$kr_ses_to_alias{$sid}};
  }
  
  ### Return the number of aliases for a session.
  
  sub _data_alias_count_ses {
    my ($self, $sid) = @_;
    return 0 unless exists $kr_ses_to_alias{$sid};
    return scalar keys %{$kr_ses_to_alias{$sid}};
  }
  
  ### Return a session's ID in a form suitable for logging.
  
  sub _data_alias_loggable {
    my ($self, $sid) = @_;
    "session $sid" . (
      (exists $kr_ses_to_alias{$sid})
      ? ( " (" . join(", ", $self->_data_alias_list($sid)) . ")" )
      : ""
    );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Resource::Aliases - internal session alias manager for POE::Kernel
  
  =head1 SYNOPSIS
  
  There is no public API.
  
  =head1 DESCRIPTION
  
  POE::Resource::Aliases is a mix-in class for POE::Kernel.  It provides
  the features to manage session aliases.  It is used internally by
  POE::Kernel, so it has no public interface.
  
  =head1 SEE ALSO
  
  See L<POE::Kernel/Session Identifiers (IDs and Aliases)> for the
  public alias API.
  
  See L<POE::Kernel/Resources> for public information about POE
  resources.
  
  See L<POE::Resource> for general discussion about resources and the
  classes that manage them.
  
  =head1 BUGS
  
  None known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_RESOURCE_ALIASES

$fatpacked{"POE/Resource/Clock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_RESOURCE_CLOCK';
  # Manage a platonic, monotonic clock to keep the event queue ordered
  
  package POE::Resource::Clock;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use strict;
  
  use Config;
  use POSIX;
  use POE::Pipe::OneWay;
  use File::Spec;
  
  require Exporter;
  our @EXPORT_OK = qw( monotime sleep walltime wall2mono mono2wall time );
  our @ISA = qw( Exporter );
  
  sub DEBUG () { 0 }
  
  sub CLK_TIMEOUT () { 0 }
  sub CLK_SKEW    () { 1 }
  
  sub CLK_EN_READ () { "rt-lock-read" }
  
  
  # Perform a runtime check for a compile-time flag.
  #
  # TODO - Enable compiler optimization of all calls to this function.
  # The customary way to do this is to migrate the environment variable
  # value into a constant at compile time, then for all callers to check
  # the constant directly.  This is such a common thing to do that POE
  # should define a utility library for it.
  
  sub _do_X 
  {
      my( $X, $default ) = @_;
      my $m = $X;
      return POE::Kernel->can( $m )->() if POE::Kernel->can( $m );
      my $k = "POE_$X";
      return $ENV{$k} if exists $ENV{$k};
      return $default if defined $default;
      return 1;
  }
  
  
  # Try to get the exact difference between the monotonic clock's epoch
  # and the system clock's epoch.  We do this by comparing the 2 for
  # 0.25 second or 10 samples.  To compensate for delays between calling
  # time and get_time, we run in both order.  Even so, I still see up to
  # 10 mS divergence in my dev VM between invocations.
  #
  # Only called once, at compile time.
  
  sub _exact_epoch
  {
      my( $monoclock ) = @_;
  
      my $N=0;
      my $total = 0;
      my $end = $monoclock->get_time() + 0.25;
      while( $end > $monoclock->get_time() or $N < 20) {
          my $hr = Time::HiRes::time();
          my $mono = $monoclock->get_time();
          $total += $hr - $mono;
          $N++;
          $mono = $monoclock->get_time();
          $hr = Time::HiRes::time();
          $total += $hr - $mono;
          $N++;
      }
      DEBUG and POE::Kernel::_warn( "<ck> RT clock samples=$N" );
      return $total/$N;
  }
  
  
  #########################################
  sub _get_epoch
  {
      my( $monoclock, $wallclock ) = @_;
      return $wallclock->get_time() - $monoclock->get_time();
  }
  
  
  #########################################
  our $FORMAT = 'iF';
  our $LENGTH = length pack $FORMAT, 0, 0;
  sub _pipe_write
  {
      my( $write, $op, $skew ) = @_;
      DEBUG and POE::Kernel::_warn( "<ck> write op=$op" );
      my $buffer = pack $FORMAT, $op, $skew;
      syswrite( $write, $buffer, $LENGTH );
  }
  
  
  #########################################
  sub _pipe_read
  {
      my( $read ) = @_;
      my $buffer;
      sysread( $read, $buffer, $LENGTH );
      return unless length $buffer;
      return unpack $FORMAT, $buffer;
  }
  
  
  our( $SIGACT, $SIGSET );
  sub _build_sig
  {
      my( $write ) = @_;
      my $handler = sub {
              DEBUG and POE::Kernel::_warn( "<ck> timeout" );
              _pipe_write( $write, CLK_TIMEOUT, 0 );
          };
      my $default = eval { _sig_number( 'RTMIN' ) } ||
                    eval { _sig_number( 'RTALRM' ) } ||
                    SIGALRM;
  
      my $signal = _do_X( 'CLOCK_SIGNAL', $default ) || $default;
      $SIGSET = POSIX::SigSet->new( $signal );
      $SIGACT = POSIX::SigAction->new( $handler, $SIGSET, 0 );
      $SIGACT->safe(1);
      POSIX::sigaction( $signal, $SIGACT );
      return $signal;
  }
  
  
  #########################################
  sub _rt_setup
  {
      my( $read, $kernel ) = @_;
      $kernel->loop_pause_time_watcher();
      DEBUG and POE::Kernel::_warn( "<ck> Setup RT pipe" );
      # Add to the select list
      $kernel->_data_handle_condition( $read );
      $kernel->loop_watch_filehandle( $read, POE::Kernel::MODE_RD() );
  }
  
  
  our $EPSILON = 0.0001;
  sub _rt_resume
  {
      my( $what, $timer, $kernel, $pri ) = @_;
      DEBUG and POE::Kernel::_warn( "<ck> $what pri=$pri" );
      $kernel->loop_pause_time_watcher();
      if( $pri <= monotime() ) {
          $timer->set_timeout( $EPSILON );
      }
      else {
          $timer->set_timeout( $pri, 0, 1 );
      }
  }
  
  
  sub _rt_pause
  {
      my( $timer, $kernel ) = @_;
      DEBUG and POE::Kernel::_warn( "<ck> Pause" );
      $timer->set_timeout( 60 );
      $kernel->loop_pause_time_watcher();
  }
  
  
  #########################################
  sub _rt_read_pipe
  {
      my( $kernel, $read ) = @_;
      my $dispatch_once;
      while( 1 ) {
          my( $op, $skew ) = _pipe_read( $read );
          return unless defined $op;
          DEBUG and POE::Kernel::_warn( "<ck> Read pipe op=$op" );
          if( $op == CLK_TIMEOUT ) {
              next unless $dispatch_once;
              $kernel->_data_ev_dispatch_due();
              $dispatch_once = 1;
          }
          elsif( $op == CLK_SKEW ) {
              rt_skew( $kernel );
              $dispatch_once = 0;
          }
          elsif( DEBUG ) {
              POE::Kernel::_warn( "<ck> Unknown op=$op" );
          }
      }
  }
  
  
  #########################################
  sub _rt_ready
  {
      my( $read, $frd, $kernel, $fileno ) = @_;
      return 0 unless $frd == $fileno;
      _rt_read_pipe( $kernel, $read );
      return 1;
  }
  
  
  #########################################
  my %SIGnames;
  sub _sig_number
  {
      my( $name ) = @_;
      return $name if $name =~ /^\d+$/;
      my $X = 0;
      $X = $1 if $name =~ s/\+(\d+)$//;
      unless( %SIGnames ) {
          # this code is lifted from Config pod
          die "Config is missing either sig_name or sig_num;  You must use a numeric signal"
              unless $Config{sig_name} and $Config{sig_num};
          my @names = split ' ', $Config{sig_name};
          @SIGnames{@names} = split ' ', $Config{sig_num};
      }
      return $SIGnames{ $name }+$X;
  }
  
  
  #########################################
  BEGIN {
      my $done;
      my $have_clock;
      if( _do_X( 'USE_POSIXRT' ) ) {
          eval {
              require File::Spec->catfile( qw( POSIX RT Clock.pm ) );
              require File::Spec->catfile( qw( POSIX RT Timer.pm ) );
              my $monoclock = POSIX::RT::Clock->new( 'monotonic' );
              my $wallclock = POSIX::RT::Clock->new( 'realtime' );
              *monotime = sub { return $monoclock->get_time(); };
              *walltime = sub { return $wallclock->get_time(); };
              *sleep = sub { $monoclock->sleep_deeply(@_) };
              if( _do_X( 'USE_STATIC_EPOCH' ) ) {
                  # This is where we cheat:  without a static epoch the tests fail
                  # because they expect alarm(), alarm_set() to arrive in order
                  # Calling _get_epoch() each time would preclude this
                  my $epoch = 0;
                  if( _do_X( 'USE_EXACT_EPOCH', 0 ) ) {
                      $epoch = _exact_epoch( $monoclock, $wallclock );
                  }
                  else {
                      $epoch = _get_epoch( $monoclock, $wallclock );
                  }
                  DEBUG and warn( "<ck> epoch=$epoch" );
                  *wall2mono = sub { $_[0] - $epoch };
                  *mono2wall = sub { $_[0] + $epoch };
              }
              else {
                  *wall2mono = sub { $_[0] - _get_epoch($monoclock, $wallclock) };
                  *mono2wall = sub { $_[0] + _get_epoch($monoclock, $wallclock) };
  
                  my ($rd, $wr) = POE::Pipe::OneWay->new();
                  die "Unable to build pipe: $!" unless defined $rd;
  
                  my $signal = _build_sig( $wr );
  
                  my $timer = POSIX::RT::Timer->new(
                    value    => 0,
                    interval => 0,
                    clock    => 'monotonic',
                    signal   => $signal
                  );
  
                  $EPSILON = $monoclock->get_resolution();
                  DEBUG and warn( "<ck> epsilon=$EPSILON" );
                  #*clock_pause  = sub { _rt_pause( $timer, @_ ); };
                  #*clock_reset  = sub { _rt_resume( Reset           = > $timer, @_ ); };
                  #*clock_resume = sub { _rt_resume( Resume          = > $timer, @_ ); };
                  #*clock_setup  = sub { _rt_setup( $rd, @_ ) };
                  my $frd = fileno( $rd );
                  #*clock_read = sub { _rt_ready( $rd, $frd, @_ ) };
                  $have_clock = 1;
              }
              $done = 1;
          };
          if( DEBUG ) {
              warn( "<ck> POSIX::RT::Clock not installed: $@" ) if $@;
              warn( "<ck> using POSIX::RT::Clock" ) if $done;
          }
      }
      if( !$done and _do_X( 'USE_HIRES' ) ) {
          eval {
              require File::Spec->catfile( qw( Time HiRes.pm ) );
              *monotime = \&Time::HiRes::time;
              *walltime = \&Time::HiRes::time;
              *sleep = \&Time::HiRes::sleep;
              *wall2mono = sub { return $_[0] };
              *mono2wall = sub { return $_[0] };
              $done = 1;
          };
          if( DEBUG ) {
              warn( "<ck> Time::HiRes not installed: $@" )if $@;
              warn( "<ck> using Time::HiRes" ) if $done;
          }
      }
      unless( $done ) {
          # \&CORE::time fails :-(
          *monotime = sub { CORE::time };
          *walltime = sub { CORE::time };
          *sleep = sub { CORE::sleep(@_) };
          *wall2mono = sub { return $_[0] };
          *mono2wall = sub { return $_[0] };
          warn( "<ck> using CORE::time" )if DEBUG;
      }
  
      unless( $have_clock ) {
          #*clock_pause  = sub { $_[0]->loop_pause_time_watcher() };
          #*clock_reset  = sub { $_[0]->loop_reset_time_watcher(mono2wall($_[1])) };
          #*clock_resume = sub { $_[0]->loop_resume_time_watcher(mono2wall($_[1])) };
          #*clock_setup  = sub { 0 };
          #*clock_read   = sub { 0 };
      }
  
      # *time = sub { Carp::confess( "This should be monotime" ) };
      *time = \&walltime;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Resource::Clock - internal clock used for ordering the queue
  
  =head1 SYNOPSIS
  
      sub POE::Kernel::USE_POSIXRT { 0 }
      use POE;
  
  =head1 DESCRIPTION
  
  POE::Resource::Clock is a helper module for POE::Kernel.  It provides the
  features to keep an internal monotonic clock and a wall clock.  It also
  converts between this monotonic clock and the wall clock.
  
  The monotonic clock is used to keep an ordered queue of events.  The wall
  clock is used to communicate the time with user code
  (L<POE::Kernel/alarm_set>, L<POE::Kernel/alarm_remove>).
  
  There are 3 possible clock sources in order of preference:
  L<POSIX::RT::Clock>, L<Time::HiRes> and L<perlfunc/time>.  Only
  C<POSIX::RT::Clock> has a separate monotonic and wall clock; the other two use the
  same source for both clocks.
  
  Clock selection and behaviour is controlled with the following:
  
  =head2 USE_POSIXRT
  
      export POE_USE_POSIXRT=0
          or
      sub POE::Kernel::USE_POSIXRT { 0 }
  
  Uses the C<monotonic> clock source for queue priority and the C<realtime>
  clock source for wall clock.  Not used if POSIX::RT::Clock is not installed
  or your system does not have a C<monotonic> clock.
  
  Defaults to true.  If you want the old POE behaviour, set this to 0.
  
  =head2 USE_STATIC_EPOCH
  
      export POE_USE_STATIC_EPOCH=0
          or
      sub POE::Kernel::USE_STATIC_EPOCH { 0 }
  
  The epoch of the POSIX::RT::Clock monotonic is different from that of the
  realtime clock.  For instance on Linux 2.6.18, the monotonic clock is the
  number of seconds since system boot.  This epoch is used to convert from
  walltime into monotonic time for L<POE::Kernel/alarm>,
  L<POE::Kernel/alarm_add> and L<POE::Kernel/alarm_set>. If
  C<USE_STATIC_EPOCH> is true (the default), then the epoch is calculated at
  load time.  If false, the epoch is calculated each time it is needed.
  
  Defaults to true.  Only relevant for if using POSIX::RT::Clock. Long-running
  POE servers should have this set to false so that system clock skew does
  mess up the queue.
  
  It is important to point out that without a static epoch, the ordering of
  the following two alarms is undefined.
  
      $poe_kernel->alarm_set( a1 => $time );
      $poe_kernel->alarm_set( a2 => $time );
  
  =head2 USE_EXACT_EPOCH
  
      export POE_USE_EXACT_EPOCH=1
          or
      sub POE::Kernel::USE_EXACT_EPOCH { 1 }
  
  There currently no way to exactly get the monotonic clock's epoch.  Instead
  the difference between the current monotonic clock value to the realtime
  clock's value is used.  This is obviously inexact because there is a slight
  delay between the 2 system calls.  Setting USE_EXACT_EPOCH to true will
  calculate an average of this difference over 250 ms or at least 20 samples.
  What's more, the system calls are done in both orders (monotonic then
  realtime, realtime then monotonic) to try and get a more exact value.
  
  Defaults to false.  Only relevant if L</USE_STATIC_EPOCH> is true.
  
  =head2 USE_HIRES
  
      export POE_USE_HIRES=0
          or
      sub POE::Kernel::USE_HIRES { 0 }
  
  Use L<Time::HiRes> as both monotonic and wall clock source.  This was POE's
  previous default clock.
  
  Defaults to true.  Only relevant if L</USE_POSIXRT> is false.  Set this to false to use
  L<perlfunc/time>.
  
  =head1 EXPORTS
  
  This module optionally exports a few timekeeping helper functions.
  
  =head2 mono2wall
  
  mono2wall() converts a monotonic time to an epoch wall time.
  
    my $wall = mono2wall( $monotonic );
  
  =head2 monotime
  
  monotime() makes a best-effort attempt to return the time from a
  monotonic system clock.  It may fall back to non-monotonic time if
  there are no monotonic clocks available.
  
    my $monotonic = monotime();
  
  =head2 sleep
  
  sleep() makes a best-effort attempt to sleep a particular amount of
  high-resolution time using a monotonic clock.  This feature will
  degrade gracefully to non-monotonic high-resolution clocks, then
  low-resolution clocks, depending on available libraries.
  
    sleep( 3.141 );
  
  =head2 time
  
  time() is a backwards compatible alias for walltime().  Please see
  walltime()'s documentation for details.
  
  =head2 wall2mono
  
  wall2mono() makes a best-effort attempt to convert wall time to its
  equivalent monotonic-clock time.  Its feature degrades gracefully
  depending on clock availability.
  
    my $monotonic = wall2mono( $epoch );
  
  =head2 walltime
  
  time() makes a best-effort attempt to return non-monotonic wall time
  at the highest available resolution known.
  
    my $epoch = walltime();
  
  =head1 SEE ALSO
  
  See L<POE::Resource> for general discussion about resources and the
  classes that manage them.
  
  =head1 BUGS
  
  None known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_RESOURCE_CLOCK

$fatpacked{"POE/Resource/Events.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_RESOURCE_EVENTS';
  # Data and accessors to manage POE's events.
  
  package POE::Resource::Events;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  # These methods are folded into POE::Kernel;
  package POE::Kernel;
  
  use strict;
  
  # A local copy of the queue so we can manipulate it directly.
  my $kr_queue;
  
  my %event_count;
  #  ( $session_id => $count,
  #    ...,
  #  );
  
  my %post_count;
  #  ( $session_id => $count,
  #    ...,
  #  );
  
  ### Begin-run initialization.
  
  sub _data_ev_initialize {
    my ($self, $queue) = @_;
    $kr_queue = $queue;
  }
  
  ### End-run leak checking.
  
  sub _data_ev_relocate_kernel_id {
    my ($self, $old_id, $new_id) = @_;
  
    $event_count{$new_id} = delete $event_count{$old_id}
      if exists $event_count{$old_id};
    $post_count{$new_id} = delete $post_count{$old_id}
      if exists $post_count{$old_id};
  }
  
  sub _data_ev_finalize {
    my $finalized_ok = 1;
    while (my ($ses_id, $cnt) = each(%event_count)) {
      $finalized_ok = 0;
      _warn("!!! Leaked event-to count: $ses_id = $cnt\n");
    }
  
    while (my ($ses_id, $cnt) = each(%post_count)) {
      $finalized_ok = 0;
      _warn("!!! Leaked event-from count: $ses_id = $cnt\n");
    }
    return $finalized_ok;
  }
  
  ### Enqueue an event.
  
  sub FIFO_TIME_EPSILON () { 0.000001 }
  my $last_fifo_time = monotime();
  
  sub _data_ev_enqueue {
    my (
      $self,
      $session, $source_session, $event, $type, $etc,
      $file, $line, $fromstate, $time, $delta, $priority
    ) = @_;
  
    my $sid = $session->ID;
  
    if (ASSERT_DATA) {
      unless ($self->_data_ses_exists($sid)) {
        _trap(
          "<ev> can't enqueue event ``$event'' for nonexistent",
          $self->_data_alias_loggable($sid)
        );
      }
    }
  
    # This is awkward, but faster than using the fields individually.
    my $event_to_enqueue = [ @_[(1+EV_SESSION) .. (1+EV_FROMSTATE)] ];
    if( defined $time ) {
      $event_to_enqueue->[EV_WALLTIME] = $time;
      $event_to_enqueue->[EV_DELTA]    = $delta;
      $priority ||= wall2mono( $time + ($delta||0) );
    }
    else {
      $priority ||= monotime();
    }
  
    my $new_id;
    my $old_head_priority = $kr_queue->get_next_priority();
  
    unless ($type & ET_MASK_DELAYED) {
      $priority = $last_fifo_time + FIFO_TIME_EPSILON if $priority <= $last_fifo_time;
      $last_fifo_time = $priority;
    }
  
    $new_id = $kr_queue->enqueue($priority, $event_to_enqueue);
    $event_to_enqueue->[EV_SEQ] = $new_id;
  
    #_carp( Carp::longmess( "<ev> priority is much to far in the future" ) ) if $priority > 1354569908;
    if (TRACE_EVENTS ) {
      _warn(
        "<ev> enqueued event $new_id ``$event'' from ",
        $self->_data_alias_loggable($source_session->ID), " to ",
        $self->_data_alias_loggable($sid),
        " at $time, priority=$priority"
      );
    }
  
    unless (defined $old_head_priority) {
      $self->loop_resume_time_watcher($priority);
    }
    elsif ($priority < $old_head_priority) {
      $self->loop_reset_time_watcher($priority);
    }
  
    # This is the counterpart to _data_ev_refcount_dec().  It's only
    # used in one place, so it's not in its own function.
  
    $self->_data_ses_refcount_inc($sid) unless $event_count{$sid}++;
  
    return $new_id if $sid eq $source_session->ID();
  
    $self->_data_ses_refcount_inc($source_session->ID) unless (
      $post_count{$source_session->ID}++
    );
  
    return $new_id;
  }
  
  sub _data_ev_set
  {
      my( $self, $alarm_id, $my_alarm, $time, $pri, $delta ) = @_;
  
      my $event = (
        grep { $_->[1] == $alarm_id }
        $kr_queue->peek_items( $my_alarm )
      )[0];
  
      return unless $event;
  
      my $payload = $event->[ITEM_PAYLOAD];
  
      # XXX - However, if there has been a clock skew, the priority will
      # have changed and we should recalculate priority from time+delta
  
      $delta = $payload->[EV_DELTA] || 0 unless defined $delta;
      $kr_queue->set_priority( $alarm_id, $my_alarm, $pri+$delta );
      $payload->[EV_WALLTIME] = $time;
      $payload->[EV_DELTA]    = $delta;
  
      return( ($payload->[EV_WALLTIME] || 0) + ($payload->[EV_DELTA] || 0) );
  }
  
  sub _data_ev_adjust
  {
      my( $self, $alarm_id, $my_alarm, $time, $delta ) = @_;
  
      # XXX - However, if there has been a clock skew, the priority will
      # have changed and we should recalculate priority from time+delta
      if( $time ) {
          # PG - We are never invoked with $time anyway.  
          $kr_queue->set_priority( $alarm_id, $my_alarm, $time+$delta );
      }
      else {
          $kr_queue->adjust_priority( $alarm_id, $my_alarm, $delta );
      }
  
      my $event = (
        grep { $_->[1] == $alarm_id }
        $kr_queue->peek_items( $my_alarm )
      )[0];
  
      return unless $event;
  
      my $payload = $event->[ITEM_PAYLOAD];
  
      $payload->[EV_WALLTIME] = $time if $time;
      $payload->[EV_DELTA] += $delta  if $delta;
  
      return( ($payload->[EV_WALLTIME] || 0) + ($payload->[EV_DELTA] || 0) );
  }
  
  ### Remove events sent to or from a specific session.
  
  sub _data_ev_clear_session {
    my ($self, $sid) = @_;
  
    # Events sent to the session.
    PENDING: {
      my $pending_count = $event_count{$sid};
      last PENDING unless $pending_count;
  
      foreach (
        $kr_queue->remove_items(
          sub { $_[0][EV_SESSION]->ID() eq $sid },
          $pending_count
        )
      ) {
        $self->_data_ev_refcount_dec(
          @{$_->[ITEM_PAYLOAD]}[EV_SOURCE, EV_SESSION]
        );
        $pending_count--;
      }
  
      # TODO - fork() can make this go negative on some systems.
      last PENDING unless $pending_count;
  
      croak "lingering pending count: $pending_count" if $pending_count;
    }
  
    # Events sent by the session.
    SENT: {
      my $sent_count = $post_count{$sid};
      last SENT unless $sent_count;
  
      foreach (
        $kr_queue->remove_items(
          sub { $_[0][EV_SOURCE]->ID() eq $sid },
          $sent_count
        )
      ) {
        $self->_data_ev_refcount_dec(
          @{$_->[ITEM_PAYLOAD]}[EV_SOURCE, EV_SESSION]
        );
        $sent_count--;
      }
  
      last SENT unless $sent_count;
  
      croak "lingering sent count: $sent_count" if $sent_count;
    }
  
    croak "lingering event count" if delete $event_count{$sid};
    croak "lingering post count" if delete $post_count{$sid};
  }
  
  # TODO Alarm maintenance functions may move out to a separate
  # POE::Resource module in the future.  Why?  Because alarms may
  # eventually be managed by something other than the event queue.
  # Especially if we incorporate a proper Session scheduler.  Be sure to
  # move the tests to a corresponding t/res/*.t file.
  
  ### Remove a specific alarm by its name.  This is in the events
  ### section because alarms are currently implemented as events with
  ### future due times.
  
  sub _data_ev_clear_alarm_by_name {
    my ($self, $sid, $alarm_name) = @_;
  
    my $my_alarm = sub {
      return 0 unless $_[0]->[EV_TYPE] & ET_ALARM;
      return 0 unless $_[0]->[EV_SESSION]->ID() eq $sid;
      return 0 unless $_[0]->[EV_NAME] eq $alarm_name;
      return 1;
    };
  
    foreach ($kr_queue->remove_items($my_alarm)) {
      $self->_data_ev_refcount_dec(@{$_->[ITEM_PAYLOAD]}[EV_SOURCE, EV_SESSION]);
    }
  }
  
  ### Remove a specific alarm by its ID.  This is in the events section
  ### because alarms are currently implemented as events with future due
  ### times.  TODO It's possible to remove non-alarms; is that wrong?
  
  sub _data_ev_clear_alarm_by_id {
    my ($self, $sid, $alarm_id) = @_;
  
    my $my_alarm = sub {
      $_[0]->[EV_SESSION]->ID() eq $sid;
    };
  
    my ($pri, $id, $event) = $kr_queue->remove_item($alarm_id, $my_alarm);
    return unless defined $pri;
  
    if (TRACE_EVENTS) {
      _warn(
        "<ev> removed event $id ``", $event->[EV_NAME], "'' to ",
        $self->_data_alias_loggable($sid), " at $pri"
      );
    }
  
    $self->_data_ev_refcount_dec( @$event[EV_SOURCE, EV_SESSION] );
    my $time = $event->[EV_WALLTIME] + ($event->[EV_DELTA]||0);
    return ($time, $event);
  }
  
  ### Remove all the alarms for a session.  Whoot!
  
  sub _data_ev_clear_alarm_by_session {
    my ($self, $sid) = @_;
  
    my $my_alarm = sub {
      return 0 unless $_[0]->[EV_TYPE] & ET_ALARM;
      return 0 unless $_[0]->[EV_SESSION]->ID() eq $sid;
      return 1;
    };
  
    my @removed;
    foreach ($kr_queue->remove_items($my_alarm)) {
      my ($pri, $event) = @$_[ITEM_PRIORITY, ITEM_PAYLOAD];
      $self->_data_ev_refcount_dec( @$event[EV_SOURCE, EV_SESSION] );
      my $time = ($event->[EV_WALLTIME]||0) + ($event->[EV_DELTA]||0);
      push @removed, [ $event->[EV_NAME], $time, @{$event->[EV_ARGS]} ];
    }
  
    return @removed;
  }
  
  ### Decrement a post refcount
  
  sub _data_ev_refcount_dec {
    my ($self, $source_session, $dest_session) = @_;
  
    my ($source_id, $dest_id) = ($source_session->ID, $dest_session->ID);
  
    if (ASSERT_DATA) {
      _trap $dest_session unless exists $event_count{$dest_id};
    }
  
    $self->_data_ses_refcount_dec($dest_id) unless --$event_count{$dest_id};
  
    return if $dest_id eq $source_id;
  
    if (ASSERT_DATA) {
      _trap $source_session unless exists $post_count{$source_id};
    }
  
    $self->_data_ses_refcount_dec($source_id) unless --$post_count{$source_id};
  }
  
  ### Fetch the number of pending events sent to a session.
  
  sub _data_ev_get_count_to {
    my ($self, $sid) = @_;
    return $event_count{$sid} || 0;
  }
  
  ### Fetch the number of pending events sent from a session.
  
  sub _data_ev_get_count_from {
    my ($self, $sid) = @_;
    return $post_count{$sid} || 0;
  }
  
  ### Dispatch events that are due for "now" or earlier.
  
  sub _data_ev_dispatch_due {
    my $self = shift;
  
    if (TRACE_EVENTS) {
      foreach ($kr_queue->peek_items(sub { 1 })) {
        my @event = map { defined() ? $_ : "(undef)" } @{$_->[ITEM_PAYLOAD]};
        _warn(
          "<ev> time($_->[ITEM_PRIORITY]) id($_->[ITEM_ID]) ",
          "event(@event)\n"
        );
      }
    }
  
    my $now = monotime();
    my $next_time;
    while (
      defined($next_time = $kr_queue->get_next_priority()) and
      $next_time <= $now
    ) {
      my ($priority, $id, $event) = $kr_queue->dequeue_next();
  
      if (TRACE_EVENTS) {
        _warn("<ev> dispatching event $id ($event->[EV_NAME])");
      }
  
      # TODO - Why can't we reverse these two lines?
      # TODO - Reversing them could avoid entering and removing GC marks.
      $self->_data_ev_refcount_dec($event->[EV_SOURCE], $event->[EV_SESSION]);
  
      if ($event->[EV_TYPE] & ET_SIGNAL) {
        $self->_dispatch_signal_event(@{$event}[EV_SESSION..EV_FROMSTATE], $priority, $id);
      }
      else {
        $self->_dispatch_event(@{$event}[EV_SESSION..EV_FROMSTATE], $priority, $id);
      }
  
      # Stop the system if an unhandled exception occurred.
      # This wipes out all sessions and associated resources.
      next unless $POE::Kernel::kr_exception;
      POE::Kernel->stop();
    }
  
    # Sweep for dead sessions.  The sweep may alter the next queue time.
  
    $self->_data_ses_gc_sweep();
    $next_time = $kr_queue->get_next_priority();
  
    # Tell the event loop to wait for the next event, if there is one.
    # Otherwise we're going to wait indefinitely for some other event.
  
    if (defined $next_time) {
      $self->loop_reset_time_watcher($next_time);
    }
    else {
      $self->loop_pause_time_watcher();
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Resource::Events - internal event manager for POE::Kernel
  
  =head1 SYNOPSIS
  
  There is no public API.
  
  =head1 DESCRIPTION
  
  POE::Resource::Events is a mix-in class for POE::Kernel.  It hides the
  complexity of managing POE's events from even POE itself.  It is used
  internally by POE::Kernel, so it has no public interface.
  
  =head1 SEE ALSO
  
  See L<POE::Kernel/Asynchronous Messages (FIFO Events)> for one public
  events API.
  
  See L<POE::Kernel/Resources> for public information about POE
  resources.
  
  See L<POE::Resource> for general discussion about resources and the
  classes that manage them.
  
  =head1 BUGS
  
  None known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_RESOURCE_EVENTS

$fatpacked{"POE/Resource/Extrefs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_RESOURCE_EXTREFS';
  # The data necessary to manage tagged extra/external reference counts
  # on sessions, and the accessors to get at them sanely from other
  # files.
  
  package POE::Resource::Extrefs;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  # These methods are folded into POE::Kernel;
  package POE::Kernel;
  
  use strict;
  
  ### The count of all extra references used in the system.
  
  my %kr_extra_refs;
  #  ( $session_id =>
  #    { $tag => $count,
  #       ...,
  #     },
  #     ...,
  #   );
  
  sub _data_extref_relocate_kernel_id {
    my ($self, $old_id, $new_id) = @_;
    return unless exists $kr_extra_refs{$old_id};
    $kr_extra_refs{$new_id} = delete $kr_extra_refs{$old_id};
  }
  
  ### End-run leak checking.
  
  sub _data_extref_finalize {
    my $finalized_ok = 1;
    foreach my $session_id (keys %kr_extra_refs) {
      $finalized_ok = 0;
      _warn "!!! Leaked extref: $session_id\n";
      foreach my $tag (keys %{$kr_extra_refs{$session_id}}) {
        _warn "!!!\t`$tag' = $kr_extra_refs{$session_id}->{$tag}\n";
      }
    }
    return $finalized_ok;
  }
  
  # Increment a session's tagged reference count.  If this is the first
  # time the tag is used in the session, then increment the session's
  # reference count as well.  Returns the tag's new reference count.
  #
  # TODO Allows incrementing reference counts on sessions that don't
  # exist, but the public interface catches that.
  #
  # TODO Need to track extref ownership for signal-based session
  # termination.  One problem seen is that signals terminate sessions
  # out of order.  Owners think extra refcounts exist for sessions that
  # are no longer around.  Ownership trees give us a few benefits: We
  # can make sure sessions destruct in a cleaner order.  We can detect
  # refcount loops and possibly prevent that.
  
  sub _data_extref_inc {
    my ($self, $sid, $tag) = @_;
    my $refcount = ++$kr_extra_refs{$sid}->{$tag};
  
    # TODO We could probably get away with only incrementing the
    # session's master refcount once, as long as any extra refcount is
    # positive.  Then the session reference count would be a flag
    # instead of a counter.
    $self->_data_ses_refcount_inc($sid) if $refcount == 1;
  
    if (TRACE_REFCNT) {
      _warn(
        "<rc> incremented extref ``$tag'' (now $refcount) for ",
        $self->_data_alias_loggable($sid)
      );
    }
  
    return $refcount;
  }
  
  # Decrement a session's tagged reference count, removing it outright
  # if the count reaches zero.  Return the new reference count or undef
  # if the tag doesn't exist.
  #
  # TODO Allows negative reference counts, and the resulting hilarity.
  # Hopefully the public interface won't allow it.
  
  sub _data_extref_dec {
    my ($self, $sid, $tag) = @_;
  
    if (ASSERT_DATA) {
      # Prevents autoviv.
      _trap("<dt> decrementing extref for session without any")
        unless exists $kr_extra_refs{$sid};
  
      unless (exists $kr_extra_refs{$sid}->{$tag}) {
        _trap(
          "<dt> decrementing extref for nonexistent tag ``$tag'' in ",
          $self->_data_alias_loggable($sid)
        );
      }
    }
  
    my $refcount = --$kr_extra_refs{$sid}->{$tag};
  
    if (TRACE_REFCNT) {
      _warn(
        "<rc> decremented extref ``$tag'' (now $refcount) for ",
        $self->_data_alias_loggable($sid)
      );
    }
  
    $self->_data_extref_remove($sid, $tag) unless $refcount;
    return $refcount;
  }
  
  ### Remove an extra reference from a session, regardless of its count.
  
  sub _data_extref_remove {
    my ($self, $sid, $tag) = @_;
  
    if (ASSERT_DATA) {
      # Prevents autoviv.
      _trap("<dt> removing extref from session without any")
        unless exists $kr_extra_refs{$sid};
      unless (exists $kr_extra_refs{$sid}->{$tag}) {
        _trap(
          "<dt> removing extref for nonexistent tag ``$tag'' in ",
          $self->_data_alias_loggable($sid)
        );
      }
    }
  
    delete $kr_extra_refs{$sid}->{$tag};
    delete $kr_extra_refs{$sid} unless scalar keys %{$kr_extra_refs{$sid}};
    $self->_data_ses_refcount_dec($sid);
  }
  
  ### Clear all the extra references from a session.
  
  sub _data_extref_clear_session {
    my ($self, $sid) = @_;
  
    # TODO - Should there be a _trap here if the session doesn't exist?
  
    return unless exists $kr_extra_refs{$sid}; # avoid autoviv
    foreach (keys %{$kr_extra_refs{$sid}}) {
      $self->_data_extref_remove($sid, $_);
    }
  
    if (ASSERT_DATA) {
      if (exists $kr_extra_refs{$sid}) {
        _trap(
          "<dt> extref clear did not remove session ",
          $self->_data_alias_loggable($sid)
        );
      }
    }
  }
  
  # Fetch the number of sessions with extra references held in the
  # entire system.
  
  sub _data_extref_count {
    return scalar keys %kr_extra_refs;
  }
  
  # Fetch whether a session has extra references.
  
  sub _data_extref_count_ses {
    my ($self, $sid) = @_;
    return 0 unless exists $kr_extra_refs{$sid};
    return scalar keys %{$kr_extra_refs{$sid}};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Resource::Extrefs - internal reference counts manager for POE::Kernel
  
  =head1 SYNOPSIS
  
  There is no public API.
  
  =head1 DESCRIPTION
  
  POE::Resource::Extrefs is a mix-in class for POE::Kernel.  It provides
  the features to manage session reference counts, specifically the ones
  that applications may use.  POE::Resource::Extrefs is used internally
  by POE::Kernel, so it has no public interface.
  
  =head1 SEE ALSO
  
  See L<POE::Kernel/Public Reference Counters> for the public extref
  API.
  
  See L<POE::Kernel/Resources> for public information about POE
  resources.
  
  See L<POE::Resource> for general discussion about resources and the
  classes that manage them.
  
  =head1 BUGS
  
  Reference counters have no ownership information, so one entity's
  reference counts may conflict with another's.  This is usually not a
  problem if all entities behave.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_RESOURCE_EXTREFS

$fatpacked{"POE/Resource/FileHandles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_RESOURCE_FILEHANDLES';
  # Manage file handles, associated descriptors, and read/write modes
  # thereon.
  
  package POE::Resource::FileHandles;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  # These methods are folded into POE::Kernel;
  package POE::Kernel;
  
  use strict;
  
  use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
  use IO::Handle ();
  use FileHandle ();
  
  ### Some portability things.
  
  # Provide dummy constants so things at least compile.  These constants
  # aren't used if we're RUNNING_IN_HELL, but Perl needs to see them.
  
  BEGIN {
    # older perls than 5.10 needs a kick in the arse to AUTOLOAD the constant...
    eval "F_GETFL" if $] < 5.010;
  
    if ( ! defined &Fcntl::F_GETFL ) {
      if ( ! defined prototype "F_GETFL" ) {
        *F_GETFL = sub { 0 };
        *F_SETFL = sub { 0 };
      } else {
        *F_GETFL = sub () { 0 };
        *F_SETFL = sub () { 0 };
      }
    }
  }
  
  ### A local reference to POE::Kernel's queue.
  
  my $kr_queue;
  
  ### Fileno structure.  This tracks the sessions that are watching a
  ### file, by its file number.  It used to track by file handle, but
  ### several handles can point to the same underlying fileno.  This is
  ### more unique.
  
  my %kr_filenos;
  BEGIN { $poe_kernel->[KR_FILENOS] = \%kr_filenos; }
  
  sub FNO_MODE_RD      () { MODE_RD } # [ [ (fileno read mode structure)
  # --- BEGIN SUB STRUCT 1 ---        #
  sub FMO_REFCOUNT     () { 0      }  #     $fileno_total_use_count,
  sub FMO_ST_ACTUAL    () { 1      }  #     $requested_file_state (see HS_PAUSED)
  sub FMO_SESSIONS     () { 2      }  #     { $session_id =>
                                      #       { $file_descriptor =>
  # --- BEGIN SUB STRUCT 2 ---        #
  sub HSS_HANDLE       () { 0      }  #         [ $blessed_handle,
  sub HSS_SESSION      () { 1      }  #           $blessed_session,
  sub HSS_STATE        () { 2      }  #           $event_name,
  sub HSS_ARGS         () { 3      }  #           \@callback_arguments
                                      #         ],
                                      #       },
  # --- CEASE SUB STRUCT 2 ---        #     },
  # --- CEASE SUB STRUCT 1 ---        #   ],
                                      #
  sub FNO_MODE_WR      () { MODE_WR } #   [ (write mode structure is the same)
                                      #   ],
                                      #
  sub FNO_MODE_EX      () { MODE_EX } #   [ (expedite mode struct is the same)
                                      #   ],
                                      #
  sub FNO_TOT_REFCOUNT () { 3      }  #   $total_number_of_file_watchers,
                                      # ]
  
  ### These are the values for FMO_ST_ACTUAL.
  
  sub HS_STOPPED   () { 0x00 }   # The file has stopped generating events.
  sub HS_PAUSED    () { 0x01 }   # The file temporarily stopped making events.
  sub HS_RUNNING   () { 0x02 }   # The file is running and can generate events.
  
  ### Handle to session.
  
  my %kr_ses_to_handle;
                              #    { $session_id =>
                              #      $fileno =>
  # --- BEGIN SUB STRUCT ---  #        [
  sub SH_HANDLE     () {  0 } #          $blessed_file_handle,
  sub SH_REFCOUNT   () {  1 } #          $total_reference_count,
  sub SH_MODECOUNT  () {  2 } #          [ $read_reference_count,     (MODE_RD)
                              #            $write_reference_count,    (MODE_WR)
                              #            $expedite_reference_count, (MODE_EX)
  # --- CEASE SUB STRUCT ---  #          ],
                              #        ],
                              #        ...
                              #      },
                              #    },
  
  sub _data_handle_relocate_kernel_id {
    my ($self, $old_id, $new_id) = @_;
  
    foreach my $fd_rec (values %kr_filenos) {
      my $rd_rec = $fd_rec->[FNO_MODE_RD][FMO_SESSIONS];
      $rd_rec->{$new_id} = delete $rd_rec->{$old_id} if exists $rd_rec->{$old_id};
  
      my $wr_rec = $fd_rec->[FNO_MODE_WR][FMO_SESSIONS];
      $wr_rec->{$new_id} = delete $wr_rec->{$old_id} if exists $wr_rec->{$old_id};
  
      my $ex_rec = $fd_rec->[FNO_MODE_EX][FMO_SESSIONS];
      $ex_rec->{$new_id} = delete $ex_rec->{$old_id} if exists $ex_rec->{$old_id};
    }
  
    $kr_ses_to_handle{$new_id} = delete $kr_ses_to_handle{$old_id}
      if exists $kr_ses_to_handle{$old_id};
  }
  
  ### Begin-run initialization.
  
  sub _data_handle_initialize {
    my ($self, $queue) = @_;
    $kr_queue = $queue;
  }
  
  ### End-run leak checking.
  
  sub _data_handle_finalize {
    my $finalized_ok = 1;
  
    while (my ($fd, $fd_rec) = each(%kr_filenos)) {
      my ($rd, $wr, $ex, $tot) = @$fd_rec;
      $finalized_ok = 0;
  
      _warn "!!! Leaked fileno: $fd (total refcnt=$tot)\n";
  
      _warn(
        "!!!\tRead:\n",
        "!!!\t\trefcnt  = $rd->[FMO_REFCOUNT]\n",
      );
      while (my ($sid, $ses_rec) = each(%{$rd->[FMO_SESSIONS]})) {
        _warn "!!!\t\tsession $sid\n";
        while (my ($fd, $hnd_rec) = each(%{$ses_rec})) {
          _warn(
            "!!!\t\t\thandle  = $hnd_rec->[HSS_HANDLE]\n",
            "!!!\t\t\tsession = $hnd_rec->[HSS_SESSION]\n",
            "!!!\t\t\tevent   = $hnd_rec->[HSS_STATE]\n",
            "!!!\t\t\targs    = (@{$hnd_rec->[HSS_ARGS]})\n",
          );
        }
      }
  
      _warn(
        "!!!\tWrite:\n",
        "!!!\t\trefcnt  = $wr->[FMO_REFCOUNT]\n",
      );
      while (my ($sid, $ses_rec) = each(%{$wr->[FMO_SESSIONS]})) {
        _warn "!!!\t\tsession = $sid\n";
        while (my ($fd, $hnd_rec) = each(%{$ses_rec})) {
          _warn(
            "!!!\t\t\thandle  = $hnd_rec->[HSS_HANDLE]\n",
            "!!!\t\t\tsession = $hnd_rec->[HSS_SESSION]\n",
            "!!!\t\t\tevent   = $hnd_rec->[HSS_STATE]\n",
            "!!!\t\t\targs    = (@{$hnd_rec->[HSS_ARGS]})\n",
          );
        }
      }
  
      _warn(
        "!!!\tException:\n",
        "!!!\t\trefcnt  = $ex->[FMO_REFCOUNT]\n",
      );
      while (my ($sid, $ses_rec) = each(%{$ex->[FMO_SESSIONS]})) {
        _warn "!!!\t\tsession = $sid\n";
        while (my ($fd, $hnd_rec) = each(%{$ses_rec})) {
          _warn(
            "!!!\t\t\thandle  = $hnd_rec->[HSS_HANDLE]\n",
            "!!!\t\t\tsession = $hnd_rec->[HSS_SESSION]\n",
            "!!!\t\t\tevent   = $hnd_rec->[HSS_STATE]\n",
            "!!!\t\t\targs    = (@{$hnd_rec->[HSS_ARGS]})\n",
          );
        }
      }
    }
  
    while (my ($ses_id, $hnd_rec) = each(%kr_ses_to_handle)) {
      $finalized_ok = 0;
      _warn "!!! Leaked file descriptor in $ses_id\n";
      while (my ($fd, $rc) = each(%$hnd_rec)) {
        _warn(
          "!!!\tDescriptor: $fd (tot refcnt=$rc->[SH_REFCOUNT])\n",
          "!!!\t\tRead      refcnt: $rc->[SH_MODECOUNT]->[MODE_RD]\n",
          "!!!\t\tWrite     refcnt: $rc->[SH_MODECOUNT]->[MODE_WR]\n",
          "!!!\t\tException refcnt: $rc->[SH_MODECOUNT]->[MODE_EX]\n",
        );
      }
    }
  
    return $finalized_ok;
  }
  
  ### Enqueue "select" events for a list of file descriptors in a given
  ### access mode.
  
  sub _data_handle_enqueue_ready {
    my ($self, $mode) = splice(@_, 0, 2);
  
    my $now = monotime();
    foreach my $fileno (@_) {
      if (ASSERT_DATA) {
        _trap "internal inconsistency: undefined fileno" unless defined $fileno;
      }
  
      # By-pass the event queue for things that come over the pipe:
      # this reduces signal latency
      if( USE_SIGNAL_PIPE ) {
        # _warn "fileno=$fileno signal_pipe_read=$POE::Kernel::signal_pipe_read_fd";
        if( $fileno == $POE::Kernel::signal_pipe_read_fd ) {
          $self->_data_sig_pipe_read( $fileno, $mode );
          next;
        }
      }
  
      # Avoid autoviviying an empty $kr_filenos record if the fileno has
      # been deactivated.  This can happen if a file descriptor is ready
      # in multiple modes, and an earlier dispatch removes it before a
      # later dispatch happens.
      next unless exists $kr_filenos{$fileno};
  
      # Gather and dispatch all the events for this fileno/mode pair.
  
      foreach my $select (
        map { values %$_ }
        values %{ $kr_filenos{$fileno}[$mode][FMO_SESSIONS] }
      ) {
        $self->_dispatch_event(
          $select->[HSS_SESSION], $select->[HSS_SESSION],
          $select->[HSS_STATE], ET_SELECT, [
            $select->[HSS_HANDLE],  # EA_SEL_HANDLE
            $mode,                  # EA_SEL_MODE
            @{$select->[HSS_ARGS]}, # EA_SEL_ARGS
          ],
          __FILE__, __LINE__, undef, $now, -__LINE__
        );
      }
    }
  
    $self->_data_ses_gc_sweep();
  }
  
  ### Test whether POE is tracking a file handle.
  
  sub _data_handle_is_good {
    my ($self, $handle, $mode) = @_;
  
    # Don't bother if the kernel isn't tracking the file.
    return 0 unless exists $kr_filenos{fileno $handle};
  
    # Don't bother if the kernel isn't tracking the file mode.
    return 0 unless $kr_filenos{fileno $handle}->[$mode]->[FMO_REFCOUNT];
  
    return 1;
  }
  
  ### Add a select to the session, and possibly begin a watcher.
  
  sub _data_handle_add {
    my ($self, $handle, $mode, $session, $event, $args) = @_;
    my $fd = fileno($handle);
  
    # First time watching the file descriptor.  Do some heavy setup.
    #
    # NB - This means we can't optimize away the delete() calls here and
    # there, because they probably ensure that the structure exists.
    unless (exists $kr_filenos{$fd}) {
  
      $kr_filenos{$fd} =
        [ [ 0,          # FMO_REFCOUNT    MODE_RD
            HS_PAUSED,  # FMO_ST_ACTUAL
            { },        # FMO_SESSIONS
          ],
          [ 0,          # FMO_REFCOUNT    MODE_WR
            HS_PAUSED,  # FMO_ST_ACTUAL
            { },        # FMO_SESSIONS
          ],
          [ 0,          # FMO_REFCOUNT    MODE_EX
            HS_PAUSED,  # FMO_ST_ACTUAL
            { },        # FMO_SESSIONS
          ],
          0,            # FNO_TOT_REFCOUNT
        ];
  
      if (TRACE_FILES) {
        _warn "<fh> adding $handle fd ($fd) in mode ($mode)";
      }
  
      $self->_data_handle_condition( $handle );
    }
  
    # Cache some high-level lookups.
    my $kr_fileno  = $kr_filenos{$fd};
    my $kr_fno_rec = $kr_fileno->[$mode];
  
    # The session is already watching this fileno in this mode.
  
    my $sid = $session->ID;
    if ($kr_fno_rec->[FMO_SESSIONS]->{$sid}) {
  
      # The session is also watching it by the same handle.  Treat this
      # as a "resume" in this mode.
  
      if (exists $kr_fno_rec->[FMO_SESSIONS]->{$sid}->{$fd}) {
        if (TRACE_FILES) {
          _warn("<fh> running $handle fileno($fd) mode($mode)");
        }
        $self->loop_resume_filehandle($handle, $mode);
        $kr_fno_rec->[FMO_ST_ACTUAL] = HS_RUNNING;
      }
  
      # The session is watching it by a different handle.  It can't be
      # done yet, but maybe later when drivers are added to the mix.
      #
      # TODO - This can occur if someone closes a filehandle without
      # calling select_foo() to deregister it from POE.  In that case,
      # the operating system reuses the file descriptor, but we still
      # have something registered for it here.
  
      else {
        foreach my $watch_sid (keys %{$kr_fno_rec->[FMO_SESSIONS]}) {
          foreach my $hdl_rec (
            values %{$kr_fno_rec->[FMO_SESSIONS]->{$watch_sid}}
          ) {
            my $other_handle = $hdl_rec->[HSS_HANDLE];
  
            my $why;
            unless (defined(fileno $other_handle)) {
              $why = "closed";
            }
            elsif (fileno($handle) == fileno($other_handle)) {
              $why = "open";
            }
            else {
              $why = "open with different file descriptor";
            }
  
            if ($sid eq $watch_sid) {
              _die(
                "A session was caught watching two different file handles that\n",
                "reference the same file descriptor in the same mode ($mode).\n",
                "This error is usually caused by a file descriptor leak.  The\n",
                "most common cause is explicitly closing a filehandle without\n",
                "first unregistering it from POE.\n",
                "\n",
                "Some possibly helpful information:\n",
                "  Session    : ",
                $self->_data_alias_loggable($sid), "\n",
                "  Old handle : $other_handle (currently $why)\n",
                "  New handle : $handle\n",
                "\n",
                "Please correct the program and try again.\n",
              );
            }
            else {
              _die(
                "Two sessions were caught watching the same file descriptor\n",
                "in the same mode ($mode).  This error is usually caused by\n",
                "a file descriptor leak.  The most common cause is explicitly\n",
                "closing a filehandle without first unregistering it from POE.\n",
                "\n",
                "Some possibly helpful information:\n",
                "  Old session: ",
                $self->_data_alias_loggable($hdl_rec->[HSS_SESSION]->ID), "\n",
                "  Old handle : $other_handle (currently $why)\n",
                "  New session: ",
                $self->_data_alias_loggable($sid), "\n",
                "  New handle : $handle\n",
                "\n",
                "Please correct the program and try again.\n",
              );
            }
          }
        }
        _trap "internal inconsistency";
      }
    }
  
    # The session is not watching this fileno in this mode.  Record
    # the session/handle pair.
  
    else {
      $kr_fno_rec->[FMO_SESSIONS]->{$sid}->{$fd} = [
        $handle,   # HSS_HANDLE
        $session,  # HSS_SESSION
        $event,    # HSS_STATE
        $args,     # HSS_ARGS
      ];
  
      # Fix reference counts.
      $kr_fileno->[FNO_TOT_REFCOUNT]++;
      $kr_fno_rec->[FMO_REFCOUNT]++;
  
      # If this is the first time a file is watched in this mode, then
      # have the event loop bridge watch it.
  
      if ($kr_fno_rec->[FMO_REFCOUNT] == 1) {
        $self->loop_watch_filehandle($handle, $mode);
        $kr_fno_rec->[FMO_ST_ACTUAL]  = HS_RUNNING;
      }
    }
  
    # If the session hasn't already been watching the filehandle, then
    # register the filehandle in the session's structure.
  
    unless (exists $kr_ses_to_handle{$sid}->{$fd}) {
      $kr_ses_to_handle{$sid}->{$fd} = [
        $handle,  # SH_HANDLE
        0,        # SH_REFCOUNT
        [ 0,      # SH_MODECOUNT / MODE_RD
          0,      # SH_MODECOUNT / MODE_WR
          0       # SH_MODECOUNT / MODE_EX
        ]
      ];
      $self->_data_ses_refcount_inc($sid);
    }
  
    # Modify the session's handle structure's reference counts, so the
    # session knows it has a reason to live.
  
    my $ss_handle = $kr_ses_to_handle{$sid}->{$fd};
    unless ($ss_handle->[SH_MODECOUNT]->[$mode]) {
      $ss_handle->[SH_MODECOUNT]->[$mode]++;
      $ss_handle->[SH_REFCOUNT]++;
    }
  }
  
  ### Condition a file handle so that it is ready for select et al
  sub _data_handle_condition {
      my( $self, $handle ) = @_;
  
      # For DOSISH systems like OS/2.  Wrapped in eval{} in case it's a
      # tied handle that doesn't support binmode.
      eval { binmode *$handle };
  
      # Turn off blocking on the handle.  Requires a sufficiently
      # advanced Perl as not to be broken.  Otherwise we must skip tied
      # filehandles or plain files.
      #
      # Perl-5.6.2 and older seem to hate tied FHs or plain files, so we
      # be careful!
      #
      # ok 115 - regular file: handle removed fully
      # Bad filehandle: GEN11
      #   at /home/cpan/poe/blib/lib/POE/Resource/FileHandles.pm line 442.
      # Compilation failed in require
      #   at t/20_resources/10_perl/filehandles.t line 9.
  
      IO::Handle::blocking($handle, 0) if (
        $] >= 5.008001 or not (tied *$handle or -f $handle)
      );
  
      # Turn off buffering.
      # you may be tempted to use $handle->autoflush(1) BUT DON'T DO THAT! ( things blow up )
      CORE::select((CORE::select($handle), $| = 1)[0]);
  }
  
  ### Remove a select from the kernel, and possibly trigger the
  ### session's destruction.
  
  sub _data_handle_remove {
    my ($self, $handle, $mode, $sid) = @_;
    my $fd = fileno($handle);
  
    # Make sure the handle is deregistered with the kernel.
  
    if (defined($fd) and exists($kr_filenos{$fd})) {
      my $kr_fileno  = $kr_filenos{$fd};
      my $kr_fno_rec = $kr_fileno->[$mode];
  
      # Make sure the handle was registered to the requested session.
  
      if (
        exists($kr_fno_rec->[FMO_SESSIONS]->{$sid}) and
        exists($kr_fno_rec->[FMO_SESSIONS]->{$sid}->{$fd})
      ) {
  
        TRACE_FILES and
          _warn(
            "<fh> removing handle ($handle) fileno ($fd) mode ($mode) from " .
            $self->_data_alias_loggable($sid) . Carp::shortmess()
          );
  
        # Remove the handle from the kernel's session record.
  
        my $handle_rec = delete $kr_fno_rec->[FMO_SESSIONS]->{$sid}->{$fd};
  
        my $kill_session = $handle_rec->[HSS_SESSION];
        my $kill_event   = $handle_rec->[HSS_STATE];
  
        # Remove any events destined for that handle.
        my $my_select = sub {
          return 0 unless $_[0]->[EV_TYPE]    &  ET_SELECT;
          return 0 unless $_[0]->[EV_SESSION] == $kill_session;
          return 0 unless $_[0]->[EV_NAME]    eq $kill_event;
          return 0 unless $_[0]->[EV_ARGS]->[EA_SEL_HANDLE] == $handle;
          return 0 unless $_[0]->[EV_ARGS]->[EA_SEL_MODE]   == $mode;
          return 1;
        };
  
        foreach ($kr_queue->remove_items($my_select)) {
          my ($time, $id, $event) = @$_;
          $self->_data_ev_refcount_dec(
            $event->[EV_SOURCE]->ID(),
            $event->[EV_SESSION]->ID(),
          );
  
          TRACE_EVENTS and _warn(
            "<ev> removing select event $id ``$event->[EV_NAME]''" .
            Carp::shortmess
          );
        }
  
        # Decrement the handle's reference count.
  
        $kr_fno_rec->[FMO_REFCOUNT]--;
  
        if (ASSERT_DATA) {
          _trap "<dt> fileno mode refcount went below zero"
            if $kr_fno_rec->[FMO_REFCOUNT] < 0;
        }
  
        # If the "mode" count drops to zero, then stop selecting the
        # handle.
  
        unless ($kr_fno_rec->[FMO_REFCOUNT]) {
          $self->loop_ignore_filehandle($handle, $mode);
          $kr_fno_rec->[FMO_ST_ACTUAL]  = HS_STOPPED;
  
          # The session is not watching handles anymore.  Remove the
          # session entirely the fileno structure.
          delete $kr_fno_rec->[FMO_SESSIONS]->{$sid}
            unless keys %{$kr_fno_rec->[FMO_SESSIONS]->{$sid}};
        }
  
        # Decrement the kernel record's handle reference count.  If the
        # handle is done being used, then delete it from the kernel's
        # record structure.  This initiates Perl's garbage collection on
        # it, as soon as whatever else in "user space" frees it.
  
        $kr_fileno->[FNO_TOT_REFCOUNT]--;
  
        if (ASSERT_DATA) {
          _trap "<dt> fileno refcount went below zero"
            if $kr_fileno->[FNO_TOT_REFCOUNT] < 0;
        }
  
        unless ($kr_fileno->[FNO_TOT_REFCOUNT]) {
          if (TRACE_FILES) {
            _warn "<fh> deleting handle ($handle) fileno ($fd) entirely";
          }
          delete $kr_filenos{$fd};
        }
      }
      elsif (TRACE_FILES) {
        _warn(
          "<fh> session doesn't own handle ($handle) fileno ($fd) mode ($mode)"
        );
      }
    }
    elsif (TRACE_FILES) {
      _warn(
        "<fh> handle ($handle) fileno ($fd) is not registered with POE::Kernel" .
        Carp::shortmess()
  
      );
    }
  
    # SS_HANDLES - Remove the select from the session, assuming there is
    # a session to remove it from.  TODO Key it on fileno?
  
    if (
      exists($kr_ses_to_handle{$sid}) and
      exists($kr_ses_to_handle{$sid}->{$fd})
    ) {
  
      # Remove it from the session's read, write or expedite mode.
  
      my $ss_handle = $kr_ses_to_handle{$sid}->{$fd};
      if ($ss_handle->[SH_MODECOUNT]->[$mode]) {
  
        # Hmm... what is this?  Was POE going to support multiple selects?
  
        $ss_handle->[SH_MODECOUNT]->[$mode] = 0;
  
        # Decrement the reference count, and delete the handle if it's done.
  
        $ss_handle->[SH_REFCOUNT]--;
  
        if (ASSERT_DATA) {
          _trap "<dt> refcount went below zero"
            if $ss_handle->[SH_REFCOUNT] < 0;
        }
  
        unless ($ss_handle->[SH_REFCOUNT]) {
          delete $kr_ses_to_handle{$sid}->{$fd};
          $self->_data_ses_refcount_dec($sid);
          delete $kr_ses_to_handle{$sid}
            unless keys %{$kr_ses_to_handle{$sid}};
        }
      }
      elsif (TRACE_FILES) {
        _warn(
          "<fh> handle ($handle) fileno ($fd) is not registered with",
          $self->_data_alias_loggable($sid)
        );
      }
    }
  }
  
  ### Resume a filehandle.  If there are no events in the queue for this
  ### handle/mode pair, then we go ahead and set the actual state now.
  ### Otherwise it must wait until the queue empties.
  
  sub _data_handle_resume {
    my ($self, $handle, $mode) = @_;
  
    my $kr_fileno = $kr_filenos{fileno($handle)};
    my $kr_fno_rec = $kr_fileno->[$mode];
  
    if (TRACE_FILES) {
      _warn(
        "<fh> resume test: $handle fileno(" . fileno($handle) . ") mode($mode)"
      );
    }
  
    $self->loop_resume_filehandle($handle, $mode);
    $kr_fno_rec->[FMO_ST_ACTUAL] = HS_RUNNING;
  }
  
  ### Pause a filehandle.  If there are no events in the queue for this
  ### handle/mode pair, then we go ahead and set the actual state now.
  ### Otherwise it must wait until the queue empties.
  
  sub _data_handle_pause {
    my ($self, $handle, $mode) = @_;
  
    my $kr_fileno = $kr_filenos{fileno($handle)};
    my $kr_fno_rec = $kr_fileno->[$mode];
  
    if (TRACE_FILES) {
      _warn(
        "<fh> pause test: $handle fileno(" . fileno($handle) . ") mode($mode)"
      );
    }
  
    $self->loop_pause_filehandle($handle, $mode);
    $kr_fno_rec->[FMO_ST_ACTUAL] = HS_PAUSED;
  }
  
  ### Return the number of active filehandles in the entire system.
  
  sub _data_handle_count {
    return scalar keys %kr_filenos;
  }
  
  ### Return the number of active handles for a single session.
  
  sub _data_handle_count_ses {
    my ($self, $sid) = @_;
    return 0 unless exists $kr_ses_to_handle{$sid};
    return scalar keys %{$kr_ses_to_handle{$sid}};
  }
  
  ### Clear all the handles owned by a session.
  
  sub _data_handle_clear_session {
    my ($self, $sid) = @_;
  
    return unless exists $kr_ses_to_handle{$sid}; # avoid autoviv
    foreach (values %{$kr_ses_to_handle{$sid}}) {
      my $handle = $_->[SH_HANDLE];
      my $refcount = $_->[SH_MODECOUNT];
  
      $self->_data_handle_remove($handle, MODE_RD, $sid) if $refcount->[MODE_RD];
      $self->_data_handle_remove($handle, MODE_WR, $sid) if $refcount->[MODE_WR];
      $self->_data_handle_remove($handle, MODE_EX, $sid) if $refcount->[MODE_EX];
    }
  }
  
  # TODO Testing accessors.  Maybe useful for introspection.  May need
  # modification before that.
  
  sub _data_handle_fno_refcounts {
    my ($self, $fd) = @_;
    return(
      $kr_filenos{$fd}->[FNO_TOT_REFCOUNT],
      $kr_filenos{$fd}->[FNO_MODE_RD]->[FMO_REFCOUNT],
      $kr_filenos{$fd}->[FNO_MODE_WR]->[FMO_REFCOUNT],
      $kr_filenos{$fd}->[FNO_MODE_EX]->[FMO_REFCOUNT],
    )
  }
  
  sub _data_handle_fno_states {
    my ($self, $fd) = @_;
    return(
      $kr_filenos{$fd}->[FNO_MODE_RD]->[FMO_ST_ACTUAL],
      $kr_filenos{$fd}->[FNO_MODE_WR]->[FMO_ST_ACTUAL],
      $kr_filenos{$fd}->[FNO_MODE_EX]->[FMO_ST_ACTUAL],
    );
  }
  
  sub _data_handle_fno_sessions {
    my ($self, $fd) = @_;
  
    return(
      $kr_filenos{$fd}->[FNO_MODE_RD]->[FMO_SESSIONS],
      $kr_filenos{$fd}->[FNO_MODE_WR]->[FMO_SESSIONS],
      $kr_filenos{$fd}->[FNO_MODE_EX]->[FMO_SESSIONS],
    );
  }
  
  sub _data_handle_handles {
    my $self = shift;
    return %kr_ses_to_handle;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Resource::FileHandles - internal filehandle manager for POE::Kernel
  
  =head1 SYNOPSIS
  
  There is no public API.
  
  =head1 DESCRIPTION
  
  POE::Resource::FileHandles is a mix-in class for POE::Kernel.  It
  provides the low-level features to manage filehandles.  It is used
  internally by POE::Kernel, so it has no public interface.
  
  =head1 SEE ALSO
  
  See L<POE::Kernel/I/O Watchers (Selects)> for the public file watcher
  API.
  
  See L<POE::Kernel/Resources> for public information about POE
  resources.
  
  See L<POE::Resource> for general discussion about resources and the
  classes that manage them.
  
  =head1 BUGS
  
  POE watches I/O based on filehandles rather than file descriptors,
  which means there can be clashes between its API and an underlying
  descriptor-based event loop.  This is usually not a problem, but it
  may require a work-around in certain edge cases.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_RESOURCE_FILEHANDLES

$fatpacked{"POE/Resource/SIDs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_RESOURCE_SIDS';
  # Session IDs: The data to maintain them, and accessors to get at them
  # sanely from other files.
  
  package POE::Resource::SIDs;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  # These methods are folded into POE::Kernel;
  package POE::Kernel;
  
  use strict;
  
  ### Map session IDs to sessions.  Map sessions to session IDs.
  ### Maintain a sequence number for determining the next session ID.
  
  my %kr_session_ids;
  #  ( $session_id => $session_reference,
  #    ...,
  #  );
  
  my $kr_sid_seq = 0;
  
  sub _data_sid_initialize {
    $poe_kernel->[KR_SESSION_IDS] = \%kr_session_ids;
    $poe_kernel->[KR_SID_SEQ] = \$kr_sid_seq;
  }
  
  sub _data_sid_relocate_kernel_id {
    my ($self, $old_id, $new_id) = @_;
    $kr_session_ids{$new_id} = delete $kr_session_ids{$old_id}
      if exists $kr_session_ids{$old_id};
  }
  
  ### End-run leak checking.
  
  sub _data_sid_finalize {
    my $finalized_ok = 1;
    while (my ($sid, $ses) = each(%kr_session_ids)) {
      _warn "!!! Leaked session ID: $sid = $ses\n";
      $finalized_ok = 0;
    }
    return $finalized_ok;
  }
  
  ### Allocate a new session ID.
  
  sub _data_sid_allocate {
    my $self = shift;
    1 while exists $kr_session_ids{++$kr_sid_seq};
    return $kr_sid_seq;
  }
  
  ### Set a session ID.
  
  sub _data_sid_set {
    my ($self, $sid, $session) = @_;
    $kr_session_ids{$sid} = $session;
  }
  
  ### Clear a session ID.
  
  sub _data_sid_clear {
    my ($self, $sid) = @_;
  
    return delete $kr_session_ids{$sid} unless ASSERT_DATA;
  
    my $removed = delete $kr_session_ids{$sid};
    _trap("unknown SID '$sid'") unless defined $removed;
    $removed;
  }
  
  ### Resolve a session ID into its session.
  
  sub _data_sid_resolve {
    my ($self, $sid) = @_;
    return $kr_session_ids{$sid};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Resource::SIDs - internal session ID manager for POE::Kernel
  
  =head1 SYNOPSIS
  
  There is no public API.
  
  =head1 DESCRIPTION
  
  POE::Resource::SIDs is a mix-in class for POE::Kernel.  It provides
  the features necessary to manage session IDs.  It is used internally
  by POE::Kernel, so it has no public interface.
  
  =head1 SEE ALSO
  
  See L<POE::Kernel/Session Identifiers (IDs and Aliases)> for more
  information about session IDs.
  
  See L<POE::Kernel/Resources> for public information about POE
  resources.
  
  See L<POE::Resource> for general discussion about resources and the
  classes that manage them.
  
  =head1 BUGS
  
  None known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_RESOURCE_SIDS

$fatpacked{"POE/Resource/Sessions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_RESOURCE_SESSIONS';
  # Manage session data structures on behalf of POE::Kernel.
  
  package POE::Resource::Sessions;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  # These methods are folded into POE::Kernel;
  package POE::Kernel;
  
  use strict;
  
  # Map stringy sessions to their references for _data_ses_resolve.
  my %kr_session_refs;
  # { $session_ref => $blessed, ... }
  
  ### Session structure.
  my %kr_sessions;
  #  { $session_id =>
  #    [ $blessed_session,         SS_SESSION
  #      $total_reference_count,   SS_REFCOUNT
  #      $parent_session,          SS_PARENT
  #      { $child_session_id => $blessed_ref,  SS_CHILDREN
  #        ...,
  #      },
  #      { $process_id => $placeholder_value,  SS_PROCESSES
  #        ...,
  #      },
  #    ],
  #    ...,
  #  };
  
  sub SS_SESSION    () { 0 }
  sub SS_REFCOUNT   () { 1 }
  sub SS_PARENT     () { 2 }
  sub SS_CHILDREN   () { 3 }
  sub SS_PROCESSES  () { 4 }
  
  BEGIN { $POE::Kernel::poe_kernel->[KR_SESSIONS] = \%kr_sessions; }
  
  sub _data_ses_relocate_kernel_id {
    my ($self, $old_id, $new_id) = @_;
  
    while (my ($sid, $ses_rec) = each %kr_sessions) {
      my $children = $ses_rec->[SS_CHILDREN];
      $children->{$new_id} = delete $children->{$old_id}
        if exists $children->{$old_id};
    }
  
    $kr_sessions{$new_id} = delete $kr_sessions{$old_id}
      if exists $kr_sessions{$old_id};
  }
  
  ### End-run leak checking.
  
  sub _data_ses_clone {
    %kr_session_refs = ();
    foreach my $ses_ref (map { $_->[SS_SESSION] } values %kr_sessions) {
      $kr_session_refs{$ses_ref} = $ses_ref;
    }
  }
  
  sub _data_ses_finalize {
    my $finalized_ok = 1;
  
    while (my ($sid, $ses_rec) = each %kr_sessions) {
      $finalized_ok = 0;
      _warn(
        "!!! Leaked session: $sid\n",
        "!!!\trefcnt = $ses_rec->[SS_REFCOUNT]\n",
        "!!!\tparent = $ses_rec->[SS_PARENT]\n",
        "!!!\tchilds = ", join("; ", keys(%{$ses_rec->[SS_CHILDREN]})), "\n",
        "!!!\tprocs  = ", join("; ", keys(%{$ses_rec->[SS_PROCESSES]})),"\n",
      );
    }
  
    while (my ($stringy, $blessed) = each %kr_session_refs) {
      $finalized_ok = 0;
      _warn "!!! Leaked stringy session $stringy = $blessed\n";
      _warn "!!!\tBad clone detected, while we're at it.\n" if (
        $stringy ne "$blessed"
      );
    }
  
    return $finalized_ok;
  }
  
  ### Enter a new session into the back-end stuff.
  
  my %kr_marked_for_gc;
  my @kr_marked_for_gc;
  
  sub _data_ses_allocate {
    my ($self, $session, $sid, $parent_id) = @_;
  
    my $parent;
    if (defined $parent_id) {
      _trap "parent session $parent_id does not exist" unless (
        exists $kr_sessions{$parent_id}
      );
  
      $parent = $kr_sessions{$parent_id}[SS_SESSION];
  
      _trap "session $session is already allocated" if exists $kr_sessions{$sid};
    }
  
    TRACE_REFCNT and _warn "<rc> allocating $session";
  
    $kr_sessions{$sid} =
      [ $session,   # SS_SESSION
        0,          # SS_REFCOUNT
        $parent,    # SS_PARENT
        { },        # SS_CHILDREN
        { },        # SS_PROCESSES
      ];
  
    # For the ID to session reference lookup.
    $self->_data_sid_set($sid, $session);
  
    # For the stringy to blessed session reference lookup.
    $kr_session_refs{$session} = $session;
  
    # Manage parent/child relationship.
    if (defined $parent_id) {
      if (TRACE_SESSIONS) {
        _warn(
          "<ss> ",
          $self->_data_alias_loggable($sid), " has parent ",
          $self->_data_alias_loggable($parent_id)
        );
      }
  
      $kr_sessions{$parent_id}->[SS_CHILDREN]->{$sid} = $session;
      $self->_data_ses_refcount_inc($parent_id);
    }
  
    TRACE_REFCNT and _warn "<rc> $session marked for gc";
    unless ($sid eq $self->ID) {
      push @kr_marked_for_gc, $sid;
      $kr_marked_for_gc{$sid} = $sid;
    }
  }
  
  # Release a session's resources, and remove it.  This doesn't do
  # garbage collection for the session itself because that should
  # already have happened.
  #
  # TODO This is yet another place where resources will need to register
  # a function.  Every resource's _data_???_clear_session is called
  # here.
  
  sub _data_ses_free {
    my ($self, $sid) = @_;
  
    TRACE_REFCNT and do {
      _warn "<rc> freeing session $sid";
      _trap("!!! free defunct session $sid?!\n") unless (
        $self->_data_ses_exists($sid)
      );
    };
  
    if (TRACE_SESSIONS) {
      _warn "<ss> freeing ", $self->_data_alias_loggable($sid);
    }
  
    # Manage parent/child relationships.
  
    my $parent   = $kr_sessions{$sid}->[SS_PARENT];
    my @children = $self->_data_ses_get_children($sid);
  
    if (defined $parent) {
      my $parent_id = $parent->ID;
  
      if (ASSERT_DATA) {
        _trap "session is its own parent" if $parent_id eq $sid;
        _trap "session's parent ($parent_id) doesn't exist"
          unless exists $kr_sessions{$parent_id};
  
        unless ($self->_data_ses_is_child($parent_id, $sid)) {
          _trap(
            $self->_data_alias_loggable($sid), " isn't a child of ",
            $self->_data_alias_loggable($parent_id), " (it's a child of ",
            $self->_data_alias_loggable($self->_data_ses_get_parent($sid)->ID),
            ")"
          );
        }
      }
  
      # Remove the departing session from its parent.
  
      _trap "internal inconsistency ($parent_id/$sid)"
        unless delete $kr_sessions{$parent_id}->[SS_CHILDREN]->{$sid};
  
      $kr_sessions{$sid}->[SS_PARENT] = undef;
  
      if (TRACE_SESSIONS) {
        _cluck(
          "<ss> removed ",
          $self->_data_alias_loggable($sid), " from ",
          $self->_data_alias_loggable($parent_id)
        );
      }
  
      $self->_data_ses_refcount_dec($parent_id);
  
      # Move the departing session's children to its parent.
  
      foreach (@children) {
        $self->_data_ses_move_child($_->ID, $parent_id)
      }
    }
    elsif (ASSERT_DATA) {
      _trap "no parent to give children to" if @children;
    }
  
    my $session = $kr_sessions{$sid}[SS_SESSION];
  
    # Things which do not hold reference counts.
  
    $self->_data_sid_clear($sid);                # Remove from SID tables.
    $self->_data_sig_clear_session($sid);        # Remove all leftover signals.
  
    # Things which do hold reference counts.
  
    $self->_data_alias_clear_session($sid);      # Remove all leftover aliases.
    $self->_data_extref_clear_session($sid);     # Remove all leftover extrefs.
    $self->_data_handle_clear_session($sid);     # Remove all leftover handles.
  
    $self->_data_ev_clear_session($sid);         # Remove all leftover events.
  
    # Remove the session itself.
  
    delete $kr_marked_for_gc{$sid};
    delete $kr_sessions{$sid};
    delete $kr_session_refs{$session};
  }
  
  ### Move a session to a new parent.
  
  sub _data_ses_move_child {
    my ($self, $sid, $new_parent_id) = @_;
  
    if (ASSERT_DATA) {
      _trap("moving nonexistent child to another parent")
        unless exists $kr_sessions{$sid};
      _trap("moving child to a nonexistent parent")
        unless exists $kr_sessions{$new_parent_id};
    }
  
    if (TRACE_SESSIONS) {
      _warn(
        "<ss> moving ",
        $self->_data_alias_loggable($sid), " to ",
        $self->_data_alias_loggable($new_parent_id)
      );
    }
  
    my $old_parent_id = $self->_data_ses_get_parent($sid)->ID;
  
    if (ASSERT_DATA) {
      _trap("moving child from a nonexistent parent")
        unless exists $kr_sessions{$old_parent_id};
    }
  
    # Remove the session from its old parent.
    delete $kr_sessions{$old_parent_id}->[SS_CHILDREN]->{$sid};
  
    if (TRACE_SESSIONS) {
      _warn(
        "<ss> removed ",
        $self->_data_alias_loggable($sid), " from ",
        $self->_data_alias_loggable($old_parent_id)
      );
    }
  
    $self->_data_ses_refcount_dec($old_parent_id);
  
    # Change the session's parent.
    $kr_sessions{$sid}->[SS_PARENT] = $kr_sessions{$new_parent_id}[SS_SESSION];
  
    if (TRACE_SESSIONS) {
      _warn(
        "<ss> changed parent of ",
        $self->_data_alias_loggable($sid), " to ",
        $self->_data_alias_loggable($new_parent_id)
      );
    }
  
    # Add the current session to the new parent's children.
    $kr_sessions{$new_parent_id}->[SS_CHILDREN]->{$sid} = (
      $kr_sessions{$sid}[SS_SESSION]
    );
  
    if (TRACE_SESSIONS) {
      _warn(
        "<ss> added ",
        $self->_data_alias_loggable($sid), " as child of ",
        $self->_data_alias_loggable($new_parent_id)
      );
    }
  
    $self->_data_ses_refcount_inc($new_parent_id);
  
    # We do not call _data_ses_collect_garbage() here.  This function is
    # called in batch for a departing session, to move its children to
    # its parent.  The GC test would be superfluous here.  Rather, it's
    # up to the caller to do the proper GC test after moving things
    # around.
  }
  
  ### Get a session's parent.
  
  sub _data_ses_get_parent {
    my ($self, $sid) = @_;
    if (ASSERT_DATA || ASSERT_USAGE) {
      _trap("undefined session ID") unless defined $sid;
      _trap("retrieving parent of a nonexistent session")
        unless exists $kr_sessions{$sid};
    }
    return $kr_sessions{$sid}->[SS_PARENT];
  }
  
  ### Get a session's children.
  
  sub _data_ses_get_children {
    my ($self, $sid) = @_;
    if (ASSERT_DATA) {
      _trap("retrieving children of a nonexistent session")
        unless exists $kr_sessions{$sid};
    }
    return values %{$kr_sessions{$sid}->[SS_CHILDREN]};
  }
  
  ### Is a session a child of another?
  
  sub _data_ses_is_child {
    my ($self, $parent_id, $child_id) = @_;
    if (ASSERT_DATA) {
      _trap("testing is-child of a nonexistent parent session")
        unless exists $kr_sessions{$parent_id};
    }
    return(
      exists $kr_sessions{$parent_id} &&
      exists $kr_sessions{$parent_id}->[SS_CHILDREN]->{$child_id}
    );
  }
  
  ### Determine whether a session exists.  We should only need to verify
  ### this for sessions provided by the outside.  Internally, our code
  ### should be so clean it's not necessary.
  
  sub _data_ses_exists {
    my ($self, $sid) = @_;
    return exists $kr_sessions{$sid};
  }
  
  ### Resolve a session into its reference.
  
  sub _data_ses_resolve {
    my ($self, $session) = @_;
    return undef unless exists $kr_session_refs{$session}; # Prevents autoviv.
    return $kr_session_refs{$session};
  }
  
  ### Resolve a session ID into its reference.
  
  sub _data_ses_resolve_to_id {
    my ($self, $session) = @_;
    $session = $self->_data_ses_resolve($session);
    return undef unless defined $session;
    return $session->ID;
  }
  
  ### Sweep the GC marks.
  
  sub _data_ses_gc_sweep {
    my $self = shift;
  
    TRACE_REFCNT and _warn "<rc> trying sweep";
    while (@kr_marked_for_gc) {
      my %temp_marked = %kr_marked_for_gc;
      %kr_marked_for_gc = ();
  
      my @todo = reverse @kr_marked_for_gc;
      @kr_marked_for_gc = ();
  
      # Never GC the POE::Kernel singleton.
      delete $temp_marked{$self->ID};
  
      foreach my $sid (@todo) {
        next unless delete $temp_marked{$sid};
        $self->_data_ses_stop($sid);
      }
    }
  }
  
  ### Decrement a session's main reference count.  This is called by
  ### each watcher when the last thing it watches for the session goes
  ### away.  In other words, a session's reference count should only
  ### enumerate the different types of things being watched; not the
  ### number of each.
  
  sub _data_ses_refcount_dec {
    my ($self, $sid) = @_;
  
    if (ASSERT_DATA) {
      _trap("decrementing refcount of a nonexistent session")
        unless exists $kr_sessions{$sid};
    }
  
    if (TRACE_REFCNT) {
      _cluck(
        "<rc> decrementing refcount for ",
        $self->_data_alias_loggable($sid)
      );
    }
  
    if (--$kr_sessions{$sid}->[SS_REFCOUNT] < 1) {
      TRACE_REFCNT and _warn "<rc> session $sid marked for gc";
      unless ($sid eq $self->ID) {
        push @kr_marked_for_gc, $sid;
        $kr_marked_for_gc{$sid} = $sid;
      }
    }
  
    $self->_data_ses_dump_refcounts($sid) if TRACE_REFCNT;
  
    if (ASSERT_DATA and $kr_sessions{$sid}->[SS_REFCOUNT] < 0) {
      _trap(
        $self->_data_alias_loggable($sid),
       " reference count went below zero"
     );
    }
  }
  
  ### Increment a session's main reference count.
  
  sub _data_ses_refcount_inc {
    my ($self, $sid) = @_;
  
    if (ASSERT_DATA) {
      _trap("incrementing refcount for nonexistent session")
        unless exists $kr_sessions{$sid};
    }
  
    if (TRACE_REFCNT) {
      _cluck(
        "<rc> incrementing refcount for ",
        $self->_data_alias_loggable($sid)
      );
    }
  
    if (++$kr_sessions{$sid}->[SS_REFCOUNT] > 0) {
      TRACE_REFCNT and _warn "<rc> session $sid unmarked for gc";
      delete $kr_marked_for_gc{$sid};
    }
    elsif (TRACE_REFCNT) {
      _warn(
        "??? session $sid refcount = $kr_sessions{$sid}->[SS_REFCOUNT]"
      );
    }
  
    $self->_data_ses_dump_refcounts($sid) if TRACE_REFCNT;
  }
  
  sub _data_ses_dump_refcounts {
    my ($self, $sid) = @_;
  
    my $ss = $kr_sessions{$sid};
  
    _warn(
      "<rc> +----- GC test for ", $self->_data_alias_loggable($sid), "-----\n",
      "<rc> | total refcnt  : ", $ss->[SS_REFCOUNT], "\n",
      "<rc> | event count   : ", $self->_data_ev_get_count_to($sid), "\n",
      "<rc> | post count    : ", $self->_data_ev_get_count_from($sid), "\n",
      "<rc> | child sessions: ", scalar(keys(%{$ss->[SS_CHILDREN]})), "\n",
      "<rc> | handles in use: ", $self->_data_handle_count_ses($sid), "\n",
      "<rc> | aliases in use: ", $self->_data_alias_count_ses($sid), "\n",
      "<rc> | extra refs    : ", $self->_data_extref_count_ses($sid), "\n",
      "<rc> | pid count     : ", $self->_data_sig_session_awaits_pids($sid), "\n",
      "<rc> +---------------------------------------------------\n",
    );
  
    unless ($ss->[SS_REFCOUNT] and $self->_data_sig_session_awaits_pids($sid)) {
      _warn(
        "<rc> | ", $self->_data_alias_loggable($sid),
        " is eligible for garbage collection.\n",
        "<rc> +---------------------------------------------------\n",
      );
    }
  
    _carp "<rc> | called";
  }
  
  # Query a session's reference count.  Added for testing purposes.
  
  sub _data_ses_refcount {
    my ($self, $sid) = @_;
    return $kr_sessions{$sid}->[SS_REFCOUNT];
  }
  
  ### Compatibility function to do a GC sweep on attempted garbage
  ### collection.  The tests still try to call this.
  
  sub _data_ses_collect_garbage {
    my ($self, $sid) = @_;
    # TODO - Deprecation warning.
    $self->_data_ses_gc_sweep();
  }
  
  ### Return the number of sessions we know about.
  
  sub _data_ses_count {
    return scalar keys %kr_sessions;
  }
  
  ### Close down a session by force.
  
  # Stop a session, dispatching _stop, _parent, and _child as necessary.
  #
  # Dispatch _stop to a session, removing it from the kernel's data
  # structures as a side effect.
  
  my %already_stopping;
  
  sub _data_ses_stop {
    my ($self, $sid) = @_;
  
    # Don't stop a session that's already in the throes of stopping.
    # This can happen with exceptions, during die() in _stop.  It can
    # probably be removed if exceptions are.
  
    return if exists $already_stopping{$sid};
    $already_stopping{$sid} = 1;
  
    TRACE_REFCNT and _warn "<rc> stopping session $sid";
  
    if (ASSERT_DATA) {
      _trap("stopping a nonexistent session") unless exists $kr_sessions{$sid};
    }
  
    if (TRACE_SESSIONS) {
      _warn("<ss> stopping ", $self->_data_alias_loggable($sid));
    }
  
    # Maintain referential integrity between parents and children.
    # First move the children of the stopping session up to its parent.
    my $parent = $self->_data_ses_get_parent($sid);
  
    foreach my $child ($self->_data_ses_get_children($sid)) {
      $self->_dispatch_event(
        $parent, $self,
        EN_CHILD, ET_CHILD, [ CHILD_GAIN, $child ],
        __FILE__, __LINE__, undef, monotime(), -__LINE__
      );
      $self->_dispatch_event(
        $child, $self,
        EN_PARENT, ET_PARENT,
        [ $self->_data_ses_get_parent($child->ID), $parent, ],
        __FILE__, __LINE__, undef, monotime(), -__LINE__
      );
    }
  
    # Referential integrity has been dealt with.  Now notify the session
    # that it has been stopped.
  
    my $session = $kr_sessions{$sid}[SS_SESSION];
    my $stop_return = $self->_dispatch_event(
      $session, $self->get_active_session(),
      EN_STOP, ET_STOP, [],
      __FILE__, __LINE__, undef, monotime(), -__LINE__
    );
  
    # If the departing session has a parent, notify it that the session
    # is being lost.
  
    if (defined $parent) {
      $self->_dispatch_event(
        $parent, $self,
        EN_CHILD, ET_CHILD, [ CHILD_LOSE, $session, $stop_return ],
        __FILE__, __LINE__, undef, monotime(), -__LINE__
      );
    }
  
    # Deallocate the session.
  
    $self->_data_ses_free($sid);
  
    # Stop the main loop if everything is gone.
    # XXX - Under Tk this is called twice.  Why?  WHY is it called twice?
    unless (keys %kr_sessions) {
      $self->loop_halt();
    }
  
    delete $already_stopping{$sid};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Resource::Sessions - internal session manager for POE::Kernel
  
  =head1 SYNOPSIS
  
  There is no public API.
  
  =head1 DESCRIPTION
  
  POE::Resource::Sessions is a mix-in class for POE::Kernel.  It
  provides the internal features that manage sessions, regardless of the
  session type.  It is used internally by POE::Kernel. so it has no
  public interface.
  
  =head1 SEE ALSO
  
  See L<POE::Session> and L<POE::NFA> for one type of session.  CPAN
  also have others.
  
  See L<POE::Kernel/Sessions> for a discussion about POE::Kernel
  sessions.
  
  See L<POE::Kernel/Session Lifespans> to learn why sessions run, and
  how to stop them.
  
  See L<POE::Kernel/Session Management> for information about managing
  sessions in your applications, and the events that occur when sessions
  come and go.
  
  See L<POE::Kernel/Session Helper Methods> for friend methods between
  POE::Kernel and POE::Session classes.
  
  See L<POE::Kernel/Resources> for public information about POE
  resources.
  
  See L<POE::Resource> for general discussion about resources and the
  classes that manage them.
  
  =head1 BUGS
  
  None known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_RESOURCE_SESSIONS

$fatpacked{"POE/Resource/Signals.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_RESOURCE_SIGNALS';
  # The data necessary to manage signals, and the accessors to get at
  # that data in a sane fashion.
  
  package POE::Resource::Signals;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  # These methods are folded into POE::Kernel;
  package POE::Kernel;
  
  use strict;
  
  use POE::Pipe::OneWay;
  use POE::Resource::FileHandles;
  use POSIX qw(:sys_wait_h sigprocmask SIG_SETMASK);
  
  ### Map watched signal names to the sessions that are watching them
  ### and the events that must be delivered when they occur.
  
  sub SEV_EVENT   () { 0 }
  sub SEV_ARGS    () { 1 }
  sub SEV_SESSION () { 2 }
  
  my %kr_signals;
  #  ( $signal_name =>
  #    { $session_id =>
  #     [ $event_name,    SEV_EVENT
  #       $event_args,    SEV_ARGS
  #       $session_ref,   SEV_SESSION
  #     ],
  #      ...,
  #    },
  #    ...,
  #  );
  
  my %kr_sessions_to_signals;
  #  ( $session_id =>
  #    { $signal_name =>
  #      [ $event_name,   SEV_EVENT
  #        $event_args,   SEV_ARGS
  #        $session_ref,  SEV_SESSION
  #      ],
  #      ...,
  #    },
  #    ...,
  #  );
  
  my %kr_pids_to_events;
  # { $pid =>
  #   { $session_id =>
  #     [ $blessed_session,   # PID_SESSION
  #       $event_name,        # PID_EVENT
  #       $args,              # PID_ARGS
  #     ]
  #   }
  # }
  
  my %kr_sessions_to_pids;
  # { $session_id => { $pid => 1 } }
  
  sub PID_SESSION () { 0 }
  sub PID_EVENT   () { 1 }
  sub PID_ARGS    () { 2 }
  
  sub _data_sig_relocate_kernel_id {
    my ($self, $old_id, $new_id) = @_;
  
    while (my ($signal, $sig_rec) = each %kr_signals) {
      next unless exists $sig_rec->{$old_id};
      $sig_rec->{$new_id} = delete $sig_rec->{$old_id};
    }
  
    $kr_sessions_to_signals{$new_id} = delete $kr_sessions_to_signals{$old_id}
      if exists $kr_sessions_to_signals{$old_id};
  
    while (my ($pid, $pid_rec) = each %kr_pids_to_events) {
      next unless exists $pid_rec->{$old_id};
      $pid_rec->{$new_id} = delete $pid_rec->{$old_id};
    }
  
    $kr_sessions_to_pids{$new_id} = delete $kr_sessions_to_pids{$old_id}
      if exists $kr_sessions_to_pids{$old_id};
  }
  
  # Bookkeeping per dispatched signal.
  
  # TODO - Why not lexicals?
  use vars (
   '@kr_signaled_sessions',            # The sessions touched by a signal.
   '$kr_signal_total_handled',         # How many sessions handled a signal.
   '$kr_signal_type',                  # The type of signal being dispatched.
  );
  
  #my @kr_signaled_sessions;           # The sessions touched by a signal.
  #my $kr_signal_total_handled;        # How many sessions handled a signal.
  #my $kr_signal_type;                 # The type of signal being dispatched.
  
  # A flag to tell whether we're currently polling for signals.
  # Under USE_SIGCHLD, determines whether a SIGCHLD polling event has
  # already been queued.
  my $polling_for_signals = 0;
  
  # There may be latent subprocesses in some environments.
  # Or we may need to "always loop once" if we're polling for SIGCHLD.
  # This constant lets us define those exceptional cases.
  # We had some in the past, but as of 2013-10-06 we seem to have
  # eliminated those special cases.
  use constant BASE_SIGCHLD_COUNT => 0;
  
  my $kr_has_child_procs = BASE_SIGCHLD_COUNT;
  
  # A list of special signal types.  Signals that aren't listed here are
  # benign (they do not kill sessions at all).  "Terminal" signals are
  # the ones that UNIX defaults to killing processes with.  Thus STOP is
  # not terminal.
  
  sub SIGTYPE_BENIGN      () { 0x00 }
  sub SIGTYPE_TERMINAL    () { 0x01 }
  sub SIGTYPE_NONMASKABLE () { 0x02 }
  
  my %_signal_types = (
    QUIT => SIGTYPE_TERMINAL,
    INT  => SIGTYPE_TERMINAL,
    KILL => SIGTYPE_TERMINAL,
    TERM => SIGTYPE_TERMINAL,
    HUP  => SIGTYPE_TERMINAL,
    IDLE => SIGTYPE_TERMINAL,
    DIE  => SIGTYPE_TERMINAL,
    ZOMBIE    => SIGTYPE_NONMASKABLE,
    UIDESTROY => SIGTYPE_NONMASKABLE,
  );
  
  # Build a list of useful, real signals.  Nonexistent signals, and ones
  # which are globally unhandled, usually cause segmentation faults if
  # perl was poorly configured.  Some signals aren't available in some
  # environments.
  
  my %_safe_signals;
  
  sub _data_sig_initialize {
    my $self = shift;
  
    $self->_data_sig_reset_procs;
  
    $poe_kernel->[KR_SIGNALS] = \%kr_signals;
    $poe_kernel->[KR_PIDS]    = \%kr_pids_to_events;
  
    # In case we're called multiple times.
    unless (keys %_safe_signals) {
      foreach my $signal (keys %SIG) {
  
        # Nonexistent signals, and ones which are globally unhandled.
        next if (
          $signal =~ /^
            ( NUM\d+
            |__[A-Z0-9]+__
            |ALL|CATCHALL|DEFER|HOLD|IGNORE|MAX|PAUSE
            |RTMIN|RTMAX|SETS
            |SEGV
            |
            )
          $/x
        );
  
        # Windows doesn't have a SIGBUS, but the debugger causes SIGBUS
        # to be entered into %SIG.  It's fatal to register its handler.
        next if $signal eq 'BUS' and RUNNING_IN_HELL;
  
        # Apache uses SIGCHLD and/or SIGCLD itself, so we can't.
        next if $signal =~ /^CH?LD$/ and exists $INC{'Apache.pm'};
  
        $_safe_signals{$signal} = 1;
      }
  
      # Reset some important signal handlers.  The rest remain
      # untouched.
  
      $self->loop_ignore_signal("CHLD") if exists $SIG{CHLD};
      $self->loop_ignore_signal("CLD")  if exists $SIG{CLD};
      $self->loop_ignore_signal("PIPE") if exists $SIG{PIPE};
  
      $self->_data_sig_pipe_build if USE_SIGNAL_PIPE;
    }
  }
  
  sub _data_sig_has_forked {
    my( $self ) = @_;
    $self->_data_sig_reset_procs;
    if( USE_SIGNAL_PIPE ) {
      $self->_data_sig_mask_all;
      $self->_data_sig_pipe_finalize;
      $self->_data_sig_pipe_build;
      $self->_data_sig_unmask_all;
    }
  }
  
  sub _data_sig_reset_procs {
    my $self = shift;
    # Initialize this to a true value so our waitpid() loop can run at
    # least once.  Starts false when running in an Apache handler so our
    # SIGCHLD hijinks don't interfere with the web server.
    $self->_data_sig_cease_polling();
    $kr_has_child_procs = BASE_SIGCHLD_COUNT;
  }
  
  
  ### Return signals that are safe to manipulate.
  
  sub _data_sig_get_safe_signals {
    return keys %_safe_signals;
  }
  
  ### End-run leak checking.
  our $finalizing;
  
  sub _data_sig_finalize {
    my( $self ) = @_;
    my $finalized_ok = 1;
    # tell _data_sig_pipe_send to ignore CHLD that waitpid might provoke
    local $finalizing = 1;
  
    $self->_data_sig_pipe_finalize;
  
    while (my ($sig, $sig_rec) = each(%kr_signals)) {
      $finalized_ok = 0;
      _warn "!!! Leaked signal $sig\n";
      while (my ($sid, $ses_rec) = each(%{$kr_signals{$sig}})) {
        my ($event, $args, $session) = @$ses_rec;
        _warn "!!!\t$sid = $session -> $event (@$args)\n";
      }
    }
  
    while (my ($sid, $ses_rec) = each(%kr_sessions_to_signals)) {
      $finalized_ok = 0;
      _warn "!!! Leaked signal cross-reference: $sid\n";
      while (my ($sig, $sig_rec) = each(%{$kr_signals{$sid}})) {
        my ($event, $args) = @$sig_rec;
        _warn "!!!\t$sig = $event (@$args)\n";
      }
    }
  
    while (my ($sid, $pid_rec) = each(%kr_sessions_to_pids)) {
      $finalized_ok = 0;
      my @pids = keys %$pid_rec;
      _warn "!!! Leaked session to PID map: $sid -> (@pids)\n";
    }
  
    while (my ($pid, $ses_rec) = each(%kr_pids_to_events)) {
      $finalized_ok = 0;
      _warn "!!! Leaked PID to event map: $pid\n";
      while (my ($sid, $ev_rec, $ses) = each %$ses_rec) {
        _warn "!!!\t$ses -> $ev_rec->[PID_EVENT] (@{$ev_rec->[PID_ARGS]})\n";
      }
    }
  
    if ($kr_has_child_procs) {
      _warn "!!! Kernel has $kr_has_child_procs child process(es).\n";
    }
  
    if ($polling_for_signals) {
      _warn "!!! Finalizing signals while polling is active.\n";
    }
  
    if (USE_SIGNAL_PIPE and $self->_data_sig_pipe_has_signals()) {
      _warn "!!! Finalizing signals while signal pipe contains messages.\n";
    }
  
    if (exists $kr_signals{CHLD}) {
      _warn "!!! Finalizing signals while a blanket _child signal is watched.\n";
    }
  
    %_safe_signals = ();
  
    unless (RUNNING_IN_HELL) {
      local $!;
      local $?;
  
      my $leaked_children = 0;
  
      PROCESS: until ((my $pid = waitpid( -1, WNOHANG )) == -1) {
        $finalized_ok = 0;
        $leaked_children++;
  
        if ($pid == 0) {
          _warn(
            "!!! At least one child process is still running " .
            "when POE::Kernel->run() is ready to return.\n"
          );
          last PROCESS;
        }
  
        _warn(
          "!!! Stopped child process (PID $pid) reaped " .
            "when POE::Kernel->run() is ready to return.\n"
        );
      }
  
      if ($leaked_children) {
        _warn("!!! Be sure to use sig_child() to reap child processes.\n");
        _warn("!!! In extreme cases, failure to reap child processes has\n");
        _warn("!!! resulted in a slow 'fork bomb' that has halted systems.\n");
      }
    }
  
    return $finalized_ok;
  }
  
  ### Add a signal to a session.
  
  sub _data_sig_add {
    my ($self, $session, $signal, $event, $args) = @_;
  
    my $sid = $session->ID;
    $kr_sessions_to_signals{$sid}->{$signal} = [ $event, $args || [], $session ];
    $self->_data_sig_signal_watch($sid, $signal);
    $kr_signals{$signal}->{$sid} = [ $event, $args || [], $session ];
  }
  
  sub _data_sig_signal_watch {
    my ($self, $sid, $signal) = @_;
  
    # TODO - $sid not used?
  
    # First session to watch the signal.
    # Ask the event loop to watch the signal.
    if (
      !exists($kr_signals{$signal}) and
      exists($_safe_signals{$signal}) and
      ($signal ne "CHLD" or !scalar(keys %kr_sessions_to_pids))
    ) {
      $self->loop_watch_signal($signal);
    }
  }
  
  sub _data_sig_signal_ignore {
    my ($self, $sid, $signal) = @_;
  
    # TODO - $sid not used?
  
    if (
      !exists($kr_signals{$signal}) and
      exists($_safe_signals{$signal}) and
      ($signal ne "CHLD" or !scalar(keys %kr_sessions_to_pids))
    ) {
      $self->loop_ignore_signal($signal);
    }
  }
  
  ### Remove a signal from a session.
  
  sub _data_sig_remove {
    my ($self, $sid, $signal) = @_;
  
    delete $kr_sessions_to_signals{$sid}->{$signal};
    delete $kr_sessions_to_signals{$sid}
      unless keys(%{$kr_sessions_to_signals{$sid}});
  
    delete $kr_signals{$signal}->{$sid};
  
    # Last watcher for that signal.  Stop watching it internally.
    unless (keys %{$kr_signals{$signal}}) {
      delete $kr_signals{$signal};
      $self->_data_sig_signal_ignore($sid, $signal);
    }
  }
  
  ### Clear all the signals from a session.
  
  # XXX - It's ok to clear signals from a session that doesn't exist.
  # Usually it means that the signals are being cleared, but it might
  # mean that the session really doesn't exist.  Should we care?
  
  sub _data_sig_clear_session {
    my ($self, $sid) = @_;
  
    if (exists $kr_sessions_to_signals{$sid}) { # avoid autoviv
      foreach (keys %{$kr_sessions_to_signals{$sid}}) {
        $self->_data_sig_remove($sid, $_);
      }
    }
  
    if (exists $kr_sessions_to_pids{$sid}) { # avoid autoviv
      foreach (keys %{$kr_sessions_to_pids{$sid}}) {
        $self->_data_sig_pid_ignore($sid, $_);
      }
    }
  }
  
  ### Watch and ignore PIDs.
  
  sub _data_sig_pid_watch {
    my ($self, $session, $pid, $event, $args) = @_;
  
    my $sid = $session->ID;
  
    $kr_pids_to_events{$pid}{$sid} = [
      $session, # PID_SESSION
      $event,   # PID_EVENT
      $args,    # PID_ARGS
    ];
  
    $self->_data_sig_signal_watch($sid, "CHLD");
  
    $kr_sessions_to_pids{$sid}{$pid} = 1;
    $self->_data_ses_refcount_inc($sid);
  
    # Assume there's a child process.  This will be corrected on the
    # next polling interval.
    $kr_has_child_procs++ unless USE_SIGCHLD;
  }
  
  sub _data_sig_pid_ignore {
    my ($self, $sid, $pid) = @_;
  
    # Remove PID to event mapping.
  
    delete $kr_pids_to_events{$pid}{$sid};
    delete $kr_pids_to_events{$pid} unless (
      keys %{$kr_pids_to_events{$pid}}
    );
  
    # Remove session to PID mapping.
  
    delete $kr_sessions_to_pids{$sid}{$pid};
    unless (keys %{$kr_sessions_to_pids{$sid}}) {
      delete $kr_sessions_to_pids{$sid};
      $self->_data_sig_signal_ignore($sid, "CHLD");
    }
  
    $self->_data_ses_refcount_dec($sid);
  }
  
  sub _data_sig_session_awaits_pids {
    my ($self, $sid) = @_;
  
    # There must be child processes or pending signals.
    # Watching PIDs doesn't matter if there are none to be reaped.
    return 0 unless $kr_has_child_procs or $self->_data_sig_pipe_has_signals();
  
    # This session is watching at least one PID with sig_child().
    # TODO - Watching a non-existent PID is legal but ill-advised.
    return 1 if exists $kr_sessions_to_pids{$sid};
  
    # Is the session waiting for a blanket sig(CHLD)?
    return(
      (exists $kr_sessions_to_signals{$sid}) &&
      (exists $kr_sessions_to_signals{$sid}{CHLD})
    );
  }
  
  sub _data_sig_pids_is_ses_watching {
    my ($self, $sid, $pid) = @_;
    return(
      exists($kr_sessions_to_pids{$sid}) &&
      exists($kr_sessions_to_pids{$sid}{$pid})
    );
  }
  
  ### Return a signal's type, or SIGTYPE_BENIGN if it's not special.
  
  sub _data_sig_type {
    my ($self, $signal) = @_;
    return $_signal_types{$signal} || SIGTYPE_BENIGN;
  }
  
  ### Flag a signal as being handled by some session.
  
  sub _data_sig_handled {
    my $self = shift;
    $kr_signal_total_handled++;
  }
  
  ### Clear the structures associated with a signal's "handled" status.
  
  sub _data_sig_reset_handled {
    my ($self, $signal) = @_;
    undef $kr_signal_total_handled;
    $kr_signal_type = $self->_data_sig_type($signal);
    undef @kr_signaled_sessions;
  }
  
  ### Is the signal explicitly watched?
  
  sub _data_sig_explicitly_watched {
    my ($self, $signal) = @_;
    return exists $kr_signals{$signal};
  }
  
  ### Return the signals watched by a session and the events they
  ### generate.  TODO Used mainly for testing, but may also be useful
  ### for introspection.
  
  sub _data_sig_watched_by_session {
    my ($self, $sid) = @_;
    return unless exists $kr_sessions_to_signals{$sid};
    return %{$kr_sessions_to_signals{$sid}};
  }
  
  ### Which sessions are watching a signal?
  
  sub _data_sig_watchers {
    my ($self, $signal) = @_;
    return %{$kr_signals{$signal}};
  }
  
  ### Return the current signal's handled status.
  ### TODO Used for testing.
  
  sub _data_sig_handled_status {
    return(
      $kr_signal_total_handled,
      $kr_signal_type,
      \@kr_signaled_sessions,
    );
  }
  
  ### Determine if a given session is watching a signal.  This uses a
  ### two-step exists so that the longer one does not autovivify keys in
  ### the shorter one.
  
  sub _data_sig_is_watched_by_session {
    my ($self, $signal, $sid) = @_;
    return(
      exists($kr_signals{$signal}) &&
      exists($kr_signals{$signal}->{$sid})
    );
  }
  
  ### Destroy sessions touched by a nonmaskable signal or by an
  ### unhandled terminal signal.  Check for garbage-collection on
  ### sessions which aren't to be terminated.
  
  sub _data_sig_free_terminated_sessions {
    my $self = shift;
  
    if (
      ($kr_signal_type & SIGTYPE_NONMASKABLE) or
      ($kr_signal_type & SIGTYPE_TERMINAL and !$kr_signal_total_handled)
    ) {
      foreach my $dead_session (@kr_signaled_sessions) {
        next unless $self->_data_ses_exists($dead_session->ID);
  
        if (TRACE_SIGNALS) {
          _warn(
            "<sg> stopping signaled session ",
            $self->_data_alias_loggable($dead_session->ID)
          );
        }
  
        $self->_data_ses_stop($dead_session->ID);
      }
    }
  
    # Erase @kr_signaled_sessions, or they will leak until the next
    # signal.
    @kr_signaled_sessions = ();
  }
  
  ### A signal has touched a session.  Record this fact for later
  ### destruction tests.
  
  sub _data_sig_touched_session {
    my ($self, $session) = @_;
    push @kr_signaled_sessions, $session;
  }
  
  # only used under !USE_SIGCHLD
  sub _data_sig_begin_polling {
    my ($self, $signal) = @_;
  
    return if $polling_for_signals;
    $polling_for_signals = 1;
  
    $self->_data_sig_enqueue_poll_event($signal);
    $self->_idle_queue_grow();
  }
  
  # only used under !USE_SIGCHLD
  sub _data_sig_cease_polling {
    $polling_for_signals = 0;
  }
  
  sub _data_sig_enqueue_poll_event {
    my ($self, $signal) = @_;
  
    if ( USE_SIGCHLD ) {
      return if $polling_for_signals;
      $polling_for_signals = 1;
  
      $self->_data_ev_enqueue(
        $self, $self, EN_SCPOLL, ET_SCPOLL, [ $signal ],
        __FILE__, __LINE__, undef
      );
    } else {
      return if $self->_data_ses_count() < 1;
      return unless $polling_for_signals;
  
      $self->_data_ev_enqueue(
        $self, $self, EN_SCPOLL, ET_SCPOLL, [ $signal ],
        __FILE__, __LINE__, undef, walltime(), POE::Kernel::CHILD_POLLING_INTERVAL(),
      );
    }
  }
  
  sub _data_sig_handle_poll_event {
    my ($self, $signal) = @_;
  
    if ( USE_SIGCHLD ) {
      $polling_for_signals = undef;
    }
  
    if (TRACE_SIGNALS) {
      _warn(
        "<sg> POE::Kernel is polling for signals at " . monotime() .
        (USE_SIGCHLD ? " due to SIGCHLD" : "")
      );
    }
  
    $self->_data_sig_reap_pids();
  
    # The poll loop is over.  Resume slowly polling for signals.
  
    if (USE_SIGCHLD) {
      if (TRACE_SIGNALS) {
        _warn("<sg> POE::Kernel has reset the SIG$signal handler");
      }
      # Per https://rt.cpan.org/Ticket/Display.html?id=45109 setting the
      # signal handler must be done after reaping the outstanding child
      # processes, at least on SysV systems like HP-UX.
      $SIG{$signal} = \&_loop_signal_handler_chld;
    }
    else {
      # The poll loop is over.  Resume slowly polling for signals.
  
      if ($polling_for_signals) {
        if (TRACE_SIGNALS) {
          _warn("<sg> POE::Kernel will poll again after a delay");
        }
        $self->_data_sig_enqueue_poll_event($signal);
      }
      else {
        if (TRACE_SIGNALS) {
          _warn("<sg> POE::Kernel SIGCHLD poll loop paused");
        }
        $self->_idle_queue_shrink();
      }
    }
  }
  
  sub _data_sig_reap_pids {
    my $self = shift();
  
    # Reap children for as long as waitpid(2) says something
    # interesting has happened.
    # TODO This has a possibility of an infinite loop, but so far it
    # hasn't hasn't happened.
  
    my $pid;
    while ($pid = waitpid(-1, WNOHANG)) {
      # waitpid(2) returned a process ID.  Emit an appropriate SIGCHLD
      # event and loop around again.
  
      if (($pid > 0) or (RUNNING_IN_HELL and $pid < -1)) {
        if (RUNNING_IN_HELL or WIFEXITED($?) or WIFSIGNALED($?)) {
  
          if (TRACE_SIGNALS) {
            _warn("<sg> POE::Kernel detected SIGCHLD (pid=$pid; exit=$?)");
          }
  
          # Check for explicit SIGCHLD watchers, and enqueue explicit
          # events for them.
  
          if (exists $kr_pids_to_events{$pid}) {
            my @sessions_to_clear;
            while (my ($sid, $ses_rec) = each %{$kr_pids_to_events{$pid}}) {
              $self->_data_ev_enqueue(
                $ses_rec->[PID_SESSION], $self, $ses_rec->[PID_EVENT], ET_SIGCLD,
                [ 'CHLD', $pid, $?, @{$ses_rec->[PID_ARGS]} ],
                __FILE__, __LINE__, undef
              );
              push @sessions_to_clear, $sid;
            }
            $self->_data_sig_pid_ignore($_, $pid) foreach @sessions_to_clear;
          }
  
          # Kick off a SIGCHLD cascade.
          $self->_data_ev_enqueue(
            $self, $self, EN_SIGNAL, ET_SIGNAL, [ 'CHLD', $pid, $? ],
            __FILE__, __LINE__, undef
          );
        }
        elsif (TRACE_SIGNALS) {
          _warn("<sg> POE::Kernel detected strange exit (pid=$pid; exit=$?");
        }
  
        if (TRACE_SIGNALS) {
          _warn("<sg> POE::Kernel will poll again immediately");
        }
  
        next;
      }
  
      # The only other negative value waitpid(2) should return is -1.
      # This is highly unlikely, but it's necessary to catch
      # portability problems.
      #
      # TODO - Find a way to test this.
  
      _trap "internal consistency error: waitpid returned $pid" if $pid != -1;
  
      # If the error is an interrupted syscall, poll again right away.
  
      if ($! == EINTR) {
        if (TRACE_SIGNALS) {
          _warn(
            "<sg> POE::Kernel's waitpid(2) was interrupted.\n",
            "POE::Kernel will poll again immediately.\n"
          );
        }
        next;
      }
  
      # No child processes exist.  TODO This is different than
      # children being present but running.  Maybe this condition
      # could halt polling entirely, and some UNIVERSAL::fork wrapper
      # could restart polling when processes are forked.
  
      if ($! == ECHILD) {
        if (TRACE_SIGNALS) {
          _warn("<sg> POE::Kernel has no child processes");
        }
        last;
      }
  
      # Some other error occurred.
  
      if (TRACE_SIGNALS) {
        _warn("<sg> POE::Kernel's waitpid(2) got error: $!");
      }
      last;
    }
  
    # Remember whether there are more processes to reap.
  
    $kr_has_child_procs = !$pid;
  }
  
  # Are there child processes worth waiting for?
  # We don't really care if we're not polling for signals.
  
  sub _data_sig_kernel_awaits_pids {
    my $self = shift();
  
    return 0 if !USE_SIGCHLD and !$polling_for_signals;
  
    # There must be child processes or pending signals.
    return 0 unless $kr_has_child_procs or $self->_data_sig_pipe_has_signals();
  
    # At least one session is watching an explicit PID.
    # TODO - Watching a non-existent PID is legal but ill-advised.
    return 1 if scalar keys %kr_pids_to_events;
  
    # Is the session waiting for a blanket sig(CHLD)?
    return exists $kr_signals{CHLD};
  }
  
  ######################
  ## Safe signals, the final solution:
  ## Semantically, signal handlers and the main loop are in different threads.
  ## To avoid all possible deadlock and race conditions once and for all we
  ## implement them as shared-nothing threads.
  ##
  ## The signal handlers are split in 2 :
  ##  - a top handler, which sends the signal number over a one-way pipe.
  ##  - a bottom handler, which is called when this number is received in the
  ##  main loop.
  ## The top handler will send a packet of PID and number.  We need the PID
  ## because of the race condition with signals in perl; signals meant for the
  ## parent end up in both the parent and child.  So we check the PID to make
  ## sure it was intended for the child.  We use 'ii' (2 ints, aka 8 bytes)
  ## and not 'iC' (int+byte, aka 5 bytes) because we want a small factor of
  ## the buffer size in the hopes of never getting a short read.  Ever.
  
  use vars qw( $signal_pipe_read_fd );
  my(
    $signal_pipe_write,
    $signal_pipe_read,
    $signal_pipe_pid,
    $signal_mask_none,
    $signal_mask_all,
  
    @pending_signals,
  );
  
  sub SIGINFO_NAME    () { 0 }
  sub SIGINFO_SRC_PID () { 1 }
  
  
  sub _data_sig_pipe_has_signals {
    my $self = shift();
    return unless $signal_pipe_read;
    my $vec = '';
    vec($vec, fileno($signal_pipe_read), 1) = 1;
  
    # Ambiguous call resolved as CORE::select(), qualify as such or use &
    return(CORE::select($vec, undef, undef, 0) > 0);
  }
  
  
  sub _data_sig_pipe_build {
    my( $self ) = @_;
    return unless USE_SIGNAL_PIPE;
    my $fake = 128;
  
    # Associate the pipe with this PID
    $signal_pipe_pid = $$;
  
    # Mess with the signal mask
    $self->_data_sig_mask_all;
  
    # Open the signal pipe.
    # TODO - Normally POE::Pipe::OneWay will do the right thing.  Why
    # are we overriding its per-platform autodetection?
    if (RUNNING_IN_HELL) {
      ( $signal_pipe_read, $signal_pipe_write ) = POE::Pipe::OneWay->new('inet');
    }
    else {
      ( $signal_pipe_read, $signal_pipe_write ) = POE::Pipe::OneWay->new('pipe');
    }
  
    unless ($signal_pipe_write) {
      _trap "<sg> Error " . ($!+0) . " trying to create the signal pipe: $!";
    }
  
    # Allows Resource::FileHandles to by-pass the queue
    $signal_pipe_read_fd = fileno $signal_pipe_read;
    if( TRACE_SIGNALS ) {
      _warn "<sg> signal_pipe_write=$signal_pipe_write";
      _warn "<sg> signal_pipe_read=$signal_pipe_read";
      _warn "<sg> signal_pipe_read_fd=$signal_pipe_read_fd";
    }
  
    # Add to the select list
    $self->_data_handle_condition( $signal_pipe_read );
    $self->loop_watch_filehandle( $signal_pipe_read, MODE_RD );
    $self->_data_sig_unmask_all;
  }
  
  sub _data_sig_mask_build {
    return if RUNNING_IN_HELL;
    $signal_mask_none  = POSIX::SigSet->new();
    $signal_mask_none->emptyset();
    $signal_mask_all  = POSIX::SigSet->new();
    $signal_mask_all->fillset();
  }
  
  ### Mask all signals
  sub _data_sig_mask_all {
    return if RUNNING_IN_HELL;
    my $self = $poe_kernel;
    unless( $signal_mask_all ) {
      $self->_data_sig_mask_build;
    }
    my $mask_temp = POSIX::SigSet->new();
    sigprocmask( SIG_SETMASK, $signal_mask_all, $mask_temp )
              or _trap "<sg> Unable to mask all signals: $!";
  }
  
  ### Unmask all signals
  sub _data_sig_unmask_all {
    return if RUNNING_IN_HELL;
    my $self = $poe_kernel;
    unless( $signal_mask_none ) {
      $self->_data_sig_mask_build;
    }
    my $mask_temp = POSIX::SigSet->new();
    sigprocmask( SIG_SETMASK, $signal_mask_none, $mask_temp )
          or _trap "<sg> Unable to unmask all signals: $!";
  }
  
  
  
  sub _data_sig_pipe_finalize {
    my( $self ) = @_;
    if( $signal_pipe_read ) {
      $self->loop_ignore_filehandle( $signal_pipe_read, MODE_RD );
      close $signal_pipe_read; undef $signal_pipe_read;
    }
    if( $signal_pipe_write ) {
      close $signal_pipe_write; undef $signal_pipe_write;
    }
    # Don't send anything more!
    undef( $signal_pipe_pid );
  }
  
  ### Send a signal "message" to the main thread
  ### Called from the top signal handlers
  sub _data_sig_pipe_send {
    local $!;
  
    my $signal_name = $_[1];
  
    if( TRACE_SIGNALS ) {
      _warn "<sg> Caught SIG$signal_name";
    }
  
    return if $finalizing;
  
    if( not defined $signal_pipe_pid ) {
      _trap "<sg> _data_sig_pipe_send called before signal pipe was initialized.";
    }
  
    # ugh- has_forked() can't be called fast enough.  This warning might
    # show up before it is called.  Should we just detect forking and do it
    # for the user?  Probably not...
  
    if( $$ != $signal_pipe_pid ) {
      _warn(
        "<sg> Kernel now running in a different process " .
        "(is=$$ was=$signal_pipe_pid ).  " .
        "You must call call \$poe_kernel->has_forked() in the child process."
      );
    }
  
    # We're registering signals in a list.  Pipes have more finite
    # capacity, so we'll just write a single-byte semaphore-like token.
    # It's up to the reader to process the list.  Duplicates are
    # permitted, and their ordering may be significant.  Precedent:
    # http://search.cpan.org/perldoc?IPC%3A%3AMorseSignals
  
    push @pending_signals, [
      $signal_name, # SIGINFO_NAME
      $$,           # SIGINFO_SRC_PID
    ];
  
    if (TRACE_SIGNALS) {
      _warn "<sg> Attempting signal pipe write";
    }
  
    my $count = syswrite( $signal_pipe_write, '!' );
  
    # TODO - We need to crash gracefully if the write fails, but not if
    # it's due to the pipe being full.  We might solve this by only
    # writing on the edge of @pending_signals == 1 after the push().
    # We assume @pending_signals > 1 means there's a byte in the pipe,
    # so the reader will wake up to catch 'em all.
  
    if ( ASSERT_DATA ) {
      unless (defined $count and $count == 1) {
        _trap "<sg> Signal pipe write failed: $!";
      }
    }
  }
  
  ### Read all signal numbers.
  ### Call the related bottom handler.  That is, inside the kernel loop.
  sub _data_sig_pipe_read {
    my( $self, $fileno, $mode ) = @_;
  
    if( ASSERT_DATA ) {
      _trap "Illegal mode=$mode on fileno=$fileno" unless
                                      $fileno == $signal_pipe_read_fd
                                  and $mode eq MODE_RD;
    }
  
    # Read all data from the signal pipe.
    # The data itself doesn't matter.
    # TODO - If writes can happen on the edge of @pending_signals (from
    # 0 to 1 element), then we oughtn't need to loop here.
  
    while (1) {
      my $octets_count = sysread( $signal_pipe_read, (my $data), 65536 );
  
      next if $octets_count;
      last if defined $octets_count;
  
      last if $! == EAGAIN or $! == EWOULDBLOCK;
  
      if (ASSERT_DATA) {
        _trap "<sg> Error " . ($!+0) . " reading from signal pipe: $!";
      }
      elsif(TRACE_SIGNALS) {
        _warn "<sg> Error " . ($!+0) . " reading from signal pipe: $!";
      }
  
      last;
    }
  
    # Double buffer signals.
    # The intent is to avoid a race condition by processing the same
    # buffer that new signals go into.
  
    return unless @pending_signals;
    my @signals = @pending_signals;
    @pending_signals = ();
  
    if (TRACE_SIGNALS) {
      _warn "<sg> Read " . scalar(@signals) . " signals from the list";
    }
  
    foreach my $signal (@signals) {
      my $signal_name    = $signal->[SIGINFO_NAME];
      my $signal_src_pid = $signal->[SIGINFO_SRC_PID];
  
      # Ignore signals from other processes.
      # This can happen if we've fork()ed without calling has_forked()
      # to reset the signals subsystem.
      #
      # TODO - We might be able to get rid of has_forked() if PID
      # mismatches are detected.
  
      next if $signal_src_pid != $$;
  
      if( $signal_name eq 'CHLD' ) {
        _loop_signal_handler_chld_bottom( $signal_name );
      }
      elsif( $signal_name eq 'PIPE' ) {
        _loop_signal_handler_pipe_bottom( $signal_name );
      }
      else {
        _loop_signal_handler_generic_bottom( $signal_name );
      }
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Resource::Signals - internal signal manager for POE::Kernel
  
  =head1 SYNOPSIS
  
  There is no public API.
  
  =head1 DESCRIPTION
  
  POE::Resource::Signals is a mix-in class for POE::Kernel.  It provides
  the features needed to manage signals.  It is used internally by
  POE::Kernel, so it has no public interface.
  
  =head1 SEE ALSO
  
  See L<POE::Kernel/Signals> for a deeper discussion about POE's signal
  handling.
  
  See L<POE::Kernel/Signal Watcher Methods> for POE's public signals
  API.
  
  See L<POE::Kernel/Resources> for public information about POE
  resources.
  
  See L<POE::Resource> for general discussion about resources and the
  classes that manage them.
  
  =head1 BUGS
  
  None known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_RESOURCE_SIGNALS

$fatpacked{"POE/Resources.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_RESOURCES';
  package POE::Resources;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  my @resources = qw(
    POE::XS::Resource::Aliases
    POE::XS::Resource::Events
    POE::XS::Resource::Extrefs
    POE::XS::Resource::FileHandles
    POE::XS::Resource::SIDs
    POE::XS::Resource::Sessions
    POE::XS::Resource::Signals
  );
  
  sub load {
    my $package = (caller())[0];
  
    foreach my $resource (@resources) {
      eval "package $package; use $resource";
      if ($@) {
        # Retry the resource, removing XS:: if it couldn't be loaded.
        # If there's no XS:: to be removed, fall through and die.
        redo if $@ =~ /Can't locate.*?in \@INC/ and $resource =~ s/::XS::/::/;
        die;
      }
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Resources - loader of POE resources
  
  =head1 SYNOPSIS
  
    # Intended for internal use by POE::Kernel.
    use POE::Resources;
    POE::Resources->load();
  
  =head1 DESCRIPTION
  
  POE::Kernel is internally split into different resources that are
  separately managed by individual mix-in classes.
  
  POE::Resources is designed as a high-level macro manager for
  POE::Resource classes.  Currently it implements a single method,
  load(), which loads all the POE::Resource classes.
  
  =head1 METHODS
  
  POE::Resources has a public interface, but it is intended to be used
  internally by POE::Kernel.  Application programmers should never need
  to use POE::Resources directly.
  
  =head2 load
  
  POE::Kernel calls load() to loads all the known POE::Resource modules.
  
  Each resource may be handled by a pure perl module, or by an XS
  module.  For each resource class, load() first tries to load the
  C<POE::XS::Resource::...> version of the module.  If that fails,
  load() falls back to C<POE::Resource::...>.
  
  =head1 SEE ALSO
  
  See L<POE::Kernel/Resources> for public information about POE
  resources.
  
  See L<POE::Resource> for general discussion about resources and the
  classes that manage them.
  
  =head1 AUTHORS & LICENSING
  
  Please see L<POE> for more information about its authors,
  contributors, and POE's licensing.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_RESOURCES

$fatpacked{"POE/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_SESSION';
  package POE::Session;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw(carp croak);
  use Errno;
  
  sub SE_NAMESPACE    () { 0 }
  sub SE_OPTIONS      () { 1 }
  sub SE_STATES       () { 2 }
  sub SE_ID           () { 3 }
  
  sub CREATE_ARGS     () { 'args' }
  sub CREATE_OPTIONS  () { 'options' }
  sub CREATE_INLINES  () { 'inline_states' }
  sub CREATE_PACKAGES () { 'package_states' }
  sub CREATE_OBJECTS  () { 'object_states' }
  sub CREATE_HEAP     () { 'heap' }
  
  sub OPT_TRACE       () { 'trace' }
  sub OPT_DEBUG       () { 'debug' }
  sub OPT_DEFAULT     () { 'default' }
  
  sub EN_START        () { '_start' }
  sub EN_DEFAULT      () { '_default' }
  sub EN_SIGNAL       () { '_signal' }
  
  #------------------------------------------------------------------------------
  # Debugging flags for subsystems.  They're done as double evals here
  # so that someone may define them before using POE::Session (or POE),
  # and the pre-defined value will take precedence over the defaults
  # here.
  
  # Shorthand for defining an assert constant.
  
  sub _define_assert {
    no strict 'refs';
    foreach my $name (@_) {
  
      local $^W = 0;
  
      next if defined *{"ASSERT_$name"}{CODE};
      if (defined *{"POE::Kernel::ASSERT_$name"}{CODE}) {
        eval(
          "sub ASSERT_$name () { " .
          *{"POE::Kernel::ASSERT_$name"}{CODE}->() .
          "}"
        );
        die if $@;
      }
      else {
        eval "sub ASSERT_$name () { ASSERT_DEFAULT }";
        die if $@;
      }
    }
  }
  
  # Shorthand for defining a trace constant.
  sub _define_trace {
    no strict 'refs';
  
    local $^W = 0;
  
    foreach my $name (@_) {
      next if defined *{"TRACE_$name"}{CODE};
      if (defined *{"POE::Kernel::TRACE_$name"}{CODE}) {
        eval(
          "sub TRACE_$name () { " .
          *{"POE::Kernel::TRACE_$name"}{CODE}->() .
          "}"
        );
        die if $@;
      }
      else {
        eval "sub TRACE_$name () { TRACE_DEFAULT }";
        die if $@;
      }
    }
  }
  
  BEGIN {
  
    # ASSERT_DEFAULT changes the default value for other ASSERT_*
    # constants.  It inherits POE::Kernel's ASSERT_DEFAULT value, if
    # it's present.
  
    unless (defined &ASSERT_DEFAULT) {
      if (defined &POE::Kernel::ASSERT_DEFAULT) {
        eval( "sub ASSERT_DEFAULT () { " . &POE::Kernel::ASSERT_DEFAULT . " }" );
      }
      else {
        eval 'sub ASSERT_DEFAULT () { 0 }';
      }
    };
  
    # TRACE_DEFAULT changes the default value for other TRACE_*
    # constants.  It inherits POE::Kernel's TRACE_DEFAULT value, if
    # it's present.
  
    unless (defined &TRACE_DEFAULT) {
      if (defined &POE::Kernel::TRACE_DEFAULT) {
        eval( "sub TRACE_DEFAULT () { " . &POE::Kernel::TRACE_DEFAULT . " }" );
      }
      else {
        eval 'sub TRACE_DEFAULT () { 0 }';
      }
    };
  
    _define_assert("STATES");
    _define_trace("DESTROY");
  }
  
  #------------------------------------------------------------------------------
  # Export constants into calling packages.  This is evil; perhaps
  # EXPORT_OK instead?  The parameters NFA has in common with SESSION
  # (and other sessions) must be kept at the same offsets as each-other.
  
  sub OBJECT  () {  0 } # TODO - deprecate and replace with SELF
  sub SESSION () {  1 }
  sub KERNEL  () {  2 }
  sub HEAP    () {  3 }
  sub STATE   () {  4 } # TODO - deprecate and replace with EVENT
  sub SENDER  () {  5 }
  # NFA keeps its state in 6.  unused in session so that args match up.
  sub CALLER_FILE () { 7 }
  sub CALLER_LINE () { 8 }
  sub CALLER_STATE () { 9 } # TODO - deprecate and replace with CALLER_EVENT
  sub ARG0    () { 10 }
  sub ARG1    () { 11 }
  sub ARG2    () { 12 }
  sub ARG3    () { 13 }
  sub ARG4    () { 14 }
  sub ARG5    () { 15 }
  sub ARG6    () { 16 }
  sub ARG7    () { 17 }
  sub ARG8    () { 18 }
  sub ARG9    () { 19 }
  
  sub import {
    my $package = caller();
    no strict 'refs';
    *{ $package . '::OBJECT'  } = \&OBJECT;
    *{ $package . '::SESSION' } = \&SESSION;
    *{ $package . '::KERNEL'  } = \&KERNEL;
    *{ $package . '::HEAP'    } = \&HEAP;
    *{ $package . '::STATE'   } = \&STATE;
    *{ $package . '::SENDER'  } = \&SENDER;
    *{ $package . '::ARG0'    } = \&ARG0;
    *{ $package . '::ARG1'    } = \&ARG1;
    *{ $package . '::ARG2'    } = \&ARG2;
    *{ $package . '::ARG3'    } = \&ARG3;
    *{ $package . '::ARG4'    } = \&ARG4;
    *{ $package . '::ARG5'    } = \&ARG5;
    *{ $package . '::ARG6'    } = \&ARG6;
    *{ $package . '::ARG7'    } = \&ARG7;
    *{ $package . '::ARG8'    } = \&ARG8;
    *{ $package . '::ARG9'    } = \&ARG9;
    *{ $package . '::CALLER_FILE' } = \&CALLER_FILE;
    *{ $package . '::CALLER_LINE' } = \&CALLER_LINE;
    *{ $package . '::CALLER_STATE' } = \&CALLER_STATE;
  }
  
  sub instantiate {
    my $type = shift;
  
    croak "$type requires a working Kernel"
      unless defined $POE::Kernel::poe_kernel;
  
    my $self =
      bless [ { }, # SE_NAMESPACE
              { }, # SE_OPTIONS
              { }, # SE_STATES
            ], $type;
  
    if (ASSERT_STATES) {
      $self->[SE_OPTIONS]->{+OPT_DEFAULT} = 1;
    }
  
    return $self;
  }
  
  sub try_alloc {
    my ($self, @args) = @_;
    # Verify that the session has a special start state, otherwise how
    # do we know what to do?  Don't even bother registering the session
    # if the start state doesn't exist.
  
    if (exists $self->[SE_STATES]->{+EN_START}) {
      $POE::Kernel::poe_kernel->session_alloc($self, @args);
    }
    else {
      carp( "discarding session ",
            $POE::Kernel::poe_kernel->ID_session_to_id($self),
            " - no '_start' state"
          );
      $self = undef;
    }
  
    $self;
  }
  
  #------------------------------------------------------------------------------
  # New style constructor.  This uses less DWIM and more DWIS, and it's
  # more comfortable for some folks; especially the ones who don't quite
  # know WTM.
  
  sub create {
    my ($type, @params) = @_;
    my @args;
  
    # We treat the parameter list strictly as a hash.  Rather than dying
    # here with a Perl error, we'll catch it and blame it on the user.
  
    if (@params & 1) {
      croak "odd number of events/handlers (missing one or the other?)";
    }
    my %params = @params;
  
    my $self = $type->instantiate(\%params);
  
    # Process _start arguments.  We try to do the right things with what
    # we're given.  If the arguments are a list reference, map its items
    # to ARG0..ARGn; otherwise make whatever the heck it is be ARG0.
  
    if (exists $params{+CREATE_ARGS}) {
      if (ref($params{+CREATE_ARGS}) eq 'ARRAY') {
        push @args, @{$params{+CREATE_ARGS}};
      }
      else {
        push @args, $params{+CREATE_ARGS};
      }
      delete $params{+CREATE_ARGS};
    }
  
    # Process session options here.  Several options may be set.
  
    if (exists $params{+CREATE_OPTIONS}) {
      if (ref($params{+CREATE_OPTIONS}) eq 'HASH') {
        $self->[SE_OPTIONS] = $params{+CREATE_OPTIONS};
      }
      else {
        croak "options for $type constructor is expected to be a HASH reference";
      }
      delete $params{+CREATE_OPTIONS};
    }
  
    # Get down to the business of defining states.
  
    while (my ($param_name, $param_value) = each %params) {
  
      # Inline states are expected to be state-name/coderef pairs.
  
      if ($param_name eq CREATE_INLINES) {
        croak "$param_name does not refer to a hash"
          unless (ref($param_value) eq 'HASH');
  
        while (my ($state, $handler) = each(%$param_value)) {
          croak "inline state for '$state' needs a CODE reference"
            unless (ref($handler) eq 'CODE');
          $self->_register_state($state, $handler);
        }
      }
  
      # Package states are expected to be package-name/list-or-hashref
      # pairs.  If the second part of the pair is a arrayref, then the
      # package methods are expected to be named after the states
      # they'll handle.  If it's a hashref, then the keys are state
      # names and the values are package methods that implement them.
  
      elsif ($param_name eq CREATE_PACKAGES) {
        croak "$param_name does not refer to an array"
          unless (ref($param_value) eq 'ARRAY');
        croak "the array for $param_name has an odd number of elements"
          if (@$param_value & 1);
  
        # Copy the parameters so they aren't destroyed.
        my @param_value = @$param_value;
        while (my ($package, $handlers) = splice(@param_value, 0, 2)) {
  
          # TODO What do we do if the package name has some sort of
          # blessing?  Do we use the blessed thingy's package, or do we
          # maybe complain because the user might have wanted to make
          # object states instead?
  
          # An array of handlers.  The array's items are passed through
          # as both state names and package method names.
  
          if (ref($handlers) eq 'ARRAY') {
            foreach my $method (@$handlers) {
              $self->_register_state($method, $package, $method);
            }
          }
  
          # A hash of handlers.  Hash keys are state names; values are
          # package methods to implement them.
  
          elsif (ref($handlers) eq 'HASH') {
            while (my ($state, $method) = each %$handlers) {
              $self->_register_state($state, $package, $method);
            }
          }
  
          else {
            croak( "states for package '$package' " .
                   "need to be a hash or array ref"
                 );
          }
        }
      }
  
      # Object states are expected to be object-reference/
      # list-or-hashref pairs.  They must be passed to &create in a list
      # reference instead of a hash reference because making object
      # references into hash keys loses their blessings.
  
      elsif ($param_name eq CREATE_OBJECTS) {
        croak "$param_name does not refer to an array"
          unless (ref($param_value) eq 'ARRAY');
        croak "the array for $param_name has an odd number of elements"
          if (@$param_value & 1);
  
        # Copy the parameters so they aren't destroyed.
        my @param_value = @$param_value;
        while (@param_value) {
          my ($object, $handlers) = splice(@param_value, 0, 2);
  
          # Verify that the object is an object.  This may catch simple
          # mistakes; or it may be overkill since it already checks that
          # $param_value is a arrayref.
  
          carp "'$object' is not an object" unless ref($object);
  
          # An array of handlers.  The array's items are passed through
          # as both state names and object method names.
  
          if (ref($handlers) eq 'ARRAY') {
            foreach my $method (@$handlers) {
              $self->_register_state($method, $object, $method);
            }
          }
  
          # A hash of handlers.  Hash keys are state names; values are
          # package methods to implement them.
  
          elsif (ref($handlers) eq 'HASH') {
            while (my ($state, $method) = each %$handlers) {
              $self->_register_state($state, $object, $method);
            }
          }
  
          else {
            croak "states for object '$object' need to be a hash or array ref";
          }
  
        }
      }
  
      # Import an external heap.  This is a convenience, since it
      # eliminates the need to connect _start options to heap values.
  
      elsif ($param_name eq CREATE_HEAP) {
        $self->[SE_NAMESPACE] = $param_value;
      }
  
      else {
        croak "unknown $type parameter: $param_name";
      }
    }
  
    return $self->try_alloc(@args);
  }
  
  #------------------------------------------------------------------------------
  
  sub DESTROY {
    my $self = shift;
  
    # Session's data structures are destroyed through Perl's usual
    # garbage collection.  TRACE_DESTROY here just shows what's in the
    # session before the destruction finishes.
  
    TRACE_DESTROY and do {
      require Data::Dumper;
      POE::Kernel::_warn(
        "----- Session $self Leak Check -----\n",
        "-- Namespace (HEAP):\n",
        Data::Dumper::Dumper($self->[SE_NAMESPACE]),
        "-- Options:\n",
      );
      foreach (sort keys (%{$self->[SE_OPTIONS]})) {
        POE::Kernel::_warn("   $_ = ", $self->[SE_OPTIONS]->{$_}, "\n");
      }
      POE::Kernel::_warn("-- States:\n");
      foreach (sort keys (%{$self->[SE_STATES]})) {
        POE::Kernel::_warn("   $_ = ", $self->[SE_STATES]->{$_}, "\n");
      }
    };
  }
  
  #------------------------------------------------------------------------------
  
  sub _invoke_state {
    my ($self, $source_session, $state, $etc, $file, $line, $fromstate) = @_;
  
    # Trace the state invocation if tracing is enabled.
  
    if ($self->[SE_OPTIONS]->{+OPT_TRACE}) {
      POE::Kernel::_warn(
        $POE::Kernel::poe_kernel->ID_session_to_id($self),
        " -> $state (from $file at $line)\n"
      );
    }
  
    # The desired destination state doesn't exist in this session.
    # Attempt to redirect the state transition to _default.
  
    unless (exists $self->[SE_STATES]->{$state}) {
  
      # There's no _default either; redirection's not happening today.
      # Drop the state transition event on the floor, and optionally
      # make some noise about it.
  
      unless (exists $self->[SE_STATES]->{+EN_DEFAULT}) {
        $! = exists &Errno::ENOSYS ? &Errno::ENOSYS : &Errno::EIO;
        if ($self->[SE_OPTIONS]->{+OPT_DEFAULT} and $state ne EN_SIGNAL) {
          my $loggable_self =
            $POE::Kernel::poe_kernel->_data_alias_loggable($self->ID);
          POE::Kernel::_warn(
            "a '$state' event was sent from $file at $line to $loggable_self ",
            "but $loggable_self has neither a handler for it ",
            "nor one for _default\n"
          );
        }
        return undef;
      }
  
      # If we get this far, then there's a _default state to redirect
      # the transition to.  Trace the redirection.
  
      if ($self->[SE_OPTIONS]->{+OPT_TRACE}) {
        POE::Kernel::_warn(
          $POE::Kernel::poe_kernel->ID_session_to_id($self),
          " -> $state redirected to _default\n"
        );
      }
  
      # Transmogrify the original state transition into a corresponding
      # _default invocation.  ARG1 is copied from $etc so it can't be
      # altered from a distance.
  
      $etc   = [ $state, [@$etc] ];
      $state = EN_DEFAULT;
    }
  
    # If we get this far, then the state can be invoked.  So invoke it
    # already!
  
    # Inline states are invoked this way.
  
    if (ref($self->[SE_STATES]->{$state}) eq 'CODE') {
      return $self->[SE_STATES]->{$state}->
        ( undef,                          # object
          $self,                          # session
          $POE::Kernel::poe_kernel,       # kernel
          $self->[SE_NAMESPACE],          # heap
          $state,                         # state
          $source_session,                # sender
          undef,                          # unused #6
          $file,                          # caller file name
          $line,                          # caller file line
          $fromstate,                     # caller state
          @$etc                           # args
        );
    }
  
    # Package and object states are invoked this way.
  
    my ($object, $method) = @{$self->[SE_STATES]->{$state}};
    return
      $object->$method                    # package/object (implied)
        ( $self,                          # session
          $POE::Kernel::poe_kernel,       # kernel
          $self->[SE_NAMESPACE],          # heap
          $state,                         # state
          $source_session,                # sender
          undef,                          # unused #6
          $file,                          # caller file name
          $line,                          # caller file line
      $fromstate,            # caller state
          @$etc                           # args
        );
  }
  
  #------------------------------------------------------------------------------
  # Add, remove or replace states in the session.
  
  sub _register_state {
    my ($self, $name, $handler, $method) = @_;
    $method = $name unless defined $method;
  
    # Deprecate _signal.
    # RC 2004-09-07 - Decided to leave this in because it blames
    # problems with _signal on the user for using it.  It should
    # probably go away after a little while, but not during the other
    # deprecations.
  
    if ($name eq EN_SIGNAL) {
  
      # Report the problem outside POE.
      my $caller_level = 0;
      local $Carp::CarpLevel = 1;
      while ( (caller $caller_level)[0] =~ /^POE::/ ) {
        $caller_level++;
        $Carp::CarpLevel++;
      }
  
      croak(
        ",----- DEPRECATION ERROR -----\n",
        "| The _signal event is deprecated.  Please use sig() to register\n",
        "| an explicit signal handler instead.\n",
        "`-----------------------------\n",
     );
    }
  
    # There is a handler, so try to define the state.  This replaces an
    # existing state.
  
    if ($handler) {
  
      # Coderef handlers are inline states.
  
      if (ref($handler) eq 'CODE') {
        carp( "redefining handler for event($name) for session(",
              $POE::Kernel::poe_kernel->ID_session_to_id($self), ")"
            )
          if ( $self->[SE_OPTIONS]->{+OPT_DEBUG} &&
               (exists $self->[SE_STATES]->{$name})
             );
        $self->[SE_STATES]->{$name} = $handler;
      }
  
      # Non-coderef handlers may be package or object states.  See if
      # the method belongs to the handler.
  
      elsif ($handler->can($method)) {
        carp( "redefining handler for event($name) for session(",
              $POE::Kernel::poe_kernel->ID_session_to_id($self), ")"
            )
          if ( $self->[SE_OPTIONS]->{+OPT_DEBUG} &&
               (exists $self->[SE_STATES]->{$name})
             );
        $self->[SE_STATES]->{$name} = [ $handler, $method ];
      }
  
      # Something's wrong.  This code also seems wrong, since
      # ref($handler) can't be 'CODE'.
  
      else {
        if ( (ref($handler) eq 'CODE') and
             $self->[SE_OPTIONS]->{+OPT_TRACE}
           ) {
          carp( $POE::Kernel::poe_kernel->ID_session_to_id($self),
                " : handler for event($name) is not a proper ref - not registered"
              )
        }
        else {
          unless ($handler->can($method)) {
            if (length ref($handler)) {
              croak "object $handler does not have a '$method' method"
            }
            else {
              croak "package $handler does not have a '$method' method";
            }
          }
        }
      }
    }
  
    # No handler.  Delete the state!
  
    else {
      delete $self->[SE_STATES]->{$name};
    }
  }
  
  #------------------------------------------------------------------------------
  # Return the session's ID.  This is a thunk into POE::Kernel, where
  # the session ID really lies.
  
  sub _set_id {
    my ($self, $id) = @_;
    $self->[SE_ID] = $id;
  }
  
  sub ID {
    return shift()->[SE_ID];
  }
  
  #------------------------------------------------------------------------------
  # Set or fetch session options.
  
  sub option {
    my $self = shift;
    my %return_values;
  
    # Options are set in pairs.
  
    while (@_ >= 2) {
      my ($flag, $value) = splice(@_, 0, 2);
      $flag = lc($flag);
  
      # If the value is defined, then set the option.
  
      if (defined $value) {
  
        # Change some handy values into boolean representations.  This
        # clobbers the user's original values for the sake of DWIM-ism.
  
        ($value = 1) if ($value =~ /^(on|yes|true)$/i);
        ($value = 0) if ($value =~ /^(no|off|false)$/i);
  
        $return_values{$flag} = $self->[SE_OPTIONS]->{$flag};
        $self->[SE_OPTIONS]->{$flag} = $value;
      }
  
      # Remove the option if the value is undefined.
  
      else {
        $return_values{$flag} = delete $self->[SE_OPTIONS]->{$flag};
      }
    }
  
    # If only one option is left, then there's no value to set, so we
    # fetch its value.
  
    if (@_) {
      my $flag = lc(shift);
      $return_values{$flag} =
        ( exists($self->[SE_OPTIONS]->{$flag})
          ? $self->[SE_OPTIONS]->{$flag}
          : undef
        );
    }
  
    # If only one option was set or fetched, then return it as a scalar.
    # Otherwise return it as a hash of option names and values.
  
    my @return_keys = keys(%return_values);
    if (@return_keys == 1) {
      return $return_values{$return_keys[0]};
    }
    else {
      return \%return_values;
    }
  }
  
  # Fetch the session's heap.  In rare cases, libraries may need to
  # break encapsulation this way, probably also using
  # $kernel->get_current_session as an accessory to the crime.
  
  sub get_heap {
    my $self = shift;
    return $self->[SE_NAMESPACE];
  }
  
  #------------------------------------------------------------------------------
  # Create an anonymous sub that, when called, posts an event back to a
  # session.  This maps postback references (stringified; blessing, and
  # thus refcount, removed) to parent session IDs.  Members are set when
  # postbacks are created, and postbacks' DESTROY methods use it to
  # perform the necessary cleanup when they go away.  Thanks to njt for
  # steering me right on this one.
  
  my %anonevent_parent_id;
  my %anonevent_weakened;
  
  # I assume that when the postback owner loses all reference to it,
  # they are done posting things back to us.  That's when the postback's
  # DESTROY is triggered, and referential integrity is maintained.
  
  sub POE::Session::AnonEvent::DESTROY {
    my $self = shift;
    my $parent_id = delete $anonevent_parent_id{$self};
    unless (delete $anonevent_weakened{$self}) {
      $POE::Kernel::poe_kernel->refcount_decrement( $parent_id, 'anon_event' );
    }
  }
  
  sub POE::Session::AnonEvent::weaken {
    my $self = shift;
    unless ($anonevent_weakened{$self}) {
      my $parent_id = $anonevent_parent_id{$self};
      $POE::Kernel::poe_kernel->refcount_decrement( $parent_id, 'anon_event' );
      $anonevent_weakened{$self} = 1;
    }
    return $self;
  }
  
  # Tune postbacks depending on variations in toolkit behavior.
  
  BEGIN {
    # Tk blesses its callbacks internally, so we need to wrap our
    # blessed callbacks in unblessed ones.  Otherwise our postback's
    # DESTROY method probably won't be called.
    if (exists $INC{'Tk.pm'}) {
      eval 'sub USING_TK () { 1 }';
    }
    else {
      eval 'sub USING_TK () { 0 }';
    }
  };
  
  # Create a postback closure, maintaining referential integrity in the
  # process.  The next step is to give it to something that expects to
  # be handed a callback.
  
  sub postback {
    my ($self, $event, @etc) = @_;
    my $id = $POE::Kernel::poe_kernel->ID_session_to_id($self);
  
    my $postback = bless sub {
      $POE::Kernel::poe_kernel->post( $id, $event, [ @etc ], [ @_ ] );
      return 0;
    }, 'POE::Session::AnonEvent';
  
    $anonevent_parent_id{$postback} = $id;
    $POE::Kernel::poe_kernel->refcount_increment( $id, 'anon_event' );
  
    # Tk blesses its callbacks, so we must present one that isn't
    # blessed.  Otherwise Tk's blessing would divert our DESTROY call to
    # its own, and that's not right.
  
    return sub { $postback->(@_) } if USING_TK;
    return $postback;
  }
  
  # Create a synchronous callback closure.  The return value will be
  # passed to whatever is handed the callback.
  
  sub callback {
    my ($self, $event, @etc) = @_;
    my $id = $POE::Kernel::poe_kernel->ID_session_to_id($self);
  
    my $callback = bless sub {
      $POE::Kernel::poe_kernel->call( $id, $event, [ @etc ], [ @_ ] );
    }, 'POE::Session::AnonEvent';
  
    $anonevent_parent_id{$callback} = $id;
    $POE::Kernel::poe_kernel->refcount_increment( $id, 'anon_event' );
  
    # Tk blesses its callbacks, so we must present one that isn't
    # blessed.  Otherwise Tk's blessing would divert our DESTROY call to
    # its own, and that's not right.
  
    return sub { $callback->(@_) } if USING_TK;
    return $callback;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Session - a generic event-driven task
  
  =head1 SYNOPSIS
  
    use POE; # auto-includes POE::Kernel and POE::Session
  
    POE::Session->create(
      inline_states => {
        _start => sub { $_[KERNEL]->yield("next") },
        next   => sub {
          print "tick...\n";
          $_[KERNEL]->delay(next => 1);
        },
      },
    );
  
    POE::Kernel->run();
    exit;
  
  POE::Session can also dispatch to object and class methods through
  L</object_states> and L</package_states> callbacks.
  
  =head1 DESCRIPTION
  
  POE::Session and its subclasses translate events from POE::Kernel's
  generic dispatcher into the particular calling conventions suitable for
  application code.  In design pattern parlance, POE::Session classes
  are adapters between L<POE::Kernel> and application code.
  
  The L<sessions|POE::Kernel/Sessions> that POE::Kernel manages are more
  like generic task structures.  Unfortunately these two disparate
  concepts have virtually identical names.
  
  =head2 A note on nomenclature
  
  This documentation will refer to event handlers as "states" in certain
  unavoidable situations.  Sessions were originally meant to be
  event-driven state machines, but their purposes evolved over time.
  Some of the legacy vocabulary lives on in the API for backward
  compatibility, however.
  
  Confusingly, L<POE::NFA> is a class for implementing actual
  event-driven state machines.  Its documentation uses "state" in the
  proper sense.
  
  =head1 USING POE::Session
  
  POE::Session has two main purposes.  First, it maps event names to the
  code that will handle them.  Second, it maps a consistent event
  dispatch interface to those handlers.
  
  Consider the L</SYNOPSIS> for example.  A POE::Session instance is
  created with two C<inline_states>, each mapping an event name
  ("_start" and "next") to an inline subroutine.  POE::Session ensures
  that L</$_[KERNEL]> and so on are meaningful within an event handler.
  
  Event handlers may also be object or class methods, using
  L</object_states> and L</package_states> respectively.  The create()
  syntax is different than for C<inline_states>, but the calling
  convention is nearly identical.
  
  Notice that the created POE::Session object has not been saved to a
  variable.  The new POE::Session object gives itself to POE::Kernel,
  which then manages it and all the resources it uses.
  
  It's possible to keep references to new POE::Session objects, but it's
  not usually necessary.  If an application is not careful about
  cleaning up these references you will create circular references,
  which will leak memory when POE::Kernel would normally destroy the
  POE::Session object.  It is recommended that you keep the session's
  L<ID> instead.
  
  =head2 POE::Session's Calling Convention
  
  The biggest syntactical hurdle most people have with POE is
  POE::Session's unconventional calling convention.  For example:
  
    sub handle_event {
      my ($kernel, $heap, $parameter) = @_[KERNEL, HEAP, ARG0];
      ...;
    }
  
  Or the use of C<$_[KERNEL]>, C<$_[HEAP]> and C<$_[ARG0]> inline,
  as is done in most examples.
  
  What's going on here is rather basic.  Perl passes parameters into
  subroutines or methods using the @_ array.  C<KERNEL>, C<HEAP>,
  C<ARG0> and others are constants exported by POE::Session (which is
  included for free when a program uses POE).
  
  So C<$_[KERNEL]> is an event handler's KERNELth parameter.
  C<@_[HEAP, ARG0]> is a slice of @_ containing the HEAPth and ARG0th
  parameters.
  
  While this looks odd, it's perfectly plain and legal Perl syntax.  POE
  uses it for a few reasons:
  
  =over 4
  
  =item 1
  
  In the common case, passing parameters in C<@_> is faster than passing
  hash or array references and then dereferencing them in the handler.
  
  =item 2
  
  Typos in hash-based parameter lists are either subtle run-time
  errors or requires constant run-time checking.  Constants are either
  known at compile time, or are clear compile-time errors.
  
  =item 3
  
  Referencing C<@_> offsets by constants allows parameters to move
  in the future without breaking application code.
  
  =item 4
  
  Most event handlers don't need all of C<@_>.  Slices allow handlers to
  use only the parameters they're interested in.
  
  =back
  
  =head2 POE::Session Parameters
  
  Event handlers receive most of their run-time context in up to nine
  callback parameters.  POE::Kernel provides many of them.
  
  =head3 $_[OBJECT]
  
  C<$_[OBJECT]> is $self for event handlers that are an object method.  It is
  the class (package) name for class-based event handlers.  It is undef
  for plain coderef callbacks, which have no special C<$self>-ish value.
  
  C<OBJECT> is always zero, since C<$_[0]> is always C<$self> or C<$class>
  in object and class methods.  Coderef handlers are called with
  an C<undef> placeholder in C<$_[0]> so that the other offsets remain valid.
  
  It's often useful for method-based event handlers to call other
  methods in the same object.  C<$_[OBJECT]> helps this happen.
  
    sub ui_update_everything {
      my $self = $_[OBJECT];
      $self->update_menu();
      $self->update_main_window();
      $self->update_status_line();
    }
  
  You may also use method inheritance.  Here we invoke
  $self->a_method(@_).  Since Perl's C<< -> >> operator unshifts $self
  onto the beginning of @_, we must first shift a copy off to maintain
  POE's parameter offsets:
  
    sub a_method {
      my $self = shift;
      $self->SUPER::a_method( @_ );
      # ... more work ...
    }
  
  =head3 $_[SESSION]
  
  C<$_[SESSION]> is a reference to the current session object.  This lets event
  handlers access their session's methods.  Programs may also compare
  C<$_[SESSION]> to C<$_[SENDER]> to verify that intra-session events did not
  come from other sessions.
  
  C<$_[SESSION]> may also be used as the destination for intra-session
  L<post()|POE::Kernel/post> and L<call()|POE::Kernel/call>.  L<yield()|POE::Kernel/yield> is marginally more convenient and
  efficient than C<post($_[SESSION], ...)> however.
  
  It is bad form to access another session directly.  The recommended
  approach is to manipulate a session through an event handler.
  
    sub enable_trace {
      my $previous_trace = $_[SESSION]->option( trace => 1 );
      my $id = $_[SESSION]->ID;
      if ($previous_trace) {
        print "Session $id: dispatch trace is still on.\n";
      }
      else {
        print "Session $id: dispatch trace has been enabled.\n";
      }
    }
  
  =head3 $_[KERNEL]
  
  The KERNELth parameter is always a reference to the application's
  singleton L<POE::Kernel> instance.  It is most often used to call
  POE::Kernel methods from event handlers.
  
    # Set a 10-second timer.
    $_[KERNEL]->delay( time_is_up => 10 );
  
  =head3 $_[HEAP]
  
  Every POE::Session object contains its own variable namespace known as
  the session's C<HEAP>.  It is modeled and named after process memory
  heaps (not priority heaps).  Heaps are by default anonymous hash
  references, but they may be initialized in L<create()|/create> to be almost
  anything.  POE::Session itself never uses C<$_[HEAP]>, although some POE
  components do.
  
  Heaps do not overlap between sessions, although create()'s "heap"
  parameter can be used to make this happen.
  
  These two handlers time the lifespan of a session:
  
    sub _start_handler {
      $_[HEAP]{ts_start} = time();
    }
  
    sub _stop_handler {
      my $time_elapsed = time() - $_[HEAP]{ts_start};
      print "Session ", $_[SESSION]->ID, " elapsed seconds: $elapsed\n";
    }
  
  =head3 $_[STATE]
  
  The STATEth handler parameter contains the name of the event being
  dispatched in the current callback.  This can be important since the
  event and handler names may significantly differ.  Also, a single
  handler may be assigned to more than one event.
  
    POE::Session->create(
      inline_states => {
        one => \&some_handler,
        two => \&some_handler,
        six => \&some_handler,
        ten => \&some_handler,
        _start => sub {
          $_[KERNEL]->yield($_) for qw(one two six ten);
        }
      }
    );
  
    sub some_handler {
      print(
        "Session ", $_[SESSION]->ID,
        ": some_handler() handled event $_[STATE]\n"
      );
    }
  
  It should be noted however that having event names and handlers names match
  will make your code easier to navigate.
  
  =head3 $_[SENDER]
  
  Events must come from somewhere.  C<$_[SENDER]> contains the currently
  dispatched event's source.
  
  C<$_[SENDER]> is commonly used as a return address for responses.  It may
  also be compared against C<$_[KERNEL]> to verify that timers and other
  POE::Kernel-generated events were not spoofed.
  
  This C<echo_handler()> responds to the sender with an "echo" event that
  contains all the parameters it received.  It avoids a feedback loop by
  ensuring the sender session and event (STATE) are not identical to the
  current ones.
  
    sub echo_handler {
      return if $_[SENDER] == $_[SESSION] and $_[STATE] eq "echo";
      $_[KERNEL]->post( $_[SENDER], "echo", @_[ARG0..$#_] );
    }
  
  =for comment
  TODO - Document which events should have $_[SENDER] == $_[KERNEL].
  Probably in POE::Kernel.>
  
  =head3 $_[CALLER_FILE], $_[CALLER_LINE] and $_[CALLER_STATE]
  
  These parameters are a form of caller(), but they describe where the
  currently dispatched event originated.  CALLER_FILE and CALLER_LINE
  are fairly plain.  CALLER_STATE contains the name of the event that
  was being handled when the event was created, or when the event
  watcher that ultimately created the event was registered.
  
  =for comment
  TODO - Rename SENDER_FILE, SENDER_LINE, SENDER_STATE?
  
  =head3 @_[ARG0..ARG9] or @_[ARG0..$#_]
  
  Parameters $_[ARG0] through the end of @_ contain parameters provided
  by application code, event watchers, or higher-level libraries.  These
  parameters are guaranteed to be at the end of @_ so that @_[ARG0..$#_]
  will always catch them all.
  
  $#_ is the index of the last value in @_.  Blame Perl if it looks odd.
  It's merely the $#array syntax where the array name is an underscore.
  
  Consider
  
    $_[KERNEL]->yield( ev_whatever => qw( zero one two three ) );
  
  The handler for ev_whatever will be called with "zero" in $_[ARG0],
  "one" in $_[ARG1], and so on.  @_[ARG0..$#_] will contain all four
  words.
  
    sub ev_whatever {
      $_[OBJECT]->whatever( @_[ARG0..$#_] );
    }
  
  =head2 Using POE::Session With Objects
  
  One session may handle events across many objects.  Or looking at it
  the other way, multiple objects can be combined into one session.  And
  what the heck---go ahead and mix in some inline code as well.
  
    POE::Session->create(
      object_states => [
        $object_1 => { event_1a => "method_1a" },
        $object_2 => { event_2a => "method_2a" },
      ],
      inline_states => {
        event_3 => \&piece_of_code,
      },
    );
  
  However only one handler may be assigned to a given event name.
  Duplicates will overwrite earlier ones.
  
  event_1a is handled by calling C<< $object_1->method_1a(...) >>.  C<$_[OBJECT]>
  is C<$object_1> in this case.  C<$_[HEAP]> belongs to the session, which
  means anything stored there will be available to any other event
  handler regardless of the object.
  
  event_2a is handled by calling C<< $object_2->method_2a(...) >>.  In this
  case C<$_[OBJECT]> is $object_2.  C<$_[HEAP]> is the same anonymous hashref
  that was passed to the event_1a handler, though.  The methods are resolved
  when the event is handled (late-binding).
  
  event_3 is handled by calling C<piece_of_code(...)>.  C<$_[OBJECT]> is C<undef>
  here because there's no object.  And once again, C<$_[HEAP]> is the same
  shared hashref that the handlers for event_1a and event_2a saw.
  
  Interestingly, there's no technical reason that a
  single object can't handle events from more than one session:
  
    for (1..2) {
      POE::Session->create(
        object_states => [
          $object_4 => { event_4 => "method_4" },
        ]
      );
    }
  
  Now C<< $object_4->method_4(...) >> may be called to handle events from one of
  two sessions.  In both cases, C<$_[OBJECT]> will be C<$object_4>, but
  C<$_[HEAP]> will hold data for a particular session.
  
  The same goes for inline states.  One subroutine may handle events
  from many sessions.  C<$_[SESSION]> and C<$_[HEAP]> can be used within the
  handler to easily access the context of the session in which the event
  is being handled.
  
  =head1 PUBLIC METHODS
  
  POE::Session has just a few public methods.
  
  =head2 create LOTS_OF_STUFF
  
  C<create()> starts a new session running.  It returns a new POE::Session
  object upon success, but most applications won't need to save it.
  
  C<create()> invokes the newly started session's _start event handler
  before returning.
  
  C<create()> also passes the new POE::Session object to L<POE::Kernel>.
  POE's kernel holds onto the object in order to dispatch events to it.
  POE::Kernel will release the object when it detects the object has
  become moribund.  This should cause Perl to destroy the object if
  application code has not saved a copy of it.
  
  C<create()> accepts several named parameters, most of which are optional.
  Note however that the parameters are not part of a hashref.
  
  =for comment
  Is it time to bring new() back as a synonym for create()?
  PG - NO!  IMHO ->new implies simply creating the object, and
  that you have to hold onto the object.  ->create implies other actions
  are happening, and that you don't want to hold on to it.
  
  =for comment
  TODO - Provide forward-compatible "handler" options and methods as
  synonyms for the "state" versions currently supported?
  PG - No, that's for 1.01
  
  =for comment
  TODO - Add a "class_handlers" as a synonym for "package_handlers"?
  PG - Maybe. However, to many synonyms can be a pain for an API.
  
  =for comment
  TODO - The above TODOs may be summarized: "deprecate old language"?
  PG - Oh, you are thinking of deprecating the old language... erm... no?
  
  =for comment
  TODO PG - I notice these =head3 are in alphabetical order.  I think
  TODO all the *_states options should be together.  Followed by heap, args,
  TODO options
  
  =head3 args => ARRAYREF
  
  The C<args> parameter accepts a reference to a list of parameters that
  will be passed to the session's _start event handler in C<@_> positions
  C<ARG0> through C<$#_> (the end of C<@_>).
  
  This example would print "arg0 arg1 etc.":
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          print "Session started with arguments: @_[ARG0..$#_]\n";
        },
      },
      args => [ 'arg0', 'arg1', 'etc.' ],
    );
  
  =head3 heap => ANYTHING
  
  The C<heap> parameter allows a session's heap to be initialized
  differently at instantiation time.  Heaps are usually anonymous
  hashrefs, but C<heap> may set them to be array references or even
  objects.
  
  This example prints "tree":
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          print "Slot 0 = $_[HEAP][0]\n";
        },
      },
      heap => [ 'tree', 'bear' ],
    );
  
  Be careful when initializing the heap to be something that doesn't behave
  like a hashref.  Some libraries assume hashref heap semantics, and
  they will fail if the heap doesn't work that way.
  
  =head3 inline_states => HASHREF
  
  C<inline_states> maps events names to the subroutines that will handle
  them.  Its value is a hashref that maps event names to the coderefs of
  their corresponding handlers:
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          print "arg0=$_[ARG0], arg1=$_[ARG1], etc.=$_[ARG2]\n";
        },
        _stop  => \&stop_handler,
      },
      args => [qw( arg0 arg1 etc. )],
    );
  
  The term "inline" comes from the fact that coderefs can be inlined
  anonymous subroutines.
  
  Be very careful with closures, however.  L</Beware circular references>.
  
  =head3 object_states => ARRAYREF
  
  C<object_states> associates one or more objects to a session and maps
  event names to the object methods that will handle them.  It's value
  is an C<ARRAYREF>; C<HASHREFs> would stringify the objects, ruining them
  for method invocation.
  
  Here _start is handled by C<< $object->_session_start() >> and _stop triggers
  C<< $object->_session_stop() >>:
  
    POE::Session->create(
      object_states => [
        $object => {
          _start => '_session_start',
          _stop  => '_session_stop',
        }
      ]
    );
  
  POE::Session also supports a short form where the event and method
  names are identical.  Here _start invokes $object->_start(), and _stop
  triggers $object->_stop():
  
    POE::Session->create(
      object_states => [
        $object => [ '_start', '_stop' ],
      ]
    );
  
  Methods are verified when the session is created, but also resolved when the
  handler is called (late binding).  Most of the time, a method won't change.
  But in some circumstance, such as dynamic inheritance, a method could
  resolve to a different subroutine.
  
  =head3 options => HASHREF
  
  POE::Session sessions support a small number of options, which may be
  initially set with the C<option> constructor parameter and changed at
  run time with the C<option()|/option> method.
  
  C<option> takes a hashref with option =E<gt> value pairs:
  
    POE::Session->create(
      ... set up handlers ...,
      options => { trace => 1, debug => 1 },
    );
  
  This is equivalent to the previous example:
  
    POE::Session->create(
      ... set up handlers ...,
    )->option( trace => 1, debug => 1 );
  
  The supported options and values are documented with the C<option()|/option>
  method.
  
  =head3 package_states => ARRAYREF
  
  C<package_states> associates one or more classes to a session and maps
  event names to the class methods that will handle them.  Its function
  is analogous to C<object_states>, but package names are specified
  rather than objects.
  
  In fact, the following documentation is a copy of the C<object_states>
  description with some word substitutions.
  
  The value for C<package_states> is an B<ARRAYREF> to be consistent
  with C<object_states>, even though class names (also known as package names) are
  already strings, so it's not necessary to avoid stringifying them.
  
  Here _start is handled by C<< $class_name->_session_start() >> and _stop
  triggers C<< $class_name->_session_stop() >>:
  
    POE::Session->create(
      package_states => [
        $class_name => {
          _start => '_session_start',
          _stop  => '_session_stop',
        }
      ]
    );
  
  POE::Session also supports a short form where the event and method
  names are identical.  Here _start invokes C<< $class_name->_start() >>, and
  _stop triggers C<< $class_name->_stop() >>:
  
    POE::Session->create(
      package_states => [
        $class_name => [ '_start', '_stop' ],
      ]
    );
  
  =head2 ID
  
  C<ID()> returns the session instance's unique identifier.  This is an
  integer that starts at 1 and counts up forever, or until the number
  wraps around.
  
  It's theoretically possible that a session ID will not be unique, but
  this requires at least 4.29 billion sessions to be created within a
  program's lifespan.  POE guarantees that no two sessions will have the
  same ID at the same time, however;  your computer doesn't have enough memory
  to store 4.29 billion session objects.
  
  A session's ID is unique within a running process, but multiple
  processes are likely to have the same session IDs.  If a global ID is
  required, it will need to include both C<< $_[KERNEL]->ID >> and
  C<< $_[SESSION]->ID >>.
  
  =head2 option OPTION_NAME [, OPTION_VALUE [, OPTION_NAME, OPTION_VALUE]... ]
  
  C<option()> sets and/or retrieves the values of various session options.
  The options in question are implemented by POE::Session and do not
  have any special meaning anywhere else.
  
  It may be called with a single OPTION_NAME to retrieve the value of
  that option.
  
    my $trace_value = $_[SESSION]->option('trace');
  
  C<option()> sets an option's value when called with a single OPTION_NAME,
  OPTION_VALUE pair.  In this case, C<option()> returns the option's
  previous value.
  
    my $previous_trace = $_[SESSION]->option(trace => 1);
  
  C<option()> may also be used to set the values of multiple options at
  once.  In this case, C<option()> returns all the specified options'
  previous values in an anonymous hashref:
  
    my $previous_values = $_[SESSION]->option(
      trace => 1,
      debug => 1,
    );
  
    print "Previous option values:\n";
    while (my ($option, $old_value) = each %$previous_values) {
      print "  $option = $old_value\n";
    }
  
  POE::Session currently supports three options:
  
  =head3 The "debug" option.
  
  The "debug" option is intended to enable additional warnings when
  strange things are afoot within POE::Session.  At this time, there is
  only one additional warning:
  
  =over 4
  
  =item * 
  
  Redefining an event handler does not usually cause a warning, but it
  will when the "debug" option is set.
  
  =back
  
  =head3 The "default" option.
  
  Enabling the "default" option causes unknown events to become
  warnings, if there is no _default handler to catch them.
  
  The class-level C<POE::Session::ASSERT_STATES> flag is implemented by
  enabling the "default" option on all new sessions.
  
  =head3 The "trace" option.
  
  Turn on the "trace" option to dump a log of all the events dispatched
  to a particular session.  This is a session-specific trace option that
  allows individual sessions to be debugged.
  
  Session-level tracing also indicates when events are redirected to
  _default.  This can be used to discover event naming errors.
  
  =head3 User-defined options.
  
  C<option()> does not verify whether OPTION_NAMEs are known, so C<option()>
  may be used to store and retrieve user-defined information.
  
  Choose option names with caution.  There is no established convention
  to avoid namespace collisions between user-defined options and future
  internal options.
  
  =head2 postback EVENT_NAME, EVENT_PARAMETERS
  
  C<postback()> manufactures callbacks that post POE events.  It returns an
  anonymous code reference that will post EVENT_NAME to the target
  session, with optional EVENT_PARAMETERS in an array reference in ARG0.
  Parameters passed to the callback will be sent in an array reference
  in ARG1.
  
  In other words, ARG0 allows the postback's creator to pass context
  through the postback.  ARG1 allows the caller to return information.
  
  This example creates a coderef that when called posts "ok_button" to
  C<$some_session> with ARG0 containing C<[ 8, 6, 7 ]>.
  
    my $postback = $some_session->postback( "ok_button", 8, 6, 7 );
  
  Here's an example event handler for "ok_button".
  
    sub handle_ok_button {
      my ($creation_args, $called_args) = @_[ARG0, ARG1];
      print "Postback created with (@$creation_args).\n";
      print "Postback called with (@$called_args).\n";
    }
  
  Calling $postback->(5, 3, 0, 9) would perform the equivalent of...
  
    $poe_kernel->post(
      $some_session, "ok_button",
      [ 8, 6, 7 ],
      [ 5, 3, 0, 9 ]
    );
  
  This would be displayed when "ok_button" was dispatched to
  handle_ok_button():
  
    Postback created with (8 6 7).
    Postback called with (5 3 0 9).
  
  Postbacks hold references to their target sessions.  Therefore
  sessions with outstanding postbacks will remain active.  Under every
  event loop except Tk, postbacks are blessed so that DESTROY may be
  called when their users are done.  This triggers a decrement on their
  reference counts, allowing sessions to stop.
  
  Postbacks have one method, weaken(), which may be used to reduce their
  reference counts upon demand.  weaken() returns the postback, so you
  can do:
  
    my $postback = $session->postback("foo")->weaken();
  
  Postbacks were created as a thin adapter between callback libraries
  and POE.  The problem at hand was how to turn callbacks from the Tk
  graphical toolkit's widgets into POE events without subclassing
  several Tk classes.  The solution was to provide Tk with plain old
  callbacks that posted POE events.
  
  Since C<postback()> and C<callback()> are Session methods, they may be
  called on C<$_[SESSION]> or C<$_[SENDER]>, depending on particular needs.
  There are usually better ways to interact between sessions than
  abusing postbacks, however.
  
  Here's a brief example of attaching a L<Gtk2> button to a POE event
  handler:
  
    my $btn = Gtk2::Button->new("Clear");
    $btn->signal_connect( "clicked", $_[SESSION]->postback("ev_clear") );
  
  Points to remember: The session will remain alive as long as $btn
  exists and holds a copy of $_[SESSION]'s postback.  Any parameters
  passed by the Gtk2 button will be in ARG1.
  
  =head2 callback EVENT_NAME, EVENT_PARAMETERS
  
  callback() manufactures callbacks that use C<< $poe_kernel->call() >> to
  deliver POE events rather than C<< $poe_kernel->post() >>.  It is identical
  to C<postback()> in every other respect.
  
  callback() was created to avoid race conditions that arise when
  external libraries assume callbacks will execute synchronously.
  L<File::Find> is an obvious (but not necessarily appropriate) example.
  It provides a lot of information in local variables that stop being
  valid after the callback.  The information would be unavailable by the
  time a post()ed event was dispatched.
  
  =head2 get_heap
  
  C<get_heap()> returns a reference to a session's heap.  This is the same
  value as C<$_[HEAP]> for the target session.  C<get_heap()> is intended to
  be used with C<$poe_kernel> and POE::Kernel's C<get_active_session()> so
  that libraries do not need these three common values explicitly passed
  to them.
  
  That is, it prevents the need for:
  
    sub some_helper_function {
      my ($kernel, $session, $heap, @specific_parameters) = @_;
      ...;
    }
  
  Rather, helper functions may use:
  
    use POE::Kernel; # exports $poe_kernel
    sub some_helper_function {
      my (@specific_parameters) = @_;
      my $session = $poe_kernel->get_active_session();
      my $heap = $session->get_heap();
    }
  
  This isn't very convenient for people writing libraries, but it makes
  the libraries much more convenient to use.
  
  Using C<get_heap()> to break another session's encapsulation is strongly
  discouraged.
  
  =head2 instantiate CREATE_PARAMETERS
  
  C<instantiate()> creates and returns an empty POE::Session object.  It is
  called with the CREATE_PARAMETERS in a hash reference just before
  C<create()> processes them.  Modifications to the CREATE_PARAMETERS will
  affect how C<create()> initializes the new session.
  
  Subclasses may override C<instantiate()> to alter the underlying
  session's structure.  They may extend C<instantiate()> to add new
  parameters to C<create()>.
  
  Any parameters not recognized by C<create()> must be removed from the
  CREATE_PARAMETERS before C<instantiate()> returns.  C<create()> will
  L<croak|Carp>
  if it discovers unknown parameters.
  
  Be sure to return C<$self> from instantiate.
  
    sub instantiate {
      my ($class, $create_params) = @_;
  
      # Have the base class instantiate the new session.
      my $self = $class->SUPER::instantiate($create_parameters);
  
      # Extend the parameters recognized by create().
      my $new_option = delete $create_parameters->{new_option};
      if (defined $new_option) {
        # ... customize $self here ...
      }
  
      return $self;
    }
  
  =head2 try_alloc START_ARGS
  
  C<try_alloc()> calls POE::Kernel's C<session_alloc()> to allocate a session
  structure and begin managing the session within POE's kernel.  It is
  called at the end of POE::Session's C<create()>.  It returns C<$self>.
  
  It is a subclassing hook for late session customization prior to
  C<create()> returning.  It may also affect the contents of C<@_[ARG0..$#_]>
  that are passed to the session's _start handler.
  
    sub try_alloc {
      my ($self, @start_args) = @_;
  
      # Perform late initialization.
      # ...
  
      # Give $self to POE::Kernel.
      return $self->SUPER::try_alloc(@args);
    }
  
  =head1 POE::Session's EVENTS
  
  Please do not define new events that begin with a leading underscore.
  POE claims /^_/ events as its own.
  
  POE::Session only generates one event, _default.  All other internal
  POE events are generated by (and documented in) POE::Kernel.
  
  =head2 _default
  
  _default is the C<AUTOLOAD> of event handlers.  If POE::Session can't
  find a handler at dispatch time, it attempts to redirect the event to
  _default's handler instead.
  
  If there's no _default handler, POE::Session will silently drop the
  event unless the "default" option is set.
  
  To preserve the original information, the original event is slightly
  changed before being redirected to the _default handler:  The original
  event parameters are moved to an array reference in ARG1, and the
  original event name is passed to _default in ARG0.
  
    sub handle_default {
      my ($event, $args) = @_[ARG0, ARG1];
      print(
        "Session ", $_[SESSION]->ID,
        " caught unhandled event $event with (@$args).\n"
      );
    }
  
  _default is quite flexible.  It may be used for debugging, or to
  handle dynamically generated event names without pre-defining their
  handlers.  In the latter sense, _default performs analogously to
  Perl's C<AUTOLOAD>.
  
  _default may also be used as the default or "otherwise" clause of a
  switch statement.  Consider an input handler that throws events based
  on a command name:
  
    sub parse_command {
      my ($command, @parameters) = split /\s+/, $_[ARG0];
      $_[KERNEL]->post( "cmd_$command", @parameters );
    }
  
  A _default handler may be used to emit errors for unknown commands:
  
    sub handle_default {
      my $event = $_[ARG0];
      return unless $event =~ /^cmd_(\S+)/;
      warn "Unknown command: $1\n";
    }
  
  The _default behavior is implemented in POE::Session, so it may be
  different for other session types.
  
  =head2 POE::Session's Debugging Features
  
  POE::Session contains one debugging assertion, for now.
  
  =head3 ASSERT_STATES
  
  Setting ASSERT_STATES to true causes every Session to warn when they
  are asked to handle unknown events.  Session.pm implements the guts of
  ASSERT_STATES by defaulting the "default" option to true instead of
  false.  See the option() method earlier in this document for details
  about the "default" option.
  
  =for comment
  TODO - It's not much of an assertion if it only warns.
  
  =head1 SEE ALSO
  
  L<POE::Kernel>.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 BUGS
  
  There is a chance that session IDs may collide after Perl's integer
  value wraps.  This can occur after as I<few> as 4.29 billion sessions.
  
  =head2 Beware circular references
  
  As you're probably aware, a circular reference is when a variable is
  part of a reference chain that eventually refers back to itself.  Perl
  will not reclaim the memory involved in such a reference chain until
  the chain is manually broken.
  
  Here a POE::Session is created that refers to itself via an external
  scalar.  The event handlers import $session via closures which are in
  turn stored within $session.  Even if this session stops, the circular
  references will remain.
  
    my $session;
    $session = POE::Session->create(
      inline_states => {
        _start => sub {
          $_[HEAP]->{todo} = [ qw( step1 step2 step2a ) ],
          $_[KERNEL]->post( $session, 'next' );
        },
        next => sub {
          my $next = shift @{ $_[HEAP]->{todo} };
          return unless $next;
          $_[KERNEL]->post( $session, $next );
        }
        # ....
      }
    );
  
  Reduced to its essence:
  
    my %event_handlers;
    $event_handler{_start} = sub { \%event_handlers };
  
  Note also that an anonymous sub creates a closure on all lexical
  variables in the scope it was defined in, even if it doesn't reference
  them.  $session is still being held in a circular reference here:
  
    my $self = $package->new;
    my $session;
    $session = POE::Session->create(
      inline_state => {
        _start => sub { $self->_start( @_[ARG0..$#_] ) }
      }
    );
  
  To avoid this, a session may set an alias for itself.  Other parts of
  the program may then refer to it by alias.  In this case, one needn't
  keep track of the session themselves (POE::Kernel will do it anyway).
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[HEAP]->{todo} = [ qw( step1 step2 step2a ) ],
          $_[KERNEL]->alias_set('step_doer');
          $_[KERNEL]->post( 'step_doer', 'next' );
        },
        next => sub {
          my $next = shift @{ $_[HEAP]->{todo} };
          return unless $next;
          $_[KERNEL]->post( 'step_doer', $next );
        }
        # ....
      }
    );
  
  Aliases aren't even needed in the previous example because the session
  refers to itself.  One could instead use POE::Kernel's yield() method
  to post the event back to the current session:
  
    next => sub {
      my $next = shift @{ $_[HEAP]->{todo} };
      return unless $next;
      $_[KERNEL]->yield( $next );
    }
  
  Or the L</$_[SESSION]> parameter passed to every event handler, but
  yield() is more efficient.
  
    next => sub {
      my $next = shift @{ $_[HEAP]->{todo} };
      return unless $next;
      $_[KERNEL]->post( $_[SESSION], $next );
    }
  
  Along the same lines as L</$_[SESSION]>, a session can respond back to
  the sender of an event by posting to L</$_[SENDER]>.  This is great for
  responding to requests.
  
  If a program must hold onto some kind of dynamic session reference,
  it's recommended to use the session's numeric ID rather than the
  object itself.  A session ID may be converted back into its object,
  but post() accepts session IDs as well as objects and aliases:
  
    my $session_id;
    $session_id = POE::Session->create(
      inline_states => {
        _start => sub {
          $_[HEAP]->{todo} = [ qw( step1 step2 step2a ) ],
          $_[KERNEL]->post( $session_id, 'next' );
        },
        # ....
      }
    )->ID;
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_SESSION

$fatpacked{"POE/Test/Sequence.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_TEST_SEQUENCE';
  package POE::Test::Sequence;
  
  use warnings;
  use strict;
  
  use Carp qw(croak);
  use POE;
  
  sub new {
    my ($class, %args) = @_;
  
    my $sequence = delete $args{sequence};
    croak "sequence required" unless defined $sequence;
  
    return bless {
      sequence   => $sequence,
      test_count => scalar( @$sequence ),
    }, $class;
  }
  
  sub next {
    my ($self, $event, $parameter) = @_;
  
    my $expected_result = shift @{ $self->{sequence} };
    unless (defined $expected_result) {
      Test::More::fail(
        "Got an unexpected result ($event, $parameter). Time to bye."
      );
      exit;
    }
  
    my $next_action = pop @$expected_result;
  
    Test::More::note "Testing (@$expected_result)";
  
    Test::More::is_deeply( [ $event, $parameter ], $expected_result );
  
    return $next_action || sub { undef };
  }
  
  sub test_count {
    return $_[0]{test_count};
  }
  
  sub create_generic_session {
    my ($self) = @_;
  
    POE::Session->create(
      inline_states => {
        _start   => sub { goto $self->next( $_[STATE], 0 ) },
        _default => sub { goto $self->next( $_[ARG0],  0 ) },
      }
    );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Test::Sequence - POE test helper to verify a sequence of events
  
  =head1 SYNOPSIS
  
    Sorry, there isn't a synopsis at this time.
  
    However, see t/90_regression/whjackson-followtail.t in POE's test
    suite for a full example.
  
  =head1 DESCRIPTION
  
  POE::Test::Sequence is a test helper that abstracts a lot of the
  tedious trickery needed to verify the relative ordering of events.
  
  With this module, one can test the sequence of events without
  necessarily relying on specific times elapsing between them.
  
  =head2 create_generic_session
  
  The create_generic_session() method creates a POE::Session that routes
  all vents through the POE::Test::Sequence object.  It returns the
  POE::Session object, but the test program does not need to store it
  anywhere.  In fact, it's recommended not to do that without
  understanding the implications.
  
  The implications can be found in the documentation for POE::Kernel and
  POE::Session.
  
  An example of create_generic_session() can be found in
  POE's t/90_regression/leolo-alarm-adjust.t test program.
  
  =head2 new
  
  Create a new sequence object.  Takes named parameter pairs, currently
  just "sequence", which references an array of steps.  Each step is an
  array reference containing the expected event, a required parameter to
  that event, and a code reference for the optional next step to take
  after testing for that event.
  
    my $sequence = POE::Test::Sequence->new(
      sequence => [
      [ got_idle_event => 0, sub { append_to_log("text") } ],
      ...,
    ]
    );
  
  next() uses the first two step elements to verify that steps are
  occurring in the order in which they should.  The third element is
  returned by next() and is suitable for use as a goto() target.  See
  the next() method for more details.
  
  =head2 next
  
  The next() method requires an event name and a scalar parameter.
  These are compared to the first two elements of the next sequence step
  to make sure events are happening in the order in which they should.
  
    sub handle_start_event {
      goto $sequence->next("got_start_event", 0);
    }
  
  =head2 test_count
  
  test_count() returns the number of test steps in the sequence object.
  It's intended to be used for test planning.
  
    use Test::More;
    my $sequence = POE::Test::Sequence->new( ... );
    plan tests => $sequence->test_count();
  
  =head1 BUGS
  
  create_generic_session() is hard-coded to pass only the event name and
  the numeric value 0 to next().  This is fine for only the most generic
  sequences.
  
  =head1 AUTHORS & LICENSING
  
  Please see L<POE> for more information about authors, contributors,
  and POE's licensing.
  
  =cut
  
  # vim: ts=2 sw=2 filetype=perl expandtab
POE_TEST_SEQUENCE

$fatpacked{"POE/Wheel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_WHEEL';
  package POE::Wheel;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw(croak);
  
  # Used to generate unique IDs for wheels.  This is static data, shared
  # by all.
  my $current_id = 0;
  my %active_wheel_ids;
  
  sub new {
    my $type = shift;
    croak "$type is not meant to be used directly";
  }
  
  sub allocate_wheel_id {
    while (1) {
      last unless exists $active_wheel_ids{ ++$current_id };
    }
    return $active_wheel_ids{$current_id} = $current_id;
  }
  
  sub free_wheel_id {
    my $id = shift;
    delete $active_wheel_ids{$id};
  }
  
  sub _test_set_wheel_id {
    $current_id = shift;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Wheel - event-driven mixins for POE::Session
  
  =head1 SYNOPSIS
  
  This base class has no synopsis.
  Please consult one of the subclasses instead.
  
  =head1 DESCRIPTION
  
  A POE::Wheel object encapsulates a bundle of event handlers that
  perform a specific task.  It also manages the event watchers that
  trigger those handlers.
  
  Object lifetime is very important for POE wheels.  At creation time,
  most wheels will add anonymous event handlers to the currently active
  session.  In other words, the session that created the wheel is
  modified to handle new events.  Event watchers may also be initialized
  as necessary to trigger the new handlers.  These event watchers are
  also owned by the session that created the wheel.
  
  Sessions must not expose their wheels to other sessions.  Doing so
  will likely cause problems because wheels are tightly integrated with
  the sessions that created them.  For example, calling put() on a
  POE::Wheel::ReadWrite instance may enable a write-okay watcher.  The
  handler for this watcher is already defined in the wheel's owner.
  Calling put() outside that session will enable the write-okay watcher
  in the wrong session, and the event will never be handled.
  
  Likewise, wheels must be destroyed from within their creator sessions.
  Otherwise breakage will occur when the wheels' DESTROY methods try to
  unregister event handlers and watchers from the wrong sessions.  To
  simplify things, it's recommended to store POE::Wheel instances in
  heaps of the sessions that created them.
  
  For example, creating a POE::Wheel::FollowTail object will register an
  event handler that periodically polls a file for new information.  It
  will also start the timer that triggers the periodic polling.
  
    use POE;
    use POE::Wheel::FollowTail;
  
    my @files_to_tail = qw( messages maillog security );
  
    foreach my $filename (@files_to_tail) {
      POE::Session->create(
        inline_states => {
          _start => sub {
            push @{$_[HEAP]{messages}}, POE::Wheel::FollowTail->new(
              Filename   => "/var/log/$filename",
              InputEvent => "got_input",
            );
          },
          got_input => sub {
            print "$filename: $_[ARG0]\n";
          },
        }
      );
    }
  
    POE::Kernel->run();
    exit;
  
  As illustrated in the previous example it is possible---sometimes
  recommended---to create more than one POE::Wheel of a particular type
  in the same session.  A session with multiple wheels may scale better
  than separate sessions with one wheel apiece.  When in doubt,
  benchmark.
  
  Unlike components (or cheese), wheels do not stand alone.  Each wheel
  must be created by a session in order to register event watchers and
  handlers within that session.  Wheels are thusly tightly coupled to
  their creator sessions and cannot be passed to other sessions.
  
  =head1 FILTERS, AND DRIVERS
  
  Many wheels perform data transfer operations on filehandles (which, as
  you probably know, includes sockets, pipes, and just about anything
  else that can store or transfer data).
  
  To avoid subclass hell, POE::Wheel objects may be customized at
  creation time by including other objects from the POE::Filter and
  POE::Driver namespaces.
  
  =head2 Filters
  
  POE "filters" implement data parsers and serializers.  For example,
  POE::Filter::Line parses streams into records separated by some string
  (the traditional network newline by default).  The Line filter also
  adds record separators to data being output.
  
  POE::Filter::HTTPD is a more complex example.  It implements a subset
  of the server-side of the HTTP protocol.  Input streams are parsed
  into HTTP requests and wrapped in HTTP::Request objects.  Server code
  sends HTTP::Response objects back to the client, which are serialized
  so they may be sent to a socket.
  
  Most wheels use POE::Filter::Line by default.
  
  =head2 Drivers
  
  POE "drivers" implement strategies for sending data to a filehandle
  and receiving input from it.  A single POE::Wheel class may interact
  with files, pipes, sockets, or devices by using the appropriate
  driver.
  
  POE::Driver::SysRW is the only driver that comes with POE.  sysread()
  and syswrite() can handle nearly every kind of stream interaction, so
  there hasn't been much call for another type of driver.
  
  =head1 METHODS
  
  POE::Wheel defines a common interface that most subclasses use.
  Subclasses may implement other methods, especially to help perform
  their unique tasks.  If something useful isn't documented here, see
  the subclass before implementing a feature.
  
  =head2 Required Methods
  
  These methods are required by all subclasses.
  
  =head3 new LOTS_OF_STUFF
  
  new() instantiates and initializes a new wheel object and returns it.
  The new wheel will continue to function for as long as it exists,
  although other methods may alter the way it functions.
  
  Part of any wheel's construction is the registration of anonymous
  event handlers to perform wheel-specific tasks.  Event watchers are
  also started to trigger the handlers when relevant activity occurs.
  
  Every wheel has a different purpose and requires different constructor
  parameters, so LOTS_OF_STUFF is documented in each particular
  subclass.
  
  =head3 DESTROY
  
  DESTROY is Ye Olde Perl Object Destructor.  When the wheel's last
  strong reference is relinquished, DESTROY triggers the wheel's
  cleanup.  The object removes itself from the session that created it:
  Active event watchers are stopped, and anonymous event handlers are
  unregistered.
  
  =head3 event EVENT_TYPE, EVENT_NAME [, EVENT_TYPE, EVENT_NAME, ....]
  
  event() changes the events that a wheel will emit.  Its parameters are
  one or more pairs of EVENT_TYPEs and the EVENT_NAMEs to emit when each
  type of event occurs.  If an EVENT_NAME is undefined, then the wheel
  will stop emitting that type of event.  Or the wheel may throw an
  error if the event type is required.
  
  EVENT_TYPEs differ for each wheel and correspond to the constructor
  parameters that match /.*Event$/.  For example, POE::Wheel::ReadWrite
  may emit up to five different kinds of event: InputEvent, ErrorEvent,
  FlushedEvent, HighEvent, LowEvent.  The name of each emitted event may
  be changed at run time.
  
  This example changes the events to emit on new input and when output
  is flushed.  It stops the wheel from emitting events when errors
  occur.
  
    $wheel->event(
      InputEvent   => 'new_input_event',
      ErrorEvent   => undef,
      FlushedEvent => 'new_flushed_event',
    );
  
  =head2 I/O Methods
  
  Wheels that perform input and output may implement some or all of
  these methods.  The put() method is a common omission.  Wheels that
  don't perform output do not have put() methods.
  
  =head3 put RECORD [, RECORD [, ....]]
  
  put() sends one or more RECORDs to the wheel for transmitting.  Each
  RECORD is serialized by the wheel's associated POE::Filter so that it
  will be ready to transmit.  The serialized stream may be transmitted
  immediately by the wheel's POE::Driver object, or it may be buffered
  in the POE::Driver until it can be flushed to the output filehandle.
  
  Most wheels use POE::Filter::Line and POE::Driver::SysRW by default,
  so it's not necessary to specify them in most cases.
  
  =head2 Class Static Functions
  
  These functions expose information that is common to all wheels.  They
  are not methods, so they should B<not> be called as methods.
  
    my $new_wheel_id = POE::Wheel::allocate_wheel_id();
    POE::Wheel::free_wheel_id($new_wheel_id);
  
  =head3 allocate_wheel_id
  
  B<This is not a class method.>
  
  Every wheel has a unique ID.  allocate_wheel_id() returns the next
  available unique wheel ID.  Wheel constructors use it to set their IDs
  internally.
  
    package POE::Wheel::Example;
    use base qw(POE::Wheel);
  
    sub new {
      # ... among other things ...
      $self->[MY_WHEEL_ID] = POE::Wheel::allocate_wheel_id();
      return $self;
    }
  
  Wheel IDs are used to tell apart events from similarly typed wheels.
  For example, a multi-file tail utility may handle all file input with
  the same function.  Wheel IDs may be used to tell which wheel
  generated the InputEvent being handled.
  
  Wheel IDs are often used to store wheel-local state in a session's
  heap.
  
    sub handle_error {
      my $wheel_id = $_[ARG3];
      print "Wheel $wheel_id caught an error.  Shutting it down.\n";
      delete $_[HEAP]{wheels}{$wheel_id};
    }
  
  It is vital for wheels to free their allocated IDs when they are
  destroyed.  POE::Wheel class keeps track of allocated wheel IDs to
  avoid collisions, and they will remain in memory until freed.  See
  free_wheel_id().
  
  =head3 free_wheel_id WHEEL_ID
  
  B<This is not a class method.>
  
  free_wheel_id() deallocates a wheel's ID so that it stops consuming
  memory and may be reused later.  This is often called from a wheel's
  destructor.
  
    package POE::Wheel::Example;
    use base qw(POE::Wheel);
  
    sub DESTROY {
      my $self = shift;
      # ... among other things ...
      POE::Wheel::free_wheel_id($self->[MY_WHEEL_ID]);
    }
  
  Wheel IDs may be reused, although it has never been reported.  Two
  active wheels will never share the same ID, however.
  
  =head3 ID
  
  B<This is usually implemented in the subclass!>
  
  The ID() method returns a wheel's unique ID. It is commonly used to
  match events with the wheels which generated them.
  
  Again, this method is not implemented in this class! If it's missing
  from the subclass, please go pester that module author---thanks!
  
  =head1 SEE ALSO
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  L<POE::Driver> - A base class for file access drivers that POE::Wheel
  may use.
  
  L<POE::Filter> - A base class for data parsers and marshalers that
  POE::Wheel may use.
  
  L<POE::Wheel::Curses> - Non-blocking input for Curses.
  
  L<POE::Wheel::FollowTail> - Non-blocking file and FIFO monitoring.
  
  L<POE::Wheel::ListenAccept> - Non-blocking server for existing
  sockets.
  
  L<POE::Wheel::ReadLine> - Non-blocking console input, with full
  readline support.
  
  L<POE::Wheel::ReadWrite> - Non-blocking stream I/O.
  
  L<POE::Wheel::Run> - Non-blocking process creation and management.
  
  L<POE::Wheel::SocketFactory> - Non-blocking socket creation,
  supporting most protocols and modes.
  
  =for comment
  TODO - Link to POE::Wheel search.cpan.org module search.
  
  =head1 BUGS
  
  It would be nice if wheels were more like proper Unix streams.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors, contributors,
  and POE;s licensing.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_WHEEL

$fatpacked{"POE/Wheel/Curses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_WHEEL_CURSES';
  #!/usr/bin/perl -w
  
  package POE::Wheel::Curses;
  
  use strict;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw(croak);
  use Curses qw(
    initscr start_color cbreak raw noecho nonl nodelay timeout keypad
    intrflush meta typeahead clear refresh
    endwin COLS
  );
  use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
  use POE qw( Wheel );
  push @ISA, qw(POE::Wheel);
  
  sub SELF_STATE_READ  () { 0 }
  sub SELF_STATE_WRITE () { 1 }
  sub SELF_EVENT_INPUT () { 2 }
  sub SELF_ID          () { 3 }
  
  sub new {
    my $type = shift;
    my %params = @_;
  
    croak "$type needs a working Kernel" unless defined $poe_kernel;
  
    my $input_event = delete $params{InputEvent};
    croak "$type requires an InputEvent parameter" unless defined $input_event;
  
    if (scalar keys %params) {
      carp( "unknown parameters in $type constructor call: ",
            join(', ', keys %params)
          );
    }
  
    # Create the object.
    my $self = bless
      [ undef,                            # SELF_STATE_READ
        undef,                            # SELF_STATE_WRITE
        $input_event,                     # SELF_EVENT_INPUT
        &POE::Wheel::allocate_wheel_id(), # SELF_ID
      ];
  
    # Set up the screen, and enable color, mangle the terminal and
    # keyboard.
  
    initscr();
    start_color();
  
    cbreak();
    raw();
    noecho();
    nonl();
  
    # Both of these achieve nonblocking input.
    nodelay(1);
    timeout(0);
  
    keypad(1);
    intrflush(0);
    meta(1);
    typeahead(-1);
  
    clear();
    refresh();
  
    # Define the input event.
    $self->_define_input_state();
  
    # Oop! Return ourself.  I forgot to do this.
    $self;
  }
  
  sub _define_input_state {
    my $self = shift;
  
    # Register the select-read handler.
    if (defined $self->[SELF_EVENT_INPUT]) {
      # Stupid closure tricks.
      my $event_input = \$self->[SELF_EVENT_INPUT];
      my $unique_id   = $self->[SELF_ID];
  
      $poe_kernel->state
        ( $self->[SELF_STATE_READ] = ref($self) . "($unique_id) -> select read",
          sub {
  
            # Prevents SEGV in older Perls.
            0 && CRIMSON_SCOPE_HACK('<');
  
            my ($k, $me) = @_[KERNEL, SESSION];
  
            # Curses' getch() normally blocks, but we've already
            # determined that STDIN has something for us.  Be explicit
            # about which getch() to use.
            while ((my $keystroke = Curses::getch) ne '-1') {
              $k->call( $me, $$event_input, $keystroke, $unique_id );
            }
          }
        );
  
      # Now start reading from it.
      $poe_kernel->select_read( \*STDIN, $self->[SELF_STATE_READ] );
  
      # Turn blocking back on for STDIN.  Some Curses implementations
      # don't deal well with non-blocking STDIN.
      my $flags = fcntl(STDIN, F_GETFL, 0) or die $!;
      fcntl(STDIN, F_SETFL, $flags & ~O_NONBLOCK) or die $!;
    }
    else {
      $poe_kernel->select_read( \*STDIN );
    }
  }
  
  sub DESTROY {
    my $self = shift;
  
    # Turn off the select.
    $poe_kernel->select( \*STDIN );
  
    # Remove states.
    if ($self->[SELF_STATE_READ]) {
      $poe_kernel->state($self->[SELF_STATE_READ]);
      $self->[SELF_STATE_READ] = undef;
    }
  
    # Restore the terminal.
    endwin if COLS;
  
    &POE::Wheel::free_wheel_id($self->[SELF_ID]);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Wheel::Curses - non-blocking input for Curses
  
  =head1 SYNOPSIS
  
    use Curses;
    use POE qw(Wheel::Curses);
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[HEAP]{console} = POE::Wheel::Curses->new(
            InputEvent => 'got_keystroke',
          );
        },
        got_keystroke => sub {
          my $keystroke = $_[ARG0];
  
          # Make control and extended keystrokes printable.
          if ($keystroke lt ' ') {
            $keystroke = '<' . uc(unctrl($keystroke)) . '>';
          }
          elsif ($keystroke =~ /^\d{2,}$/) {
            $keystroke = '<' . uc(keyname($keystroke)) . '>';
          }
  
          # Just display it.
          addstr($keystroke);
          noutrefresh();
          doupdate;
  
          # Gotta exit somehow.
          delete $_[HEAP]{console} if $keystroke eq "<^C>";
        },
      }
    );
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Wheel::Curses implements non-blocking input for Curses programs.
  
  POE::Wheel::Curses will emit an "InputEvent" of your choosing whenever
  an input event is registered on a recognized input device (keyboard
  and sometimes mouse, depending on the curses library).  Meanwhile,
  applications can be doing other things like monitoring network
  connections or child processes, or managing timers and stuff.
  
  =head1 PUBLIC METHODS
  
  POE::Wheel::Curses is rather simple.
  
  =head2 new
  
  new() creates a new POE::Wheel::Curses object.  During construction,
  the wheel registers an input watcher for STDIN (via select_read()) and
  registers an internal handler to preprocess keystrokes.
  
  new() accepts only one parameter C<InputEvent>.  C<InputEvent>
  contains the name of the event that the wheel will emit whenever there
  is input on the console or terminal.  As with all wheels, the event
  will be sent to the session that was active when the wheel was
  constructed.
  
  It should be noted that an application may only have one active
  POE::Wheel::Curses object.
  
  =head1 EVENTS AND PARAMETERS
  
  These are the events sent by POE::Wheel::Curses.
  
  =head2 InputEvent
  
  C<InputEvent> defines the event that will be emitted when
  POE::Wheel::Curses detects and reads console input.  This event
  includes two parameters:
  
  C<$_[ARG0]> contains the raw keystroke as received by Curses::getch().
  An application may process the keystroke using Curses::unctrl() and
  Curses::keyname() on the keystroke.
  
  C<$_[ARG1]> contains the POE::Wheel::Curses object's ID.
  
  Mouse events aren't portable.  As of October 2009, it's up to the
  application to decide whether to call mousemask().
  
  =head1 SEE ALSO
  
  L<Curses> documents what can be done with Curses.  Also see the man
  page for whichever version of libcurses happens to be installed
  (curses, ncurses, etc.).
  
  L<POE::Wheel> describes wheels in general.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 BUGS
  
  None known, although curses implementations vary widely.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_WHEEL_CURSES

$fatpacked{"POE/Wheel/FollowTail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_WHEEL_FOLLOWTAIL';
  package POE::Wheel::FollowTail;
  
  use strict;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw( croak carp );
  use Symbol qw( gensym );
  use POSIX qw(SEEK_SET SEEK_CUR SEEK_END S_ISCHR S_ISBLK);
  use POE qw(Wheel Driver::SysRW Filter::Line);
  push @ISA, qw(POE::Wheel);
  use IO::Handle ();
  use Errno qw(ENOENT);
  
  sub CRIMSON_SCOPE_HACK ($) { 0 }
  
  sub SELF_HANDLE      () {  0 }
  sub SELF_FILENAME    () {  1 }
  sub SELF_DRIVER      () {  2 }
  sub SELF_FILTER      () {  3 }
  sub SELF_INTERVAL    () {  4 }
  sub SELF_EVENT_INPUT () {  5 }
  sub SELF_EVENT_ERROR () {  6 }
  sub SELF_EVENT_RESET () {  7 }
  sub SELF_UNIQUE_ID   () {  8 }
  sub SELF_STATE_READ  () {  9 }
  sub SELF_LAST_STAT   () { 10 }
  sub SELF_FOLLOW_MODE () { 11 }
  sub SELF_EVENT_IDLE  () { 12 }
  
  sub MODE_TIMER  () { 0x01 } # Follow on a timer loop.
  sub MODE_SELECT () { 0x02 } # Follow via select().
  
  # Turn on tracing.  A lot of debugging occurred just after 0.11.
  sub TRACE_POLL         () { 0 }
  sub TRACE_RESET        () { 0 }
  sub TRACE_STAT         () { 0 }
  sub TRACE_STAT_VERBOSE () { 0 }
  
  # Tk doesn't provide a SEEK method, as of 800.022
  BEGIN {
    if (exists $INC{'Tk.pm'}) {
      eval <<'    EOE';
        sub Tk::Event::IO::SEEK {
          my $o = shift;
          $o->wait(Tk::Event::IO::READABLE);
          my $h = $o->handle;
          sysseek($h, shift, shift);
        }
      EOE
    }
  }
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
    my %params = @_;
  
    croak "wheels no longer require a kernel reference as their first parameter"
      if @_ and (ref($_[0]) eq 'POE::Kernel');
  
    croak "$type requires a working Kernel" unless (defined $poe_kernel);
  
    croak "FollowTail requires a Handle or Filename parameter, but not both"
      unless $params{Handle} xor defined $params{Filename};
  
    my $driver = delete $params{Driver};
    $driver = POE::Driver::SysRW->new() unless defined $driver;
  
    my $filter = delete $params{Filter};
    $filter = POE::Filter::Line->new() unless defined $filter;
  
    croak "InputEvent required" unless defined $params{InputEvent};
  
    my $handle   = $params{Handle};
    my $filename = $params{Filename};
  
    my $poll_interval = (
      defined($params{PollInterval})
      ?  $params{PollInterval}
      : 1
    );
  
    my $seek;
    if (exists $params{SeekBack}) {
      $seek = $params{SeekBack} * -1;
      if (exists $params{Seek}) {
        croak "can't have Seek and SeekBack at the same time";
      }
    }
    elsif (exists $params{Seek}) {
      $seek = $params{Seek};
    }
    else {
      $seek = -4096;
    }
  
    my $self = bless [
      $handle,                          # SELF_HANDLE
      $filename,                        # SELF_FILENAME
      $driver,                          # SELF_DRIVER
      $filter,                          # SELF_FILTER
      $poll_interval,                   # SELF_INTERVAL
      delete $params{InputEvent},       # SELF_EVENT_INPUT
      delete $params{ErrorEvent},       # SELF_EVENT_ERROR
      delete $params{ResetEvent},       # SELF_EVENT_RESET
      &POE::Wheel::allocate_wheel_id(), # SELF_UNIQUE_ID
      undef,                            # SELF_STATE_READ
      [ (-1) x 8 ],                     # SELF_LAST_STAT
      undef,                            # SELF_FOLLOW_MODE
      delete $params{IdleEvent},        # SELF_EVENT_IDLE
    ], $type;
  
    if (defined $filename) {
      $handle = $self->[SELF_HANDLE] = _open_file($filename);
      $self->[SELF_LAST_STAT] = [ (stat $filename)[0..7] ] if $handle;
    }
    elsif (defined $handle) {
      $self->[SELF_LAST_STAT] = [ (stat $handle)[0..7] ];
    }
  
    # Honor SeekBack and discard partial input if we have a plain file
    # that is successfully open at this point.
    #
    # SeekBack attempts to position the file pointer somewhere before
    # the end of the file.  If it's specified, we assume the user knows
    # where a record begins.  Otherwise we just seek back and discard
    # everything to EOF so we can frame the input record.
  
    if (defined $handle) {
  
      # Handle is a plain file.  Honor SeekBack and PollInterval.
  
      if (-f $handle) {
        my $end = sysseek($self->[SELF_HANDLE], 0, SEEK_END);
  
        # Seeking back from EOF.
        if ($seek < 0) {
          if (defined($end) and ($end < -$seek)) {
            sysseek($self->[SELF_HANDLE], 0, SEEK_SET);
          }
          else {
            sysseek($self->[SELF_HANDLE], $seek, SEEK_END);
          }
        }
  
        # Seeking forward from the beginning of the file.
        elsif ($seek > 0) {
          if ($seek > $end) {
            sysseek($self->[SELF_HANDLE], 0, SEEK_END);
          }
          else {
            sysseek($self->[SELF_HANDLE], $seek, SEEK_SET);
          }
        }
  
        # If they set Seek to 0, we start at the beginning of the file.
        # If it was SeekBack, we start at the end.
        elsif (exists $params{Seek}) {
          sysseek($self->[SELF_HANDLE], 0, SEEK_SET);
        }
        elsif (exists $params{SeekBack}) {
          sysseek($self->[SELF_HANDLE], 0, SEEK_END);
        }
        else {
          die;  # Should never happen.
        }
  
        # Discard partial input chunks unless a SeekBack was specified.
        unless (defined $params{SeekBack} or defined $params{Seek}) {
          while (defined(my $raw_input = $driver->get($self->[SELF_HANDLE]))) {
            # Skip out if there's no more input.
            last unless @$raw_input;
            $filter->get($raw_input);
          }
        }
  
        # Start the timer loop.
        $self->[SELF_FOLLOW_MODE] = MODE_TIMER;
        $self->_define_timer_states();
  
        return $self;
      }
  
      # Strange things that ought not be tailed?  Directories...
  
      if (-d $self->[SELF_HANDLE]) {
        croak "FollowTail does not tail directories";
      }
  
      # Handle is not a plain file.  Can't honor SeekBack.
  
      carp "POE::Wheel::FollowTail can't SeekBack special files"
        if defined $params{SeekBack};
  
      # The handle isn't legal to multiplex on this platform.
      if (POE::Kernel::RUNNING_IN_HELL and not -S $handle) {
        $self->[SELF_FOLLOW_MODE] = MODE_TIMER;
        $self->_define_timer_states();
        return $self;
      }
  
      # Multiplexing should be more efficient where it's supported.
  
      carp "FollowTail does not need PollInterval for special files"
        if defined $params{PollInterval};
  
      $self->[SELF_FOLLOW_MODE] = MODE_SELECT;
      $self->_define_select_states();
      return $self;
    }
  
    # We don't have an open filehandle yet.  We can't tell whether
    # multiplexing is legal, and we can't seek back yet.  Don't honor
    # either.
  
    $self->[SELF_FOLLOW_MODE] = MODE_TIMER;
    $self->_define_timer_states();
    return $self;
  }
  
  ### Define the select based polling loop.  This relies on stupid
  ### closure tricks to keep references to $self out of anonymous
  ### coderefs.  Otherwise a circular reference would occur, and the
  ### wheel would never self-destruct.
  
  sub _define_select_states {
    my $self = shift;
  
    my $filter      = $self->[SELF_FILTER];
    my $driver      = $self->[SELF_DRIVER];
    my $handle      = \$self->[SELF_HANDLE];
    my $unique_id   = $self->[SELF_UNIQUE_ID];
    my $event_input = \$self->[SELF_EVENT_INPUT];
    my $event_error = \$self->[SELF_EVENT_ERROR];
    my $event_reset = \$self->[SELF_EVENT_RESET];
    my $event_idle  = \$self->[SELF_EVENT_IDLE];
  
    TRACE_POLL and warn "<poll> defining select state";
  
    $poe_kernel->state(
      $self->[SELF_STATE_READ] = ref($self) . "($unique_id) -> select read",
      sub {
  
        # Protects against coredump on older perls.
        0 && CRIMSON_SCOPE_HACK('<');
  
        # The actual code starts here.
        my ($k, $ses) = @_[KERNEL, SESSION];
  
        # Reset position.
        eval { sysseek($$handle, 0, SEEK_CUR) };
        $! = 0;
  
        TRACE_POLL and warn "<poll> " . time . " read ok";
  
        # Read the next chunk, and return its data.  Go around again.
        if (defined(my $raw_input = $driver->get($$handle))) {
          TRACE_POLL and warn "<poll> " . time . " raw input";
          $filter->get_one_start($raw_input);
          my $cooked_array;
          while (@{$cooked_array = $filter->get_one()}) {
            foreach my $cooked_input (@$cooked_array) {
              TRACE_POLL and warn "<poll> " . time . " cooked input";
              $k->call($ses, $$event_input, $cooked_input, $unique_id);
            }
          }
  
          # Clear the filehandle's EOF status, if any.
          IO::Handle::clearerr($$handle);
  
          return;
        }
  
        # Error reading.  Report the error if it's not EOF, or if it's
        # EOF on a socket or TTY.  Shut down the select, too.
        else {
          if ($! or (-S $$handle) or (-t $$handle)) {
            TRACE_POLL and warn "<poll> " . time . " error: $!";
            $$event_error and
              $k->call($ses, $$event_error, 'read', ($!+0), $!, $unique_id);
          }
          elsif (defined $$event_idle) {
            $k->call($ses, $$event_idle, $unique_id);
          }
  
          $k->select_read($$handle => undef);
          eval { IO::Handle::clearerr($$handle) }; # could be a globref
        }
      }
    );
  
    $poe_kernel->select_read($$handle, $self->[SELF_STATE_READ]);
  }
  
  ### Define the timer based polling loop.  This also relies on stupid
  ### closure tricks.
  
  sub _define_timer_states {
    my $self = shift;
  
    # Tail by filename.
    if (defined $self->[SELF_FILENAME]) {
      TRACE_POLL and warn "<poll> defining timer state for filename tail";
      $self->_generate_filename_timer();
    }
    else {
      TRACE_POLL and warn "<poll> defining timer state for handle tail";
      $self->_generate_filehandle_timer();
    }
  
    # Fire up the loop.  The delay() aspect of the loop will prevent
    # duplicate events from being significant for long.
    $poe_kernel->delay($self->[SELF_STATE_READ], 0);
  }
  
  sub _generate_filehandle_timer {
    my $self = shift;
  
    my $filter        = $self->[SELF_FILTER];
    my $driver        = $self->[SELF_DRIVER];
    my $unique_id     = $self->[SELF_UNIQUE_ID];
    my $poll_interval = $self->[SELF_INTERVAL];
    my $last_stat     = $self->[SELF_LAST_STAT];
  
    my $filename      = \$self->[SELF_FILENAME];
    my $handle        = \$self->[SELF_HANDLE];
    my $event_input   = \$self->[SELF_EVENT_INPUT];
    my $event_error   = \$self->[SELF_EVENT_ERROR];
    my $event_reset   = \$self->[SELF_EVENT_RESET];
    my $event_idle    = \$self->[SELF_EVENT_IDLE];
  
    $self->[SELF_STATE_READ] = ref($self) . "($unique_id) -> handle timer read";
    my $state_read    = \$self->[SELF_STATE_READ];
  
    $poe_kernel->state(
      $$state_read,
      sub {
  
        # Protects against coredump on older perls.
        0 && CRIMSON_SCOPE_HACK('<');
  
        # The actual code starts here.
        my ($k, $ses) = @_[KERNEL, SESSION];
  
        # File isn't open?  We're done.
        unless (defined $$handle and fileno $$handle) {
          TRACE_POLL and warn "<poll> ", time, " $$handle closed";
          $$event_error and
            $k->call($ses, $$event_error, 'read', 0, "", $unique_id);
          return;
        }
  
        # Reset position.
        eval { sysseek($$handle, 0, SEEK_CUR) };
        $! = 0;
  
        # Read the next chunk, and return its data.  Go around again.
        if (defined(my $raw_input = $driver->get($$handle))) {
          TRACE_POLL and warn "<poll> " . time . " raw input";
          $filter->get_one_start($raw_input);
          while (1) {
            my $next_rec = $filter->get_one();
            last unless @$next_rec;
            foreach my $cooked_input (@$next_rec) {
              TRACE_POLL and warn "<poll> " . time . " cooked input";
              $k->call($ses, $$event_input, $cooked_input, $unique_id);
            }
          }
  
          # Clear the filehandle's EOF status, if any.
          IO::Handle::clearerr($$handle);
  
          # Must use a timer so that it can be cleared in DESTROY.
          $k->delay($$state_read, 0) if defined $$state_read;
          return;
        }
  
        # Some kind of important error?
        if ($!) {
          TRACE_POLL and warn "<poll> ", time, " $$handle error: $!";
          $$event_error and
            $k->call($ses, $$event_error, 'read', ($!+0), "$!", $unique_id);
          return;
        }
  
        # Merely EOF.  Check for file rotation.
  
        my @new_stat = (
          (defined $$filename)
          ? ((stat $$filename)[0..7])
          : ((stat $$handle)[0..7])
        );
  
        unless (@new_stat) {
          TRACE_POLL and warn "<poll> ", time, " $$handle stat error";
          $$event_error and
            $k->call($ses, $$event_error, 'stat', ($!+0), "$!", $unique_id);
          return;
        }
  
        TRACE_STAT_VERBOSE and do {
          my @test_new = @new_stat;
          my @test_old = @$last_stat;
          warn "<stat> from: @test_old\n<stat> to  : @test_new" if (
            "@test_new" ne "@test_old"
          );
        };
  
        # Ignore rdev changes for non-device files
        eval {
          if (!S_ISBLK($new_stat[2]) and !S_ISCHR($new_stat[2])) {
            $last_stat->[6] = $new_stat[6];
          }
        };
  
        # Something fundamental about the file changed.
        # Consider it a reset, and try to rewind to the top of the file.
        if (
          $new_stat[1] != $last_stat->[1] or # inode's number
          $new_stat[0] != $last_stat->[0] or # inode's device
          $new_stat[6] != $last_stat->[6] or # device type
          $new_stat[3] != $last_stat->[3] or # number of links
          $new_stat[7] <  $last_stat->[7]    # size reduced
        ) {
          TRACE_STAT and do {
            warn "<stat> inode $new_stat[1] != old $last_stat->[1]"
              if $new_stat[1] != $last_stat->[1];
            warn "<stat> inode device $new_stat[0] != old $last_stat->[0]"
              if $new_stat[0] != $last_stat->[0];
            warn "<stat> device type $new_stat[6] != old $last_stat->[6]"
              if $new_stat[6] != $last_stat->[6];
            warn "<stat> link count $new_stat[3] != old $last_stat->[3]"
              if $new_stat[3] != $last_stat->[3];
            warn "<stat> file size $new_stat[7] < old $last_stat->[7]"
              if $new_stat[7] < $last_stat->[7];
          };
  
          # File has reset.
          TRACE_RESET and warn "<reset> filehandle has reset";
          $$event_reset and $k->call($ses, $$event_reset, $unique_id);
  
          sysseek($$handle, 0, SEEK_SET);
        }
        elsif (defined $$event_idle) {
          $k->call($ses, $$event_idle, $unique_id);
        }
  
        # The file didn't roll.  Try again shortly.
        @$last_stat = @new_stat;
        IO::Handle::clearerr($$handle);
        $k->delay($$state_read, $poll_interval) if defined $$state_read;
        return;
      }
    );
  }
  
  sub _generate_filename_timer {
    my $self = shift;
  
    my $filter        = $self->[SELF_FILTER];
    my $driver        = $self->[SELF_DRIVER];
    my $unique_id     = $self->[SELF_UNIQUE_ID];
    my $poll_interval = $self->[SELF_INTERVAL];
    my $filename      = $self->[SELF_FILENAME];
    my $last_stat     = $self->[SELF_LAST_STAT];
  
    my $handle        = \$self->[SELF_HANDLE];
    my $event_input   = \$self->[SELF_EVENT_INPUT];
    my $event_error   = \$self->[SELF_EVENT_ERROR];
    my $event_reset   = \$self->[SELF_EVENT_RESET];
    my $event_idle    = \$self->[SELF_EVENT_IDLE];
  
    $self->[SELF_STATE_READ] = ref($self) . "($unique_id) -> name timer read";
    my $state_read    = \$self->[SELF_STATE_READ];
  
    $poe_kernel->state(
      $$state_read,
      sub {
  
        # Protects against coredump on older perls.
        0 && CRIMSON_SCOPE_HACK('<');
  
        # The actual code starts here.
        my ($k, $ses) = @_[KERNEL, SESSION];
  
        # File isn't open?  Try to open it.
        unless ($$handle) {
          $$handle = _open_file($filename);
  
          # Couldn't open yet.
          unless ($$handle) {
            $k->call($ses, $$event_idle, $unique_id) if defined $$event_idle;
            $k->delay($$state_read, $poll_interval) if defined $$state_read;
            return;
          }
  
          # File has reset.
          TRACE_RESET and warn "<reset> file name has reset";
          $$event_reset and $k->call($ses, $$event_reset, $unique_id);
  
          @$last_stat = (stat $filename)[0..7];
        }
        else {
          # Reset position.
          eval { sysseek($$handle, 0, SEEK_CUR) };
          $! = 0;
        }
  
        # Read the next chunk, and return its data.  Go around again.
        if (defined(my $raw_input = $driver->get($$handle))) {
          TRACE_POLL and warn "<poll> " . time . " raw input";
          $filter->get_one_start($raw_input);
          my $cooked_array;
          while (@{$cooked_array = $filter->get_one()}) {
            foreach my $cooked_input (@$cooked_array) {
              TRACE_POLL and warn "<poll> " . time . " cooked input";
              $k->call($ses, $$event_input, $cooked_input, $unique_id);
            }
          }
  
          # Clear the filehandle's EOF status, if any.
          IO::Handle::clearerr($$handle);
  
          # Must use a timer so that it can be cleared in DESTROY.
          $k->delay($$state_read, 0) if defined $$state_read;
          return;
        }
  
        # Some kind of important error?
        if ($!) {
          TRACE_POLL and warn "<poll> ", time, " $$handle error: $!";
          $$event_error and
            $k->call($ses, $$event_error, 'read', ($!+0), "$!", $unique_id);
          return;
        }
  
        # Merely EOF.  Check for file rotation.
        my @new_stat = (stat $filename)[0..7];
        unless (@new_stat) {
          TRACE_POLL and warn "<poll> ", time, " $filename stat error: $!";
          if ($! != ENOENT) {
            $$event_error and
              $k->call($ses, $$event_error, 'stat', ($!+0), "$!", $unique_id);
            return;
          }
          @new_stat = (-1) x 8;
        }
  
        TRACE_STAT_VERBOSE and do {
          my @test_new = @new_stat;
          my @test_old = @$last_stat;
          warn "<stat> from: @test_old\n<stat> to  : @test_new" if (
            "@test_new" ne "@test_old"
          );
        };
  
        # Ignore rdev changes for non-device files
        eval {
          if (!S_ISBLK($new_stat[2]) and !S_ISCHR($new_stat[2])) {
            $last_stat->[6] = $new_stat[6];
          }
        };
  
        # Something fundamental about the file changed.
        # Consider it a reset, and close the file.
        if (
          $new_stat[1] != $last_stat->[1] or # inode's number
          $new_stat[0] != $last_stat->[0] or # inode's device
          $new_stat[6] != $last_stat->[6] or # device type
          $new_stat[3] != $last_stat->[3] or # number of links
          $new_stat[7] <  $last_stat->[7]    # size reduced
        ) {
          TRACE_STAT and do {
            warn "<stat> inode $new_stat[1] != old $last_stat->[1]"
              if $new_stat[1] != $last_stat->[1];
            warn "<stat> inode device $new_stat[0] != old $last_stat->[0]"
              if $new_stat[0] != $last_stat->[0];
            warn "<stat> device type $new_stat[6] != old $last_stat->[6]"
              if $new_stat[6] != $last_stat->[6];
            warn "<stat> link count $new_stat[3] != old $last_stat->[3]"
              if $new_stat[3] != $last_stat->[3];
            warn "<stat> file size $new_stat[7] < old $last_stat->[7]"
              if $new_stat[7] < $last_stat->[7];
          };
  
          $$handle = undef;
          @$last_stat = @new_stat;
  
          # Must use a timer so that it can be cleared in DESTROY.
          $k->delay($$state_read, 0) if defined $$state_read;
          return;
        }
        elsif (defined $$event_idle) {
          $k->call($ses, $$event_idle, $unique_id);
        }
  
        # The file didn't roll.  Try again shortly.
        @$last_stat = @new_stat;
        IO::Handle::clearerr($$handle);
        $k->delay($$state_read, $poll_interval) if defined $$state_read;
        return;
      }
    );
  }
  
  #------------------------------------------------------------------------------
  
  sub event {
    my $self = shift;
    push(@_, undef) if (scalar(@_) & 1);
  
    while (@_) {
      my ($name, $event) = splice(@_, 0, 2);
  
      if ($name eq 'InputEvent') {
        if (defined $event) {
          $self->[SELF_EVENT_INPUT] = $event;
        }
        else {
          carp "InputEvent requires an event name.  ignoring undef";
        }
      }
      elsif ($name eq 'ErrorEvent') {
        $self->[SELF_EVENT_ERROR] = $event;
      }
      elsif ($name eq 'ResetEvent') {
        $self->[SELF_EVENT_RESET] = $event;
      }
      elsif ($name eq 'IdleEvent') {
        $self->[SELF_EVENT_IDLE] = $event;
      }
      else {
        carp "ignoring unknown FollowTail parameter '$name'";
      }
    }
  }
  
  #------------------------------------------------------------------------------
  
  sub DESTROY {
    my $self = shift;
  
    # Remove our tentacles from our owner.
    $poe_kernel->select_read($self->[SELF_HANDLE] => undef) if (
      defined $self->[SELF_HANDLE]
    );
  
    if ($self->[SELF_STATE_READ]) {
      $poe_kernel->delay($self->[SELF_STATE_READ]);
      $poe_kernel->state($self->[SELF_STATE_READ]);
      undef $self->[SELF_STATE_READ];
    }
  
    &POE::Wheel::free_wheel_id($self->[SELF_UNIQUE_ID]);
  }
  
  #------------------------------------------------------------------------------
  
  sub ID {
    return $_[0]->[SELF_UNIQUE_ID];
  }
  
  sub tell {
    my $self = shift;
    return sysseek($self->[SELF_HANDLE], 0, SEEK_CUR);
  }
  
  sub _open_file {
    my $filename = shift;
  
    my $handle = gensym();
  
    # FIFOs (named pipes) are opened R/W so they don't report EOF.
    # Everything else is opened read-only.
    if (-p $filename) {
      return $handle if open $handle, "+<", $filename;
      return;
    }
  
    return $handle if open $handle, "<", $filename;
    return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Wheel::FollowTail - follow the tail of an ever-growing file
  
  =head1 SYNOPSIS
  
    #!perl
  
    use POE qw(Wheel::FollowTail);
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          $_[HEAP]{tailor} = POE::Wheel::FollowTail->new(
            Filename => "/var/log/system.log",
            InputEvent => "got_log_line",
            ResetEvent => "got_log_rollover",
          );
        },
        got_log_line => sub {
          print "Log: $_[ARG0]\n";
        },
        got_log_rollover => sub {
          print "Log rolled over.\n";
        },
      }
    );
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Wheel::FollowTail objects watch for new data at the end of a file
  and generate new events when things happen to the file. Its C<Filter>
  parameter defines how to parse data from the file. Each new item is sent
  to the creator's session as an C<InputEvent> event. Log rotation will
  trigger a C<ResetEvent>.
  
  POE::Wheel::FollowTail only reads from a file, so it doesn't implement
  a put() method.
  
  =head1 PUBLIC METHODS
  
  =head2 new
  
  new() returns a new POE::Wheel::FollowTail object.  As long as this
  object exists, it will generate events when the corresponding file's
  status changes.
  
  new() accepts a small set of named parameters:
  
  =head3 Driver
  
  The optional C<Driver> parameter specifies which driver to use when
  reading from the tailed file.  If omitted, POE::Wheel::FollowTail will
  use POE::Driver::SysRW.  This is almost always the right thing to do.
  
  =head3 Filter
  
  C<Filter> is an optional constructor parameter that specifies how to
  parse data from the followed file.  By default, POE::Wheel::FollowTail
  will use POE::Filter::Line to parse files as plain, newline-separated
  text.
  
    $_[HEAP]{tailor} = POE::Wheel::FollowTail->new(
      Filename => "/var/log/snort/alert",
      Filter => POE::Filter::Snort->new(),
      InputEvent => "got_snort_alert",
    );
  
  =head3 PollInterval
  
  POE::Wheel::FollowTail needs to periodically check for new data on the
  followed file.  C<PollInterval> specifies the number of seconds to
  wait between checks.  Applications that need to poll once per second
  may omit C<PollInterval>, as it defaults to 1.
  
  Longer poll intervals may be used to reduce the polling overhead for
  infrequently updated files.
  
    $_[HEAP]{tailor} = POE::Wheel::FollowTail->new(
      ...,
      PollInterval => 10,
    );
  
  =head3 Seek
  
  If specified, C<Seek> instructs POE::Wheel::FollowTail to seek to a
  specific spot in the tailed file before beginning to read from it.  A
  positive C<Seek> value is interpreted as the number of octets to seek
  from the start of the file.  Negative C<Seek> will, like negative
  array indices, seek backwards from the end of the file.  Zero C<Seek>
  starts reading from the beginning of the file.
  
  Be careful when using C<Seek>, as it's quite easy to seek into the
  middle of a record.  When in doubt, and when beginning at the end of
  the file, omit C<Seek> entirely.  POE::Wheel::FollowTail will seek
  4 kilobytes back from the end of the file, then parse and discard all
  records unto EOF.  As long as the file's records are smaller than 4
  kilobytes, this will guarantee that the first record returned will be
  complete.
  
  C<Seek> may also be used with the wheel's tell() method to restore the
  file position after a program restart.  Save the tell() value prior to
  exiting, and load and C<Seek> back to it on subsequent start-up.
  
  =for comment
  TODO - Example.
  
  =head3 SeekBack
  
  C<SeekBack> behaves like the inverse of C<Seek>.  A positive value
  acts like a negative C<Seek>.  A negative value acts like a positive
  C<Seek>.  A zero C<SeekBack> instructs POE::Wheel::FollowTail to begin
  at the very end of the file.
  
  C<Seek> and C<SeekBack> are mutually exclusive.
  
  See L</Seek> for caveats, techniques, and an explanation of the magic
  that happens when neither C<Seek> nor C<SeekBack> is specified.
  
  =for comment
  TODO - Example.
  
  =head3 Handle
  
  POE::Wheel::FollowTail may follow a previously opened file C<Handle>.
  Unfortunately it cannot follow log resets this way, as it won't be
  able to reopen the file once it has been reset.  Applications that
  must follow resets should use C<Filename> instead.
  
  C<Handle> is still useful for files that will never be reset, or for
  devices that require setup outside of POE::Wheel::FollowTail's
  purview.
  
  C<Handle> and C<Filename> are mutually exclusive.  One of them is
  required, however.
  
  =for comment
  TODO - Example.
  
  =head3 Filename
  
  Specify the C<Filename> to watch.  POE::Wheel::FollowTail will wait
  for the file to appear if it doesn't exist.  The wheel will also
  reopen the file if it disappears, such as when it has been reset or
  rolled over.  In the case of a reset, POE::Wheel::FollowTail will also
  emit a C<ResetEvent>, if one has been requested.
  
  C<Handle> and C<Filename> are mutually exclusive.  One of them is
  required, however.
  
  See the L</SYNOPSIS> for an example.
  
  =head3 IdleEvent
  
  C<IdleEvent> is an optional event.  If specified, it will fire
  whenever POE::Wheel::FollowTail checks for activity but sees nothing.
  It was added in POE 1.362 as a way to advance certain test programs
  without needing to wait conservatively large amounts of time.
  
  C<IdleEvent> is described in L</PUBLIC EVENTS>.
  
  =head3 InputEvent
  
  The C<InputEvent> parameter is required, and it specifies the event to
  emit when new data arrives in the watched file.  C<InputEvent> is
  described in detail in L</PUBLIC EVENTS>.
  
  =head3 ResetEvent
  
  C<ResetEvent> is an optional.  It specifies the name of the event that
  indicates file rollover or reset.  Please see L</PUBLIC EVENTS> for
  more details.
  
  =head3 ErrorEvent
  
  POE::Wheel::FollowTail may emit optional C<ErrorEvent>s whenever it
  runs into trouble.  The data that comes with this event is explained
  in L</PUBLIC EVENTS>.
  
  =head2 event
  
  event() allows a session to change the events emitted by a wheel
  without destroying and re-creating the object.  It accepts one or more
  of the events listed in L</PUBLIC EVENTS>.  Undefined event names
  disable those events.
  
  Stop handling log resets:
  
    sub some_event_handler {
      $_[HEAP]{tailor}->event( ResetEvent => undef );
    }
  
  The events are described in more detail in L</PUBLIC EVENTS>.
  
  =head2 ID
  
  The ID() method returns the wheel's unique ID.  It's useful for
  storing the wheel in a hash.  All POE::Wheel events should be
  accompanied by a wheel ID, which allows the wheel to be referenced in
  their event handlers.
  
    sub setup_tailor {
      my $wheel = POE::Wheel::FollowTail->new(... incomplete ...);
      $_[HEAP]{tailors}{$wheel->ID} = $wheel;
    }
  
  See the example in L</ErrorEvent> for a handler that will find this
  wheel again.
  
  =head2 tell
  
  tell() returns the current position for the file being watched by
  POE::Wheel::FollowTail.  It may be useful for saving the position
  program termination.  new()'s C<Seek> parameter may be used to
  resume watching the file where tell() left off.
  
    sub handle_shutdown {
      # Not robust.  Do better in production.
      open my $save, ">", "position.save" or die $!;
      print $save $_[HEAP]{tailor}->tell(), "\n";
      close $save;
    }
  
    sub handle_startup {
      open my $save, "<", "position.save" or die $!;
      chomp(my $seek = <$save>);
      $_[HEAP]{tailor} = POE::Wheel::FollowTail->new(
        ...,
        Seek => $seek,
      );
    }
  
  =head1 PUBLIC EVENTS
  
  POE::Wheel::FollowTail emits a small number of events.
  
  =head2 IdleEvent
  
  C<IdleEvent> specifies the name of an event to be fired when
  POE::Wheel::FollowTail doesn't detect activity on the watched file.
  
  C<$_[ARG0]> contains the ID of the POE::Wheel::FollowTail object that
  fired the event.
  
  =head2 InputEvent
  
  C<InputEvent> sets the name of the event to emit when new data arrives
  into the tailed file.  The event will be accompanied by two
  parameters:
  
  C<$_[ARG0]> contains the data that was read from the file, after being
  parsed by the current C<Filter>.
  
  C<$_[ARG1]> contains the wheel's ID, which may be used as a key into a
  data structure tracking multiple wheels.  No assumption should be made
  about the nature or format of this ID, as it may change at any time.
  Therefore, track your wheels in a hash.
  
  See the L</SYNOPSIS> for an example.
  
  =head2 ResetEvent
  
  C<ResetEvent> names the event to be emitted whenever the wheel detects
  that the followed file has been reset.  It's only available when
  watching files by name, as POE::Wheel::FollowTail must reopen the file
  after it has been reset.
  
  C<ResetEvent> comes with only one parameter, C<$_[ARG0]>, which
  contains the wheel's ID.  See L</InputEvent> for some notes about what
  may be done with wheel IDs.
  
  See the L</SYNOPSIS> for an example.
  
  =head2 ErrorEvent
  
  C<ErrorEvent> names the event emitted when POE::Wheel::FollowTail
  encounters a problem.  Every C<ErrorEvent> comes with four parameters
  that describe the error and its situation:
  
  C<$_[ARG0]> describes the operation that failed.  This is usually
  "read", since POE::Wheel::FollowTail spends most of its time reading
  from a file.
  
  C<$_[ARG1]> and C<$_[ARG2]> contain the numeric and stringified values
  of C<$!>, respectively.  They will never contain EAGAIN (or its local
  equivalent) since POE::Wheel::FollowTail handles that error itself.
  
  C<$_[ARG3]> contains the wheel's ID, which has been discussed in
  L</InputEvent>.
  
  This error handler logs a message to STDERR and then shuts down the
  wheel.  It assumes that the session is watching multiple files.
  
    sub handle_tail_error {
      my ($operation, $errnum, $errstr, $wheel_id) = @_[ARG0..ARG3];
      warn "Wheel $wheel_id: $operation error $errnum: $errstr\n";
      delete $_[HEAP]{tailors}{$wheel_id};
    }
  
  =head1 SEE ALSO
  
  L<POE::Wheel> describes the basic operations of all wheels in more
  depth.  You need to know this.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 BUGS
  
  This wheel can't tail pipes and consoles on some operating systems.
  
  POE::Wheel::FollowTail generally reads ahead of the data it returns,
  so the tell() position may be later in the file than the data an
  application has already received.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_WHEEL_FOLLOWTAIL

$fatpacked{"POE/Wheel/ListenAccept.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_WHEEL_LISTENACCEPT';
  package POE::Wheel::ListenAccept;
  
  use strict;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw( croak carp );
  use Symbol qw( gensym );
  
  use POSIX qw(:fcntl_h);
  use Errno qw(EWOULDBLOCK);
  use POE qw( Wheel );
  push @ISA, qw(POE::Wheel);
  
  sub SELF_HANDLE       () { 0 }
  sub SELF_EVENT_ACCEPT () { 1 }
  sub SELF_EVENT_ERROR  () { 2 }
  sub SELF_UNIQUE_ID    () { 3 }
  sub SELF_STATE_ACCEPT () { 4 }
  
  sub CRIMSON_SCOPE_HACK ($) { 0 }
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
    my %params = @_;
  
    croak "wheels no longer require a kernel reference as their first parameter"
      if (@_ && (ref($_[0]) eq 'POE::Kernel'));
  
    croak "$type requires a working Kernel" unless defined $poe_kernel;
  
    croak "Handle required"      unless defined $params{Handle};
    croak "AcceptEvent required" unless defined $params{AcceptEvent};
  
    my $self = bless [ $params{Handle},                  # SELF_HANDLE
                       delete $params{AcceptEvent},      # SELF_EVENT_ACCEPT
                       delete $params{ErrorEvent},       # SELF_EVENT_ERROR
                       &POE::Wheel::allocate_wheel_id(), # SELF_UNIQUE_ID
                       undef,                            # SELF_STATE_ACCEPT
                     ], $type;
                                          # register private event handlers
    $self->_define_accept_state();
    $poe_kernel->select($self->[SELF_HANDLE], $self->[SELF_STATE_ACCEPT]);
  
    $self;
  }
  
  #------------------------------------------------------------------------------
  
  sub event {
    my $self = shift;
    push(@_, undef) if (scalar(@_) & 1);
  
    while (@_) {
      my ($name, $event) = splice(@_, 0, 2);
  
      if ($name eq 'AcceptEvent') {
        if (defined $event) {
          $self->[SELF_EVENT_ACCEPT] = $event;
        }
        else {
          carp "AcceptEvent requires an event name.  ignoring undef";
        }
      }
      elsif ($name eq 'ErrorEvent') {
        $self->[SELF_EVENT_ERROR] = $event;
      }
      else {
        carp "ignoring unknown ListenAccept parameter '$name'";
      }
    }
  }
  
  #------------------------------------------------------------------------------
  
  sub _define_accept_state {
    my $self = shift;
                                          # stupid closure trick
    my $event_accept = \$self->[SELF_EVENT_ACCEPT];
    my $event_error  = \$self->[SELF_EVENT_ERROR];
    my $handle       = $self->[SELF_HANDLE];
    my $unique_id    = $self->[SELF_UNIQUE_ID];
                                          # register the select-read handler
    $poe_kernel->state
      ( $self->[SELF_STATE_ACCEPT] =  ref($self) . "($unique_id) -> select read",
        sub {
          # prevents SEGV
          0 && CRIMSON_SCOPE_HACK('<');
  
          # subroutine starts here
          my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];
  
          my $new_socket = gensym;
          my $peer = accept($new_socket, $handle);
  
          if ($peer) {
            $k->call($me, $$event_accept, $new_socket, $peer, $unique_id);
          }
          elsif ($! != EWOULDBLOCK) {
            $$event_error &&
              $k->call($me, $$event_error, 'accept', ($!+0), $!, $unique_id);
          }
        }
      );
  }
  
  #------------------------------------------------------------------------------
  
  sub DESTROY {
    my $self = shift;
                                          # remove tentacles from our owner
    $poe_kernel->select($self->[SELF_HANDLE]);
  
    if ($self->[SELF_STATE_ACCEPT]) {
      $poe_kernel->state($self->[SELF_STATE_ACCEPT]);
      undef $self->[SELF_STATE_ACCEPT];
    }
  
    &POE::Wheel::free_wheel_id($self->[SELF_UNIQUE_ID]);
  }
  
  #------------------------------------------------------------------------------
  
  sub ID {
    return $_[0]->[SELF_UNIQUE_ID];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Wheel::ListenAccept - accept connections from regular listening sockets
  
  =head1 SYNOPSIS
  
  See L<POE::Wheel::SocketFactory/SYNOPSIS> for a simpler version of
  this program.
  
    #!perl
  
    use warnings;
    use strict;
  
    use IO::Socket;
    use POE qw(Wheel::ListenAccept Wheel::ReadWrite);
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          # Start the server.
          $_[HEAP]{server} = POE::Wheel::ListenAccept->new(
            Handle => IO::Socket::INET->new(
              LocalPort => 12345,
              Listen => 5,
            ),
            AcceptEvent => "on_client_accept",
            ErrorEvent => "on_server_error",
          );
        },
        on_client_accept => sub {
          # Begin interacting with the client.
          my $client_socket = $_[ARG0];
          my $io_wheel = POE::Wheel::ReadWrite->new(
            Handle => $client_socket,
            InputEvent => "on_client_input",
            ErrorEvent => "on_client_error",
          );
          $_[HEAP]{client}{ $io_wheel->ID() } = $io_wheel;
        },
        on_server_error => sub {
          # Shut down server.
          my ($operation, $errnum, $errstr) = @_[ARG0, ARG1, ARG2];
          warn "Server $operation error $errnum: $errstr\n";
          delete $_[HEAP]{server};
        },
        on_client_input => sub {
          # Handle client input.
          my ($input, $wheel_id) = @_[ARG0, ARG1];
          $input =~ tr[a-zA-Z][n-za-mN-ZA-M]; # ASCII rot13
          $_[HEAP]{client}{$wheel_id}->put($input);
        },
        on_client_error => sub {
          # Handle client error, including disconnect.
          my $wheel_id = $_[ARG3];
          delete $_[HEAP]{client}{$wheel_id};
        },
      }
    );
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Wheel::ListenAccept implements non-blocking accept() calls for
  plain old listening server sockets.  The application provides the
  socket, using some normal means such as socket(), IO::Socket::INET, or
  IO::Socket::UNIX.  POE::Wheel::ListenAccept monitors the listening
  socket and emits events whenever a new client has been accepted.
  
  Please see L<POE::Wheel::SocketFactory> if you need non-blocking
  connect() or a more featureful listen/accept solution.
  
  POE::Wheel::ListenAccept only accepts client connections.  It does not
  read or write data, so it neither needs nor includes a put() method.
  L<POE::Wheel::ReadWrite> generally handles the accepted client socket.
  
  =head1 PUBLIC METHODS
  
  =head2 new
  
  new() creates a new POE::Wheel::ListenAccept object for a given
  listening socket.  The object will generate events relating to the
  socket for as long as it exists.
  
  new() accepts two required named parameters:
  
  =head3 Handle
  
  The C<Handle> constructor parameter must contain a listening socket
  handle.  POE::Wheel::FollowTail will monitor this socket and accept()
  new connections as they arrive.
  
  =head3 AcceptEvent
  
  C<AcceptEvent> is a required event name that POE::Wheel::ListenAccept
  will emit for each accepted client socket.  L</PUBLIC EVENTS>
  describes it in detail
  
  =head3 ErrorEvent
  
  C<ErrorEvent> is an optional event name that will be emitted whenever
  a serious problem occurs.  Please see L</PUBLIC EVENTS> for more
  details.
  
  =head2 event
  
  event() allows a session to change the events emitted by a wheel
  without destroying and re-creating the object.  It accepts one or more
  of the events listed in L</PUBLIC EVENTS>.  Undefined event names
  disable those events.
  
  Ignore connections:
  
    sub ignore_new_connections {
      $_[HEAP]{tailor}->event( AcceptEvent => "on_ignored_accept" );
    }
  
    sub handle_ignored_accept {
      # does nothing
    }
  
  =head2 ID
  
  The ID() method returns the wheel's unique ID.  It's useful for
  storing the wheel in a hash.  All POE::Wheel events should be
  accompanied by a wheel ID, which allows the wheel to be referenced in
  their event handlers.
  
    sub setup_listener {
      my $wheel = POE::Wheel::ListenAccept->new(... etc  ...);
      $_[HEAP]{listeners}{$wheel->ID} = $wheel;
    }
  
  =head1 PUBLIC EVENTS
  
  POE::Wheel::ListenAccept emits a couple events.
  
  =head2 AcceptEvent
  
  C<AcceptEvent> names the event that will be emitted for each newly
  accepted client socket.  It is accompanied by three parameters:
  
  C<$_[ARG0]> contains the newly accepted client socket handle.  It's up
  to the application to do something with this socket.  Most use cases
  involve passing the socket to a L<POE::Wheel::ReadWrite> constructor.
  
  C<$_[ARG1]> contains the accept() call's return value, which is often
  the encoded remote end of the remote end of the socket.
  
  C<$_[ARG2]> contains the POE::Wheel::ListenAccept object's unique ID.
  This is the same value as returned by the wheel's ID() method.
  
  A sample C<AcceptEvent> handler:
  
    sub accept_state {
      my ($client_socket, $remote_addr, $wheel_id) = @_[ARG0..ARG2];
  
      # Make the remote address human readable.
      my ($port, $packed_ip) = sockaddr_in($remote_addr);
      my $dotted_quad = inet_ntoa($packed_ip);
  
      print(
        "Wheel $wheel_id accepted a connection from ",
        "$dotted_quad port $port.\n"
      );
  
      # Spawn off a session to interact with the socket.
      create_server_session($handle);
    }
  
  =head2 ErrorEvent
  
  C<ErrorEvent> names the event that will be generated whenever a new
  connection could not be successfully accepted.  This event is
  accompanied by four parameters:
  
  C<$_[ARG0]> contains the name of the operation that failed.  This
  usually is 'accept', but be aware that it's not necessarily a function
  name.
  
  C<$_[ARG1]> and C<$_[ARG2]> hold the numeric and stringified values
  of C<$!>, respectively.  POE::Wheel::ListenAccept knows how to handle
  EAGAIN (and system-dependent equivalents), so this error will never be
  returned.
  
  C<$_[ARG3]> contains the wheel's unique ID, which may be useful for
  shutting down one particular wheel out of a group of them.
  
  A sample C<ErrorEvent> event handler.  This assumes the wheels are
  saved as in the L</ID> example.
  
    sub error_state {
      my ($operation, $errnum, $errstr, $wheel_id) = @_[ARG0..ARG3];
      warn "Wheel $wheel_id generated $operation error $errnum: $errstr\n";
      delete $_[HEAP]{listeners}{$wheel_id};
    }
  
  =head1 SEE ALSO
  
  L<POE::Wheel> describes the basic operations of all wheels in more
  depth.  You need to know this.
  
  L<POE::Wheel::ReadWrite> for one possible way to handle clients once
  you have their sockets.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 BUGS
  
  None known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_WHEEL_LISTENACCEPT

$fatpacked{"POE/Wheel/ReadLine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_WHEEL_READLINE';
  package POE::Wheel::ReadLine;
  
  use warnings;
  use strict;
  BEGIN { eval { require bytes } and bytes->import; }
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw( croak carp );
  use Symbol qw(gensym);
  use POE qw( Wheel );
  push @ISA, qw(POE::Wheel);
  use POSIX ();
  
  if ($^O eq "MSWin32") {
    die "$^O cannot run " . __PACKAGE__;
  }
  
  # After a massive hackathon on Cygwin/perl/windows/POE it was determined that
  # having TERM='dumb' is worthless and VERY problematic to work-around...
  # Actually, the problem lies deep in Term::Cap's internals - it blows up
  # when we try to do "$termcap->Trequire( qw( cl ku kd kl kr) )" in new()
  # eval{} will not catch the croak() in the sub
  # Cygwin v1.7.1-1 on Windows Server 2008 64bit with Perl v5.10.1 with Term::Cap v1.12 with POE v1.287
  # For detailed info, please consult RT#55365
  # sorry about the defined $ENV{TERM} check, it was needed to make sure we spew no warnings...
  if ($^O eq 'cygwin' and defined $ENV{TERM} and $ENV{TERM} eq 'dumb') {
    die "$^O with TERM='$ENV{TERM}' cannot run " . __PACKAGE__;
  }
  
  # Things we'll need to interact with the terminal.
  use Term::Cap ();
  use Term::ReadKey qw( ReadKey ReadMode GetTerminalSize );
  
  my $initialised = 0;
  my $termcap;         # Termcap entry.
  my $tc_bell;         # How to ring the terminal.
  my $tc_visual_bell;  # How to ring the terminal.
  my $tc_has_ce;       # Termcap can clear to end of line.
  
  # Note: we use 2-arg open() below because Perl 5.6 doesn't recognize
  # the '>&' and '<&' modes with a 3-arg open()
  
  # Private STDIN and STDOUT.
  my $stdin  = gensym();
  open($stdin, "<&STDIN") or die "Can't open private STDIN: $!";
  
  my $stdout = gensym;
  open($stdout, ">&STDOUT") or die "Can't open private STDOUT: $!";
  
  # Offsets into $self.
  sub SELF_INPUT          () {  0 }
  sub SELF_CURSOR_INPUT   () {  1 }
  sub SELF_EVENT_INPUT    () {  2 }
  sub SELF_READING_LINE   () {  3 }
  sub SELF_STATE_READ     () {  4 }
  sub SELF_PROMPT         () {  5 }
  sub SELF_HIST_LIST      () {  6 }
  sub SELF_HIST_INDEX     () {  7 }
  sub SELF_INPUT_HOLD     () {  8 }
  sub SELF_KEY_BUILD      () {  9 }
  sub SELF_INSERT_MODE    () { 10 }
  sub SELF_PUT_MODE       () { 11 }
  sub SELF_PUT_BUFFER     () { 12 }
  sub SELF_IDLE_TIME      () { 13 }
  sub SELF_STATE_IDLE     () { 14 }
  sub SELF_HAS_TIMER      () { 15 }
  sub SELF_CURSOR_DISPLAY () { 16 }
  sub SELF_UNIQUE_ID      () { 17 }
  sub SELF_KEYMAP         () { 18 }
  sub SELF_OPTIONS        () { 19 }
  sub SELF_APP            () { 20 }
  sub SELF_ALL_KEYMAPS    () { 21 }
  sub SELF_PENDING        () { 22 }
  sub SELF_COUNT          () { 23 }
  sub SELF_MARK           () { 24 }
  sub SELF_MARKLIST       () { 25 }
  sub SELF_KILL_RING      () { 26 }
  sub SELF_LAST           () { 27 }
  sub SELF_PENDING_FN     () { 28 }
  sub SELF_SOURCE         () { 29 }
  sub SELF_SEARCH         () { 30 }
  sub SELF_SEARCH_PROMPT  () { 31 }
  sub SELF_SEARCH_MAP     () { 32 }
  sub SELF_PREV_PROMPT    () { 33 }
  sub SELF_SEARCH_DIR     () { 34 }
  sub SELF_SEARCH_KEY     () { 35 }
  sub SELF_UNDO           () { 36 }
  
  sub CRIMSON_SCOPE_HACK ($) { 0 }
  
  #------------------------------------------------------------------------------
  
  # Build a hash of input characters and their "normalized" display
  # versions.  ISO Latin-1 characters (8th bit set "ASCII") are
  # mishandled.  European users, please forgive me.  If there's a good
  # way to handle this-- perhaps this is an interesting use for
  # Unicode-- please let me know.
  
  my (%normalized_character, @normalized_extra_width);
  
  #------------------------------------------------------------------------------
  # Gather information about the user's terminal.  This just keeps
  # getting uglier.
  
  my $ospeed = undef;
  my $termios = undef;
  my $term = undef;
  my $tc_left = undef;
  my $trk_cols = undef;
  my $trk_rows = undef;
  
  sub _curs_left {
    my $amount = shift;
  
    if ($tc_left eq "LE") {
      $termcap->Tgoto($tc_left, 1, $amount, $stdout);
      return;
    }
  
    for (1..$amount) {
      $termcap->Tgoto($tc_left, 1, 1, $stdout);
    }
  }
  
  
  our $defuns = {
  "abort"                                  => \&rl_abort,
  "accept-line"                            => \&rl_accept_line,
  "backward-char"                          => \&rl_backward_char,
  "backward-delete-char"                   => \&rl_backward_delete_char,
  "backward-kill-line"                     => \&rl_unix_line_discard, # reuse emacs
  "backward-kill-word"                     => \&rl_backward_kill_word,
  "backward-word"                          => \&rl_backward_word,
  "beginning-of-history"                   => \&rl_beginning_of_history,
  "beginning-of-line"                      => \&rl_beginning_of_line,
  "capitalize-word"                        => \&rl_capitalize_word,
  "character-search"                       => \&rl_character_search,
  "character-search-backward"              => \&rl_character_search_backward,
  "clear-screen"                           => \&rl_clear_screen,
  "complete"                               => \&rl_complete,
  "copy-region-as-kill"                    => \&rl_copy_region_as_kill,
  "delete-char"                            => \&rl_delete_char,
  "delete-horizontal-space"                => \&rl_delete_horizontal_space,
  "digit-argument"                         => \&rl_digit_argument,
  "ding"                                   => \&rl_ding,
  "downcase-word"                          => \&rl_downcase_word,
  "dump-key"                               => \&rl_dump_key,
  "dump-macros"                            => \&rl_dump_macros,
  "dump-variables"                         => \&rl_dump_variables,
  "emacs-editing-mode"                     => \&rl_emacs_editing_mode,
  "end-of-history"                         => \&rl_end_of_history,
  "end-of-line"                            => \&rl_end_of_line,
  "forward-char"                           => \&rl_forward_char,
  "forward-search-history"                 => \&rl_forward_search_history,
  "forward-word"                           => \&rl_forward_word,
  "insert-comment"                         => \&rl_insert_comment,
  "insert-completions"                     => \&rl_insert_completions,
  "insert-macro"                           => \&rl_insert_macro,
  "interrupt"                              => \&rl_interrupt,
  "isearch-again"                          => \&rl_isearch_again,
  "kill-line"                              => \&rl_kill_line,
  "kill-region"                            => \&rl_kill_region,
  "kill-whole-line"                        => \&rl_kill_whole_line,
  "kill-word"                              => \&rl_kill_word,
  "next-history"                           => \&rl_next_history,
  "non-incremental-forward-search-history" => \&rl_non_incremental_forward_search_history,
  "non-incremental-reverse-search-history" => \&rl_non_incremental_reverse_search_history,
  "overwrite-mode"                         => \&rl_overwrite_mode,
  "poe-wheel-debug"                        => \&rl_poe_wheel_debug,
  "possible-completions"                   => \&rl_possible_completions,
  "previous-history"                       => \&rl_previous_history,
  "quoted-insert"                          => \&rl_quoted_insert,
  "re-read-init-file"                      => \&rl_re_read_init_file,
  "redraw-current-line"                    => \&rl_redraw_current_line,
  "reverse-search-history"                 => \&rl_reverse_search_history,
  "revert-line"                            => \&rl_revert_line,
  "search-abort"                           => \&rl_search_abort,
  "search-finish"                          => \&rl_search_finish,
  "search-key"                             => \&rl_search_key,
  "self-insert"                            => \&rl_self_insert,
  "set-keymap"                             => \&rl_set_keymap,
  "set-mark"                               => \&rl_set_mark,
  "tab-insert"                             => \&rl_ding, # UNIMPLEMENTED
  "tilde-expand"                           => \&rl_tilde_expand,
  "transpose-chars"                        => \&rl_transpose_chars,
  "transpose-words"                        => \&rl_transpose_words,
  "undo"                                   => \&rl_undo,
  "unix-line-discard"                      => \&rl_unix_line_discard,
  "unix-word-rubout"                       => \&rl_unix_word_rubout,
  "upcase-word"                            => \&rl_upcase_word,
  "vi-append-eol"                          => \&rl_vi_append_eol,
  "vi-append-mode"                         => \&rl_vi_append_mode,
  "vi-arg-digit"                           => \&rl_vi_arg_digit,
  "vi-change-case"                         => \&rl_vi_change_case,
  "vi-change-char"                         => \&rl_vi_change_char,
  "vi-change-to"                           => \&rl_vi_change_to,
  "vi-char-search"                         => \&rl_vi_char_search,
  "vi-column"                              => \&rl_vi_column,
  "vi-complete"                            => \&rl_vi_cmplete,
  "vi-delete"                              => \&rl_vi_delete,
  "vi-delete-to"                           => \&rl_vi_delete_to,
  "vi-editing-mode"                        => \&rl_vi_editing_mode,
  "vi-end-spec"                            => \&rl_vi_end_spec,
  "vi-end-word"                            => \&rl_vi_end_word,
  "vi-eof-maybe"                           => \&rl_vi_eof_maybe,
  "vi-fetch-history"                       => \&rl_beginning_of_history, # re-use emacs version
  "vi-first-print"                         => \&rl_vi_first_print,
  "vi-goto-mark"                           => \&rl_vi_goto_mark,
  "vi-insert-beg"                          => \&rl_vi_insert_beg,
  "vi-insertion-mode"                      => \&rl_vi_insertion_mode,
  "vi-match"                               => \&rl_vi_match,
  "vi-movement-mode"                       => \&rl_vi_movement_mode,
  "vi-next-word"                           => \&rl_vi_next_word,
  "vi-prev-word"                           => \&rl_vi_prev_word,
  "vi-put"                                 => \&rl_vi_put,
  "vi-redo"                                => \&rl_vi_redo,
  "vi-replace"                             => \&rl_vi_replace,
  "vi-search"                              => \&rl_vi_search,
  "vi-search-accept"                       => \&rl_vi_search_accept,
  "vi-search-again"                        => \&rl_vi_search_again,
  "vi-search-key"                          => \&rl_vi_search_key,
  "vi-set-mark"                            => \&rl_vi_set_mark,
  "vi-spec-beginning-of-line"              => \&rl_vi_spec_beginning_of_line,
  "vi-spec-end-of-line"                    => \&rl_vi_spec_end_of_line,
  "vi-spec-first-print"                    => \&rl_vi_spec_first_print,
  "vi-spec-forward-char"                   => \&rl_vi_spec_forward_char,
  "vi-spec-mark"                           => \&rl_vi_spec_mark,
  "vi-spec-word"                           => \&rl_vi_spec_word,
  "vi-subst"                               => \&rl_vi_subst,
  "vi-tilde-expand"                        => \&rl_vi_tilde_expand,
  "vi-undo"                                => \&rl_undo, # re-use emacs version
  "vi-yank-arg"                            => \&rl_vi_yank_arg,
  "vi-yank-to"                             => \&rl_vi_yank_to,
  "yank"                                   => \&rl_yank,
  "yank-last-arg"                          => \&rl_yank_last_arg,
  "yank-nth-arg"                           => \&rl_yank_nth_arg,
  "yank-pop"                               => \&rl_yank_pop,
  };
  
  # what functions are for counting
  my @fns_counting = (
    'rl_vi_arg_digit',
    'rl_digit_argument',
    'rl_universal-argument',
  );
  
  # what functions are purely for movement...
  my @fns_movement = (
    'rl_beginning_of_line',
    'rl_backward_char',
    'rl_forward_char',
    'rl_backward_word',
    'rl_forward_word',
    'rl_end_of_line',
    'rl_character_search',
    'rl_character_search_backward',
    'rl_vi_prev_word',
    'rl_vi_next_word',
    'rl_vi_goto_mark',
    'rl_vi_end_word',
    'rl_vi_column',
    'rl_vi_first_print',
    'rl_vi_char_search',
    'rl_vi_spec_char_search',
    'rl_vi_spec_end_of_line',
    'rl_vi_spec_beginning_of_line',
    'rl_vi_spec_first_print',
    'rl_vi_spec_word',
    'rl_vi_spec_mark',
  );
  
  # the list of functions that we don't want to record for
  # later redo usage in vi mode.
  my @fns_anon = (
    'rl_vi_redo',
    @fns_counting,
    @fns_movement,
  );
  
  
  my $defaults_inputrc = <<'INPUTRC';
  set comment-begin #
  INPUTRC
  
  my $emacs_inputrc = <<'INPUTRC';
  C-a: beginning-of-line
  C-b: backward-char
  C-c: interrupt
  C-d: delete-char
  C-e: end-of-line
  C-f: forward-char
  C-g: abort
  C-h: backward-delete-char
  C-i: complete
  C-j: accept-line
  C-k: kill-line
  C-l: clear-screen
  C-m: accept-line
  C-n: next-history
  C-p: previous-history
  C-q: poe-wheel-debug
  C-r: reverse-search-history
  C-s: forward-search-history
  C-t: transpose-chars
  C-u: unix-line-discard
  C-v: quoted-insert
  C-w: unix-word-rubout
  C-y: yank
  C-]: character-search
  C-_: undo
  del: backward-delete-char
  rubout: backward-delete-char
  
  M-C-g: abort
  M-C-h: backward-kill-word
  M-C-i: tab-insert
  M-C-j: vi-editing-mode
  M-C-r: revert-line
  M-C-y: yank-nth-arg
  M-C-[: complete
  M-C-]: character-search-backward
  M-space: set-mark
  M-#: insert-comment
  M-&: tilde-expand
  M-*: insert-completions
  M--: digit-argument
  M-.: yank-last-arg
  M-0: digit-argument
  M-1: digit-argument
  M-2: digit-argument
  M-3: digit-argument
  M-4: digit-argument
  M-5: digit-argument
  M-6: digit-argument
  M-7: digit-argument
  M-8: digit-argument
  M-9: digit-argument
  M-<: beginning-of-history
  M->: end-of-history
  M-?: possible-completions
  
  M-b: backward-word
  M-c: capitalize-word
  M-d: kill-word
  M-f: forward-word
  M-l: downcase-word
  M-n: non-incremental-forward-search-history
  M-p: non-incremental-reverse-search-history
  M-r: revert-line
  M-t: transpose-words
  M-u: upcase-word
  M-y: yank-pop
  M-\: delete-horizontal-space
  M-~: tilde-expand
  M-del: backward-kill-word
  M-_: yank-last-arg
  
  C-xC-r: re-read-init-file
  C-xC-g: abort
  C-xDel: backward-kill-line
  C-xm: dump-macros
  C-xv: dump-variables
  C-xk: dump-key
  
  home: beginning-of-line
  end: end-of-line
  ins: overwrite-mode
  del: delete-char
  left: backward-char
  right: forward-char
  up: previous-history
  down: next-history
  bs: backward-delete-char
  INPUTRC
  
  my $vi_inputrc = <<'INPUTRC';
  
  # VI uses two keymaps, depending on which mode we're in.
  set keymap vi-insert
  
  C-d: vi-eof-maybe
  C-h: backward-delete-char
  C-i: complete
  C-j: accept-line
  C-m: accept-line
  C-r: reverse-search-history
  C-s: forward-search-history
  C-t: transpose-chars
  C-u: unix-line-discard
  C-v: quoted-insert
  C-w: unix-word-rubout
  C-y: yank
  C-[: vi-movement-mode
  C-_: undo
  C-?: backward-delete-char
  
  set keymap vi-command
  C-d: vi-eof-maybe
  C-e: emacs-editing-mode
  C-g: abort
  C-h: backward-char
  C-j: accept-line
  C-k: kill-line
  C-l: clear-screen
  C-m: accept-line
  C-n: next-history
  C-p: previous-history
  C-q: quoted-insert
  C-r: reverse-search-history
  C-s: forward-search-history
  C-t: transpose-chars
  C-u: unix-line-discard
  C-v: quoted-insert
  C-w: unix-word-rubout
  C-y: yank
  C-_: vi-undo
  " ": forward-char
  "#": insert-comment
  "$": end-of-line
  "%": vi-match
  "&": vi-tilde-expand
  "*": vi-complete
  "+": next-history
  ",": vi-char-search
  "-": previous-history
  ".": vi-redo
  "/": vi-search
  "0": vi-arg-digit
  "1": vi-arg-digit
  "2": vi-arg-digit
  "3": vi-arg-digit
  "4": vi-arg-digit
  "5": vi-arg-digit
  "6": vi-arg-digit
  "7": vi-arg-digit
  "8": vi-arg-digit
  "9": vi-arg-digit
  ";": vi-char-search
  "=": vi-complete
  "?": vi-search
  A: vi-append-eol
  B: vi-prev-word
  C: vi-change-to
  D: vi-delete-to
  E: vi-end-word
  F: vi-char-search
  G: vi-fetch-history
  I: vi-insert-beg
  N: vi-search-again
  P: vi-put
  R: vi-replace
  S: vi-subst
  T: vi-char-search
  U: revert-line
  W: vi-next-word
  X: backward-delete-char
  Y: vi-yank-to
  "\": vi-complete
  "^": vi-first-print
  "_": vi-yank-arg
  "`": vi-goto-mark
  a: vi-append-mode
  b: backward-word
  c: vi-change-to
  d: vi-delete-to
  e: vi-end-word
  h: backward-char
  i: vi-insertion-mode
  j: next-history
  k: previous-history
  l: forward-char
  m: vi-set-mark
  n: vi-search-again
  p: vi-put
  r: vi-change-char
  s: vi-subst
  t: vi-char-search
  w: vi-next-word
  x: vi-delete
  y: vi-yank-to
  "|": vi-column
  "~": vi-change-case
  
  set keymap vi-specification
  "^": vi-spec-first-print
  "`": vi-spec-mark
  "$": vi-spec-end-of-line
  "0": vi-spec-beginning-of-line
  "1": vi-arg-digit
  "2": vi-arg-digit
  "3": vi-arg-digit
  "4": vi-arg-digit
  "5": vi-arg-digit
  "6": vi-arg-digit
  "7": vi-arg-digit
  "8": vi-arg-digit
  "9": vi-arg-digit
  w: vi-spec-word
  t: vi-spec-forward-char
  
  INPUTRC
  
  my $search_inputrc = <<'INPUTRC';
  set keymap isearch
  C-r: isearch-again
  C-s: isearch-again
  
  set keymap vi-search
  C-j: vi-search-accept
  C-m: vi-search-accept
  INPUTRC
  
  #------------------------------------------------------------------------------
  # Helper functions.
  
  sub _vislength {
    return 0 unless $_[0];
    my $len = length($_[0]);
    while ($_[0] =~ m{(\\\[.*?\\\])}g) {
      $len -= length($1);
    }
    return $len;
  }
  
  # Wipe the current input line.
  sub _wipe_input_line {
    my ($self) = shift;
  
    # Clear the current prompt and input, and home the cursor.
    _curs_left( $self->[SELF_CURSOR_DISPLAY] + _vislength($self->[SELF_PROMPT]));
  
    if ( $tc_has_ce ) {
      print $stdout $termcap->Tputs( 'ce', 1 );
    } else {
      my $wlen = _vislength($self->[SELF_PROMPT]) + _display_width($self->[SELF_INPUT]);
      print $stdout ( ' ' x $wlen);
      _curs_left($wlen);
    }
  }
  
  # Helper to flush any buffered output.
  sub _flush_output_buffer {
    my ($self) = shift;
  
    # Flush anything buffered.
    if ( @{ $self->[SELF_PUT_BUFFER] } ) {
      print $stdout @{ $self->[SELF_PUT_BUFFER] };
  
      # Do not change the interior arrayref, or the event handlers will
      # become confused.
      @{ $self->[SELF_PUT_BUFFER] } = ();
    }
  }
  
  # Set up the prompt and input line like nothing happened.
  sub _repaint_input_line {
    my ($self) = shift;
    my $sp = $self->[SELF_PROMPT];
    $sp =~ s{\\[\[\]]}{}g;
    print $stdout $sp, _normalize($self->[SELF_INPUT]);
  
    if ( $self->[SELF_CURSOR_INPUT] != length( $self->[SELF_INPUT]) ) {
      _curs_left(
        _display_width($self->[SELF_INPUT]) - $self->[SELF_CURSOR_DISPLAY]
      );
    }
  }
  
  sub _clear_to_end {
    my ($self) = @_;
    if (length $self->[SELF_INPUT]) {
      if ($tc_has_ce) {
        print $stdout $termcap->Tputs( 'ce', 1 );
      } else {
        my $display_width = _display_width($self->[SELF_INPUT]);
        print $stdout ' ' x $display_width;
        _curs_left($display_width);
      }
    }
  }
  
  sub _delete_chars {
    my ($self, $from, $howmany) = @_;
    # sanitize input
    if ($howmany < 0) {
      $from -= $howmany;
      $howmany = -$howmany;
      if ($from < 0) {
        $howmany -= $from;
        $from = 0;
      }
    }
  
    my $old = substr($self->[SELF_INPUT], $from, $howmany);
    my $killed_width = _display_width($old);
    substr($self->[SELF_INPUT], $from, $howmany) = '';
    if ($self->[SELF_CURSOR_INPUT] > $from) {
      my $newdisp = length(_normalize(substr($self->[SELF_INPUT], 0, $from)));
      _curs_left($self->[SELF_CURSOR_DISPLAY] - $newdisp);
      $self->[SELF_CURSOR_INPUT] = $from;
      $self->[SELF_CURSOR_DISPLAY] = $newdisp;
    }
  
    my $normal_remaining = _normalize(substr($self->[SELF_INPUT], $from));
    print $stdout $normal_remaining;
    my $normal_remaining_length = length($normal_remaining);
  
    if ($tc_has_ce) {
      print $stdout $termcap->Tputs( 'ce', 1 );
    } else {
      print $stdout ' ' x $killed_width;
      $normal_remaining_length += $killed_width;
    }
  
    _curs_left($normal_remaining_length)
    if $normal_remaining_length;
  
    return $old;
  }
  
  sub _search {
    my ($self, $rebuild) = @_;
    if ($rebuild) {
      $self->_wipe_input_line;
      $self->_build_search_prompt;
    }
    # find in history....
    my $found = 0;
    for (
      my $i = $self->[SELF_HIST_INDEX];
      $i < scalar @{$self->[SELF_HIST_LIST]} && $i >= 0;
      $i += $self->[SELF_SEARCH_DIR]
    ) {
      next unless $self->[SELF_HIST_LIST]->[$i] =~ /$self->[SELF_SEARCH]/;
  
      $self->[SELF_HIST_INDEX] = $i;
      $self->[SELF_INPUT] = $self->[SELF_HIST_LIST]->[$i];
      $self->[SELF_CURSOR_INPUT] = 0;
      $self->[SELF_CURSOR_DISPLAY] = 0;
      $self->[SELF_UNDO] = [ $self->[SELF_INPUT], 0, 0 ]; # reset undo info
      $found++;
      last;
    }
    $self->rl_ding unless $found;
    $self->_repaint_input_line;
  }
  
  # Return a normalized version of a string.  This includes destroying
  # 8th-bit-set characters, turning them into strange multi-byte
  # sequences.  Apologies to everyone; please let me know of a portable
  # way to deal with this.
  sub _normalize {
    local $_ = shift;
    s/([^ -~])/$normalized_character{$1}/g;
    return $_;
  }
  
  sub _readable_key {
    my ($raw_key) = @_;
    my @text = ();
    foreach my $l (split(//, $raw_key)) {
      if (ord($l) == 0x1B) {
        push(@text, 'Meta-');
        next;
      }
      if (ord($l) < 32) {
        push(@text, 'Control-' . chr(ord($l)+64));
        next;
      }
      if (ord($l) > 127) {
        my $l = ord($l)-128;
        if ($l < 32) {
          $l = "Control-" . chr($l+64);
        }
        push(@text, 'Meta-' . chr($l));
        next;
      }
      if (ord($l) == 127) {
        push @text, "^?";
        next;
      }
      push(@text, $l);
    }
    return join("", @text);
  }
  
  # Calculate the display width of a string.  The display width is
  # sometimes wider than the actual string because some characters are
  # represented on the terminal as multiple characters.
  
  sub _display_width {
    local $_ = shift;
    my $width = length;
    $width += $normalized_extra_width[ord] foreach (m/([\x00-\x1F\x7F-\xFF])/g);
    return $width;
  }
  
  sub _build_search_prompt {
    my ($self) = @_;
    $self->[SELF_PROMPT] = $self->[SELF_SEARCH_PROMPT];
    $self->[SELF_PROMPT] =~ s{%s}{$self->[SELF_SEARCH]};
  }
  
  sub _global_init {
    return if $initialised;
  
    # Get the terminal speed for Term::Cap.
    $termios = POSIX::Termios->new();
    $termios->getattr();
    $ospeed = $termios->getospeed() || eval { POSIX::B38400() } || 0;
  
    # Get the current terminal's capabilities.
    $term = $ENV{TERM} || 'vt100';
    $termcap = eval { Term::Cap->Tgetent( { TERM => $term, OSPEED => $ospeed } ) };
    die "could not find termcap entry for ``$term'': $!" unless defined $termcap;
  
    # Require certain capabilities.
    $termcap->Trequire( qw( cl ku kd kl kr) );
  
    # Cursor movement.
    $tc_left = "LE";
    eval { $termcap->Trequire($tc_left) };
    if ($@) {
      $tc_left = "le";
      eval { $termcap->Trequire($tc_left) };
      if ($@) {
        # try out to see if we have a better terminfo defun.
        # it may well not work (hence eval the lot), but it's worth a shot
        eval {
          my @tc = `infocmp -C $term`;
          chomp(@tc);
          splice(@tc, 0, 1); # remove header line
          $ENV{TERMCAP} = join("", @tc);
          $termcap = Term::Cap->Tgetent( { TERM => $term, OSPEED => $ospeed } );
          $termcap->Trequire($tc_left);
        };
      }
      die "POE::Wheel::ReadLine requires a termcap that supports LE or le" if $@;
    }
  
    # Terminal size.
    # We initialize the values once on start-up,
    # and then from then on, we check them on every entry into
    # the input state engine (so that we have valid values) and
    # before handing control back to the user (so that they get
    # an up-to-date value).
    eval { ($trk_cols, $trk_rows) = GetTerminalSize($stdout) };
    ($trk_cols, $trk_rows) = (80, 25) if $@;
  
    # Configuration...
    # Some things are optional.
    eval { $termcap->Trequire( 'ce' ) };
    $tc_has_ce = 1 unless $@;
  
    # o/` You can ring my bell, ring my bell. o/`
    my $bell = $termcap->Tputs( bl => 1 );
    $bell = $termcap->Tputs( vb => 1 ) unless defined $bell;
    $tc_bell = (defined $bell) ? $bell : '';
    $bell = $termcap->Tputs( vb => 1 ) || '';
    $tc_visual_bell = $bell;
  
    my $convert_meta = 1;
    for (my $ord = 0; $ord < 256; $ord++) {
      my $str = chr($ord);
      if ($ord > 127) {
        if ($convert_meta) {
          $str = "^[";
          if (($ord - 128) < 32) {
            $str .= "^" . lc(chr($ord-128+64));
          } else {
            $str .= lc(chr($ord-128));
          }
        } else {
          $str = sprintf "<%2x>", $ord;
        }
      } elsif ($ord < 32) {
        $str = '^' . lc(chr($ord+64));
      }
      elsif ($ord == 127) {
        $str = "^?";
      }
      $normalized_character{chr($ord)} = $str;
      $normalized_extra_width[$ord] = length ( $str ) - 1;
    }
    $initialised++;
  }
  
  #------------------------------------------------------------------------------
  # The methods themselves.
  
  # Create a new ReadLine wheel.
  sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
  
    my %params = @_;
    croak "$class requires a working Kernel" unless defined $poe_kernel;
  
    my $input_event = delete $params{InputEvent};
    croak "$class requires an InputEvent parameter" unless defined $input_event;
  
    my $put_mode = delete $params{PutMode};
    $put_mode = 'idle' unless defined $put_mode;
    croak "$class PutMode must be either 'immediate', 'idle', or 'after'"
      unless $put_mode =~ /^(immediate|idle|after)$/;
  
    my $idle_time = delete $params{IdleTime};
    $idle_time = 2 unless defined $idle_time;
  
    my $app = delete($params{AppName}) || delete($params{appname});
    delete $params{appname}; # in case AppName was present
    $app ||= 'poe-readline';
  
    if (scalar keys %params) {
      carp(
        "unknown parameters in $class constructor call: ",
        join(', ', keys %params)
      );
    }
  
    my $self = undef;
    if (ref $proto) {
      $self = bless [], $class;
      @$self = @$proto;
      $self->[SELF_SOURCE] = $proto;
      # ensure we're not bound to the old handler
      $poe_kernel->select_read($stdin);
    } else {
      $self = bless [
        '',           # SELF_INPUT
        0,            # SELF_CURSOR_INPUT
        $input_event, # SELF_EVENT_INPUT
        0,            # SELF_READING_LINE
        undef,        # SELF_STATE_READ
        '>',          # SELF_PROMPT
        [ ],          # SELF_HIST_LIST
        0,            # SELF_HIST_INDEX
        '',           # SELF_INPUT_HOLD
        '',           # SELF_KEY_BUILD
        1,            # SELF_INSERT_MODE
        $put_mode,    # SELF_PUT_MODE
        [ ],          # SELF_PUT_BUFFER
        $idle_time,   # SELF_IDLE_TIME
        undef,        # SELF_STATE_IDLE
        0,            # SELF_HAS_TIMER
        0,            # SELF_CURSOR_DISPLAY
        &POE::Wheel::allocate_wheel_id(),  # SELF_UNIQUE_ID
        undef,        # SELF_KEYMAP
        { },          # SELF_OPTIONS
        $app,         # SELF_APP
        {},           # SELF_ALL_KEYMAPS
        undef,        # SELF_PENDING
        0,            # SELF_COUNT
        0,            # SELF_MARK
        {},           # SELF_MARKLIST
        [],           # SELF_KILL_RING
        '',           # SELF_LAST
        undef,        # SELF_PENDING_FN
        undef,        # SELF_SOURCE
        '',           # SELF_SEARCH
        undef,        # SELF_SEARCH_PROMPT
        undef,        # SELF_SEARCH_MAP
        '',           # SELF_PREV_PROMPT
        0,            # SELF_SEARCH_DIR
        '',           # SELF_SEARCH_KEY
        [],           # SELF_UNDO
      ], $class;
  
      _global_init();
      $self->rl_re_read_init_file();
    }
  
    # Turn off $stdout buffering.
    select((select($stdout), $| = 1)[0]);
  
    # Set up the event handlers.  Idle goes first.
    $self->[SELF_STATE_IDLE] = (
      ref($self) . "(" . $self->[SELF_UNIQUE_ID] . ") -> input timeout"
    );
  
    $self->[SELF_STATE_READ] = (
      ref($self) . "(" . $self->[SELF_UNIQUE_ID] . ") -> select read"
    );
  
    # TODO - The following hack breaks a circular reference on $self.
    {
      my $weak_self = $self;
      use Scalar::Util qw(weaken);
      weaken $weak_self;
  
      $poe_kernel->state(
        $self->[SELF_STATE_IDLE],
        sub { _idle_state($weak_self, @_[1..$#_]) }
      );
  
      $poe_kernel->state(
        $self->[SELF_STATE_READ],
        sub { _read_state($weak_self, @_[1..$#_]) }
      );
    }
  
    return $self;
  }
  
  #------------------------------------------------------------------------------
  # Destroy the ReadLine wheel.  Clean up the terminal.
  
  sub DESTROY {
    my $self = shift;
  
    return unless $initialised;
  
    # Stop selecting on the handle.
    $poe_kernel->select_read($stdin);
  
    # Detach our tentacles from the parent session.
    if ($self->[SELF_STATE_READ]) {
      $poe_kernel->state($self->[SELF_STATE_READ]);
      $self->[SELF_STATE_READ] = undef;
    }
  
    if ($self->[SELF_STATE_IDLE]) {
      $poe_kernel->alarm($self->[SELF_STATE_IDLE]);
      $poe_kernel->state($self->[SELF_STATE_IDLE]);
      $self->[SELF_STATE_IDLE] = undef;
    }
  
    # tell the terminal that we want to leave 'application' mode
    print $termcap->Tputs('ke' => 1) if $termcap->Tputs('ke');
    # Restore the console.
    ReadMode('restore');
  
    &POE::Wheel::free_wheel_id($self->[SELF_UNIQUE_ID]);
  }
  
  #------------------------------------------------------------------------------
  # Redefine the idle handler.  This also uses stupid closure tricks.
  # See the comments for &_define_read_state for more information about
  # these closure tricks.
  
  sub _idle_state {
    my ($self) = $_[OBJECT];
  
    if (@{$self->[SELF_PUT_BUFFER]}) {
      $self->_wipe_input_line;
      $self->_flush_output_buffer;
      $self->_repaint_input_line;
    }
  
    # No more timer.
    $self->[SELF_HAS_TIMER] = 0;
  }
  
  sub _read_state {
    my ($self, $k) = @_[OBJECT, KERNEL];
  
    # Read keys, non-blocking, as long as there are some.
    while (defined(my $raw_key = ReadKey(-1))) {
  
      # Not reading a line; discard the input.
      next unless $self->[SELF_READING_LINE];
  
      # Update the timer on significant input.
      if ( $self->[SELF_PUT_MODE] eq 'idle' ) {
        $k->delay( $self->[SELF_STATE_IDLE], $self->[SELF_IDLE_TIME] );
        $self->[SELF_HAS_TIMER] = 1;
      }
  
      push(
        @{$self->[SELF_UNDO]}, [
          $self->[SELF_INPUT],
          $self->[SELF_CURSOR_INPUT],
          $self->[SELF_CURSOR_DISPLAY]
        ]
      );
  
      # Build-multi character codes and make the keystroke printable.
      $self->[SELF_KEY_BUILD] .= $raw_key;
      $raw_key = $self->[SELF_KEY_BUILD];
      my $key = _normalize($raw_key);
  
      if ($self->[SELF_PENDING_FN]) {
        my $old = $self->[SELF_INPUT];
        my $oldref = $self->[SELF_PENDING_FN];
        push(
          @{$self->[SELF_UNDO]}, [
            $old,
            $self->[SELF_CURSOR_INPUT],
            $self->[SELF_CURSOR_DISPLAY]
          ]
        );
        $self->[SELF_PENDING_FN]->($self, $key, $raw_key);
        pop(@{$self->[SELF_UNDO]}) if ($old eq $self->[SELF_INPUT]);
        $self->[SELF_KEY_BUILD] = '';
        if ($self->[SELF_PENDING_FN] && "$self->[SELF_PENDING_FN]" eq $oldref) {
          $self->[SELF_PENDING_FN] = undef;
        }
        next;
      }
  
      # Keep glomming keystrokes until they stop existing in the
      # hash of meta prefixes.
      next if exists $self->[SELF_KEYMAP]->{prefix}->{$raw_key};
  
      # PROCESS KEY
      my $old = $self->[SELF_INPUT];
      push(
        @{$self->[SELF_UNDO]}, [
          $old,
          $self->[SELF_CURSOR_INPUT],
          $self->[SELF_CURSOR_DISPLAY]
        ]
      );
      $self->[SELF_KEY_BUILD] = '';
      $self->_apply_key($key, $raw_key);
  
      pop(@{$self->[SELF_UNDO]}) if ($old eq $self->[SELF_INPUT]);
    }
  }
  
  sub _apply_key {
    my ($self, $key, $raw_key) = @_;
    my $mapping = $self->[SELF_KEYMAP];
    my $fn = $mapping->{default};
  
    if (exists $mapping->{binding}->{$raw_key}) {
      $fn = $mapping->{binding}->{$raw_key};
    }
  
    # print "\r\ninvoking $fn for $key\r\n";$self->_repaint_input_line;
    if ($self->[SELF_COUNT] && !grep { $_ eq $fn } @fns_counting) {
      $self->[SELF_COUNT] = int($self->[SELF_COUNT]);
      $self->[SELF_COUNT] ||= 1;
      while ($self->[SELF_COUNT] > 0) {
        if (ref $fn) {
          $self->$fn($key, $raw_key);
        } else {
          &{$defuns->{$fn}}($self, $key, $raw_key);
        }
        $self->[SELF_COUNT]--;
      }
      $self->[SELF_COUNT] = "";
    } else {
      if (ref $fn) {
        $self->$fn($key, $raw_key);
      } else {
        &{$defuns->{$fn}}($self, $key, $raw_key);
      }
    }
    $self->[SELF_LAST] = $fn unless grep { $_ eq $fn } @fns_anon;
  }
  
  # Send a prompt; get a line.
  sub get {
    my ($self, $prompt) = @_;
  
    # Already reading a line here, people.  Sheesh!
    if ($self->[SELF_READING_LINE]) {
      # Let's update the prompt if the user changed it
      if (defined $prompt && $prompt ne $self->[SELF_PROMPT]) {
        $self->_wipe_input_line;
        $self->[SELF_PROMPT] = $prompt;
        $self->_repaint_input_line;
      }
      return;
    }
  
    # recheck the terminal size every prompt, in case the size
    # has changed
    eval { ($trk_cols, $trk_rows) = GetTerminalSize($stdout) };
    ($trk_cols, $trk_rows) = (80, 25) if $@;
  
    ReadMode('ultra-raw');
    # Tell the terminal that we want to be in 'application' mode.
    print $termcap->Tputs('ks' => 1) if $termcap->Tputs('ks');
  
    # Set up for the read.
    $self->[SELF_READING_LINE]   = 1;
    $self->[SELF_PROMPT]         = $prompt if defined $prompt;
    $self->[SELF_INPUT]          = '';
    $self->[SELF_CURSOR_INPUT]   = 0;
    $self->[SELF_CURSOR_DISPLAY] = 0;
    $self->[SELF_HIST_INDEX]     = @{$self->[SELF_HIST_LIST]};
    $self->[SELF_INSERT_MODE]    = 1;
    $self->[SELF_UNDO]           = [];
    $self->[SELF_LAST]           = '';
  
    # Watch the filehandle.  STDIN is made blocking to avoid buffer
    # overruns when put()ing large quantities of data.
    # TODO - Why does it matter to STDOUT whether STDIN is blocking?
    # TODO - Why does AIX require STDIN to be non-blocking?
    $poe_kernel->select($stdin, $self->[SELF_STATE_READ]);
    $stdin->blocking(1) unless $^O eq 'aix';
  
    my $sp = $self->[SELF_PROMPT];
    $sp =~ s{\\[\[\]]}{}g;
  
    print $stdout $sp;
  }
  
  # Write a line on the terminal.
  sub put {
    my $self = shift;
    my @lines = map { $_ . "\x0D\x0A" } @_;
  
    # Write stuff immediately under certain conditions: (1) The wheel is
    # in immediate mode.  (2) The wheel currently isn't reading a line.
    # (3) The wheel is in idle mode, and there.
  
    if (
      $self->[SELF_PUT_MODE] eq 'immediate' or
      !$self->[SELF_READING_LINE] or
      ( $self->[SELF_PUT_MODE] eq 'idle' and !$self->[SELF_HAS_TIMER] )
    ) {
  
      # Only clear the input line if we're reading input already
      $self->_wipe_input_line if ($self->[SELF_READING_LINE]);
  
      # Print the new stuff.
      $self->_flush_output_buffer;
      print $stdout @lines;
  
      # Only repaint the input if we're reading a line.
      $self->_repaint_input_line if ($self->[SELF_READING_LINE]);
  
      return;
    }
  
    # Otherwise buffer stuff.
    push @{$self->[SELF_PUT_BUFFER]}, @lines;
  
    # Set a timer, if timed.
    if ( $self->[SELF_PUT_MODE] eq 'idle' and !$self->[SELF_HAS_TIMER] ) {
      $poe_kernel->delay( $self->[SELF_STATE_IDLE], $self->[SELF_IDLE_TIME] );
      $self->[SELF_HAS_TIMER] = 1;
    }
  }
  
  # Clear the screen.
  sub clear {
    my $self = shift;
    $termcap->Tputs( cl => 1, $stdout );
  }
  
  sub terminal_size {
    return ($trk_cols, $trk_rows);
  }
  
  # Add things to the edit history.
  sub add_history {
    my $self = shift;
    push @{$self->[SELF_HIST_LIST]}, @_;
  }
  
  # RCC 2008-06-15. Backwards compatibility.
  *addhistory = *add_history;
  
  sub get_history {
    my $self = shift;
    return @{$self->[SELF_HIST_LIST]};
  }
  
  # RCC 2008-06-15. Backwards compatibility.
  *GetHistory = *get_history;
  
  sub write_history {
    my ($self, $file) = @_;
    $file ||= "$ENV{HOME}/.history";
    open(HIST, ">$file") || return undef;
    print HIST join("\n", @{$self->[SELF_HIST_LIST]}) . "\n";
    close(HIST);
    return 1;
  }
  
  # RCC 2008-06-15. Backwards compatibility.
  *WriteHistory = *write_history;
  
  sub read_history {
    my ($self, $file, $from, $to) = @_;
    $from ||= 0;
    $to = -1 unless defined $to;
    $file ||= "$ENV{HOME}/.history";
    open(HIST, $file) or return undef;
    my @hist = <HIST>;
    close(HIST);
    my $line = 0;
    foreach my $h (@hist) {
      chomp($h);
      $self->add_history($h) if ($line >= $from && ($to < $from || $line <= $to));
      $line++;
    }
    return 1;
  }
  
  # RCC 2008-06-15. Backwards compatibility.
  *ReadHistory = *read_history;
  
  sub history_truncate_file {
    my ($self, $file, $lines) = @_;
    $lines ||= 0;
    $file ||= "$ENV{HOME}/.history";
    open(HIST, $file) or return undef;
    my @hist = <HIST>;
    close(HIST);
    chomp(@hist);
  
    if ((scalar @hist) > $lines) {
      open(HIST, ">$file") or return undef;
      if ($lines) {
        splice(@hist, 0, (scalar @hist)-$lines);
        @{$self->[SELF_HIST_LIST]} = @hist;
        print HIST "$_\n" foreach @hist;
      } else {
        @{$self->[SELF_HIST_LIST]} = ();
      }
      close(HIST);
    }
    return 1;
  }
  
  # Get the wheel's ID.
  sub ID {
    return $_[0]->[SELF_UNIQUE_ID];
  }
  
  sub attribs {
    my ($self) = @_;
    return $self->[SELF_OPTIONS];
  }
  
  # RCC 2008-06-15. Backwards compatibility.
  *Attribs = *attribs;
  
  sub option {
    my ($self, $arg) = @_;
    $arg = lc($arg);
    return "" unless exists $self->[SELF_OPTIONS]->{$arg};
    return $self->[SELF_OPTIONS]->{$arg};
  }
  
  sub _init_keymap {
    my ($self, $default, @names) = @_;
    my $name = $names[0];
    if (!exists $defuns->{$default}) {
      die("cannot initialise keymap $name, since default function $default is unknown")
    }
    my $map = POE::Wheel::ReadLine::Keymap->init(
      default => $default,
      name    => $name,
      termcap => $termcap
    );
    foreach my $n (@names) {
      $self->[SELF_ALL_KEYMAPS]->{$n} = $map;
    }
    return $map;
  }
  
  sub rl_re_read_init_file {
    my ($self) = @_;
  
    $self->_init_keymap('self-insert', 'emacs');
    $self->_init_keymap('ding', 'vi-command', 'vi');
    $self->_init_keymap('self-insert', 'vi-insert');
  
    # searching
    my $isearch = $self->_init_keymap('search-finish', 'isearch');
    my $vi_search = $self->_init_keymap('search-finish', 'vi-search');
    $self->_parse_inputrc($search_inputrc);
  
    # A keymap to take the VI range specification commands
    # used by the -to commands (e.g. change-to, etc)
    $self->_init_keymap('vi-end-spec', 'vi-specification');
  
    $self->_parse_inputrc($defaults_inputrc);
  
    $self->rl_set_keymap('vi');
    $self->_parse_inputrc($vi_inputrc);
  
    $self->rl_set_keymap('emacs');
    $self->_parse_inputrc($emacs_inputrc);
  
    my $personal = exists $ENV{INPUTRC} ? $ENV{INPUTRC} : "$ENV{HOME}/.inputrc";
    foreach my $file ($personal) {
      my $input = "";
      if (open(IN, $file)) {
        local $/ = undef;
        $input = <IN>;
        close(IN);
        $self->_parse_inputrc($input);
      }
    }
  
    if (!$self->option('editing-mode')) {
      $self->[SELF_OPTIONS]->{'editing-mode'} = 'emacs';
    }
  
    if ($self->option('editing-mode') eq 'vi') {
      # by default, start in insert mode already
      $self->rl_set_keymap('vi-insert');
    }
  
    my $isearch_term = $self->option('isearch-terminators') || 'C-[ C-J';
    foreach my $key (split(/\s+/, $isearch_term)) {
      $isearch->bind_key($key, 'search-abort');
    }
    foreach my $key (ord(' ') .. ord('~')) {
      $isearch->bind_key('"' . chr($key) . '"', 'search-key');
      $vi_search->bind_key('"' . chr($key) . '"', 'vi-search-key');
    }
  }
  
  sub _parse_inputrc {
    my ($self, $input, $depth) = @_;
    $depth ||= 0;
    my @cond = (); # allows us to nest conditionals.
  
    foreach my $line (split(/\n+/, $input)) {
      next if $line =~ /^#/;
      if ($line =~ /^\$(.*)/) {
        my (@parms) = split(/[ \t+=]/,$1);
        if ($parms[0] eq 'if') {
          my $bool = 0;
          if ($parms[1] eq 'mode') {
            if ($self->option('editing-mode') eq $parms[2]) {
              $bool = 1;
            }
          } elsif ($parms[1] eq 'term') {
            my ($half, $full) = ($ENV{TERM} =~ /^([^-]*)(-.*)?$/);
            if ($half eq $parms[2] || ($full && $full eq $parms[2])) {
              $bool = 1;
            }
          } elsif ($parms[1] eq $self->[SELF_APP]) {
            $bool = 1;
          }
          push(@cond, $bool);
        } elsif ($parms[0] eq 'else') {
          $cond[$#cond] = not $cond[$#cond];
        } elsif ($parms[0] eq 'endif') {
          pop(@cond);
        } elsif ($parms[0] eq 'include') {
          if ($depth > 10) {
            print STDERR "WARNING: ignoring ``include $parms[1] directive, since we're too deep''";
          } else {
            my $fh = gensym;
            if (open $fh, "< $parms[1]\0") {
              my $contents = do { local $/; <$fh> };
              close $fh;
              $self->_parse_inputrc($contents, $depth+1);
            }
          }
        }
      } else {
        next if (scalar @cond and not $cond[$#cond]);
        if ($line =~ /^set\s+([\S]+)\s+([\S]+)/) {
          my ($var,$val) = ($1, $2);
          $self->[SELF_OPTIONS]->{lc($var)} = $val;
          my $fn = "rl_set_" . lc($var);
          $fn =~ s{-}{_}g;
          if ($self->can($fn)) {
            $self->$fn($self->[SELF_OPTIONS]->{$var});
          }
        } elsif ($line =~ /^([^:]+):\s*(.*)/) {
          my ($seq, $fn) = ($1, lc($2));
          chomp($fn);
          $self->[SELF_KEYMAP]->bind_key($seq, $fn);
        }
      }
    }
  }
  
  # take a key and output it in a form nice to read...
  sub _dump_key_line {
    my ($self, $key, $raw_key) = @_;
    if (exists $self->[SELF_KEYMAP]->{prefix}->{$raw_key}) {
      $self->[SELF_PENDING_FN] = sub {
        my ($s, $k, $rk) = @_;
        $s->_dump_key_line($key.$k, $raw_key.$rk);
      };
      return;
    }
  
    my $fn = $self->[SELF_KEYMAP]->{default};
    if (exists $self->[SELF_KEYMAP]->{binding}->{$raw_key}) {
      $fn = $self->[SELF_KEYMAP]->{binding}->{$raw_key};
    }
    if (ref $fn) {
      $fn = "[coderef]";
    }
  
    print "\x0D\x0A" . _readable_key($raw_key) . ": " . $fn . "\x0D\x0A";
    $self->_repaint_input_line;
  }
  
  sub bind_key {
    my ($self, $seq, $fn, $map) = @_;
    $map ||= $self->[SELF_KEYMAP];
    $map->bind_key($seq, $fn);
  }
  
  sub add_defun {
    my ($self, $name, $fn) = @_;
    $defuns->{$name} = $fn;
  }
  
  # -----------------------------------------------------
  # Any variable assignments that we care about
  # -----------------------------------------------------
  sub rl_set_keymap {
    my ($self, $arg) = @_;
    $arg = lc($arg);
    if (exists $self->[SELF_ALL_KEYMAPS]->{$arg}) {
      $self->[SELF_KEYMAP] = $self->[SELF_ALL_KEYMAPS]->{$arg};
      $self->[SELF_OPTIONS]->{keymap} = $self->[SELF_KEYMAP]->{name};
    }
    # always reset overstrike mode on keymap change
    $self->[SELF_INSERT_MODE] = 1;
  }
  
  # ----------------------------------------------------
  # From here on, we have the helper functions which can
  # be bound to keys. The functions are named after the
  # readline counterparts.
  # ----------------------------------------------------
  
  sub rl_self_insert {
    my ($self, $key, $raw_key) = @_;
  
    if ($self->[SELF_CURSOR_INPUT] < length($self->[SELF_INPUT])) {
      if ($self->[SELF_INSERT_MODE]) {
        # Insert.
        my $normal = _normalize(substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]));
        substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT], 0) = $raw_key;
        print $stdout $key, $normal;
        $self->[SELF_CURSOR_INPUT] += length($raw_key);
        $self->[SELF_CURSOR_DISPLAY] += length($key);
        _curs_left(length($normal));
      } else {
        # Overstrike.
        my $replaced_width = _display_width(
          substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT], length($raw_key))
        );
        substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT], length($raw_key)) = $raw_key;
  
        print $stdout $key;
        $self->[SELF_CURSOR_INPUT] += length($raw_key);
        $self->[SELF_CURSOR_DISPLAY] += length($key);
  
        # Expand or shrink the display if unequal replacement.
        if (length($key) != $replaced_width) {
          my $rest = _normalize(substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]));
          # Erase trailing screen cruft if it's shorter.
          if (length($key) < $replaced_width) {
            $rest .= ' ' x ($replaced_width - length($key));
          }
          print $stdout $rest;
          _curs_left(length($rest));
        }
      }
    } else {
      # Append.
      print $stdout $key;
      $self->[SELF_INPUT] .= $raw_key;
      $self->[SELF_CURSOR_INPUT] += length($raw_key);
      $self->[SELF_CURSOR_DISPLAY] += length($key);
    }
  }
  
  sub rl_insert_macro {
    my ($self, $key) = @_;
    my $macro = $self->[SELF_KEYMAP]->{macros}->{$key};
    $macro =~ s{\\a}{$tc_bell}g;
    $macro =~ s{\\r}{\r}g;
    $macro =~ s{\\n}{\n}g;
    $macro =~ s{\\t}{\t}g;
    $self->rl_self_insert($macro, $macro);
  }
  
  sub rl_insert_comment {
    my ($self) = @_;
    my $comment = $self->option('comment-begin');
    $self->_wipe_input_line;
    if ($self->[SELF_COUNT]) {
      if (substr($self->[SELF_INPUT], 0, length($comment)) eq $comment) {
        substr($self->[SELF_INPUT], 0, length($comment)) = "";
      } else {
        $self->[SELF_INPUT] = $comment . $self->[SELF_INPUT];
      }
      $self->[SELF_COUNT] = 0;
    } else {
      $self->[SELF_INPUT] = $comment . $self->[SELF_INPUT];
    }
    $self->_repaint_input_line;
    $self->rl_accept_line;
  }
  
  sub rl_revert_line {
    my ($self) = @_;
    return $self->rl_ding unless scalar @{$self->[SELF_UNDO]};
    $self->_wipe_input_line;
    (
      $self->[SELF_INPUT],
      $self->[SELF_CURSOR_INPUT],
      $self->[SELF_CURSOR_DISPLAY]
    ) = @{$self->[SELF_UNDO]->[0]};
    $self->[SELF_UNDO] = [];
    $self->_repaint_input_line;
  }
  
  sub rl_yank_last_arg {
    my ($self) = @_;
    if ($self->[SELF_HIST_INDEX] == 0) {
      return $self->rl_ding;
    }
    if ($self->[SELF_COUNT]) {
      return &rl_yank_nth_arg;
    }
    my $prev = $self->[SELF_HIST_LIST]->[$self->[SELF_HIST_INDEX]-1];
    my ($arg) = ($prev =~ m{(\S+)$});
    $self->rl_self_insert($arg, $arg);
    1;
  }
  
  sub rl_yank_nth_arg {
    my ($self) = @_;
    if ($self->[SELF_HIST_INDEX] == 0) {
      return $self->rl_ding;
    }
    my $prev = $self->[SELF_HIST_LIST]->[$self->[SELF_HIST_INDEX]-1];
    my @args = split(/\s+/, $prev);
    my $pos = $self->[SELF_COUNT] || 1;
    $self->[SELF_COUNT] = 0;
    if ($pos < 0) {
      $pos = (scalar @args) + $pos;
    }
    if ($pos > scalar @args || $pos < 0) {
      return $self->rl_ding;
    }
    $self->rl_self_insert($args[$pos], $args[$pos]);
  }
  
  sub rl_dump_key {
    my ($self) = @_;
    $self->[SELF_PENDING_FN] = sub {
      my ($s,$k,$rk) = @_;
      $s->_dump_key_line($k, $rk);
    };
  }
  
  sub rl_dump_macros {
    my ($self) = @_;
    print $stdout "\x0D\x0A";
    my $c = 0;
    foreach my $macro (keys %{$self->[SELF_KEYMAP]->{macros}}) {
      print $stdout '"' . _normalize($macro) . "\": \"$self->[SELF_KEYMAP]->{macros}->{$macro}\"\x0D\x0A";
      $c++;
    }
    if (!$c) {
      print "# no macros defined\x0D\x0A";
    }
    $self->_repaint_input_line;
  }
  
  sub rl_dump_variables {
    my ($self) = @_;
    print $stdout "\x0D\x0A";
    my $c = 0;
    foreach my $var (keys %{$self->[SELF_OPTIONS]}) {
      print $stdout "set $var $self->[SELF_OPTIONS]->{$var}\x0D\x0A";
      $c++;
    }
    if (!$c) {
      print "# no variables defined\x0D\x0A";
    }
    $self->_repaint_input_line;
  }
  
  sub rl_set_mark {
    my ($self) = @_;
    if ($self->[SELF_COUNT]) {
      $self->[SELF_MARK] = $self->[SELF_COUNT];
    } else {
      $self->[SELF_MARK] = $self->[SELF_CURSOR_INPUT];
    }
    $self->[SELF_COUNT] = 0;
  }
  
  sub rl_digit_argument {
    my ($self, $key) = @_;
    $self->[SELF_COUNT] .= $key;
  }
  
  sub rl_beginning_of_line {
    my ($self, $key) = @_;
    if ($self->[SELF_CURSOR_INPUT]) {
      _curs_left($self->[SELF_CURSOR_DISPLAY]);
      $self->[SELF_CURSOR_DISPLAY] = $self->[SELF_CURSOR_INPUT] = 0;
    }
  }
  
  sub rl_end_of_line {
    my ($self, $key) = @_;
    my $max = length($self->[SELF_INPUT]);
    $max-- if ($self->[SELF_KEYMAP]->{name} =~ /vi/);
    if ($self->[SELF_CURSOR_INPUT] < $max) {
      my $right_string = substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]);
      print _normalize($right_string);
      my $right = _display_width($right_string);
      if ($self->[SELF_KEYMAP]->{name} =~ /vi/) {
        $self->[SELF_CURSOR_DISPLAY] += $right - 1;
        $self->[SELF_CURSOR_INPUT] = length($self->[SELF_INPUT]) - 1;
        _curs_left(1);
      } else {
        $self->[SELF_CURSOR_DISPLAY] += $right;
        $self->[SELF_CURSOR_INPUT] = length($self->[SELF_INPUT]);
      }
    }
  }
  
  sub rl_backward_char {
    my ($self, $key) = @_;
    if ($self->[SELF_CURSOR_INPUT]) {
      $self->[SELF_CURSOR_INPUT]--;
      my $left = _display_width(substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT], 1));
      _curs_left($left);
      $self->[SELF_CURSOR_DISPLAY] -= $left;
    }
    else {
      $self->rl_ding;
    }
  }
  
  sub rl_forward_char {
    my ($self, $key) = @_;
    my $max = length($self->[SELF_INPUT]);
    $max-- if ($self->[SELF_KEYMAP]->{name} =~ /vi/);
    if ($self->[SELF_CURSOR_INPUT] < $max) {
      my $normal = _normalize(substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT], 1));
      print $stdout $normal;
      $self->[SELF_CURSOR_INPUT]++;
      $self->[SELF_CURSOR_DISPLAY] += length($normal);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_forward_word {
    my ($self, $key) = @_;
    if (substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]) =~ /^(\W*\w+)/) {
      $self->[SELF_CURSOR_INPUT] += length($1);
      my $right = _display_width($1);
      print _normalize($1);
      $self->[SELF_CURSOR_DISPLAY] += $right;
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_backward_word {
    my ($self, $key) = @_;
    if (substr($self->[SELF_INPUT], 0, $self->[SELF_CURSOR_INPUT]) =~ /(\w+\W*)$/) {
      $self->[SELF_CURSOR_INPUT] -= length($1);
      my $left = _display_width($1);
      _curs_left($left);
      $self->[SELF_CURSOR_DISPLAY] -= $left;
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_backward_kill_word {
    my ($self) = @_;
    if ($self->[SELF_CURSOR_INPUT]) {
      substr($self->[SELF_INPUT], 0, $self->[SELF_CURSOR_INPUT]) =~ /(\w*\W*)$/;
      my $kill = $self->_delete_chars($self->[SELF_CURSOR_INPUT] - length($1), length($1));
      push(@{$self->[SELF_KILL_RING]}, $kill);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_kill_region {
    my ($self) = @_;
    my $kill = $self->_delete_chars($self->[SELF_CURSOR_INPUT], $self->[SELF_CURSOR_INPUT] - $self->[SELF_MARK]);
    push(@{$self->[SELF_KILL_RING]}, $kill);
  }
  
  sub rl_kill_word {
    my ($self, $key) = @_;
    if ($self->[SELF_CURSOR_INPUT] < length($self->[SELF_INPUT])) {
      substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]) =~ /^(\W*\w*\W*)/;
      my $kill = $self->_delete_chars($self->[SELF_CURSOR_INPUT], length($1));
      push(@{$self->[SELF_KILL_RING]}, $kill);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_kill_line {
    my ($self, $key) = @_;
    if ($self->[SELF_CURSOR_INPUT] < length($self->[SELF_INPUT])) {
      my $kill = $self->_delete_chars($self->[SELF_CURSOR_INPUT], length($self->[SELF_INPUT]) - $self->[SELF_CURSOR_INPUT]);
      push(@{$self->[SELF_KILL_RING]}, $kill);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_unix_word_rubout {
    my ($self, $key) = @_;
    if ($self->[SELF_CURSOR_INPUT]) {
      substr($self->[SELF_INPUT], 0, $self->[SELF_CURSOR_INPUT]) =~ /(\S*\s*)$/;
      my $kill = $self->_delete_chars($self->[SELF_CURSOR_INPUT] - length($1), length($1));
      push(@{$self->[SELF_KILL_RING]}, $kill);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_delete_horizontal_space {
    my ($self) = @_;
    substr($self->[SELF_INPUT], 0, $self->[SELF_CURSOR_INPUT]) =~ /(\s*)$/;
    my $left = length($1);
    substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]) =~ /^(\s*)/;
    my $right = length($1);
  
    if ($left + $right) {
      $self->_delete_chars($self->[SELF_CURSOR_INPUT] - $left, $left + $right);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_copy_region_as_kill {
    my ($self) = @_;
    my $from = $self->[SELF_CURSOR_INPUT];
    my $howmany = $self->[SELF_CURSOR_INPUT] - $self->[SELF_MARK];
    if ($howmany < 0) {
      $from -= $howmany;
      $howmany = -$howmany;
      if ($from < 0) {
        $howmany -= $from;
        $from = 0;
      }
    }
    my $old = substr($self->[SELF_INPUT], $from, $howmany);
    push(@{$self->[SELF_KILL_RING]}, $old);
  }
  
  sub rl_abort {
    my ($self, $key) = @_;
    print $stdout uc($key), "\x0D\x0A";
    $poe_kernel->select_read($stdin);
    if ($self->[SELF_HAS_TIMER]) {
      $poe_kernel->delay( $self->[SELF_STATE_IDLE] );
      $self->[SELF_HAS_TIMER] = 0;
    }
    $poe_kernel->yield(
      $self->[SELF_EVENT_INPUT],
      undef, 'cancel', $self->[SELF_UNIQUE_ID]
    );
    $self->[SELF_READING_LINE] = 0;
    $self->[SELF_HIST_INDEX] = @{$self->[SELF_HIST_LIST]};
    $self->_flush_output_buffer;
  }
  
  sub rl_interrupt {
    my ($self, $key) = @_;
    print $stdout uc($key), "\x0D\x0A";
    $poe_kernel->select_read($stdin);
    if ($self->[SELF_HAS_TIMER]) {
      $poe_kernel->delay( $self->[SELF_STATE_IDLE] );
      $self->[SELF_HAS_TIMER] = 0;
    }
    $poe_kernel->yield( $self->[SELF_EVENT_INPUT], undef, 'interrupt', $self->[SELF_UNIQUE_ID] );
    $self->[SELF_READING_LINE] = 0;
    $self->[SELF_HIST_INDEX] = @{$self->[SELF_HIST_LIST]};
  
    $self->_flush_output_buffer;
  }
  
  # Delete a character.  On an empty line, it throws an
  # "eot" exception, just like Term::ReadLine does.
  sub rl_delete_char {
    my ($self, $key) = @_;
    if (length $self->[SELF_INPUT] == 0) {
      print $stdout uc($key), "\x0D\x0A";
      $poe_kernel->select_read($stdin);
      if ($self->[SELF_HAS_TIMER]) {
        $poe_kernel->delay( $self->[SELF_STATE_IDLE] );
        $self->[SELF_HAS_TIMER] = 0;
      }
      $poe_kernel->yield(
        $self->[SELF_EVENT_INPUT],
        undef, "eot", $self->[SELF_UNIQUE_ID]
      );
      $self->[SELF_READING_LINE] = 0;
      $self->[SELF_HIST_INDEX] = @{$self->[SELF_HIST_LIST]};
  
      $self->_flush_output_buffer;
      return;
    }
  
    if ($self->[SELF_CURSOR_INPUT] < length($self->[SELF_INPUT])) {
      $self->_delete_chars($self->[SELF_CURSOR_INPUT], 1);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_backward_delete_char {
    my ($self, $key) = @_;
    if ($self->[SELF_CURSOR_INPUT]) {
      $self->_delete_chars($self->[SELF_CURSOR_INPUT]-1, 1);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_accept_line {
    my ($self, $key) = @_;
    if ($self->[SELF_CURSOR_INPUT] < length($self->[SELF_INPUT])) {
      my $right_string = substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]);
      print _normalize($right_string);
      my $right = _display_width($right_string);
      $self->[SELF_CURSOR_DISPLAY] += $right;
      $self->[SELF_CURSOR_INPUT] = length($self->[SELF_INPUT]);
    }
    # home the cursor.
    $self->[SELF_CURSOR_DISPLAY] = 0;
    $self->[SELF_CURSOR_INPUT] = 0;
    print $stdout "\x0D\x0A";
    $poe_kernel->select_read($stdin);
    if ($self->[SELF_HAS_TIMER]) {
      $poe_kernel->delay( $self->[SELF_STATE_IDLE] );
      $self->[SELF_HAS_TIMER] = 0;
    }
    $poe_kernel->yield( $self->[SELF_EVENT_INPUT], $self->[SELF_INPUT], $self->[SELF_UNIQUE_ID] );
    $self->[SELF_READING_LINE] = 0;
    $self->[SELF_HIST_INDEX] = @{$self->[SELF_HIST_LIST]};
    $self->_flush_output_buffer;
    ReadMode('restore');
    eval { ($trk_cols, $trk_rows) = GetTerminalSize($stdout) };
    ($trk_cols, $trk_rows) = (80, 25) if $@;
    if ($self->[SELF_KEYMAP]->{name} =~ /vi/) {
      $self->rl_set_keymap('vi-insert');
    }
  }
  
  sub rl_clear_screen {
    my ($self, $key) = @_;
    my $left = _display_width(substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]));
    $termcap->Tputs( 'cl', 1, $stdout );
    my $sp = $self->[SELF_PROMPT];
    $sp =~ s{\\[\[\]]}{}g;
    print $stdout $sp, _normalize($self->[SELF_INPUT]);
    _curs_left($left) if $left;
  }
  
  sub rl_transpose_chars {
    my ($self, $key) = @_;
    if (length($self->[SELF_INPUT]) > 1 && length($self->[SELF_INPUT]) == $self->[SELF_CURSOR_INPUT]) {
      my $transposition = reverse substr($self->[SELF_INPUT], -2, 2);
      substr($self->[SELF_INPUT], -2, 2) = $transposition;
      _curs_left(_display_width($transposition));
      print $stdout _normalize($transposition);
    } elsif (length($self->[SELF_INPUT]) > 1 && $self->[SELF_CURSOR_INPUT] > 0) {
      my $width_left = _display_width(substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT] - 1, 1));
  
      my $transposition = reverse substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT] - 1, 2);
      substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT] - 1, 2) = $transposition;
  
      _curs_left($width_left);
      print $stdout _normalize($transposition);
      _curs_left($width_left);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_transpose_words {
    my ($self, $key) = @_;
  
    my $cursor_sub_one = $self->[SELF_CURSOR_INPUT] - 1;
    if ($self->[SELF_INPUT] =~ s/^(.{0,$cursor_sub_one})(?<!\S)(\S+)(\s+)(\S+)/$1$4$3$2/) {
      $termcap->Tgoto('LE', 1, $self->[SELF_CURSOR_DISPLAY] - _display_width($1), $stdout);
      print $stdout _normalize($4 . $3 . $2);
      $self->[SELF_CURSOR_INPUT] = length($1 . $2 . $3 . $4);
      $self->[SELF_CURSOR_DISPLAY] = _display_width($1 . $2 . $3 . $4);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_unix_line_discard {
    my ($self, $key) = @_;
    if (length $self->[SELF_INPUT]) {
      my $kill = $self->_delete_chars(0, $self->[SELF_CURSOR_INPUT]);
      push(@{$self->[SELF_KILL_RING]}, $kill);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_kill_whole_line {
    my ($self, $key) = @_;
    if (length $self->[SELF_INPUT]) {
      # Back up to the beginning of the line.
      if ($self->[SELF_CURSOR_INPUT]) {
        _curs_left($self->[SELF_CURSOR_DISPLAY]);
        $self->[SELF_CURSOR_DISPLAY] = $self->[SELF_CURSOR_INPUT] = 0;
      }
      $self->_clear_to_end;
  
      # Clear the input buffer.
      push(@{$self->[SELF_KILL_RING]}, $self->[SELF_INPUT]);
      $self->[SELF_INPUT] = '';
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_yank {
    my ($self) = @_;
    my $pos = scalar @{$self->[SELF_KILL_RING]};
    return $self->rl_ding unless ($pos);
  
    $pos--;
    $self->rl_self_insert($self->[SELF_KILL_RING]->[$pos], $self->[SELF_KILL_RING]->[$pos]);
  }
  
  sub rl_yank_pop {
    my ($self) = @_;
    return $self->rl_ding unless ($self->[SELF_LAST] =~ /yank/);
    my $pos = scalar @{$self->[SELF_KILL_RING]};
    return $self->rl_ding unless ($pos);
  
    my $top = pop @{$self->[SELF_KILL_RING]};
    unshift(@{$self->[SELF_KILL_RING]}, $top);
    $self->rl_yank;
  }
  
  sub rl_previous_history {
    my ($self, $key) = @_;
    if ($self->[SELF_HIST_INDEX]) {
      # Moving away from a new input line; save it in case
      # we return.
      if ($self->[SELF_HIST_INDEX] == @{$self->[SELF_HIST_LIST]}) {
          $self->[SELF_INPUT_HOLD] = $self->[SELF_INPUT];
      }
  
      # Move cursor to start of input.
      if ($self->[SELF_CURSOR_INPUT]) {
          _curs_left($self->[SELF_CURSOR_DISPLAY]);
      }
      $self->_clear_to_end;
  
      # Move the history cursor back, set the new input
      # buffer, and show what the user's editing.  Set the
      # cursor to the end of the new line.
      my $normal;
      print $stdout $normal = _normalize($self->[SELF_INPUT] = $self->[SELF_HIST_LIST]->[--$self->[SELF_HIST_INDEX]]);
      $self->[SELF_UNDO] = [ [ $self->[SELF_INPUT], 0, 0 ] ]; # reset undo info
      $self->[SELF_CURSOR_INPUT] = length($self->[SELF_INPUT]);
      $self->[SELF_CURSOR_DISPLAY] = length($normal);
      $self->rl_backward_char if (length($self->[SELF_INPUT]) && $self->[SELF_KEYMAP]->{name} =~ /vi/);
    } else {
      # At top of history list.
      $self->rl_ding;
    }
  }
  
  sub rl_next_history {
    my ($self, $key) = @_;
    if ($self->[SELF_HIST_INDEX] < @{$self->[SELF_HIST_LIST]}) {
      # Move cursor to start of input.
      if ($self->[SELF_CURSOR_INPUT]) {
        _curs_left($self->[SELF_CURSOR_DISPLAY]);
      }
      $self->_clear_to_end;
  
      my $normal;
      if (++$self->[SELF_HIST_INDEX] == @{$self->[SELF_HIST_LIST]}) {
        # Just past the end of the history.  Whatever was
        # there when we left it.
        print $stdout $normal = _normalize($self->[SELF_INPUT] = $self->[SELF_INPUT_HOLD]);
      } else {
        # There's something in the history list.  Make that
        # the current line.
        print $stdout $normal = _normalize($self->[SELF_INPUT] = $self->[SELF_HIST_LIST]->[$self->[SELF_HIST_INDEX]]);
      }
  
      $self->[SELF_UNDO] = [ [ $self->[SELF_INPUT], 0, 0 ] ]; # reset undo info
      $self->[SELF_CURSOR_INPUT] = length($self->[SELF_INPUT]);
      $self->[SELF_CURSOR_DISPLAY] = length($normal);
      $self->rl_backward_char if (length($self->[SELF_INPUT]) && $self->[SELF_KEYMAP]->{name} =~ /vi/);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_beginning_of_history {
    my ($self) = @_;
    # First in history.
    if ($self->[SELF_HIST_INDEX]) {
      # Moving away from a new input line; save it in case
      # we return.
      if ($self->[SELF_HIST_INDEX] == @{$self->[SELF_HIST_LIST]}) {
        $self->[SELF_INPUT_HOLD] = $self->[SELF_INPUT];
      }
  
      # Move cursor to start of input.
      if ($self->[SELF_CURSOR_INPUT]) {
        _curs_left($self->[SELF_CURSOR_DISPLAY]);
      }
      $self->_clear_to_end;
  
      # Move the history cursor back, set the new input
      # buffer, and show what the user's editing.  Set the
      # cursor to the end of the new line.
      print $stdout my $normal =
        _normalize($self->[SELF_INPUT] = $self->[SELF_HIST_LIST]->[$self->[SELF_HIST_INDEX] = 0]);
      $self->[SELF_CURSOR_INPUT] = length($self->[SELF_INPUT]);
      $self->[SELF_CURSOR_DISPLAY] = length($normal);
      $self->[SELF_UNDO] = [ [ $self->[SELF_INPUT], 0, 0 ] ]; # reset undo info
    } else {
      # At top of history list.
      $self->rl_ding;
    }
  }
  
  sub rl_end_of_history {
    my ($self) = @_;
    if ($self->[SELF_HIST_INDEX] != @{$self->[SELF_HIST_LIST]} - 1) {
  
      # Moving away from a new input line; save it in case
      # we return.
      if ($self->[SELF_HIST_INDEX] == @{$self->[SELF_HIST_LIST]}) {
        $self->[SELF_INPUT_HOLD] = $self->[SELF_INPUT];
      }
  
      # Move cursor to start of input.
      if ($self->[SELF_CURSOR_INPUT]) {
        _curs_left($self->[SELF_CURSOR_DISPLAY]);
      }
      $self->_clear_to_end;
  
      # Move the edit line down to the last history line.
      $self->[SELF_HIST_INDEX] = @{$self->[SELF_HIST_LIST]} - 1;
      print $stdout my $normal = _normalize($self->[SELF_INPUT] = $self->[SELF_HIST_LIST]->[$self->[SELF_HIST_INDEX]]);
      $self->[SELF_CURSOR_INPUT] = length($self->[SELF_INPUT]);
      $self->[SELF_CURSOR_DISPLAY] = length($normal);
      $self->[SELF_UNDO] = [ [ $self->[SELF_INPUT], 0, 0 ] ]; # reset undo info
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_forward_search_history {
    my ($self, $key) = @_;
    $self->_wipe_input_line;
    $self->[SELF_PREV_PROMPT] = $self->[SELF_PROMPT];
    $self->[SELF_SEARCH_PROMPT] = '(forward-i-search)`%s\': ';
    $self->[SELF_SEARCH_MAP] = $self->[SELF_KEYMAP];
    $self->[SELF_SEARCH_DIR] = +1;
    $self->[SELF_SEARCH_KEY] = $key;
    $self->_build_search_prompt;
    $self->_repaint_input_line;
    $self->rl_set_keymap('isearch');
  }
  
  sub rl_reverse_search_history {
    my ($self, $key) = @_;
    $self->_wipe_input_line;
    $self->[SELF_PREV_PROMPT] = $self->[SELF_PROMPT];
    $self->[SELF_SEARCH_PROMPT] = '(reverse-i-search)`%s\': ';
    $self->[SELF_SEARCH_MAP] = $self->[SELF_KEYMAP];
    $self->[SELF_SEARCH_DIR] = -1;
    $self->[SELF_SEARCH_KEY] = $key;
    # start at the previous line...
    $self->[SELF_HIST_INDEX]-- if $self->[SELF_HIST_INDEX];
    $self->_build_search_prompt;
    $self->_repaint_input_line;
    $self->rl_set_keymap('isearch');
  }
  
  sub rl_capitalize_word {
    my ($self, $key) = @_;
    # Capitalize from cursor on.
    if (substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]) =~ /^(\s*)(\S+)/) {
      # Track leading space, and uppercase word.
      my $space = $1; $space = '' unless defined $space;
      my $word  = ucfirst(lc($2));
  
      # Replace text with the uppercase version.
      substr(
        $self->[SELF_INPUT],
        $self->[SELF_CURSOR_INPUT] + length($space),
        length($word)
      ) = $word;
  
      # Display the new text; move the cursor after it.
      print $stdout $space, _normalize($word);
      $self->[SELF_CURSOR_INPUT] += length($space . $word);
      $self->[SELF_CURSOR_DISPLAY] += length($space) + _display_width($word);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_upcase_word {
    my ($self, $key) = @_;
    # Uppercase from cursor on.
    # Modeled after capitalize.
    if (substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]) =~ /^(\s*)(\S+)/) {
      my $space = $1; $space = '' unless defined $space;
      my $word  = uc($2);
      substr(
        $self->[SELF_INPUT],
        $self->[SELF_CURSOR_INPUT] + length($space),
        length($word)
      ) = $word;
      print $stdout $space, _normalize($word);
      $self->[SELF_CURSOR_INPUT] += length($space . $word);
      $self->[SELF_CURSOR_DISPLAY] += length($space) + _display_width($word);
    } else {
      $self->rl_ding;
    }
  }
  
  
  sub rl_downcase_word {
    my ($self, $key) = @_;
    # Lowercase from cursor on.
    # Modeled after capitalize.
    if (substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]) =~ /^(\s*)(\S+)/) {
      my $space = $1; $space = '' unless defined $space;
      my $word  = lc($2);
      substr(
        $self->[SELF_INPUT],
        $self->[SELF_CURSOR_INPUT] + length($space),
        length($word)
      ) = $word;
      print $stdout $space, _normalize($word);
      $self->[SELF_CURSOR_INPUT] += length($space . $word);
      $self->[SELF_CURSOR_DISPLAY] += length($space) + _display_width($word);
    } else {
      $self->rl_ding;
    }
  }
  
  sub rl_quoted_insert {
    my ($self, $key) = @_;
    $self->[SELF_PENDING_FN] = sub {
      my ($s,$k,$rk) = @_;
      $s->rl_self_insert($k, $rk);
    };
  }
  
  sub rl_overwrite_mode {
    my ($self, $key) = @_;
    $self->[SELF_INSERT_MODE] = !$self->[SELF_INSERT_MODE];
    if ($self->[SELF_COUNT]) {
      if ($self->[SELF_COUNT] > 0) {
        $self->[SELF_INSERT_MODE] = 0;
      } else {
        $self->[SELF_INSERT_MODE] = 1;
      }
    }
  }
  
  sub rl_vi_replace {
    my ($self) = @_;
    $self->rl_vi_insertion_mode;
    $self->rl_overwrite_mode;
  }
  
  sub rl_tilde_expand {
    my ($self) = @_;
    my $pre = substr($self->[SELF_INPUT], 0, $self->[SELF_CURSOR_INPUT]);
    my ($append) = (substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]) =~ /^(\w+)/);
    my ($left,$user) = ("$pre$append" =~  /^(.*)~(\S+)$/);
    if ($user) {
      my $dir = (getpwnam($user))[7];
      if (!$dir) {
        print "\x0D\x0Ausername '$user' not found\x0D\x0A";
        $self->_repaint_input_line;
        return $self->rl_ding;
      }
      $self->_wipe_input_line;
      substr($self->[SELF_INPUT], length($left), length($user) + 1) = $dir; # +1 for tilde
      $self->[SELF_CURSOR_INPUT] += length($dir) - length($user) - 1;
      $self->[SELF_CURSOR_DISPLAY] += length($dir) - length($user) - 1;
      $self->_repaint_input_line;
      return 1;
    } else {
      return $self->rl_ding;
    }
  }
  
  sub _complete_match {
    my ($self) = @_;
    my $lookfor = substr($self->[SELF_INPUT], 0, $self->[SELF_CURSOR_INPUT]);
    $lookfor =~ /(\S+)$/;
    $lookfor = defined($1) ? $1 : "";
    my $point = $self->[SELF_CURSOR_INPUT] - length($lookfor);
  
    my @clist = ();
    if ($self->option("completion_function")) {
      my $fn = $self->[SELF_OPTIONS]->{completion_function};
      @clist = &$fn($lookfor, $self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]);
    }
    my @poss = @clist;
    if ($lookfor) {
      my $l = length $lookfor;
      @poss = grep { substr($_, 0, $l) eq $lookfor } @clist;
    }
  
    return @poss;
  }
  
  sub _complete_list {
    my ($self, @poss) = @_;
    my $width = 0;
    if ($self->option('print-completions-horizontally') eq 'on') {
      map { $width = (length($_) > $width) ? length($_) : $width } @poss;
      my $cols = int($trk_cols / $width);
      $cols = int($trk_cols / ($width+$cols)); # ensure enough room for spaces
      $width = int($trk_cols / $cols);
  
      print $stdout "\x0D\x0A";
      my $c = 0;
      foreach my $word (@poss) {
        print $stdout $word . (" " x ($width - length($word)));
        if (++$c == $cols) {
          print $stdout "\x0D\x0A";
          $c = 0;
        }
      }
      print "\x0D\x0A" if $c;
    } else {
      print "\x0D\x0A";
      foreach my $word (@poss) {
        print $stdout $word . "\x0D\x0A";
      }
    }
    $self->_repaint_input_line;
  }
  
  sub rl_possible_completions {
    my ($self, $key) = @_;
  
    my @poss = $self->_complete_match;
    if (scalar @poss == 0) {
      return $self->rl_ding;
    }
    $self->_complete_list(@poss);
  }
  
  sub rl_complete {
    my ($self, $key) = @_;
  
    my $lookfor = substr($self->[SELF_INPUT], 0, $self->[SELF_CURSOR_INPUT]);
    $lookfor =~ /(\S+)$/;
    $lookfor = defined($1) ? $1 : "";
    my $point = $self->[SELF_CURSOR_INPUT] - length($lookfor);
    my @poss = $self->_complete_match;
    if (scalar @poss == 0) {
      return $self->rl_ding;
    }
  
    if (scalar @poss == 1) {
      substr($self->[SELF_INPUT], $point, $self->[SELF_CURSOR_INPUT]) = $poss[0];
      my $rest = substr($self->[SELF_INPUT], $point+length($lookfor));
      print $stdout $rest;
      _curs_left(length($rest)-length($poss[0]));
      $self->[SELF_CURSOR_INPUT] += length($poss[0])-length($lookfor);
      $self->[SELF_CURSOR_DISPLAY] += length($poss[0])-length($lookfor);
      return 1;
    }
  
    # so at this point, we have multiple possibilities
    # find out how much more is in common with the possibilities.
    my $max = length($lookfor);
    while (1) {
      my $letter = undef;
      my $ok = 1;
      foreach my $p (@poss) {
        if ((length $p) < $max) {
          $ok = 0;
          last;
        }
        if (!$letter) {
          $letter = substr($p, $max, 1);
          next;
        }
        if (substr($p, $max, 1) ne $letter) {
          $ok = 0;
          last;
        }
      }
      if ($ok) {
        $max++;
      } else {
        last;
      }
    }
    if ($max > length($lookfor)) {
      my $partial = substr($poss[0], 0, $max);
      substr($self->[SELF_INPUT], $point, $self->[SELF_CURSOR_INPUT]) = $partial;
      my $rest = substr($self->[SELF_INPUT], $point+length($lookfor));
      print $stdout $rest;
      _curs_left(length($rest)-length($partial));
      $self->[SELF_CURSOR_INPUT]   += length($partial)-length($lookfor);
      $self->[SELF_CURSOR_DISPLAY] += length($partial)-length($lookfor);
      return $self->rl_ding if @poss == 1;
    }
  
    if ($self->[SELF_LAST] !~ /complete/ && !$self->option('show-all-if-ambiguous')) {
      return $self->rl_ding;
    }
    $self->_complete_list(@poss);
    return 0;
  }
  
  sub rl_insert_completions {
    my ($self) = @_;
    my @poss = $self->_complete_match;
    if (scalar @poss == 0) {
      return $self->rl_ding;
    }
    # need to back up the current text
    my $lookfor = substr($self->[SELF_INPUT], 0, $self->[SELF_CURSOR_INPUT]);
    $lookfor =~ /(\S+)$/;
    $lookfor = $1;
    my $point = length($lookfor);
    while ($point--) {
      $self->rl_backward_delete_char;
    }
    my $text = join(" ", @poss);
    $self->rl_self_insert($text, $text);
  }
  
  sub rl_ding {
    my ($self) = @_;
    if (!$self->option('bell-style') || $self->option('bell-style') eq 'audible') {
      print $stdout $tc_bell;
    } elsif ($self->option('bell-style') eq 'visible') {
      print $stdout $tc_visual_bell;
    }
    return 0;
  }
  
  sub rl_redraw_current_line {
    my ($self) = @_;
    $self->_wipe_input_line;
    $self->_repaint_input_line;
  }
  
  sub rl_poe_wheel_debug {
    my ($self, $key) = @_;
    my $left = _display_width(substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]));
    my $sp = $self->[SELF_PROMPT];
    $sp =~ s{\\[\[\]]}{}g;
    print( $stdout
     "\x0D\x0A",
     "ID=$self->[SELF_UNIQUE_ID] ",
     "cursor_input($self->[SELF_CURSOR_INPUT]) ",
     "cursor_display($self->[SELF_CURSOR_DISPLAY]) ",
     "term_columns($trk_cols)\x0D\x0A",
     $sp, _normalize($self->[SELF_INPUT])
    );
    _curs_left($left) if $left;
  }
  
  sub rl_vi_movement_mode {
    my ($self) = @_;
    $self->rl_set_keymap('vi');
    $self->rl_backward_char if ($self->[SELF_INPUT]);
  }
  
  sub rl_vi_append_mode {
    my ($self) = @_;
    if ($self->[SELF_CURSOR_INPUT] < length($self->[SELF_INPUT])) {
      # we can't just call forward-char, coz we don't want bell to ring.
      my $normal = _normalize(substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT], 1));
      print $stdout $normal;
      $self->[SELF_CURSOR_INPUT]++;
      $self->[SELF_CURSOR_DISPLAY] += length($normal);
    }
    $self->rl_set_keymap('vi-insert');
  }
  
  sub rl_vi_append_eol {
    my ($self) = @_;
    $self->rl_end_of_line;
    $self->rl_vi_append_mode;
  }
  
  sub rl_vi_insertion_mode {
    my ($self) = @_;
    $self->rl_set_keymap('vi-insert');
  }
  
  sub rl_vi_insert_beg {
    my ($self) = @_;
    $self->rl_beginning_of_line;
    $self->rl_vi_insertion_mode;
  }
  
  sub rl_vi_editing_mode {
    my ($self) = @_;
    $self->rl_set_keymap('vi');
  }
  
  sub rl_emacs_editing_mode {
    my ($self) = @_;
    $self->rl_set_keymap('emacs');
  }
  
  sub rl_vi_eof_maybe {
    my ($self, $key) = @_;
    if (length $self->[SELF_INPUT] == 0) {
      print $stdout uc($key), "\x0D\x0A";
      $poe_kernel->select_read($stdin);
      if ($self->[SELF_HAS_TIMER]) {
        $poe_kernel->delay( $self->[SELF_STATE_IDLE] );
        $self->[SELF_HAS_TIMER] = 0;
      }
      $poe_kernel->yield(
        $self->[SELF_EVENT_INPUT],
        undef, "eot", $self->[SELF_UNIQUE_ID]
      );
      $self->[SELF_READING_LINE] = 0;
      $self->[SELF_HIST_INDEX] = @{$self->[SELF_HIST_LIST]};
  
      $self->_flush_output_buffer;
      return 0;
    } else {
      return $self->rl_ding;
    }
  }
  
  sub rl_vi_change_case {
    my ($self) = @_;
    my $char = substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT], 1);
    if ($char lt 'a') {
      substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT], 1) = lc($char);
    } else {
      substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT], 1) = uc($char);
    }
    $self->rl_forward_char;
  }
  
  sub rl_vi_prev_word {
    &rl_backward_word;
  }
  
  sub rl_vi_next_word {
    my ($self, $key) = @_;
    if (substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]) =~ /^(\s*\S+\s)/) {
      $self->[SELF_CURSOR_INPUT] += length($1);
      my $right = _display_width($1);
      print _normalize($1);
      $self->[SELF_CURSOR_DISPLAY] += $right;
    } else {
      return $self->rl_ding;
    }
  }
  
  sub rl_vi_end_word {
    my ($self, $key) = @_;
    if ($self->[SELF_CURSOR_INPUT] < length($self->[SELF_INPUT])) {
      $self->rl_forward_char;
      if (substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]) =~ /^(\s*\S+)/) {
        $self->[SELF_CURSOR_INPUT] += length($1)-1;
        my $right = _display_width($1);
        print _normalize($1);
        $self->[SELF_CURSOR_DISPLAY] += $right-1;
        _curs_left(1);
      }
    } else {
      return $self->rl_ding;
    }
  }
  
  sub rl_vi_column {
    my ($self) = @_;
    $self->[SELF_COUNT] ||= 0;
    $self->rl_beginning_of_line;
    while ($self->[SELF_COUNT]--) {
      $self->rl_forward_char;
    }
    $self->[SELF_COUNT] = 0;
  }
  
  sub rl_vi_match {
    my ($self) = @_;
    return $self->rl_ding unless $self->[SELF_INPUT];
    # what paren are we after? look forwards down the line for the closest
    my $pos = $self->[SELF_CURSOR_INPUT];
    my $where = substr($self->[SELF_INPUT], $pos);
    my ($adrift) = ($where =~ m/([^\(\)\{\}\[\]]*)/);
    my $paren = substr($where, length($adrift), 1);
    $pos += length($adrift);
  
    return $self->rl_ding unless $paren;
    my $what_to_do = {
      '(' => [ ')', 1 ],
      '{' => [ '}', 1 ],
      '[' => [ ']', 1 ],
      ')' => [ '(', -1 ],
      '}' => [ '{', -1 ],
      ']' => [ '[', -1 ],
    }->{$paren};
    my($opp,$dir) = @{$what_to_do};
    my $level = 1;
    while ($level) {
      if ($dir > 0) {
        return $self->rl_ding if ($pos == length($self->[SELF_INPUT]));
        $pos++;
      } else {
        return $self->rl_ding unless $pos;
        $pos--;
      }
      my $c = substr($self->[SELF_INPUT], $pos, 1);
      if ($c eq $opp) {
        $level--;
      } elsif ($c eq $paren) {
        $level++
      }
    }
    $self->[SELF_COUNT] = $pos;
    $self->rl_vi_column;
    return 1;
  }
  
  sub rl_vi_first_print {
    my ($self) = @_;
    $self->rl_beginning_of_line;
    substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]) =~ /^(\s*)/;
    if (length($1)) {
      $self->[SELF_CURSOR_INPUT] += length($1);
      my $right = _display_width($1);
      print _normalize($1);
      $self->[SELF_CURSOR_DISPLAY] += $right;
    }
  }
  
  sub rl_vi_delete {
    my ($self) = @_;
    if ($self->[SELF_CURSOR_INPUT] < length($self->[SELF_INPUT])) {
      $self->_delete_chars($self->[SELF_CURSOR_INPUT], 1);
      if ($self->[SELF_INPUT] && $self->[SELF_CURSOR_INPUT] >= length($self->[SELF_INPUT])) {
        $self->[SELF_CURSOR_INPUT]--;
        $self->[SELF_CURSOR_DISPLAY]--;
        _curs_left(1);
      }
    } else {
      return $self->rl_ding;
    }
  }
  
  sub rl_vi_put {
    my ($self, $key) = @_;
    my $pos = scalar @{$self->[SELF_KILL_RING]};
    return $self->rl_ding unless ($pos);
    $pos--;
    if ($self->[SELF_INPUT] && $key eq 'p') {
      my $normal = _normalize(substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT], 1));
      print $stdout $normal;
      $self->[SELF_CURSOR_INPUT]++;
      $self->[SELF_CURSOR_DISPLAY] += length($normal);
    }
    $self->rl_self_insert($self->[SELF_KILL_RING]->[$pos], $self->[SELF_KILL_RING]->[$pos]);
    if ($self->[SELF_CURSOR_INPUT] >= length($self->[SELF_INPUT])) {
      $self->[SELF_CURSOR_INPUT]--;
      $self->[SELF_CURSOR_DISPLAY]--;
      _curs_left(1);
    }
  }
  
  sub rl_vi_yank_arg {
    my ($self) = @_;
    $self->rl_vi_append_mode;
    if ($self->rl_yank_last_arg) {
      $self->rl_set_keymap('vi-insert');
    } else {
      $self->rl_set_keymap('vi-command');
    }
  }
  
  sub rl_vi_end_spec {
    my ($self) = @_;
    $self->[SELF_PENDING] = undef;
    $self->rl_ding;
    $self->rl_set_keymap('vi');
  }
  
  sub rl_vi_spec_end_of_line {
    my ($self) = @_;
    $self->rl_set_keymap('vi');
    $self->_vi_apply_spec($self->[SELF_CURSOR_INPUT], length($self->[SELF_INPUT]) - $self->[SELF_CURSOR_INPUT]);
  }
  
  sub rl_vi_spec_beginning_of_line {
    my ($self) = @_;
    $self->rl_set_keymap('vi');
    $self->_vi_apply_spec(0, $self->[SELF_CURSOR_INPUT]);
  }
  
  sub rl_vi_spec_first_print {
    my ($self) = @_;
    substr($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT]) =~ /^(\s*)/;
    my $len = length($1) || 0;
    my $from = $self->[SELF_CURSOR_INPUT];
    if ($from > $len) {
      my $tmp = $from;
      $from = $len;
      $len = $tmp - $from;
    }
    $self->_vi_apply_spec($from, $len);
  }
  
  
  sub rl_vi_spec_word {
    my ($self) = @_;
  
    my $from = $self->[SELF_CURSOR_INPUT];
    my $len  = length($self->[SELF_INPUT]) - $from + 1;
    if (substr($self->[SELF_INPUT], $from) =~ /^(\s*\S+\s)/) {
      my $word = $1;
      $len = length($word);
    }
    $self->rl_set_keymap('vi');
    $self->_vi_apply_spec($from, $len);
  }
  
  sub rl_character_search {
    my ($self) = @_;
    $self->[SELF_PENDING_FN] = sub {
      my ($s, $key) = @_;
      return $s->rl_ding unless substr($s->[SELF_INPUT], $s->[SELF_CURSOR_INPUT]) =~ /(.*)$key/;
      $s->[SELF_COUNT] = $s->[SELF_INPUT] + length($1);
      $s->vi_column;
    };
  }
  
  sub rl_character_search_backward {
    my ($self) = @_;
    $self->[SELF_PENDING_FN] = sub {
      my ($s, $key) = @_;
      return $s->rl_ding unless substr($s->[SELF_INPUT], 0, $s->[SELF_CURSOR_INPUT]) =~ /$key([^$key])*$/;
      $s->[SELF_COUNT] = $s->[SELF_INPUT] - length($1);
      $s->vi_column;
    };
  }
  
  sub rl_vi_spec_forward_char {
    my ($self) = @_;
    $self->[SELF_PENDING_FN] = sub {
      my ($s, $key) = @_;
      return $s->rl_ding unless substr($s->[SELF_INPUT], $s->[SELF_CURSOR_INPUT]) =~ /(.*)$key/;
      $s->_vi_apply_spec($s->[SELF_CURSOR_INPUT], length($1));
    };
  }
  
  sub rl_vi_spec_mark {
    my ($self) = @_;
  
    $self->[SELF_PENDING_FN] = sub {
      my ($s, $key) = @_;
      return $s->rl_ding unless exists $s->[SELF_MARKLIST]->{$key};
      my $pos = $s->[SELF_CURSOR_INPUT];
      my $len = $s->[SELF_MARKLIST]->{$key} - $s->[SELF_CURSOR_INPUT];
      if ($len < 0) {
        $pos += $len;
        $len = -$len;
      }
      $s->_vi_apply_spec($pos, $len);
    };
  }
  
  sub _vi_apply_spec {
    my ($self, $from, $howmany) = @_;
    $self->[SELF_PENDING]->($self, $from, $howmany);
    $self->[SELF_PENDING] = undef if ($self->[SELF_COUNT] <= 1);
  }
  
  sub rl_vi_yank_to {
    my ($self, $key) = @_;
    $self->[SELF_PENDING] = sub {
      my ($s, $from, $howmany) = @_;
      push(@{$s->[SELF_KILL_RING]}, substr($s->[SELF_INPUT], $from, $howmany));
    };
    if ($key eq 'Y') {
      $self->rl_vi_spec_end_of_line;
    } else {
      $self->rl_set_keymap('vi-specification');
    }
  }
  
  sub rl_vi_delete_to {
    my ($self, $key) = @_;
    $self->[SELF_PENDING] = sub {
      my ($s, $from, $howmany) = @_;
      $s->_delete_chars($from, $howmany);
      if ($s->[SELF_INPUT] && $s->[SELF_CURSOR_INPUT] >= length($s->[SELF_INPUT])) {
        $s->[SELF_CURSOR_INPUT]--;
        $s->[SELF_CURSOR_DISPLAY]--;
        _curs_left(1);
      }
      $s->rl_set_keymap('vi');
    };
    if ($key eq 'D') {
      $self->rl_vi_spec_end_of_line;
    } else {
      $self->rl_set_keymap('vi-specification');
    }
  }
  
  sub rl_vi_change_to {
    my ($self, $key) = @_;
    $self->[SELF_PENDING] = sub {
      my ($s, $from, $howmany) = @_;
      $s->_delete_chars($from, $howmany);
      $s->rl_set_keymap('vi-insert');
    };
    if ($key eq 'C') {
      $self->rl_vi_spec_end_of_line;
    } else {
      $self->rl_set_keymap('vi-specification');
    }
  }
  
  sub rl_vi_arg_digit {
    my ($self, $key) = @_;
    if ($key == '0' && !$self->[SELF_COUNT]) {
      $self->rl_beginning_of_line;
    } else {
      $self->[SELF_COUNT] .= $key;
    }
  }
  
  sub rl_vi_tilde_expand {
    my ($self) = @_;
    if ($self->rl_tilde_expand) {
      $self->rl_vi_append_mode;
    }
  }
  
  sub rl_vi_complete {
    my ($self) = @_;
    if ($self->rl_complete) {
      $self->rl_set_keymap('vi-insert');
    }
  }
  
  sub rl_vi_goto_mark {
    my ($self) = @_;
    $self->[SELF_PENDING_FN] = sub {
      my ($s, $key) = @_;
      return $s->rl_ding unless exists $s->[SELF_MARKLIST]->{$key};
      $s->[SELF_COUNT] = $s->[SELF_MARKLIST]->{$key};
      $s->rl_vi_column;
    };
  }
  
  sub rl_vi_set_mark  {
    my ($self) = @_;
    $self->[SELF_PENDING_FN] = sub {
      my ($s, $key) = @_;
      return $s->rl_ding unless ($key >= 'a' && $key <= 'z');
      $s->[SELF_MARKLIST]->{$key} = $s->[SELF_CURSOR_INPUT];
    };
  }
  
  sub rl_search_abort {
    my ($self) = @_;
    $self->_wipe_input_line;
    $self->[SELF_PROMPT] = $self->[SELF_PREV_PROMPT];
    $self->_repaint_input_line;
    $self->[SELF_KEYMAP] = $self->[SELF_SEARCH_MAP];
    $self->[SELF_SEARCH_MAP] = undef;
    $self->[SELF_SEARCH] = undef;
  }
  
  sub rl_search_finish {
    my ($self, $key, $raw) = @_;
    $self->_wipe_input_line;
    $self->[SELF_PROMPT] = $self->[SELF_PREV_PROMPT];
    $self->_repaint_input_line;
    $self->[SELF_KEYMAP] = $self->[SELF_SEARCH_MAP];
    $self->[SELF_SEARCH_MAP] = undef;
    $self->[SELF_SEARCH] = undef;
    $self->_apply_key($key, $raw);
  }
  
  sub rl_search_key {
    my ($self, $key) = @_;
    $self->[SELF_SEARCH] .= $key;
    $self->_search(1);
  }
  
  sub rl_vi_search_key {
    my ($self, $key) = @_;
    $self->rl_self_insert($key, $key);
  }
  
  sub rl_vi_search {
    my ($self, $key) = @_;
    $self->_wipe_input_line;
    $self->[SELF_SEARCH_MAP] = $self->[SELF_KEYMAP];
    if ($key eq '/' && $self->[SELF_HIST_INDEX] < scalar @{$self->[SELF_HIST_LIST]}) {
      $self->[SELF_SEARCH_DIR] = -1;
    } else {
      $self->[SELF_SEARCH_DIR] = +1;
    }
    $self->[SELF_SEARCH_KEY] = $key;
    $self->[SELF_INPUT] = $key;
    $self->[SELF_CURSOR_INPUT] = 1;
    $self->[SELF_CURSOR_DISPLAY] = 1;
    $self->_repaint_input_line;
    $self->rl_set_keymap('vi-search');
  }
  
  sub rl_vi_search_accept {
    my ($self) = @_;
    $self->_wipe_input_line;
    $self->[SELF_CURSOR_INPUT] = 0;
    $self->[SELF_CURSOR_DISPLAY] = 0;
    $self->[SELF_INPUT] =~ s{^[/?]}{};
    $self->[SELF_SEARCH] = $self->[SELF_INPUT] if $self->[SELF_INPUT];
    $self->_search(0);
    $self->[SELF_KEYMAP] = $self->[SELF_SEARCH_MAP];
    $self->[SELF_SEARCH_MAP] = undef;
  }
  
  sub rl_vi_search_again {
    my ($self, $key) = @_;
    return $self->rl_ding unless $self->[SELF_SEARCH];
    $self->[SELF_HIST_INDEX] += $self->[SELF_SEARCH_DIR];
    if ($self->[SELF_HIST_INDEX] < 0) {
      $self->[SELF_HIST_INDEX] = 0;
      return $self->rl_ding;
    } elsif ($self->[SELF_HIST_INDEX] >= scalar @{$self->[SELF_HIST_LIST]}) {
      $self->[SELF_HIST_INDEX] = (scalar @{$self->[SELF_HIST_LIST]}) - 1;
      return $self->rl_ding;
    }
    $self->_wipe_input_line;
    $self->_search(0);
  }
  
  sub rl_isearch_again {
    my ($self, $key) = @_;
    if ($key ne $self->[SELF_SEARCH_KEY]) {
      $self->[SELF_SEARCH_KEY] = $key;
      $self->[SELF_SEARCH_DIR] = -$self->[SELF_SEARCH_DIR];
    }
    $self->[SELF_HIST_INDEX] += $self->[SELF_SEARCH_DIR];
    if ($self->[SELF_HIST_INDEX] < 0) {
      $self->[SELF_HIST_INDEX] = 0;
      return $self->rl_ding;
    } elsif ($self->[SELF_HIST_INDEX] >= scalar @{$self->[SELF_HIST_LIST]}) {
      $self->[SELF_HIST_INDEX] = (scalar @{$self->[SELF_HIST_LIST]}) - 1;
      return $self->rl_ding;
    }
    $self->_search(1);
  }
  
  sub rl_non_incremental_forward_search_history {
    my ($self) = @_;
    $self->_wipe_input_line;
    $self->[SELF_CURSOR_INPUT] = 0;
    $self->[SELF_CURSOR_DISPLAY] = 0;
    $self->[SELF_SEARCH_DIR] = +1;
    $self->[SELF_SEARCH] = substr($self->[SELF_INPUT], 0, $self->[SELF_CURSOR_INPUT]);
    $self->_search(0);
  }
  
  sub rl_non_incremental_reverse_search_history {
    my ($self) = @_;
    $self->[SELF_HIST_INDEX] --;
    if ($self->[SELF_HIST_INDEX] < 0) {
      $self->[SELF_HIST_INDEX] = 0;
      return $self->rl_ding;
    }
    $self->_wipe_input_line;
    $self->[SELF_CURSOR_INPUT] = 0;
    $self->[SELF_CURSOR_DISPLAY] = 0;
    $self->[SELF_SEARCH_DIR] = -1;
    $self->[SELF_SEARCH] = substr($self->[SELF_INPUT], 0, $self->[SELF_CURSOR_INPUT]);
    $self->_search(0);
  }
  
  sub rl_undo {
    my ($self) = @_;
    $self->rl_ding unless scalar @{$self->[SELF_UNDO]};
    my $tuple = pop @{$self->[SELF_UNDO]};
    ($self->[SELF_INPUT], $self->[SELF_CURSOR_INPUT], $self->[SELF_CURSOR_DISPLAY]) = @$tuple;
  }
  
  sub rl_vi_redo {
    my ($self, $key) = @_;
    return $self->rl_ding unless $self->[SELF_LAST];
    my $fn = $self->[SELF_LAST];
    $self->$fn();
  }
  
  sub rl_vi_char_search {
    my ($self, $key) = @_;
    $self->[SELF_PENDING_FN] = sub {
      my ($s,$k,$rk) = @_;
      $rk = "\\" . $rk if ($rk !~ /\w/);
      return $s->rl_ding unless substr($s->[SELF_INPUT], $s->[SELF_CURSOR_INPUT]) =~ /([^$rk]*)$rk/;
      $s->[SELF_COUNT] = $s->[SELF_CURSOR_INPUT] + length($1);
      $s->rl_vi_column;
    };
  }
  
  sub rl_vi_change_char {
    my ($self, $key) = @_;
    $self->[SELF_PENDING_FN] = sub {
      my ($s,$k,$rk) = @_;
      $s->rl_delete_char;
      $s->rl_self_insert($k,$rk);
      $s->rl_backward_char;
    };
  }
  
  sub rl_vi_subst {
    my ($self, $key) = @_;
    if ($key eq 's') {
      $self->rl_vi_delete;
    } else {
      $self->rl_beginning_of_line;
      $self->rl_kill_line;
    }
    $self->rl_vi_insertion_mode;
  }
  
  # ============================================================
  # THE KEYMAP CLASS ITSELF
  # ============================================================
  
  package POE::Wheel::ReadLine::Keymap;
  
  my %english_to_termcap = (
    'up'        => 'ku',
    'down'      => 'kd',
    'left'      => 'kl',
    'right'     => 'kr',
    'insert'    => 'kI',
    'ins'       => 'kI',
    'delete'    => 'kD',
    'del'       => 'kD',
    'home'      => 'kh',
    'end'       => 'kH',
    'backspace' => 'kb',
    'bs'        => 'kb',
  );
  
  my %english_to_key = (
    'space'     => " ",
    'esc'       => "\e",
    'escape'    => "\e",
    'tab'       => "\cI",
    'ret'       => "\cJ",
    'return'    => "\cJ",
    'newline'   => "\cM",
    'lfd'       => "\cL",
    'rubout'    => chr(127),
  );
  
  sub init {
    my ($proto, %opts) = @_;
    my $class = ref($proto) || $proto;
  
    my $default = delete $opts{default} or die("no default specified for keymap");
    my $name    = delete $opts{name} or die("no name specified for keymap");
    my $termcap = delete $opts{termcap} or die("no termcap specified for keymap");
  
    my $self = {
      name    => $name,
      default => $default,
      binding => {},
      prefix  => {},
      termcap => $termcap,
    };
  
    return bless $self, $class;
  }
  
  sub decode  {
    my ($self, $seq) = @_;
    if (exists $english_to_termcap{lc($seq)}) {
      my $key = $self->{termcap}->Tputs($english_to_termcap{lc($seq)}, 1);
      $seq = defined($key) ? $key : "";
    } elsif (exists $english_to_key{lc($seq)}) {
      $seq = $english_to_key{lc($seq)};
    }
  
    return $seq;
  }
  
  sub control {
    my $c = shift;
    return chr(0x7F) if $c eq "?";
    return chr(ord(uc($c))-64);
  }
  
  sub meta    { return "\x1B" . $_[0] };
  sub bind_key {
    my ($self, $inseq, $fn) = @_;
    my $seq = $inseq;
    my $macro = undef;
    if (!ref $fn) {
      if ($fn =~ /^["'](.*)['"]$/) {
        # A macro
        $macro = $1;
        $fn = 'insert-macro';
      } else {
        if (!exists $POE::Wheel::ReadLine::defuns->{$fn}) {
          print "ignoring $inseq, since function '$fn' is not known\r\n";
          next;
        }
      }
    }
  
    # Need to parse key sequence into a trivial lookup form.
    if ($seq =~ s{^"(.*)"$}{$1}) {
      $seq =~ s{\\C-(.)}{control($1)}ge;
      $seq =~ s{\\M-(.)}{meta($1)}ge;
      $seq =~ s{\\e}{\x1B}g;
      $seq =~ s{\\\\}{\\}g;
      $seq =~ s{\\"}{"}g;
      $seq =~ s{\\'}{'}g;
    } else {
      my $orig = $seq;
      do {
        $orig = $seq;
        $seq =~ s{(\w*)$}{$self->decode($1)}ge;
        # horrible regex, coz we need to work backwards, to allow
        # for things like C-M-r, or C-xC-x
        $seq =~ s{C(ontrol)?-(.)([^-]*)$}{control($2).$3}ge;
        $seq =~ s{M(eta)?-(.)([^-]*)$}{meta($2).$3}ge;
      } while ($seq ne $orig);
    }
  
    $self->{binding}->{$seq} = $fn if length $seq;
    $self->{macros}->{$seq} = $macro if $macro;
    #print "bound $inseq (" . POE::Wheel::ReadLine::_normalize($seq) . ") to $fn in map $self->{name}\r\n";
  
    if (length($seq) > 1) {
      # XXX: Should store rawkey prefixes, to avoid the ^ problem.
      # requires converting seq into raw, then applying normalize
      # later on for binding. May not need last step if we keep
      # everything as raw.
      # Some keystrokes generate multi-byte sequences.  Record the prefixes
      # for multi-byte sequences so the keystroke builder knows it's in the
      # middle of something.
      while (length($seq) > 1) {
        chop $seq;
        $self->{prefix}->{$seq}++;
      }
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Wheel::ReadLine - non-blocking Term::ReadLine for POE
  
  =head1 SYNOPSIS
  
    #!perl
  
    use warnings;
    use strict;
  
    use POE qw(Wheel::ReadLine);
  
    POE::Session->create(
      inline_states=> {
        _start => \&setup_console,
        got_user_input => \&handle_user_input,
      }
    );
  
    POE::Kernel->run();
    exit;
  
    sub handle_user_input {
      my ($input, $exception) = @_[ARG0, ARG1];
      my $console = $_[HEAP]{console};
  
      unless (defined $input) {
        $console->put("$exception caught.  B'bye!");
        $_[KERNEL]->signal($_[KERNEL], "UIDESTROY");
        $console->write_history("./test_history");
        return;
      }
  
      $console->put("  You entered: $input");
      $console->addhistory($input);
      $console->get("Go: ");
    }
  
    sub setup_console {
      $_[HEAP]{console} = POE::Wheel::ReadLine->new(
        InputEvent => 'got_user_input'
      );
      $_[HEAP]{console}->read_history("./test_history");
      $_[HEAP]{console}->clear();
      $_[HEAP]{console}->put(
        "Enter some text.",
        "Ctrl+C or Ctrl+D exits."
      );
      $_[HEAP]{console}->get("Go: ");
    }
  
  =head1 DESCRIPTION
  
  POE::Wheel::ReadLine is a non-blocking form of Term::ReadLine that's
  compatible with POE.  It uses Term::Cap to interact with the terminal
  display and Term::ReadKey to interact with the keyboard.
  
  POE::Wheel::ReadLine handles almost all common input editing keys.  It
  provides an input history list.  It has both vi and emacs modes.  It
  supports incremental input search.  It's fully customizable, and it's
  compatible with standard readline(3) implementations such as
  Term::ReadLine::Gnu.
  
  POE::Wheel::ReadLine is configured by placing commands in an "inputrc"
  initialization file.  The file's name is taken from the C<INPUTRC>
  environment variable, or ~/.inputrc by default.  POE::Wheel::ReadLine
  will read the inputrc file and configure itself according to the
  commands and variables therein.  See readline(3) for details about
  inputrc files.
  
  The default editing mode will be emacs-style, although this can be
  configured by setting the 'editing-mode' variable within an inputrc
  file.  If all else fails, POE::Wheel::ReadLine will determine the
  user's favorite editor by examining the EDITOR environment variable.
  
  =head1 PUBLIC METHODS
  
  =head2 Constructor
  
  Most of POE::Wheel::ReadLine's interaction is through its constructor,
  new().
  
  =head3 new
  
  new() creates and returns a new POE::Wheel::ReadLine object.  Be sure
  to instantiate only one, as multiple console readers would conflict.
  
  =head4 InputEvent
  
  C<InputEvent> names the event that will indicate a new line of console
  input.  See L</PUBLIC EVENTS> for more details.
  
  =head4 PutMode
  
  C<PutMode> controls how output is displayed when put() is called
  during user input.
  
  When set to "immediate", put() pre-empts the user immediately.  The
  input prompt and user's input to date are redisplayed after put() is
  done.
  
  The "after" C<PutMode> tells put() to wait until after the user enters
  or cancels her input.
  
  Finally, "idle" will allow put() to pre-empt user input if the user
  stops typing for L</IdleTime> seconds.  This mode behaves like "after"
  if the user can't stop typing long enough.  This is
  POE::Wheel::ReadLine's default mode.
  
  =head4 IdleTime
  
  C<IdleTime> tells POE::Wheel::ReadLine how long the keyboard must be
  idle before C<put()> becomes immediate or buffered text is flushed to
  the display.  It is only meaningful when L</PutMode> is "idle".
  C<IdleTime> defaults to 2 seconds.
  
  =head4 AppName
  
  C<AppName> registers an application name which is used to retrieve
  application-specific key bindings from the inputrc file.  The default
  C<AppName> is "poe-readline".
  
    # If using POE::Wheel::ReadLine, set
    # the key mapping to emacs mode and
    # trigger debugging output on a certain
    # key sequence.
    $if poe-readline
    set keymap emacs
    Control-xP: poe-wheel-debug
    $endif
  
  =head2 History List Management
  
  POE::Wheel::ReadLine supports an input history, with searching.
  
  =head3 add_history
  
  add_history() accepts a list of lines to add to the input history.
  Generally it's called with a single line: the last line of input
  received from the terminal.  The L</SYNOPSIS> shows add_history() in
  action.
  
  =head3 get_history
  
  get_history() returns a list containing POE::Wheel::ReadLine's current
  input history.  It may not contain everything entered into the wheel
  
  =for comment
  TODO - Example.
  
  =head3 write_history
  
  write_history() writes the current input history to a file.  It
  accepts one optional parameter: the name of the file where the input
  history will be written.  write_history() will write to ~/.history if
  no file name is specified.
  
  Returns true on success, or false if not.
  
  The L</SYNOPSIS> shows an example of write_history() and the
  corresponding read_history().
  
  =head3 read_history
  
  read_history(FILENAME, START, END) reads a previously saved input
  history from a named file, or from ~/.history if no file name is
  specified.  It may also read a subset of the history file if it's
  given optional START and END parameters.  The file will be read from
  the beginning if START is omitted or zero.  It will be read to the end
  if END is omitted or earlier than START.
  
  Returns true on success, or false if not.
  
  The L</SYNOPSIS> shows an example of read_history() and the
  corresponding write_history().
  
  Read the first ten history lines:
  
    $_[HEAP]{console}->read_history("filename", 0, 9);
  
  =head3 history_truncate_file
  
  history_truncate_file() truncates a history file to a certain number
  of lines.  It accepts two parameters: the name of the file to
  truncate, and the maximum number of history lines to leave in the
  file.  The history file will be cleared entirely if the line count is
  zero or omitted.
  
  The file to be truncated defaults to ~/.history.  So calling
  history_truncate_file() with no parameters clears ~/.history.
  
  Returns true on success, or false if not.
  
  Note that history_trucate_file() removes the earliest lines from the
  file.  The later lines remain intact since they were the ones most
  recently entered.
  
  Keep ~/.history down to a manageable 100 lines:
  
    $_[HEAP]{console}->history_truncate_file(undef, 100);
  
  =head2 Key Binding Methods
  
  =head3 bind_key
  
  bind_key(KEYSTROKE, FUNCTION) binds a FUNCTION to a named KEYSTROKE
  sequence.  The keystroke sequence can be in any of the forms defined
  within readline(3).  The function should either be a pre-defined name,
  such as "self-insert" or a function reference.  The binding is made in
  the current keymap.  Use the rl_set_keymap() method to change keymaps,
  if desired.
  
  =head3 add_defun NAME FN
  
  add_defun(NAME, FUNCTION) defines a new global FUNCTION, giving it a
  specific NAME.  The function may then be bound to keystrokes by that
  NAME.
  
  =head2 Console I/O Methods
  
  =head3 clear
  
  Clears the terminal.
  
  =head3 terminal_size
  
  Returns what POE::Wheel::ReadLine thinks are the current dimensions of
  the terminal.  Returns a list of two values: the number of columns and
  number of rows, respectively.
  
    sub some_event_handler {
      my ($columns, $rows) = $_[HEAP]{console}->terminal_size;
      $_[HEAP]{console}->put(
        "Terminal columns: $columns",
        "Terminal rows: $rows",
      );
    }
  
  =head3 get
  
  get() causes POE::Wheel::ReadLine to display a prompt and then wait
  for input.  Input is not noticed unless get() has enabled the wheel's
  internal I/O watcher.
  
  After get() is called, the next line of input or exception on the
  console will trigger an C<InputEvent> with the appropriate parameters.
  POE::Wheel::ReadLine will then enter an inactive state until get() is
  called again.
  
  Calls to get() without an argument will preserve the current prompt.
  Calling get() with an argument before a whole line of input is
  received will change the prompt on the fly.
  
  See the L</SYNOPSIS> for sample usage.
  
  =head3 put
  
  put() accepts a list of lines to put on the terminal.
  POE::Wheel::ReadLine is line-based.  See L<POE::Wheel::Curses> for
  more funky display options.
  
  Please do not use print() with POE::Wheel::ReadLine.  print()
  invariably gets the newline wrong, leaving an application's output to
  stairstep down the terminal.  Also, put() understands when a user is
  entering text, and C<PutMode> may be used to avoid interrupting the
  user.
  
  =head2 ReadLine Option Methods
  
  =head3 attribs
  
  attribs() returns a reference to a hash of readline options.  The
  returned hash may be used to query or modify POE::Wheel::ReadLine's
  behavior.
  
  =head3 option
  
  option(NAME) returns a specific member of the hash returned by
  attribs().  It's a more convenient way to query POE::Wheel::ReadLine
  options.
  
  =head1 PUBLIC EVENTS
  
  POE::Wheel::ReadLine emits only a single event.
  
  =head2 InputEvent
  
  C<InputEvent> names the event that will be emitted upon any kind of
  complete terminal input.  Every C<InputEvent> handler receives three
  parameters:
  
  C<$_[ARG0]> contains a line of input.  It may be an empty string if
  the user entered an empty line.  An undefined C<$_[ARG0]> indicates
  some exception such as end-of-input or the fact that the user canceled
  their input or pressed C-c (^C).
  
  C<$_[ARG1]> describes an exception, if one occurred.  It may contain
  one of the following strings:
  
  =over 2
  
  =item cancel
  
  The "cancel" exception indicates when a user has canceled a line of
  input.  It's sent when the user triggers the "abort" function, which
  is bound to C-g (^G) by default.
  
  =item eot
  
  "eot" is the ASCII code for "end of tape".  It's emitted when the user
  requests that the terminal be closed.  By default, it's triggered when
  the user presses C-d (^D) on an empty line.
  
  =item interrupt
  
  "interrupt" is sent as a result of the user pressing C-c (^C) or
  otherwise triggering the "interrupt" function.
  
  =back
  
  Finally, C<$_[ARG2]> contains the ID for the POE::Wheel::ReadLine
  object that sent the C<InputEvent>.
  
  =head1 CUSTOM BINDINGS
  
  POE::Wheel::ReadLine allows custom functions to be bound to
  keystrokes.  The function must be made visible to the wheel before it
  can be bound.  To register a function, use POE::Wheel::ReadLine's
  add_defun() method:
  
    POE::Wheel::ReadLine->add_defun('reverse-line', \&reverse_line);
  
  When adding a new defun, an optional third parameter may be provided
  which is a key sequence to bind to.  This should be in the same format
  as that understood by the inputrc parsing.
  
  Bound functions receive three parameters: A reference to the wheel
  object itself, the key sequence that triggered the function (in
  printable form), and the raw key sequence.  The bound function is
  expected to dig into the POE::Wheel::ReadLine data members to do its
  work and display the new line contents itself.
  
  This is less than ideal, and it may change in the future.
  
  =head1 CUSTOM COMPLETION
  
  An application may modify POE::Wheel::ReadLine's "completion_function"
  in order to customize how input should be completed.  The new
  completion function must accept three scalar parameters: the word
  being completed, the entire input text, and the position within the
  input text of the word being completed.
  
  The completion function should return a list of possible matches.  For
  example:
  
    my $attribs = $wheel->attribs();
    $attribs->{completion_function} = sub {
      my ($text, $line, $start) = @_;
      return qw(a list of candidates to complete);
    }
  
  This is the only form of completion currently supported.
  
  =head1 IMPLEMENTATION DIFFERENCES
  
  Although POE::Wheel::ReadLine is modeled after the readline(3)
  library, there are some areas which have not been implemented.  The
  only option settings which have effect in this implementation are:
  bell-style, editing-mode, isearch-terminators, comment-begin,
  print-completions-horizontally, show-all-if-ambiguous and
  completion_function.
  
  The function 'tab-insert' is not implemented, nor are tabs displayed
  properly.
  
  =head1 SEE ALSO
  
  L<POE::Wheel> describes the basic operations of all wheels in more
  depth.  You need to know this.
  
  readline(3), L<Term::Cap>, L<Term::ReadKey>.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  L<Term::Visual> is an alternative to POE::Wheel::ReadLine.  It
  provides scrollback and a status bar in addition to editable user
  input.  Term::Visual supports POE despite the lack of "POE" in its
  name.
  
  =head1 BUGS
  
  POE::Wheel::ReadLine has some known issues:
  
  =head2 Perl 5.8.0 is Broken
  
  Non-blocking input with Term::ReadKey does not work with Perl 5.8.0,
  especially on Linux systems for some reason.  Upgrading Perl will fix
  things.  If you can't upgrade Perl, consider alternative input
  methods, such as Term::Visual.
  
  L<http://rt.cpan.org/Ticket/Display.html?id=4524> and related tickets
  explain the issue in detail.  If you suspect your system is one where
  Term::ReadKey fails, you can run this test program to be sure.
  
    #!/usr/bin/perl
    use Term::ReadKey;
    print "Press 'q' to quit this test.\n";
    ReadMode 5; # Turns off controls keys
    while (1) {
      while (not defined ($key = ReadKey(-1))) {
        print "Didn't get a key.  Sleeping 1 second.\015\012";
        sleep (1);
      }
      print "Got key: $key\015\012";
      ($key eq 'q') and last;
    }
    ReadMode 0; # Reset tty mode before exiting
    exit;
  
  =head2 Non-Optimal Code
  
  Dissociating the input and display cursors introduced a lot of code.
  Much of this code was thrown in hastily, and things can probably be
  done with less work.
  
  =for comment
  TODO: Apply some thought to what's already been done.
  
  =for comment
  TODO: Ensure that the screen updates as quickly as possible,
  especially on slow systems.  Do little or no calculation during
  displaying; either put it all before or after the display.  Do it
  consistently for each handled keystroke, so that certain pairs of
  editing commands don't have extra perceived latency.
  
  =head2 Unimplemented Features
  
  Input editing is not kept on one line.  If it wraps, and a terminal
  cannot wrap back through a line division, the cursor will become lost.
  
  Unicode support.  I feel real bad about throwing away native
  representation of all the 8th-bit-set characters.  I also have no idea
  how to do this, and I don't have a system to test this.  Patches are
  very much welcome.
  
  =head1 GOTCHAS / FAQ
  
  =head2 Lost Prompts
  
  Q: Why do I lose my prompt every time I send output to the screen?
  
  A: You probably are using print or printf to write screen output.
  ReadLine doesn't track STDOUT itself, so it doesn't know when to
  refresh the prompt after you do this.  Use ReadLine's put() method to
  write lines to the console.
  
  =head2 Edit Keystrokes Display as ^C
  
  Q: None of the editing keystrokes work.  Ctrl-C displays "^c" rather
  than generating an interrupt.  The arrow keys don't scroll through my
  input history.  It's generally a bad experience.
  
  A: You're probably a vi/vim user.  In the absence of a ~/.inputrc
  file, POE::Wheel::ReadLine checks your EDITOR environment variable for
  clues about your editing preference.  If it sees /vi/ in there, it
  starts in vi mode.  You can override this by creating a ~/.inputrc
  file containing the line "set editing-mode emacs", or adding that line
  to your existing ~/.inputrc.  While you're in there, you should
  totally get acquainted with all the other cool stuff you can do with
  .inputrc files.
  
  =head2 Lack of Windows Support
  
  Q: Why doesn't POE::Wheel::ReadLine work on Windows?  Term::ReadLine
  does.
  
  A: POE::Wheel::ReadLine requires select(), because that's what POE
  uses by default to detect keystrokes without blocking.  About half the
  flavors of Perl on Windows implement select() in terms of the same
  function in the WinSock library, which limits select() to working only
  with sockets.  Your console isn't a socket, so select() doesn't work
  with your version of Perl on Windows.
  
  Really good workarounds are possible but don't exist as of this
  writing.  They involve writing a special POE::Loop for Windows that
  either uses a Win32-specific module for better multiplexing, that
  polls for input, or that uses blocking I/O watchers in separate
  threads.
  
  =head2 Cygwin Support
  
  Q: Why does POE::Wheel::ReadLine complain about my "dumb" terminal?
  
  A: Do you have Strawberry Perl installed? Due to the way it works, on
  installation it sets a global environment variable in MSWin32 for
  TERM=dumb. ( it may be fixed in a future version, but it's here to stay
  for now, ha! ) In this case, logging into the Cygwin shell via the
  cygwin.bat launcher results in a nonfunctional readline.
  
  Normally, Cygwin will set TERM=cygwin in the launcher. However, if the 
  TERM was already set it will not alter the value. Hence, the "bug"
  appears! What you can do is to hack the cygwin.bat file to add this line:
  
    SET TERM=cygwin
  
  Other users reported that you can have better results by editing the
  ~/.bash_profile file to set TERM=cygwin because on a Cygwin upgrade it
  overwrites the cygwin.bat file.
  
  Alternatively, you could install different terminals like "xterm" or "rxvt"
  as shown here: L<http://c2.com/cgi/wiki?BetterCygwinTerminal>. Please let
  us know if you encounter problems using any terminal other than "dumb".
  
  If you feel brave, you can peruse the RT ticket at 
  L<http://rt.cpan.org/Ticket/Display.html?id=55365> for more information
  on this problem.
  
  =head1 AUTHORS & COPYRIGHTS
  
  POE::Wheel::ReadLine was originally written by Rocco Caputo.
  
  Nick Williams virtually rewrote it to support a larger subset of GNU
  readline.
  
  Please see L<POE> for more information about other authors and
  contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_WHEEL_READLINE

$fatpacked{"POE/Wheel/ReadWrite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_WHEEL_READWRITE';
  package POE::Wheel::ReadWrite;
  
  use strict;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw( croak carp );
  use POE qw(Wheel Driver::SysRW Filter::Line);
  push @ISA, qw(POE::Wheel);
  
  # Offsets into $self.
  sub HANDLE_INPUT               () {  0 }
  sub HANDLE_OUTPUT              () {  1 }
  sub FILTER_INPUT               () {  2 }
  sub FILTER_OUTPUT              () {  3 }
  sub DRIVER_BOTH                () {  4 }
  sub EVENT_INPUT                () {  5 }
  sub EVENT_ERROR                () {  6 }
  sub EVENT_FLUSHED              () {  7 }
  sub WATERMARK_WRITE_MARK_HIGH  () {  8 }
  sub WATERMARK_WRITE_MARK_LOW   () {  9 }
  sub WATERMARK_WRITE_EVENT_HIGH () { 10 }
  sub WATERMARK_WRITE_EVENT_LOW  () { 11 }
  sub WATERMARK_WRITE_STATE      () { 12 }
  sub DRIVER_BUFFERED_OUT_OCTETS () { 13 }
  sub STATE_WRITE                () { 14 }
  sub STATE_READ                 () { 15 }
  sub UNIQUE_ID                  () { 16 }
  sub AUTOFLUSH                  () { 17 }
  
  sub CRIMSON_SCOPE_HACK ($) { 0 }
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
    my %params = @_;
  
    croak "wheels no longer require a kernel reference as their first parameter"
      if (@_ && (ref($_[0]) eq 'POE::Kernel'));
  
    croak "$type requires a working Kernel" unless defined $poe_kernel;
  
    my ($in_handle, $out_handle);
    if (defined $params{Handle}) {
      carp "Ignoring InputHandle parameter (Handle parameter takes precedence)"
        if defined $params{InputHandle};
      carp "Ignoring OutputHandle parameter (Handle parameter takes precedence)"
        if defined $params{OutputHandle};
      $in_handle = $out_handle = delete $params{Handle};
    }
    else {
      croak "Handle or InputHandle required"
        unless defined $params{InputHandle};
      croak "Handle or OutputHandle required"
        unless defined $params{OutputHandle};
      $in_handle  = delete $params{InputHandle};
      $out_handle = delete $params{OutputHandle};
    }
  
    my ($in_filter, $out_filter);
    if (defined $params{Filter}) {
      carp "Ignoring InputFilter parameter (Filter parameter takes precedence)"
        if (defined $params{InputFilter});
      carp "Ignoring OutputFilter parameter (Filter parameter takes precedence)"
        if (defined $params{OutputFilter});
      $in_filter = $out_filter = delete $params{Filter};
    }
    else {
      $in_filter = delete $params{InputFilter};
      $out_filter = delete $params{OutputFilter};
  
      # If neither Filter, InputFilter or OutputFilter is defined, then
      # they default to POE::Filter::Line.
      unless (defined $in_filter and defined $out_filter) {
        my $new_filter = POE::Filter::Line->new();
        $in_filter = $new_filter unless defined $in_filter;
        $out_filter = $new_filter unless defined $out_filter;
      }
    }
  
    my $driver = delete $params{Driver};
    $driver = POE::Driver::SysRW->new() unless defined $driver;
  
    { my $mark_errors = 0;
      if (defined($params{HighMark}) xor defined($params{LowMark})) {
        carp "HighMark and LowMark parameters require each-other";
        $mark_errors++;
      }
      # Then they both exist, and they must be checked.
      elsif (defined $params{HighMark}) {
        unless (defined($params{HighMark}) and defined($params{LowMark})) {
          carp "HighMark and LowMark parameters must both be defined";
          $mark_errors++;
        }
        unless (($params{HighMark} > 0) and ($params{LowMark} > 0)) {
          carp "HighMark and LowMark parameters must be above 0";
          $mark_errors++;
        }
      }
      if (defined $params{HighEvent} and not defined $params{HighMark}) {
        carp "HighEvent requires a corresponding HighMark";
        $mark_errors++;
      }
      if (defined($params{LowMark}) xor defined($params{LowEvent})) {
        carp "LowMark and LowEvent parameters require each-other";
        $mark_errors++;
      }
      croak "Water mark errors" if $mark_errors;
    }
  
    my $self = bless [
      $in_handle,                       # HANDLE_INPUT
      $out_handle,                      # HANDLE_OUTPUT
      $in_filter,                       # FILTER_INPUT
      $out_filter,                      # FILTER_OUTPUT
      $driver,                          # DRIVER_BOTH
      delete $params{InputEvent},       # EVENT_INPUT
      delete $params{ErrorEvent},       # EVENT_ERROR
      delete $params{FlushedEvent},     # EVENT_FLUSHED
      # Water marks.
      delete $params{HighMark},         # WATERMARK_WRITE_MARK_HIGH
      delete $params{LowMark},          # WATERMARK_WRITE_MARK_LOW
      delete $params{HighEvent},        # WATERMARK_WRITE_EVENT_HIGH
      delete $params{LowEvent},         # WATERMARK_WRITE_EVENT_LOW
      0,                                # WATERMARK_WRITE_STATE
      # Driver statistics.
      0,                                # DRIVER_BUFFERED_OUT_OCTETS
      # Dynamic state names.
      undef,                            # STATE_WRITE
      undef,                            # STATE_READ
      # Unique ID.
      &POE::Wheel::allocate_wheel_id(), # UNIQUE_ID
      delete $params{AutoFlush},         # AUTOFLUSH
    ], $type;
  
    if (scalar keys %params) {
      carp(
        "unknown parameters in $type constructor call: ",
        join(', ', keys %params)
      );
    }
  
    $self->_define_read_state();
    $self->_define_write_state();
  
    return $self;
  }
  
  #------------------------------------------------------------------------------
  # Redefine the select-write handler.  This uses stupid closure tricks
  # to prevent keeping extra references to $self around.
  
  sub _define_write_state {
    my $self = shift;
  
    # Read-only members.  If any of these change, then the write state
    # is invalidated and needs to be redefined.
    my $driver        = $self->[DRIVER_BOTH];
    my $high_mark     = $self->[WATERMARK_WRITE_MARK_HIGH];
    my $low_mark      = $self->[WATERMARK_WRITE_MARK_LOW];
    my $event_error   = \$self->[EVENT_ERROR];
    my $event_flushed = \$self->[EVENT_FLUSHED];
    my $event_high    = \$self->[WATERMARK_WRITE_EVENT_HIGH];
    my $event_low     = \$self->[WATERMARK_WRITE_EVENT_LOW];
    my $unique_id     = $self->[UNIQUE_ID];
  
    # Read/write members.  These are done by reference, to avoid pushing
    # $self into the anonymous sub.  Extra copies of $self are bad and
    # can prevent wheels from destructing properly.
    my $is_in_high_water_state     = \$self->[WATERMARK_WRITE_STATE];
    my $driver_buffered_out_octets = \$self->[DRIVER_BUFFERED_OUT_OCTETS];
  
    # Register the select-write handler.
  
    $poe_kernel->state(
      $self->[STATE_WRITE] = ref($self) . "($unique_id) -> select write",
      sub {                             # prevents SEGV
        0 && CRIMSON_SCOPE_HACK('<');
                                        # subroutine starts here
        my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];
  
        $$driver_buffered_out_octets = $driver->flush($handle);
  
        # When you can't write, nothing else matters.
        if ($!) {
          $$event_error && $k->call(
            $me, $$event_error, 'write', ($!+0), $!, $unique_id
          );
          $k->select_write($handle);
        }
  
        # Could write, or perhaps couldn't but only because the
        # filehandle's buffer is choked.
        else {
  
          # In high water state?  Check for low water.  High water
          # state will never be set if $event_low is undef, so don't
          # bother checking its definedness here.
          if ($$is_in_high_water_state) {
            if ( $$driver_buffered_out_octets <= $low_mark ) {
              $$is_in_high_water_state = 0;
              $k->call( $me, $$event_low, $unique_id ) if defined $$event_low;
            }
          }
  
          # Not in high water state.  Check for high water.  Needs to
          # also check definedness of $$driver_buffered_out_octets.
          # Although we know this ahead of time and could probably
          # optimize it away with a second state definition, it would
          # be best to wait until ReadWrite stabilizes.  That way
          # there will be only half as much code to maintain.
          elsif (
            $high_mark and
            ( $$driver_buffered_out_octets >= $high_mark )
          ) {
            $$is_in_high_water_state = 1;
            $k->call( $me, $$event_high, $unique_id ) if defined $$event_high;
          }
        }
  
        # All chunks written; fire off a "flushed" event.  This
        # occurs independently, so it's possible to get a low-water
        # call and a flushed call at the same time (if the low mark
        # is 1).
        unless ($$driver_buffered_out_octets) {
          $k->select_pause_write($handle);
          $$event_flushed && $k->call($me, $$event_flushed, $unique_id);
        }
      }
    );
  
    $poe_kernel->select_write($self->[HANDLE_OUTPUT], $self->[STATE_WRITE]);
  
    # Pause the write select immediately, unless output is pending.
    $poe_kernel->select_pause_write($self->[HANDLE_OUTPUT])
      unless ($self->[DRIVER_BUFFERED_OUT_OCTETS]);
  }
  
  #------------------------------------------------------------------------------
  # Redefine the select-read handler.  This uses stupid closure tricks
  # to prevent keeping extra references to $self around.
  
  sub _define_read_state {
    my $self = shift;
  
    # Register the select-read handler.
  
    if (defined $self->[EVENT_INPUT]) {
  
      # If any of these change, then the read state is invalidated and
      # needs to be redefined.
  
      my $driver       = $self->[DRIVER_BOTH];
      my $input_filter = \$self->[FILTER_INPUT];
      my $event_input  = \$self->[EVENT_INPUT];
      my $event_error  = \$self->[EVENT_ERROR];
      my $unique_id    = $self->[UNIQUE_ID];
  
      # If the filter can get_one, then define the input state in terms
      # of get_one_start() and get_one().
  
      if (
        $$input_filter->can('get_one') and
        $$input_filter->can('get_one_start')
      ) {
        $poe_kernel->state(
          $self->[STATE_READ] = ref($self) . "($unique_id) -> select read",
          sub {
  
            # Protects against coredump on older perls.
            0 && CRIMSON_SCOPE_HACK('<');
  
            # The actual code starts here.
            my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];
            if (defined(my $raw_input = $driver->get($handle))) {
              $$input_filter->get_one_start($raw_input);
              while (1) {
                my $next_rec = $$input_filter->get_one();
                last unless @$next_rec;
                foreach my $cooked_input (@$next_rec) {
                  $k->call($me, $$event_input, $cooked_input, $unique_id);
                }
              }
            }
            else {
              $$event_error and $k->call(
                $me, $$event_error, 'read', ($!+0), $!, $unique_id
              );
              $k->select_read($handle);
            }
          }
        );
      }
  
      # Otherwise define the input state in terms of the older, less
      # robust, yet faster get().
  
      else {
        $poe_kernel->state(
          $self->[STATE_READ] = ref($self) . "($unique_id) -> select read",
          sub {
  
            # Protects against coredump on older perls.
            0 && CRIMSON_SCOPE_HACK('<');
  
            # The actual code starts here.
            my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];
            if (defined(my $raw_input = $driver->get($handle))) {
              foreach my $cooked_input (@{$$input_filter->get($raw_input)}) {
                $k->call($me, $$event_input, $cooked_input, $unique_id);
              }
            }
            else {
              $$event_error and $k->call(
                $me, $$event_error, 'read', ($!+0), $!, $unique_id
              );
              $k->select_read($handle);
            }
          }
        );
      }
                                          # register the state's select
      $poe_kernel->select_read($self->[HANDLE_INPUT], $self->[STATE_READ]);
    }
                                          # undefine the select, just in case
    else {
      $poe_kernel->select_read($self->[HANDLE_INPUT])
    }
  }
  
  #------------------------------------------------------------------------------
  # Redefine events.
  
  sub event {
    my $self = shift;
    push(@_, undef) if (scalar(@_) & 1);
  
    my ($redefine_read, $redefine_write) = (0, 0);
  
    while (@_) {
      my ($name, $event) = splice(@_, 0, 2);
  
      if ($name eq 'InputEvent') {
        $self->[EVENT_INPUT] = $event;
        $redefine_read = 1;
      }
      elsif ($name eq 'ErrorEvent') {
        $self->[EVENT_ERROR] = $event;
        $redefine_read = $redefine_write = 1;
      }
      elsif ($name eq 'FlushedEvent') {
        $self->[EVENT_FLUSHED] = $event;
        $redefine_write = 1;
      }
      elsif ($name eq 'HighEvent') {
        if (defined $self->[WATERMARK_WRITE_MARK_HIGH]) {
          $self->[WATERMARK_WRITE_EVENT_HIGH] = $event;
          $redefine_write = 1;
        }
        else {
          carp "Ignoring HighEvent (there is no high watermark set)";
        }
      }
      elsif ($name eq 'LowEvent') {
        if (defined $self->[WATERMARK_WRITE_MARK_LOW]) {
          $self->[WATERMARK_WRITE_EVENT_LOW] = $event;
          $redefine_write = 1;
        }
        else {
          carp "Ignoring LowEvent (there is no high watermark set)";
        }
      }
      else {
        carp "ignoring unknown ReadWrite parameter '$name'";
      }
    }
  
    $self->_define_read_state()  if $redefine_read;
    $self->_define_write_state() if $redefine_write;
  }
  
  #------------------------------------------------------------------------------
  
  sub DESTROY {
    my $self = shift;
  
    # Turn off the select.  This is a problem if a wheel is being
    # swapped, since it will turn off selects for the other wheel.
    if ($self->[HANDLE_INPUT]) {
      $poe_kernel->select_read($self->[HANDLE_INPUT]);
      $self->[HANDLE_INPUT] = undef;
    }
  
    if ($self->[HANDLE_OUTPUT]) {
      $poe_kernel->select_write($self->[HANDLE_OUTPUT]);
      $self->[HANDLE_OUTPUT] = undef;
    }
  
    if ($self->[STATE_READ]) {
      $poe_kernel->state($self->[STATE_READ]);
      $self->[STATE_READ] = undef;
    }
  
    if ($self->[STATE_WRITE]) {
      $poe_kernel->state($self->[STATE_WRITE]);
      $self->[STATE_WRITE] = undef;
    }
  
    &POE::Wheel::free_wheel_id($self->[UNIQUE_ID]);
  }
  
  #------------------------------------------------------------------------------
  # TODO - We set the high/low watermark state here, but we don't fire
  # events for it.  My assumption is that the return value tells us
  # all we want to know.
  
  sub put {
    my ($self, @chunks) = @_;
  
    my $old_buffered_out_octets = $self->[DRIVER_BUFFERED_OUT_OCTETS];
    my $new_buffered_out_octets =
      $self->[DRIVER_BUFFERED_OUT_OCTETS] =
      $self->[DRIVER_BOTH]->put($self->[FILTER_OUTPUT]->put(\@chunks));
  
    if (
      $self->[AUTOFLUSH] &&
      $new_buffered_out_octets and !$old_buffered_out_octets
    ) {
      $old_buffered_out_octets = $new_buffered_out_octets;
      $self->flush();
      $new_buffered_out_octets = $self->[DRIVER_BUFFERED_OUT_OCTETS];
    }
  
    # Resume write-ok if the output buffer gets data.  This avoids
    # redundant calls to select_resume_write(), which is probably a good
    # thing.
    if ($new_buffered_out_octets and !$old_buffered_out_octets) {
      $poe_kernel->select_resume_write($self->[HANDLE_OUTPUT]);
    }
  
    # If the high watermark has been reached, return true.
    if (
      $self->[WATERMARK_WRITE_MARK_HIGH] and
      $new_buffered_out_octets >= $self->[WATERMARK_WRITE_MARK_HIGH]
    ) {
      return $self->[WATERMARK_WRITE_STATE] = 1;
    }
  
    return $self->[WATERMARK_WRITE_STATE] = 0;
  }
  
  #------------------------------------------------------------------------------
  # Redefine filter. -PG / Now that there are two filters internally,
  # one input and one output, make this set both of them at the same
  # time. -RCC
  
  sub _transfer_input_buffer {
    my ($self, $buf) = @_;
  
    my $old_input_filter = $self->[FILTER_INPUT];
  
    # If the new filter implements "get_one", use that.
    if (
      $old_input_filter->can('get_one') and
      $old_input_filter->can('get_one_start')
    ) {
      if (defined $buf) {
        $self->[FILTER_INPUT]->get_one_start($buf);
        while ($self->[FILTER_INPUT] == $old_input_filter) {
          my $next_rec = $self->[FILTER_INPUT]->get_one();
          last unless @$next_rec;
          foreach my $cooked_input (@$next_rec) {
            $poe_kernel->call(
              $poe_kernel->get_active_session(),
              $self->[EVENT_INPUT],
              $cooked_input, $self->[UNIQUE_ID]
            );
          }
        }
      }
    }
  
    # Otherwise use the old behavior.
    else {
      if (defined $buf) {
        foreach my $cooked_input (@{$self->[FILTER_INPUT]->get($buf)}) {
          $poe_kernel->call(
            $poe_kernel->get_active_session(),
            $self->[EVENT_INPUT],
            $cooked_input, $self->[UNIQUE_ID]
          );
        }
      }
    }
  }
  
  # Set input and output filters.
  
  sub set_filter {
    my ($self, $new_filter) = @_;
    my $buf = $self->[FILTER_INPUT]->get_pending();
    $self->[FILTER_INPUT] = $self->[FILTER_OUTPUT] = $new_filter;
  
    $self->_transfer_input_buffer($buf);
  }
  
  # Redefine input and/or output filters separately.
  sub set_input_filter {
    my ($self, $new_filter) = @_;
    my $buf = $self->[FILTER_INPUT]->get_pending();
    $self->[FILTER_INPUT] = $new_filter;
  
    $self->_transfer_input_buffer($buf);
  }
  
  # No closures need to be redefined or anything.  All the previously
  # put stuff has been serialized already.
  sub set_output_filter {
    my ($self, $new_filter) = @_;
    $self->[FILTER_OUTPUT] = $new_filter;
  }
  
  # Get the current input filter; used for accessing the filter's custom
  # methods, as in: $wheel->get_input_filter()->filter_method();
  sub get_input_filter {
    my $self = shift;
    return $self->[FILTER_INPUT];
  }
  
  # Get the current input filter; used for accessing the filter's custom
  # methods, as in: $wheel->get_input_filter()->filter_method();
  sub get_output_filter {
    my $self = shift;
    return $self->[FILTER_OUTPUT];
  }
  
  # Set the high water mark.
  
  sub set_high_mark {
    my ($self, $new_high_mark) = @_;
  
    unless (defined $self->[WATERMARK_WRITE_MARK_HIGH]) {
      carp "Ignoring high mark (must be initialized in constructor first)";
      return;
    }
  
    unless (defined $new_high_mark) {
      carp "New high mark is undefined.  Ignored";
      return;
    }
  
    unless ($new_high_mark > $self->[WATERMARK_WRITE_MARK_LOW]) {
      carp "New high mark would not be greater than low mark.  Ignored";
      return;
    }
  
    $self->[WATERMARK_WRITE_MARK_HIGH] = $new_high_mark;
    $self->_define_write_state();
  }
  
  sub set_low_mark {
    my ($self, $new_low_mark) = @_;
  
    unless (defined $self->[WATERMARK_WRITE_MARK_LOW]) {
      carp "Ignoring low mark (must be initialized in constructor first)";
      return;
    }
  
    unless (defined $new_low_mark) {
      carp "New low mark is undefined.  Ignored";
      return;
    }
  
    unless ($new_low_mark > 0) {
      carp "New low mark would be less than one.  Ignored";
      return;
    }
  
    unless ($new_low_mark < $self->[WATERMARK_WRITE_MARK_HIGH]) {
      carp "New low mark would not be less than high high mark.  Ignored";
      return;
    }
  
    $self->[WATERMARK_WRITE_MARK_LOW] = $new_low_mark;
    $self->_define_write_state();
  }
  
  # Return driver statistics.
  sub get_driver_out_octets {
    $_[0]->[DRIVER_BUFFERED_OUT_OCTETS];
  }
  
  sub get_driver_out_messages {
    $_[0]->[DRIVER_BOTH]->get_out_messages_buffered();
  }
  
  # Get the wheel's ID.
  sub ID {
    return $_[0]->[UNIQUE_ID];
  }
  
  # Pause the wheel's input watcher.
  sub pause_input {
    my $self = shift;
    return unless defined $self->[HANDLE_INPUT];
    $poe_kernel->select_pause_read( $self->[HANDLE_INPUT] );
  }
  
  # Resume the wheel's input watcher.
  sub resume_input {
    my $self = shift;
    return unless  defined $self->[HANDLE_INPUT];
    $poe_kernel->select_resume_read( $self->[HANDLE_INPUT] );
  }
  
  # Return the wheel's input handle
  sub get_input_handle {
    my $self = shift;
    return $self->[HANDLE_INPUT];
  }
  
  # Return the wheel's output handle
  sub get_output_handle {
    my $self = shift;
    return $self->[HANDLE_OUTPUT];
  }
  
  # Shutdown the socket for reading.
  sub shutdown_input {
    my $self = shift;
    return unless defined $self->[HANDLE_INPUT];
    eval { local $^W = 0; shutdown($self->[HANDLE_INPUT], 0) };
    $poe_kernel->select_read($self->[HANDLE_INPUT], undef);
  }
  
  # Shutdown the socket for writing.
  sub shutdown_output {
    my $self = shift;
    return unless defined $self->[HANDLE_OUTPUT];
    eval { local $^W=0; shutdown($self->[HANDLE_OUTPUT], 1) };
    $poe_kernel->select_write($self->[HANDLE_OUTPUT], undef);
  }
  
  # Flush the output handle
  sub flush {
    my $self = shift;
    return unless defined $self->[HANDLE_OUTPUT];
    $poe_kernel->call($poe_kernel->get_active_session(),
          $self->[STATE_WRITE], $self->[HANDLE_OUTPUT]);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Wheel::ReadWrite - non-blocking buffered I/O mix-in for POE::Session
  
  =head1 SYNOPSIS
  
    #!perl
  
    use warnings;
    use strict;
  
    use IO::Socket::INET;
    use POE qw(Wheel::ReadWrite);
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          # Note: IO::Socket::INET will block.  We recommend
          # POE::Wheel::SocketFactory or POE::Component::Client::TCP if
          # blocking is contraindicated.
          $_[HEAP]{client} = POE::Wheel::ReadWrite->new(
            Handle => IO::Socket::INET->new(
              PeerHost => 'www.yahoo.com',
              PeerPort => 80,
            ),
            InputEvent => 'on_remote_data',
            ErrorEvent => 'on_remote_fail',
          );
  
          print "Connected.  Sending request...\n";
          $_[HEAP]{client}->put(
            "GET / HTTP/0.9",
            "Host: www.yahoo.com",
            "",
          );
        },
        on_remote_data => sub {
          print "Received: $_[ARG0]\n";
        },
        on_remote_fail => sub {
          print "Connection failed or ended.  Shutting down...\n";
          delete $_[HEAP]{client};
        },
      },
    );
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Wheel::ReadWrite encapsulates a common design pattern: dealing
  with buffered I/O in a non-blocking, event driven fashion.
  
  The pattern goes something like this:
  
  Given a filehandle, watch it for incoming data.  When notified of
  incoming data, read it, buffer it, and parse it according to some
  low-level protocol (such as line-by-line).  Generate higher-level
  "here be lines" events, one per parsed line.
  
  In the other direction, accept whole chunks of data (such as lines)
  for output.  Reformat them according to some low-level protocol (such
  as by adding newlines), and buffer them for output.  Flush the
  buffered data when the filehandle is ready to transmit it.
  
  =head1 PUBLIC METHODS
  
  =head2 Constructor
  
  POE::Wheel subclasses tend to perform a lot of setup so that they run
  lighter and faster.  POE::Wheel::ReadWrite's constructor is no
  exception.
  
  =head3 new
  
  new() creates and returns a new POE:Wheel::ReadWrite instance.  Under
  most circumstances, the wheel will continue to read/write to one or
  more filehandles until it's destroyed.
  
  =head4 Handle
  
  Handle defines the filehandle that a POE::Wheel::ReadWrite object will
  read from and write to.  The L</SYNOPSIS> includes an example using
  Handle.
  
  A single POE::Wheel::ReadWrite object can read from and write to different
  filehandles.  See L</InputHandle> for more information and an example.
  
  =head4 InputHandle
  
  InputHandle and OutputHandle may be used to specify different handles
  for input and output.  For example, input may be from STDIN and output
  may go to STDOUT:
  
    $_[HEAP]{console} = POE::Wheel::ReadWrite->new(
      InputHandle => \*STDIN,
      OutputHandle => \*STDOUT,
      InputEvent => "console_input",
    );
  
  InputHandle and OutputHandle may not be used with Handle.
  
  =head4 OutputHandle
  
  InputHandle and OutputHandle may be used to specify different handles
  for input and output.  Please see L</InputHandle> for more information
  and an example.
  
  =head4 Driver
  
  Driver specifies how POE::Wheel::ReadWrite will actually read from and
  write to its filehandle or filehandles.  Driver must be an object that
  inherits from L<POE::Driver>.
  
  L<POE::Driver::SysRW>, which implements sysread() and syswrite(), is the
  default.  It's used in nearly all cases, so there's no point in
  specifying it.
  
  =for comment
  TODO - Example.
  
  =head4 Filter
  
  Filter is the parser that POE::Wheel::ReadWrite will used to recognize
  input data and the serializer it uses to prepare data for writing.  It
  defaults to a new L<POE::Filter::Line> instance since many network
  protocols are line based.
  
  =for comment
  TODO - Example.
  
  =head4 InputFilter
  
  InputFilter and OutputFilter may be used to specify different filters
  for input and output.
  
  =for comment
  TODO - Example.
  
  =head4 OutputFilter
  
  InputFilter and OutputFilter may be used to specify different filters
  for input and output. Please see L</InputFilter> for more information
  and an example.
  
  =head4 InputEvent
  
  InputEvent specifies the name of the event that will be sent for every
  complete input unit (as parsed by InputFilter or Filter).
  
  Every input event includes two parameters:
  
  C<ARG0> contains the parsed input unit, and C<ARG1> contains the
  unique ID for the POE::Wheel::ReadWrite object that generated the
  event.
  
  InputEvent is optional.  If omitted, the POE::Wheel::ReadWrite object
  will not watch its Handle or InputHandle for input, and no input
  events will be generated.
  
  A sample InputEvent handler:
  
    sub handle_input {
      my ($heap, $input, $wheel_id) = @_[HEAP, ARG0, ARG1];
      print "Echoing input from wheel $wheel_id: $input\n";
      $heap->{wheel}->put($input); # Put... the input... beck!
    }
  
  =head4 FlushedEvent
  
  FlushedEvent specifies the event that a POE::Wheel::ReadWrite object
  will emit whenever its output buffer transitions from containing data
  to becoming empty.
  
  FlushedEvent comes with a single parameter: C<ARG0> contains the
  unique ID for the POE::Wheel::ReadWrite object that generated the
  event.  This may be used to match the event to a particular wheel.
  
  "Flushed" events are often used to shut down I/O after a "goodbye"
  message has been sent.  For example, the following input_handler()
  responds to "quit" by instructing the wheel to say "Goodbye." and then
  to send a "shutdown" event when that has been flushed to the socket.
  
    sub handle_input {
      my ($input, $wheel_id) = @_[ARG0, ARG1];
      my $wheel = $_[HEAP]{wheel}{$wheel_id};
  
      if ($input eq "quit") {
        $wheel->event( FlushedEvent => "shutdown" );
        $wheel->put("Goodbye.");
      }
      else {
        $wheel->put("Echo: $input");
      }
    }
  
  Here's the shutdown handler.  It just destroys the wheel to end the
  connection:
  
    sub handle_flushed {
      my $wheel_id = $_[ARG0];
      delete $_[HEAP]{wheel}{$wheel_id};
    }
  
  =head4 ErrorEvent
  
  ErrorEvent names the event that a POE::Wheel::ReadWrite object will
  emit whenever an error occurs.  Every ErrorEvent includes four
  parameters:
  
  C<ARG0> describes what failed, either "read" or "write".  It doesn't
  name a particular function since POE::Wheel::ReadWrite delegates
  actual reading and writing to a L<POE::Driver> object.
  
  C<ARG1> and C<ARG2> hold numeric and string values for C<$!> at the
  time of failure.  Applicatin code cannot test C<$!> directly since its
  value may have changed between the time of the error and the time the
  error event is dispatched.
  
  C<ARG3> contains the wheel's unique ID.  The wheel's ID is used to
  differentiate between many wheels managed by a single session.
  
  ErrorEvent may also indicate EOF on a FileHandle by returning
  operation "read" error 0.  For sockets, this means the remote end has
  closed the connection.
  
  A sample ErrorEvent handler:
  
    sub error_state {
      my ($operation, $errnum, $errstr, $id) = @_[ARG0..ARG3];
      if ($operation eq "read" and $errnum == 0) {
        print "EOF from wheel $id\n";
      }
      else {
        warn "Wheel $id encountered $operation error $errnum: $errstr\n";
      }
      delete $_[HEAP]{wheels}{$id}; # shut down that wheel
    }
  
  =head4 HighEvent
  
  HighEvent and LowEvent are used along with HighMark and LowMark to
  control the flow of streamed output.
  
  A HighEvent is sent when the output buffer of a POE::Wheel::ReadWrite
  object exceeds a certain size (the "high water" mark, or HighMark).
  This advises an application to stop streaming output.  POE and Perl
  really don't care if the application continues, but it's possible that
  the process may run out of memory if a buffer grows without bounds.
  
  A POE::Wheel::ReadWrite object will continue to flush its buffer even
  after an application stops streaming data, until the buffer is empty.
  Some streaming applications may require the buffer to always be primed
  with data, however.  For example, a media server would encounter
  stutters if it waited for a FlushedEvent before sending more data.
  
  LowEvent solves the stutter problem.  A POE::Wheel::ReadWrite object
  will send a LowEvent when its output buffer drains below a certain
  level (the "low water" mark, or LowMark).  This notifies an
  application that the buffer is small enough that it may resume
  streaming.
  
  The stutter problem is solved because the output buffer never quite
  reaches empty.
  
  HighEvent and LowEvent are edge-triggered, not level-triggered.  This
  means they are emitted once whenever a POE::Wheel::ReadWrite object's
  output buffer crosses the HighMark or LowMark.  If an application
  continues to put() data after the HighMark is reached, it will not
  cause another HighEvent to be sent.
  
  HighEvent is generally not needed.  The put() method will return the
  high watermark state: true if the buffer is at or above the high
  watermark, or false if the buffer has room for more data.  Here's a
  quick way to prime a POE::Wheel::ReadWrite object's output buffer:
  
    1 while not $_[HEAP]{readwrite}->put(get_next_data());
  
  POE::Wheel::ReadWrite objects always start in a low-water state.
  
  HighEvent and LowEvent are optional.  Omit them if flow control is not
  needed.
  
  =head4 LowEvent
  
  HighEvent and LowEvent are used along with HighMark and LowMark to
  control the flow of streamed output.  Please see L</HighEvent> for
  more information and examples.
  
  =for comment
  TODO - Example here.
  
  =head2 put RECORDS
  
  put() accepts a list of RECORDS, which will be serialized by the
  wheel's Filter and buffered and written by its Driver.
  
  put() returns true if a HighMark has been set and the Driver's output
  buffer has reached or exceeded the limit.  False is returned if
  HighMark has not been set, or if the Driver's buffer is smaller than
  that limit.
  
  put()'s return value is purely advisory; an application may continue
  buffering data beyond the HighMark---at the risk of exceeding the
  process' memory limits.  Do not use C<<1 while not $wheel->put()>>
  syntax if HighMark isn't set: the application will fail spectacularly!
  
  =head2 event EVENT_TYPE => EVENT_NAME, ...
  
  event() allows an application to modify the events emitted by a
  POE::Wheel::ReadWrite object.  All constructor parameters ending in
  "Event" may be changed at run time: L</InputEvent>, L</FlushedEvent>,
  L</ErrorEvent>, L</HighEvent>, and L</LowEvent>.
  
  Setting an event to undef will disable the code within the wheel that
  generates the event.  So for example, stopping InputEvent will also
  stop reading from the filehandle.  L</pause_input> and
  L</resume_input> may be a better way to manage input events, however.
  
  =for comment
  TODO - Example.
  
  =head2 set_filter POE_FILTER
  
  set_filter() changes the way a POE::Wheel::ReadWrite object parses
  input and serializes output.  Any pending data that has not been
  dispatched to the application will be parsed with the new POE_FILTER.
  Information that has been put() but not flushed will not be
  reserialized.
  
  set_filter() performs the same act as calling set_input_filter()
  and set_output_filter() with the same POE::Filter object.
  
  Switching filters can be tricky.  Please see the discussion of
  get_pending() in L<POE::Filter>.  Some filters may not support being
  dynamically loaded or unloaded.
  
  =for comment
  TODO - Example.
  
  =head2 set_input_filter POE_FILTER
  
  set_input_filter() changes a POE::Wheel::ReadWrite object's input
  filter while leaving the output filter unchanged.  This alters the way
  data is parsed without affecting how it's serialized for output.
  
  =for comment
  TODO - Example.
  
  =head2 set_output_filter POE_FILTER
  
  set_output_filter() changes how a POE::Wheel::ReadWrite object
  serializes its output but does not affect the way data is parsed.
  
  =for comment
  TODO - Example.
  
  =head2 get_input_filter
  
  get_input_filter() returns the POE::Filter object currently used by a
  POE::Wheel::ReadWrite object to parse incoming data.  The returned
  object may be introspected or altered via its own methods.
  
  There is no get_filter() method because there is no sane return value
  when input and output filters differ.
  
  =for comment
  TODO - Example.
  
  =head2 get_output_filter
  
  get_output_filter() returns the L<POE::Filter> object currently used by a
  POE::Wheel::ReadWrite object to serialize outgoing data.  The returned
  object may be introspected or altered via its own methods.
  
  There is no get_filter() method because there is no sane return value
  when input and output filters differ.
  
  =for comment
  TODO - Example.
  
  =head2 set_high_mark HIGH_MARK_OCTETS
  
  Sets the high water mark---the number of octets that designates a
  "full enough" output buffer.  A POE::Wheel::ReadWrite object will emit
  a HighEvent when its output buffer expands to reach this point.  All
  put() calls will return true when the output buffer is equal or
  greater than HIGH_MARK_OCTETS.
  
  Both HighEvent and put() indicate that it's unsafe to continue writing
  when the output buffer expands to at least HIGH_MARK_OCTETS.
  
  =for comment
  TODO - Example.
  
  =head2 set_low_mark LOW_MARK_OCTETS
  
  Sets the low water mark---the number of octets that designates an
  "empty enough" output buffer.  This event lets an application know
  that it's safe to resume writing again.
  
  POE::Wheel::ReadWrite objects will emit a LowEvent when their output
  buffers shrink to LOW_MARK_OCTETS after having reached
  HIGH_MARK_OCTETS.
  
  =for comment
  TODO - Example.
  
  =head2 ID
  
  ID() returns a POE::Wheel::ReadWrite object's unique ID.  ID() is
  usually called after the object is created so that the object may be
  stashed by its ID.  Events generated by the POE::Wheel::ReadWrite
  object will include the ID of the object, so that they may be matched
  back to their sources.
  
  =for comment
  TODO - Example.
  
  =head2 pause_input
  
  pause_input() instructs a POE::Wheel::ReadWrite object to stop
  watching for input, and thus stop emitting InputEvent events.  It's
  much more efficient than destroying the object outright, especially if
  an application intends to resume_input() later.
  
  =for comment
  TODO - Example.
  
  =head2 resume_input
  
  resume_input() turns a POE::Wheel::ReadWrite object's input watcher
  back on.  It's used to resume watching for input, and thus resume
  sending InputEvent events.  pause_input() and resume_input() implement
  a form of input flow control, driven by the application itself.
  
  =for comment
  TODO - Example.
  
  =head2 get_input_handle
  
  get_input_handle() returns the filehandle being watched for input.
  
  Manipulating filehandles that are managed by POE may cause nasty side
  effects, which may change from one POE release to the next.  Please
  use caution.
  
  =for comment
  TODO - Example.
  
  =head2 get_output_handle
  
  get_output_handle() returns the filehandle being watched for output.
  
  Manipulating filehandles that are managed by POE may cause nasty side
  effects, which may change from one POE release to the next.  Please
  use caution.
  
  =for comment
  TODO - Example.
  
  =head2 shutdown_input
  
  Call shutdown($fh,0) on a POE::Wheel::ReadWrite object's input
  filehandle.  This only works for sockets; nothing will happen for
  other types of filehandle.
  
  Occasionally, the POE::Wheel::ReadWrite object will stop monitoring
  its input filehandle for new data.  This occurs regardless of the
  filehandle type.
  
  =for comment
  TODO - Example.
  
  =head2 shutdown_output
  
  Call shutdown($fh,1) on a POE::Wheel::ReadWrite object's output
  filehandle.  This only works for sockets; nothing will happen for
  other types of filehandle.
  
  Occasionally, the POE::Wheel::ReadWrite object will stop monitoring its
  output filehandle for new data. This occurs regardless of the
  filehandle type.
  
  =for comment
  TODO - Example.
  
  =head2 get_driver_out_octets
  
  L<POE::Driver> objects contain output buffers that are flushed
  asynchronously.  get_driver_out_octets() returns the number of octets
  remaining in the wheel's driver's output buffer.
  
  =for comment
  TODO - Example.
  
  =head2 get_driver_out_messages
  
  L<POE::Driver> objects' output buffers may be message based.  Every put()
  call may be buffered individually.  get_driver_out_messages() will
  return the number of pending put() messages that remain to be sent.
  
  Stream-based drivers will simply return 1 if any data remains to be
  flushed.  This is because they operate with one potentially large
  message.
  
  =for comment
  TODO - Example.
  
  =head2 flush
  
  flush() manually attempts to flush a wheel's output in a synchronous
  fashion.  This can be used to flush small messages.  Note, however,
  that complete flushing is not guaranteed---to do so would mean
  potentially blocking indefinitely, which is undesirable in most POE
  applications.
  
  If an application must guarantee a full buffer flush, it may loop
  flush() calls:
  
    $wheel->flush() while $wheel->get_driver_out_octets();
  
  However it would be prudent to check for errors as well.  A flush()
  failure may be permanent, and an infinite loop is probably not what
  most developers have in mind here.
  
  It should be obvious by now that B<this method is experimental>.  Its
  behavior may change or it may disappear outright.  Please let us know
  whether it's useful.
  
  =for comment
  TODO - Example?
  
  =head1 SEE ALSO
  
  L<POE::Wheel> describes wheels in general.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 BUGS
  
  None known.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_WHEEL_READWRITE

$fatpacked{"POE/Wheel/Run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_WHEEL_RUN';
  package POE::Wheel::Run;
  
  use strict;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw(carp croak);
  use POSIX qw(
    sysconf setsid _SC_OPEN_MAX ECHO ICANON IEXTEN ISIG BRKINT ICRNL
    INPCK ISTRIP IXON CSIZE PARENB OPOST TCSANOW
  );
  
  use POE qw( Wheel Pipe::TwoWay Pipe::OneWay Driver::SysRW Filter::Line );
  push @ISA, qw(POE::Wheel);
  
  # http://rt.cpan.org/Ticket/Display.html?id=50068
  # Avoid using these constants in Windows' subprocesses (actually
  # interpreter threads).  Reported in the above ticket to avoid a
  # memory leak.
  my ($STD_INPUT_HANDLE, $STD_OUTPUT_HANDLE, $STD_ERROR_HANDLE);
  
  BEGIN {
    die "$^O does not support fork()\n" if $^O eq 'MacOS';
  
    local $SIG{'__DIE__'} = 'DEFAULT';
    eval    { require IO::Pty; };
    if ($@) {
      eval '
        sub PTY_AVAILABLE () { 0 }
        sub TIOCSWINSZ_AVAILABLE () { 0 }
      ';
    }
    else {
      IO::Pty->import();
      eval 'sub PTY_AVAILABLE () { 1 }';
  
      eval { require IO::Tty; };
      if ($@) {
        eval 'sub TIOCSWINSZ_AVAILABLE () { 0 }';
      }
      else {
        IO::Tty->import('TIOCSWINSZ');
        eval 'sub TIOCSWINSZ_AVAILABLE () { 1 }';
      }
    }
  
    if (POE::Kernel::RUNNING_IN_HELL) {
      eval    { require Win32::Console; Win32::Console->import() };
      if ($@) { die "Win32::Console needed for POE::Wheel::Run on $^O:\n$@" }
  
      eval    {
        require Win32API::File;
        Win32API::File->import("FdGetOsFHandle");
      };
      if ($@) { die "Win32API::File needed for POE::Wheel::Run on $^O:\n$@" }
  
      eval    { require Win32::Process; Win32::Process->import() };
      if ($@) { die "Win32::Process needed for POE::Wheel::Run on $^O:\n$@" }
  
      eval    { require Win32::Job; Win32::Job->import() };
      if ($@) { die "Win32::Job needed for POE::Wheel::Run on $^O:\n$@" }
  
      eval    { require Win32; Win32->import() };
      if ($@) { die "Win32.pm needed for POE::Wheel::Run on $^O:\n$@" }
  
      $STD_INPUT_HANDLE  = STD_INPUT_HANDLE();
      $STD_OUTPUT_HANDLE = STD_OUTPUT_HANDLE();
      $STD_ERROR_HANDLE  = STD_ERROR_HANDLE();
    }
  
    # Determine the most file descriptors we can use.
    my $max_open_fds;
    eval {
      $max_open_fds = sysconf(_SC_OPEN_MAX);
    };
    $max_open_fds = 1024 unless $max_open_fds;
    eval "sub MAX_OPEN_FDS () { $max_open_fds }";
    die if $@;
  };
  
  # Offsets into $self.
  sub UNIQUE_ID     () {  0 }
  sub ERROR_EVENT   () {  1 }
  sub CLOSE_EVENT   () {  2 }
  sub PROGRAM       () {  3 }
  sub CHILD_PID     () {  4 }
  sub CONDUIT_TYPE  () {  5 }
  sub IS_ACTIVE     () {  6 }
  sub CLOSE_ON_CALL () {  7 }
  sub STDIO_TYPE    () {  8 }
  
  sub HANDLE_STDIN  () {  9 }
  sub FILTER_STDIN  () { 10 }
  sub DRIVER_STDIN  () { 11 }
  sub EVENT_STDIN   () { 12 }
  sub STATE_STDIN   () { 13 }
  sub OCTETS_STDIN  () { 14 }
  
  sub HANDLE_STDOUT () { 15 }
  sub FILTER_STDOUT () { 16 }
  sub DRIVER_STDOUT () { 17 }
  sub EVENT_STDOUT  () { 18 }
  sub STATE_STDOUT  () { 19 }
  
  sub HANDLE_STDERR () { 20 }
  sub FILTER_STDERR () { 21 }
  sub DRIVER_STDERR () { 22 }
  sub EVENT_STDERR  () { 23 }
  sub STATE_STDERR  () { 24 }
  
  sub MSWIN32_GROUP_PID () { 25 }
  
  # Used to work around a bug in older perl versions.
  sub CRIMSON_SCOPE_HACK ($) { 0 }
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
    croak "$type needs an even number of parameters" if @_ & 1;
    my %params = @_;
  
    croak "wheels no longer require a kernel reference as their first parameter"
      if @_ and ref($_[0]) eq 'POE::Kernel';
  
    croak "$type requires a working Kernel" unless defined $poe_kernel;
  
    my $program = delete $params{Program};
    croak "$type needs a Program parameter" unless defined $program;
  
    my $prog_args = delete $params{ProgramArgs};
    $prog_args = [] unless defined $prog_args;
    croak "ProgramArgs must be an ARRAY reference"
      unless ref($prog_args) eq "ARRAY";
  
    my $priority_delta = delete $params{Priority};
    $priority_delta = 0 unless defined $priority_delta;
  
    my $close_on_call = delete $params{CloseOnCall};
    $close_on_call = 0 unless defined $close_on_call;
  
    my $user_id  = delete $params{User};
    my $group_id = delete $params{Group};
  
    # The following $stdio_type is new.  $conduit is kept around for now
    # to preserve the logic of the rest of the module.  This change
    # allows a Session using POE::Wheel::Run to define the type of pipe
    # to be created for stdin and stdout.  Read the POD on Conduit.
    # However, the documentation lies, because if Conduit is undefined,
    # $stdio_type is set to undefined (so the default pipe type provided
    # by POE::Pipe::TwoWay will be used). Otherwise, $stdio_type
    # determines what type of pipe Pipe:TwoWay creates unless it's
    # 'pty'.
  
    my $conduit = delete $params{Conduit};
    my $stdio_type;
    if (defined $conduit) {
      croak "$type\'s Conduit type ($conduit) is unknown" if (
        $conduit ne 'pipe' and
        $conduit ne 'pty'  and
        $conduit ne 'pty-pipe' and
        $conduit ne 'socketpair' and
        $conduit ne 'inet'
      );
      unless ($conduit =~ /^pty(-pipe)?$/) {
        $stdio_type = $conduit;
        $conduit = "pipe";
      }
    }
    else {
      $conduit = "pipe";
    }
  
    my $winsize = delete $params{Winsize};
  
    if ($winsize) {
      carp "winsize can only be specified for a Conduit of type pty"
        if $conduit !~ /^pty(-pipe)?$/ and $winsize;
  
      if( 'ARRAY' eq ref $winsize and 2==@$winsize ) {
          # Standard VGA cell in 9x16
          # http://en.wikipedia.org/wiki/VGA-compatible_text_mode#Fonts
          $winsize->[2] = $winsize->[1]*9;
          $winsize->[3] = $winsize->[0]*16;
      }
      carp "winsize must be a 4 element arrayref" unless ref($winsize) eq 'ARRAY'
        and scalar @$winsize == 4;
  
      carp "winsize only works when IO::Tty::TIOCSWINSZ is"
        unless TIOCSWINSZ_AVAILABLE;
    }
  
    my $stdin_event  = delete $params{StdinEvent};
    my $stdout_event = delete $params{StdoutEvent};
    my $stderr_event = delete $params{StderrEvent};
  
    if ($conduit eq 'pty' and defined $stderr_event) {
      carp "ignoring StderrEvent with pty conduit";
      undef $stderr_event;
    }
  
    #croak "$type needs at least one of StdinEvent, StdoutEvent or StderrEvent"
    #  unless (defined($stdin_event) or defined($stdout_event) or defined ($stderr_event));
  
    my $stdio_driver  = delete $params{StdioDriver}  || POE::Driver::SysRW->new();
    my $stdin_driver  = delete $params{StdinDriver}  || $stdio_driver;
    my $stdout_driver = delete $params{StdoutDriver} || $stdio_driver;
    my $stderr_driver = delete $params{StderrDriver} || POE::Driver::SysRW->new();
  
    my $stdio_filter  = delete $params{Filter};
    my $stdin_filter  = delete $params{StdinFilter};
    my $stdout_filter = delete $params{StdoutFilter};
    my $stderr_filter = delete $params{StderrFilter};
  
    #For optional redirection...
    my $redir_err     = delete $params{RedirectStderr};
    my $redir_out     = delete $params{RedirectStdout};
    my $redir_in      = delete $params{RedirectStdin};
    my $redir_output  = delete $params{RedirectOutput};
  
    my $no_stdin      = delete $params{NoStdin};
  
    if(defined $redir_output) {
      $redir_out = $redir_err = $redir_output;
    }
  
    #Sanity check. We can't wait for redirected filehandles
    if( (defined $redir_in and defined $stdin_event) ||
       (defined $redir_out and defined $stdout_event) ||
       (defined $redir_err and defined $stderr_event) ) {
      croak("Redirect* and *Event stdio options are mutually exclusive");
    }
  
    if (defined $stdio_filter) {
      croak "Filter and StdioFilter cannot be used together"
        if defined $params{StdioFilter};
      croak "Replace deprecated Filter with StdioFilter and StderrFilter"
        if defined $stderr_event and not defined $stderr_filter;
      carp "Filter is deprecated.  Please try StdioFilter and/or StderrFilter";
    }
    else {
      $stdio_filter = delete $params{StdioFilter};
    }
    $stdio_filter = POE::Filter::Line->new(Literal => "\n")
      unless defined $stdio_filter;
  
    $stdin_filter  = $stdio_filter unless defined $stdin_filter;
    $stdout_filter = $stdio_filter unless defined $stdout_filter;
  
    if ($conduit eq 'pty' and defined $stderr_filter) {
      carp "ignoring StderrFilter with pty conduit";
      undef $stderr_filter;
    }
    else {
      $stderr_filter = POE::Filter::Line->new(Literal => "\n")
        unless defined $stderr_filter;
    }
  
    croak "$type needs either StdioFilter or StdinFilter when using StdinEvent"
      if defined($stdin_event) and not defined($stdin_filter);
    croak "$type needs either StdioFilter or StdoutFilter when using StdoutEvent"
      if defined($stdout_event) and not defined($stdout_filter);
    croak "$type needs a StderrFilter when using StderrEvent"
      if defined($stderr_event) and not defined($stderr_filter);
  
    my $error_event = delete $params{ErrorEvent};
    my $close_event = delete $params{CloseEvent};
  
    my $no_setsid = delete $params{NoSetSid};
    my $no_setpgrp = delete $params{NoSetPgrp};
  
    # Make sure the user didn't pass in parameters we're not aware of.
    if (scalar keys %params) {
      carp(
        "unknown parameters in $type constructor call: ",
        join(', ', sort keys %params)
      );
    }
  
    # Did the user mangle stdio?
    unless (ref($program) eq 'CODE') {
      croak "Someone has closed or moved STDIN... exec() won't find it"
        unless defined fileno(STDIN) && fileno(STDIN) == 0;
      croak "Someone has closed or moved STDOUT... exec() won't find it"
        unless tied(*STDOUT) || defined fileno(STDOUT) && fileno(STDOUT) == 1;
      croak "Someone has closed or moved STDERR... exec() won't find it"
        unless tied(*STDERR) || defined fileno(STDERR) && fileno(STDERR) == 2;
    }
  
    my (
      $stdin_read, $stdout_write, $stdout_read, $stdin_write,
      $stderr_read, $stderr_write,
    );
  
    _filespec_to_fh(\$stdin_read, "<", $redir_in);
    if($redir_output) {
      _filespec_to_fh(\$stdout_write, ">", $redir_output);
      _filespec_to_fh(\$stderr_write, ">", $stdout_write);
    } else {
      _filespec_to_fh(\$stdout_write, ">", $redir_out);
      _filespec_to_fh(\$stderr_write, ">", $redir_err);
    }
  
    # Create a semaphore pipe.  This is used so that the parent doesn't
    # begin listening until the child's stdio has been set up.
  
    my ($sem_pipe_read, $sem_pipe_write) = POE::Pipe::OneWay->new();
    croak "could not create semaphore pipe: $!" unless defined $sem_pipe_read;
  
    # Use IO::Pty if requested.  IO::Pty turns on autoflush for us.
  
    if(defined $stdout_event
       or defined $stdin_event
       or defined $stderr_event
       or (!$no_stdin))
    #Bypass all the conduit handling if the user does not care for child I/O
    {
      if ($conduit =~ /^pty(-pipe)?$/) {
        croak "IO::Pty is not available" unless PTY_AVAILABLE;
  
        if(defined $redir_err or defined $redir_in or defined $redir_out) {
          croak "Redirection with pty conduit is unsupported";
        }
  
        $stdin_write = $stdout_read = IO::Pty->new();
        croak "could not create master pty: $!" unless defined $stdout_read;
        if ($conduit eq "pty-pipe") {
          ($stderr_read, $stderr_write) = POE::Pipe::OneWay->new();
          croak "could not make stderr pipes: $!"
            unless defined $stderr_read and defined $stderr_write;
        }
      }
  
      # Use pipes otherwise.
      elsif ($conduit eq 'pipe') {
        # We make more pipes than strictly necessary in case someone wants
        # to turn some on later.  Uses a TwoWay pipe for STDIN/STDOUT and
        # a OneWay pipe for STDERR.  This may save 2 filehandles if
        # socketpair() is available and no other $stdio_type is selected.
  
        foreach (
          [\$redir_out, \$stdout_read, \$stdout_write, $stdout_event, "stdout"],
          [\$redir_err, \$stderr_read, \$stderr_write, $stderr_event, "stderr"],
          [\$redir_in, \$stdin_read, \$stdin_write, $stdin_event, "stdin"]
          ) {
          my ($redir_ref,$rfd_ref,$wfd_ref,$evname, $prettyprint) = @$_;
          if(defined $evname && (!defined $$redir_ref)) {
            ($$rfd_ref,$$wfd_ref) = POE::Pipe::OneWay->new();
            croak "could not make $prettyprint pipe: $!"
              unless defined $$rfd_ref and defined $$wfd_ref;
          }
        }
        unless (defined($redir_in) or $no_stdin) {
          ($stdin_read, $stdin_write) = POE::Pipe::OneWay->new();
          croak "could not make stdin pipe $!"
            unless defined $stdin_write and defined $stdin_read;
        }
      }
  
      # Sanity check.
      else {
        croak "unknown conduit type $conduit";
      }
    }
  
    # Block signals until safe
    my $must_unmask;
    if( $poe_kernel->can( '_data_sig_mask_all' ) ) {
      $poe_kernel->_data_sig_mask_all;
      $must_unmask = 1;
    }
  
    # Fork!  Woo-hoo!
    my $pid = fork;
  
    # Child.  Parent side continues after this block.
    unless ($pid) {
      # removed the croak because it wasn't "safe" RT#56417
      #croak "couldn't fork: $!" unless defined $pid;
      # ANY OTHER DIE/CROAK/EXIT/WHATEVER in the child MUST use the helper!
      __PACKAGE__->_warn_and_exit_child( "couldn't fork: $!", int( $! ) )
        unless defined $pid;
  
      # Stdio should not be tied.  Resolves rt.cpan.org ticket 1648.
      if (tied *STDIN) {
        carp "Cannot redirect out of tied STDIN.  Untying it";
        untie *STDIN;
      }
  
      if (tied *STDOUT) {
        carp "Cannot redirect into tied STDOUT.  Untying it";
        untie *STDOUT;
      }
  
      if (tied *STDERR) {
        carp "Cannot redirect into tied STDERR.  Untying it";
        untie *STDERR;
      }
  
      # If running pty, we delay the slave side creation 'til after
      # doing the necessary bits to become our own [unix] session.
      if ($conduit =~ /^pty(-pipe)?$/) {
  
        # Become a new unix session.
        # Program 19.3, APITUE.  W. Richard Stevens built my hot rod.
        eval 'setsid()' unless $no_setsid;
  
        # Acquire a controlling terminal.  Program 19.3, APITUE.
        $stdin_write->make_slave_controlling_terminal();
  
        # Open the slave side of the pty.
        $stdin_read = $stdout_write = $stdin_write->slave();
        __PACKAGE__->_warn_and_exit_child( "could not create slave pty: $!", int( $! ) )
          unless defined $stdin_read;
  
        # For a simple pty conduit, stderr is wedged into stdout.
        $stderr_write = $stdout_write if $conduit eq 'pty';
  
        # Put the pty conduit (slave side) into "raw" or "cbreak" mode,
        # per APITUE 19.4 and 11.10.
        $stdin_read->set_raw();
  
        if (TIOCSWINSZ_AVAILABLE) {
          if ($winsize) {
            ioctl($stdin_read, TIOCSWINSZ, pack('vvvv', @$winsize));
          }
        }
        else {
          # Set the pty conduit (slave side) window size to our window
          # size.  APITUE 19.4 and 19.5.
  
          eval { $stdin_read->clone_winsize_from(\*STDIN) } if -T STDIN;
        }
      }
      else {
        # TODO - Can this be block eval?  Or a do{} block?
        eval 'setpgrp(0,0)' unless $no_setpgrp;
      }
  
      # Reset all signals in the child process.  POE's own handlers are
      # silly to keep around in the child process since POE won't be
      # using them.
      my @safe_signals = $poe_kernel->_data_sig_get_safe_signals();
      @SIG{@safe_signals} = ("DEFAULT") x @safe_signals;
      $poe_kernel->_data_sig_unmask_all if $must_unmask;
  
      # TODO How to pass events to the parent process?  Maybe over a
      # expedited (OOB) filehandle.
  
      # Fix the child process' priority.  Don't bother doing this if it
      # wasn't requested.  Can't emit events on failure because we're in
      # a separate process, so just fail quietly.
  
      if ($priority_delta) {
        eval {
          if (defined(my $priority = getpriority(0, $$))) {
            unless (setpriority(0, $$, $priority + $priority_delta)) {
              # TODO can't set child priority
            }
          }
          else {
            # TODO can't get child priority
          }
        };
        if ($@) {
          # TODO can't get child priority
        }
      }
  
      # Fix the group ID.  TODO Add getgrnam so group IDs can be
      # specified by name.  TODO Warn if not superuser to begin with.
      if (defined $group_id) {
        $( = $) = $group_id;
      }
  
      # Fix the user ID.  TODO Add getpwnam so user IDs can be specified
      # by name.  TODO Warn if not superuser to begin with.
      if (defined $user_id) {
        $< = $> = $user_id;
      }
  
      # Close what the child won't need.
      close $stdin_write if defined $stdin_write;
      close $stdout_read if defined $stdout_read;
      close $stderr_read if defined $stderr_read;
  
      if (POE::Kernel::RUNNING_IN_HELL) {
        __PACKAGE__->_redirect_child_stdio_in_hell(
          $stdin_read, $stdout_write, $stderr_write
        );
      }
  
      else {
        __PACKAGE__->_redirect_child_stdio_sanely(
          $stdin_read, $stdout_write, $stderr_write
        );
      }
  
      # Make STDOUT and/or STDERR auto-flush.
      select STDERR;  $| = 1;
      select STDOUT;  $| = 1;
  
      # The child doesn't need to read from the semaphore pipe.
      $sem_pipe_read = undef;
  
      # Run Perl code.  This is fairly consistent across most systems.
  
      if (ref($program) eq 'CODE') {
  
        # Tell the parent that the stdio has been set up.
        print $sem_pipe_write "go\n";
        close $sem_pipe_write;
  
        # Close any close-on-exec file descriptors.  Except STDIN,
        # STDOUT, and STDERR, of course.
        if ($close_on_call) {
          for (0..MAX_OPEN_FDS-1) {
            next if fileno(STDIN)  == $_;
            next if fileno(STDOUT) == $_;
            next if fileno(STDERR) == $_;
            POSIX::close($_);
          }
        }
  
        # TODO what if the program tries to exit? It needs to use
        # our _exit_child_any_way_we_can handler...
        # Should we replace CORE::exit? CORE::die too? blahhhhhh
        # We've documented that users should not do it, but who knows!
        eval { $program->(@$prog_args) };
  
        my $exitval;
        if ($@) {
          chomp $@;
          warn "$@\n";
          $exitval = -1;
        }
  
        __PACKAGE__->_exit_child_any_way_we_can( $exitval || 0 );
      }
  
      # Execute an external program.  This gets weird.
  
      # Windows! What I do for you!
      __PACKAGE__->_exec_in_hell(
        $close_on_call, $sem_pipe_write, $program, $prog_args
      ) if POE::Kernel::RUNNING_IN_HELL;
  
      # Everybody else seems sane.
      # Tell the parent that the stdio has been set up.
      print $sem_pipe_write "go\n";
      close $sem_pipe_write;
  
      # exec(ARRAY)
      if (ref($program) eq 'ARRAY') {
        exec(@$program, @$prog_args)
           or __PACKAGE__->_warn_and_exit_child(
             "can't exec (@$program) in child pid $$: $!", int( $! ) );
      }
  
      # exec(SCALAR)
      exec(join(" ", $program, @$prog_args))
        or __PACKAGE__->_warn_and_exit_child(
          "can't exec ($program) in child pid $$: $!", int( $! ) );
    }
  
    # Parent here.  Close what the parent won't need.
  
    defined($stdin_read)   and close $stdin_read;
    defined($stdout_write) and close $stdout_write;
    defined($stderr_write) and close $stderr_write;
  
  
  
    # Also close any slave ptys
    $stdout_read->close_slave() if (
      defined $stdout_read and ref($stdout_read) eq 'IO::Pty'
    );
  
    $stderr_read->close_slave() if (
      defined $stderr_read and ref($stderr_read) eq 'IO::Pty'
    );
  
    my $active_count = 0;
    $active_count++ if $stdout_event and $stdout_read;
    $active_count++ if $stderr_event and $stderr_read;
  
    my $self = bless [
      &POE::Wheel::allocate_wheel_id(),  # UNIQUE_ID
      $error_event,   # ERROR_EVENT
      $close_event,   # CLOSE_EVENT
      $program,       # PROGRAM
      $pid,           # CHILD_PID
      $conduit,       # CONDUIT_TYPE
      $active_count,  # IS_ACTIVE
      $close_on_call, # CLOSE_ON_CALL
      $stdio_type,    # STDIO_TYPE
      # STDIN
      $stdin_write,   # HANDLE_STDIN
      $stdin_filter,  # FILTER_STDIN
      $stdin_driver,  # DRIVER_STDIN
      $stdin_event,   # EVENT_STDIN
      undef,          # STATE_STDIN
      0,              # OCTETS_STDIN
      # STDOUT
      $stdout_read,   # HANDLE_STDOUT
      $stdout_filter, # FILTER_STDOUT
      $stdout_driver, # DRIVER_STDOUT
      $stdout_event,  # EVENT_STDOUT
      undef,          # STATE_STDOUT
      # STDERR
      $stderr_read,   # HANDLE_STDERR
      $stderr_filter, # FILTER_STDERR
      $stderr_driver, # DRIVER_STDERR
      $stderr_event,  # EVENT_STDERR
      undef,          # STATE_STDERR
      undef,          # MSWIN32_GROUP_PID
    ], $type;
  
    # PG- I suspect <> might need PIPE
    $poe_kernel->_data_sig_unmask_all if $must_unmask;
  
    # Wait here while the child sets itself up.
    $sem_pipe_write = undef;
    {
      local $/ = "\n";  # TODO - Needed?
      my $chldout = <$sem_pipe_read>;
      chomp $chldout;
      $self->[MSWIN32_GROUP_PID] = $chldout if $chldout ne 'go';
    }
    close $sem_pipe_read;
  
    $self->_define_stdin_flusher() if defined $stdin_write;
    $self->_define_stdout_reader() if defined $stdout_read;
    $self->_define_stderr_reader() if defined $stderr_read;
  
    return $self;
  }
  
  #------------------------------------------------------------------------------
  # Define the internal state that will flush output to the child
  # process' STDIN pipe.
  
  sub _define_stdin_flusher {
    my $self = shift;
  
    # Read-only members.  If any of these change, then the write state
    # is invalidated and needs to be redefined.
    my $unique_id    = $self->[UNIQUE_ID];
    my $driver       = $self->[DRIVER_STDIN];
    my $error_event  = \$self->[ERROR_EVENT];
    my $close_event  = \$self->[CLOSE_EVENT];
    my $stdin_filter = $self->[FILTER_STDIN];
    my $stdin_event  = \$self->[EVENT_STDIN];
    my $is_active    = \$self->[IS_ACTIVE];
  
    # Read/write members.  These are done by reference, to avoid pushing
    # $self into the anonymous sub.  Extra copies of $self are bad and
    # can prevent wheels from destructing properly.
    my $stdin_octets = \$self->[OCTETS_STDIN];
  
    # Register the select-write handler.
    $poe_kernel->state(
      $self->[STATE_STDIN] = ref($self) . "($unique_id) -> select stdin",
      sub {                             # prevents SEGV
        0 && CRIMSON_SCOPE_HACK('<');
                                        # subroutine starts here
        my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];
  
        $$stdin_octets = $driver->flush($handle);
  
        # When you can't write, nothing else matters.
        if ($!) {
          $$error_event && $k->call(
            $me, $$error_event,
            'write', ($!+0), $!, $unique_id, "STDIN"
          );
          $k->select_write($handle);
        }
  
        # Could write, or perhaps couldn't but only because the
        # filehandle's buffer is choked.
        else {
  
          # All chunks written; fire off a "flushed" event.
          unless ($$stdin_octets) {
            $k->select_pause_write($handle);
            $$stdin_event && $k->call($me, $$stdin_event, $unique_id);
          }
        }
      }
    );
  
    $poe_kernel->select_write($self->[HANDLE_STDIN], $self->[STATE_STDIN]);
  
    # Pause the write select immediately, unless output is pending.
    $poe_kernel->select_pause_write($self->[HANDLE_STDIN])
      unless ($self->[OCTETS_STDIN]);
  }
  
  #------------------------------------------------------------------------------
  # Define the internal state that will read input from the child
  # process' STDOUT pipe.  This is virtually identical to
  # _define_stderr_reader, but they aren't implemented as a common
  # function for speed reasons.
  
  sub _define_stdout_reader {
    my $self = shift;
  
    # Can't do anything if we don't have a handle.
    return unless defined $self->[HANDLE_STDOUT];
  
    # No event?  Unregister the handler and leave.
    my $stdout_event  = \$self->[EVENT_STDOUT];
    unless ($$stdout_event) {
      $poe_kernel->select_read($self->[HANDLE_STDOUT]);
      return;
    }
  
    # If any of these change, then the read state is invalidated and
    # needs to be redefined.
    my $unique_id     = $self->[UNIQUE_ID];
    my $driver        = $self->[DRIVER_STDOUT];
    my $stdout_filter = $self->[FILTER_STDOUT];
  
    # These can change without redefining the callback since they're
    # enclosed by reference.
    my $is_active     = \$self->[IS_ACTIVE];
    my $close_event   = \$self->[CLOSE_EVENT];
    my $error_event   = \$self->[ERROR_EVENT];
  
    # Register the select-read handler for STDOUT.
    if (
      $stdout_filter->can("get_one") and
      $stdout_filter->can("get_one_start")
    ) {
      $poe_kernel->state(
        $self->[STATE_STDOUT] = ref($self) . "($unique_id) -> select stdout",
        sub {
          # prevents SEGV
          0 && CRIMSON_SCOPE_HACK('<');
  
          # subroutine starts here
          my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];
          if (defined(my $raw_input = $driver->get($handle))) {
            $stdout_filter->get_one_start($raw_input);
            while (1) {
              my $next_rec = $stdout_filter->get_one();
              last unless @$next_rec;
              foreach my $cooked_input (@$next_rec) {
                $k->call($me, $$stdout_event, $cooked_input, $unique_id);
              }
            }
          }
          else {
            $$error_event and $k->call(
              $me, $$error_event,
              'read', ($!+0), $!, $unique_id, 'STDOUT'
            );
            unless (--$$is_active) {
              $k->call( $me, $$close_event, $unique_id )
                if defined $$close_event;
            }
            $k->select_read($handle);
          }
        }
      );
    }
  
    # Otherwise we can't get one.
    else {
      $poe_kernel->state(
        $self->[STATE_STDOUT] = ref($self) . "($unique_id) -> select stdout",
        sub {
          # prevents SEGV
          0 && CRIMSON_SCOPE_HACK('<');
  
          # subroutine starts here
          my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];
          if (defined(my $raw_input = $driver->get($handle))) {
            foreach my $cooked_input (@{$stdout_filter->get($raw_input)}) {
              $k->call($me, $$stdout_event, $cooked_input, $unique_id);
            }
          }
          else {
            $$error_event and
              $k->call(
                $me, $$error_event,
                'read', ($!+0), $!, $unique_id, 'STDOUT'
              );
            unless (--$$is_active) {
              $k->call( $me, $$close_event, $unique_id )
                if defined $$close_event;
            }
            $k->select_read($handle);
          }
        }
      );
    }
  
    # register the state's select
    $poe_kernel->select_read($self->[HANDLE_STDOUT], $self->[STATE_STDOUT]);
  }
  
  #------------------------------------------------------------------------------
  # Define the internal state that will read input from the child
  # process' STDERR pipe.
  
  sub _define_stderr_reader {
    my $self = shift;
  
    # Can't do anything if we don't have a handle.
    return unless defined $self->[HANDLE_STDERR];
  
    # No event?  Unregister the handler and leave.
    my $stderr_event  = \$self->[EVENT_STDERR];
    unless ($$stderr_event) {
      $poe_kernel->select_read($self->[HANDLE_STDERR]);
      return;
    }
  
    my $unique_id     = $self->[UNIQUE_ID];
    my $driver        = $self->[DRIVER_STDERR];
    my $stderr_filter = $self->[FILTER_STDERR];
  
    # These can change without redefining the callback since they're
    # enclosed by reference.
    my $error_event   = \$self->[ERROR_EVENT];
    my $close_event   = \$self->[CLOSE_EVENT];
    my $is_active     = \$self->[IS_ACTIVE];
  
    # Register the select-read handler for STDERR.
    if (
      $stderr_filter->can("get_one") and
      $stderr_filter->can("get_one_start")
    ) {
      $poe_kernel->state(
        $self->[STATE_STDERR] = ref($self) . "($unique_id) -> select stderr",
        sub {
          # prevents SEGV
          0 && CRIMSON_SCOPE_HACK('<');
  
          # subroutine starts here
          my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];
          if (defined(my $raw_input = $driver->get($handle))) {
            $stderr_filter->get_one_start($raw_input);
            while (1) {
              my $next_rec = $stderr_filter->get_one();
              last unless @$next_rec;
              foreach my $cooked_input (@$next_rec) {
                $k->call($me, $$stderr_event, $cooked_input, $unique_id);
              }
            }
          }
          else {
            $$error_event and $k->call(
              $me, $$error_event,
              'read', ($!+0), $!, $unique_id, 'STDERR'
            );
            unless (--$$is_active) {
              $k->call( $me, $$close_event, $unique_id )
                if defined $$close_event;
            }
            $k->select_read($handle);
          }
        }
      );
    }
  
    # Otherwise we can't get_one().
    else {
      $poe_kernel->state(
        $self->[STATE_STDERR] = ref($self) . "($unique_id) -> select stderr",
        sub {
          # prevents SEGV
          0 && CRIMSON_SCOPE_HACK('<');
  
          # subroutine starts here
          my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];
          if (defined(my $raw_input = $driver->get($handle))) {
            foreach my $cooked_input (@{$stderr_filter->get($raw_input)}) {
              $k->call($me, $$stderr_event, $cooked_input, $unique_id);
            }
          }
          else {
            $$error_event and $k->call(
              $me, $$error_event,
              'read', ($!+0), $!, $unique_id, 'STDERR'
            );
            unless (--$$is_active) {
              $k->call( $me, $$close_event, $unique_id )
                if defined $$close_event;
            }
            $k->select_read($handle);
          }
        }
      );
    }
  
    # Register the state's select.
    $poe_kernel->select_read($self->[HANDLE_STDERR], $self->[STATE_STDERR]);
  }
  
  #------------------------------------------------------------------------------
  # Redefine events.
  
  sub event {
    my $self = shift;
    push(@_, undef) if (scalar(@_) & 1);
  
    my ($redefine_stdin, $redefine_stdout, $redefine_stderr) = (0, 0, 0);
  
    while (@_) {
      my ($name, $event) = splice(@_, 0, 2);
  
      if ($name eq 'StdinEvent') {
        $self->[EVENT_STDIN] = $event;
        $redefine_stdin = 1;
      }
      elsif ($name eq 'StdoutEvent') {
        $self->[EVENT_STDOUT] = $event;
        $redefine_stdout = 1;
      }
      elsif ($name eq 'StderrEvent') {
        if ($self->[CONDUIT_TYPE] ne 'pty') {
          $self->[EVENT_STDERR] = $event;
          $redefine_stderr = 1;
        }
        else {
          carp "ignoring StderrEvent on a pty conduit";
        }
      }
      elsif ($name eq 'ErrorEvent') {
        $self->[ERROR_EVENT] = $event;
      }
      elsif ($name eq 'CloseEvent') {
        $self->[CLOSE_EVENT] = $event;
      }
      else {
        carp "ignoring unknown Run parameter '$name'";
      }
    }
  
    # Recalculate the active handles count.
    my $active_count = 0;
    $active_count++ if $self->[EVENT_STDOUT] and $self->[HANDLE_STDOUT];
    $active_count++ if $self->[EVENT_STDERR] and $self->[HANDLE_STDERR];
    $self->[IS_ACTIVE] = $active_count;
  }
  
  #------------------------------------------------------------------------------
  # Destroy the wheel.
  
  sub DESTROY {
    my $self = shift;
  
    return if(ref POE::Kernel->get_active_session eq 'POE::Kernel');
  
    # Turn off the STDIN thing.
    if ($self->[HANDLE_STDIN]) {
      $poe_kernel->select_write($self->[HANDLE_STDIN]);
      $self->[HANDLE_STDIN] = undef;
    }
  
    if ($self->[STATE_STDIN]) {
      $poe_kernel->state($self->[STATE_STDIN]);
      $self->[STATE_STDIN] = undef;
    }
  
    if ($self->[HANDLE_STDOUT]) {
      $poe_kernel->select_read($self->[HANDLE_STDOUT]);
      $self->[HANDLE_STDOUT] = undef;
    }
    if ($self->[STATE_STDOUT]) {
      $poe_kernel->state($self->[STATE_STDOUT]);
      $self->[STATE_STDOUT] = undef;
    }
  
    if ($self->[HANDLE_STDERR]) {
      $poe_kernel->select_read($self->[HANDLE_STDERR]);
      $self->[HANDLE_STDERR] = undef;
    }
    if ($self->[STATE_STDERR]) {
      $poe_kernel->state($self->[STATE_STDERR]);
      $self->[STATE_STDERR] = undef;
    }
  
    &POE::Wheel::free_wheel_id($self->[UNIQUE_ID]);
  }
  
  #------------------------------------------------------------------------------
  # Queue input for the child process.
  
  sub put {
    my ($self, @chunks) = @_;
  
    # Avoid big bada boom if someone put()s on a dead wheel.
    croak "Called put() on a wheel without an open STDIN handle" unless (
      $self->[HANDLE_STDIN]
    );
  
    if (
      $self->[OCTETS_STDIN] =  # assignment on purpose
      $self->[DRIVER_STDIN]->put($self->[FILTER_STDIN]->put(\@chunks))
    ) {
      $poe_kernel->select_resume_write($self->[HANDLE_STDIN]);
    }
  
    # No watermark.
    return 0;
  }
  
  #------------------------------------------------------------------------------
  # Pause and resume various input events.
  
  sub pause_stdout {
    my $self = shift;
    return unless defined $self->[HANDLE_STDOUT];
    $poe_kernel->select_pause_read($self->[HANDLE_STDOUT]);
  }
  
  sub pause_stderr {
    my $self = shift;
    return unless defined $self->[HANDLE_STDERR];
    $poe_kernel->select_pause_read($self->[HANDLE_STDERR]);
  }
  
  sub resume_stdout {
    my $self = shift;
    return unless defined $self->[HANDLE_STDOUT];
    $poe_kernel->select_resume_read($self->[HANDLE_STDOUT]);
  }
  
  sub resume_stderr {
    my $self = shift;
    return unless defined $self->[HANDLE_STDERR];
    $poe_kernel->select_resume_read($self->[HANDLE_STDERR]);
  }
  
  # Shutdown the pipe that leads to the child's STDIN.
  sub shutdown_stdin {
    my $self = shift;
    return unless defined $self->[HANDLE_STDIN];
  
    $poe_kernel->select_write($self->[HANDLE_STDIN], undef);
  
    eval { local $^W = 0; shutdown($self->[HANDLE_STDIN], 1) };
    if ($@ or $self->[HANDLE_STDIN] != $self->[HANDLE_STDOUT]) {
      close $self->[HANDLE_STDIN];
    }
  
    $self->[HANDLE_STDIN] = undef;
  }
  
  #------------------------------------------------------------------------------
  # Redefine filters, one at a time or at once.  This is based on PG's
  # code in Wheel::ReadWrite.
  
  sub _transfer_stdout_buffer {
    my ($self, $buf) = @_;
  
    my $old_output_filter = $self->[FILTER_STDOUT];
  
    # Assign old buffer contents to the new filter, and send out any
    # pending packets.
  
    # Use "get_one" if the new filter implements it.
    if (defined $buf) {
      if (
        $old_output_filter->can("get_one") and
        $old_output_filter->can("get_one_start")
      ) {
        $old_output_filter->get_one_start($buf);
  
        # Don't bother to continue if the filter has switched out from
        # under our feet again.  The new switcher will finish the job.
  
        while ($self->[FILTER_STDOUT] == $old_output_filter) {
          my $next_rec = $old_output_filter->get_one();
          last unless @$next_rec;
          foreach my $cooked_input (@$next_rec) {
            $poe_kernel->call(
              $poe_kernel->get_active_session(), $self->[EVENT_STDOUT],
              $cooked_input, $self->[UNIQUE_ID]
            );
          }
        }
      }
  
      # Otherwise use the old get() behavior.
      else {
        foreach my $cooked_input (@{$self->[FILTER_STDOUT]->get($buf)}) {
          $poe_kernel->call(
            $poe_kernel->get_active_session(), $self->[EVENT_STDOUT],
            $cooked_input, $self->[UNIQUE_ID]
          );
        }
      }
    }
  }
  
  sub _transfer_stderr_buffer {
    my ($self, $buf) = @_;
  
    my $old_output_filter = $self->[FILTER_STDERR];
  
    # Assign old buffer contents to the new filter, and send out any
    # pending packets.
  
    # Use "get_one" if the new filter implements it.
    if (defined $buf) {
      if (
        $old_output_filter->can("get_one") and
        $old_output_filter->can("get_one_start")
      ) {
        $old_output_filter->get_one_start($buf);
  
        # Don't bother to continue if the filter has switched out from
        # under our feet again.  The new switcher will finish the job.
  
        while ($self->[FILTER_STDERR] == $old_output_filter) {
          my $next_rec = $old_output_filter->get_one();
          last unless @$next_rec;
          foreach my $cooked_input (@$next_rec) {
            $poe_kernel->call(
              $poe_kernel->get_active_session(), $self->[EVENT_STDERR],
              $cooked_input, $self->[UNIQUE_ID]
            );
          }
        }
      }
  
      # Otherwise use the old get() behavior.
      else {
        foreach my $cooked_input (@{$self->[FILTER_STDERR]->get($buf)}) {
          $poe_kernel->call(
            $poe_kernel->get_active_session(), $self->[EVENT_STDERR],
            $cooked_input, $self->[UNIQUE_ID]
          );
        }
      }
    }
  }
  
  sub set_stdio_filter {
    my ($self, $new_filter) = @_;
    $self->set_stdout_filter($new_filter);
    $self->set_stdin_filter($new_filter);
  }
  
  sub set_stdin_filter {
    my ($self, $new_filter) = @_;
    $self->[FILTER_STDIN] = $new_filter;
  }
  
  sub set_stdout_filter {
    my ($self, $new_filter) = @_;
  
    my $buf = $self->[FILTER_STDOUT]->get_pending();
    $self->[FILTER_STDOUT] = $new_filter;
  
    $self->_transfer_stdout_buffer($buf);
  }
  
  sub set_stderr_filter {
    my ($self, $new_filter) = @_;
  
    my $buf = $self->[FILTER_STDERR]->get_pending();
    $self->[FILTER_STDERR] = $new_filter;
  
    $self->_transfer_stderr_buffer($buf);
  }
  
  sub get_stdin_filter {
    my $self = shift;
    return $self->[FILTER_STDIN];
  }
  
  sub get_stdout_filter {
    my $self = shift;
    return $self->[FILTER_STDOUT];
  }
  
  sub get_stderr_filter {
    my $self = shift;
    return $self->[FILTER_STDERR];
  }
  
  #------------------------------------------------------------------------------
  # Data accessors.
  
  sub get_driver_out_octets {
    $_[0]->[OCTETS_STDIN];
  }
  
  sub get_driver_out_messages {
    $_[0]->[DRIVER_STDIN]->get_out_messages_buffered();
  }
  
  sub ID {
    $_[0]->[UNIQUE_ID];
  }
  
  sub PID {
    $_[0]->[CHILD_PID];
  }
  
  sub kill {
    my ($self, $signal) = @_;
    $signal = 'TERM' unless defined $signal;
    if ( $self->[MSWIN32_GROUP_PID] ) {
      # TODO use https://rt.cpan.org/Ticket/Display.html?id=67774 when available :)
      Win32::Process::KillProcess( $self->[MSWIN32_GROUP_PID], 293 ) ? 1 : 0;
    }
    else {
      eval { kill $signal, $self->[CHILD_PID] };
    }
  }
  
  ### Internal helpers.
  
  sub _redirect_child_stdio_in_hell {
    my ($class, $stdin_read, $stdout_write, $stderr_write) = @_;
  
    # Win32 needs the stdio handles closed before they're reopened
    # because the standard handles aren't dup()'d.
  
    close STDIN;
    close STDOUT;
    close STDERR;
  
    $class->_redirect_child_stdio_sanely(
      $stdin_read, $stdout_write, $stderr_write
    );
  
    # The Win32 pseudo fork sets up the std handles in the child
    # based on the true win32 handles.  The reopening of stdio
    # handles isn't enough.  We must also set the underlying
    # Win32 notion of these handles for completeness.
    #
    # Only necessary for the exec, as Perl CODE subroutine goes
    # through 0/1/2 which are correct.  But of course that coderef
    # might invoke exec, so better do it regardless.
    #
    # HACK: Using Win32::Console as nothing else exposes
    # SetStdHandle
    #
    # TODO - https://rt.cpan.org/Ticket/Display.html?id=50068 claims
    # that these _SetStdHandle() calls may leak memory.  Do we have
    # alternatives?
  
    Win32::Console::_SetStdHandle(
      $STD_INPUT_HANDLE,
      FdGetOsFHandle(fileno($stdin_read))
    ) if defined $stdin_read;
  
    Win32::Console::_SetStdHandle(
      $STD_OUTPUT_HANDLE,
      FdGetOsFHandle(fileno($stdout_write))
    ) if defined $stdout_write;
  
    Win32::Console::_SetStdHandle(
      $STD_ERROR_HANDLE,
      FdGetOsFHandle(fileno($stderr_write))
    ) if defined $stderr_write;
  }
  
  sub _filespec_to_fh {
    my ($dest,$mode,$fspec) = @_;
    return unless defined $fspec;
    if(ref $fspec) {
      if (ref $fspec eq 'GLOB') {
        open $$dest, "$mode&", $fspec;
      } else {
        die("Bad file specifier '$fspec'");
      }
    } else {
      open $$dest, $mode, $fspec;
    }
  }
  
  sub _redirect_child_stdio_sanely {
    my ($class, $stdin_read, $stdout_write, $stderr_write) = @_;
  
    # Note: we use 2-arg open() below because Perl 5.6 doesn't recognize
    # the '>&' and '<&' modes with a 3-arg open()
  
    # Redirect STDIN from the read end of the stdin pipe.
    if(defined $stdin_read) {
      open( STDIN, "<&" . fileno($stdin_read) )
        or $class->_warn_and_exit_child(
          "can't redirect STDIN in child pid $$: $!", int( $! ) );
    }
  
    # Redirect STDOUT to the write end of the stdout pipe.
    if(defined $stdout_write) {
      open( STDOUT, ">&" . fileno($stdout_write) )
        or $class->_warn_and_exit_child(
          "can't redirect stdout in child pid $$: $!", int( $! ) );
    }
      # Redirect STDERR to the write end of the stderr pipe.
    if(defined $stderr_write) {
      open( STDERR, ">&" . fileno($stderr_write) )
        or $class->_warn_and_exit_child(
          "can't redirect stderr in child pid $$: $!", int( $! ) );
    }
  }
  
  sub _exit_child_any_way_we_can {
    my $class = shift;
    my $exitval = shift || 0;
  
    # First make sure stdio are flushed.
    close STDIN  if defined fileno(STDIN); # Voodoo?
    close STDOUT if defined fileno(STDOUT);
    close STDERR if defined fileno(STDERR);
  
    # On Windows, subprocesses run in separate threads.  All the "fancy"
    # methods act on entire processes, so they also exit the parent.
  
    unless (POE::Kernel::RUNNING_IN_HELL) {
      # Try to avoid triggering END blocks and object destructors.
      eval { POSIX::_exit( $exitval ); };
  
      # TODO those methods will not exit with $exitval... what to do?
      eval { CORE::kill KILL => $$; };
      eval { exec("$^X -e 0"); };
    } else {
      eval { CORE::kill( KILL => $$ ); };
  
      # TODO Interestingly enough, the KILL is not enough to terminate this process...
      # However, it *is* enough to stop execution of END blocks/etc
      # So we will end up falling through to the exit( $exitval ) below
    }
  
    # Do what we must.
    exit( $exitval );
  }
  
  # RUNNING_IN_HELL use Win32::Process to create a pucker new shiny
  # process. It'll inherit our processes handles which is neat.
  
  sub _exec_in_hell {
    my (
      $class, $close_on_call, $sem_pipe_write,
      $program, $prog_args
    ) = @_;
  
    # Close any close-on-exec file descriptors.
    # Except STDIN, STDOUT, and STDERR, of course.
  
    if ($close_on_call) {
      for (0..MAX_OPEN_FDS-1) {
        next if fileno(STDIN) == $_;
        next if fileno(STDOUT) == $_;
        next if fileno(STDERR) == $_;
        POSIX::close($_);
      }
    }
  
    my ($appname, $cmdline);
  
    if (ref $program eq 'ARRAY') {
      $appname = $program->[0];
      $cmdline = join(
        ' ',
        map { /\s/ && ! /"/ ? qq{"$_"} : $_ }
        (@$program, @$prog_args)
      );
    }
    else {
      $appname = undef;
      $cmdline = join(
        ' ', $program,
        map { /\s/ && ! /"/ ? qq{"$_"} : $_ }
        @$prog_args
      );
    }
  
    my $w32job;
  
    unless ( $w32job = Win32::Job->new() ) {
      print $sem_pipe_write "go\n\n"; # TODO why the double newline?
      close $sem_pipe_write;
      $class->_warn_and_exit_child(
        Win32::FormatMessage( Win32::GetLastError() ), Win32::GetLastError() );
    }
  
    my $w32pid;
  
    unless ( $w32pid = $w32job->spawn( $appname, $cmdline ) ) {
      print $sem_pipe_write "go\n";
      close $sem_pipe_write;
      $class->_warn_and_exit_child(
        Win32::FormatMessage( Win32::GetLastError() ), Win32::GetLastError() );
    }
  
    print $sem_pipe_write "$w32pid\n";
    close $sem_pipe_write;
  
    # TODO why 60? Why not MAX_INT so we don't do unnecessary work?
    my $ok = $w32job->watch( sub { 0 }, 60 );
    my $hashref = $w32job->status();
  
    # In case flushing them wasn't good enough.
    close STDOUT if defined fileno(STDOUT);
    close STDERR if defined fileno(STDERR);
  
    $class->_exit_child_any_way_we_can( $hashref->{$w32pid}->{exitcode} );
  }
  
  # Simple helper to ease the pain of warn+exit
  sub _warn_and_exit_child {
    my( $class, $warning, $exitval ) = @_;
  
    warn "$warning\n";
  
    $class->_exit_child_any_way_we_can( $exitval );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Wheel::Run - portably run blocking code and programs in subprocesses
  
  =head1 SYNOPSIS
  
    #!/usr/bin/perl
  
    use warnings;
    use strict;
  
    use POE qw( Wheel::Run );
  
    POE::Session->create(
      inline_states => {
        _start           => \&on_start,
        got_child_stdout => \&on_child_stdout,
        got_child_stderr => \&on_child_stderr,
        got_child_close  => \&on_child_close,
        got_child_signal => \&on_child_signal,
      }
    );
  
    POE::Kernel->run();
    exit 0;
  
    sub on_start {
      my $child = POE::Wheel::Run->new(
        Program => [ "/bin/ls", "-1", "/" ],
        StdoutEvent  => "got_child_stdout",
        StderrEvent  => "got_child_stderr",
        CloseEvent   => "got_child_close",
      );
  
      $_[KERNEL]->sig_child($child->PID, "got_child_signal");
  
      # Wheel events include the wheel's ID.
      $_[HEAP]{children_by_wid}{$child->ID} = $child;
  
      # Signal events include the process ID.
      $_[HEAP]{children_by_pid}{$child->PID} = $child;
  
      print(
        "Child pid ", $child->PID,
        " started as wheel ", $child->ID, ".\n"
      );
    }
  
    # Wheel event, including the wheel's ID.
    sub on_child_stdout {
      my ($stdout_line, $wheel_id) = @_[ARG0, ARG1];
      my $child = $_[HEAP]{children_by_wid}{$wheel_id};
      print "pid ", $child->PID, " STDOUT: $stdout_line\n";
    }
  
    # Wheel event, including the wheel's ID.
    sub on_child_stderr {
      my ($stderr_line, $wheel_id) = @_[ARG0, ARG1];
      my $child = $_[HEAP]{children_by_wid}{$wheel_id};
      print "pid ", $child->PID, " STDERR: $stderr_line\n";
    }
  
    # Wheel event, including the wheel's ID.
    sub on_child_close {
      my $wheel_id = $_[ARG0];
      my $child = delete $_[HEAP]{children_by_wid}{$wheel_id};
  
      # May have been reaped by on_child_signal().
      unless (defined $child) {
        print "wid $wheel_id closed all pipes.\n";
        return;
      }
  
      print "pid ", $child->PID, " closed all pipes.\n";
      delete $_[HEAP]{children_by_pid}{$child->PID};
    }
  
    sub on_child_signal {
      print "pid $_[ARG1] exited with status $_[ARG2].\n";
      my $child = delete $_[HEAP]{children_by_pid}{$_[ARG1]};
  
      # May have been reaped by on_child_close().
      return unless defined $child;
  
      delete $_[HEAP]{children_by_wid}{$child->ID};
    }
  
  =head1 DESCRIPTION
  
  POE::Wheel::Run executes a program or block of code in a subprocess,
  created the usual way: using fork().  The parent process may exchange
  information with the child over the child's STDIN, STDOUT and STDERR
  filehandles.
  
  In the parent process, the POE::Wheel::Run object represents the child
  process.  It has methods such as PID() and kill() to query and manage
  the child process.
  
  POE::Wheel::Run's put() method sends data to the child's STDIN.  Child
  output on STDOUT and STDERR may be dispatched as events within the
  parent, if requested.
  
  POE::Wheel::Run can also notify the parent when the child has closed
  its output filehandles.  Some programs remain active, but they close
  their output filehandles to indicate they are done writing.
  
  A more reliable way to detect child exit is to use POE::Kernel's
  sig_child() method to wait for the wheel's process to be reaped.  It
  is in fact vital to use sig_child() in all circumstances since without
  it, POE will not try to reap child processes.
  
  Failing to use sig_child() has in the past led to wedged machines.
  Long-running programs have leaked processes, eventually consuming all
  available slots in the process table and requiring reboots.
  
  Because process leaks are so severe, POE::Kernel will check for this
  condition on exit and display a notice if it finds that processes are
  leaking.  Developers should heed these warnings.
  
  POE::Wheel::Run communicates with the child process in a line-based
  fashion by default.  Programs may override this by specifying some
  other POE::Filter object in L</StdinFilter>, L</StdoutFilter>,
  L</StdioFilter> and/or L</StderrFilter>.
  
  =head1 PUBLIC METHODS
  
  =head2 Constructor
  
  POE::Wheel subclasses tend to perform a lot of setup so that they run
  lighter and faster.  POE::Wheel::Run's constructor is no exception.
  
  =head3 new
  
  new() creates and returns a new POE::Wheel::Run object.  If it's
  successful, the object will represent a child process with certain
  specified qualities.  It also provides an OO- and event-based
  interface for asynchronously interacting with the process.
  
  =head4 Conduit
  
  Conduit specifies the inter-process communications mechanism that will
  be used to pass data between the parent and child process.  Conduit
  may be one of "pipe", "socketpair", "inet", "pty", or "pty-pipe".
  POE::Wheel::Run will use the most appropriate Conduit for the run-time
  (not the compile-time) operating system, but this varies from one OS
  to the next.
  
  Internally, POE::Wheel::Run passes the Conduit type to
  L<POE::Pipe::OneWay> and L<POE::Pipe::TwoWay>.  These helper classes
  were created to make IPC portable and reusable.  They do not require
  the rest of POE.
  
  Three Conduit types use pipes or pipelike inter-process communication:
  "pipe", "socketpair" and "inet".  They determine whether the internal
  IPC uses pipe(), socketpair() or Internet sockets.  These Conduit
  values are passed through to L<POE::Pipe::OneWay> or
  L<POE::Pipe::TwoWay> internally.
  
  The "pty" conduit type runs the child process under a pseudo-tty,
  which is created by L<IO::Pty>.  Pseudo-ttys (ptys) convince child
  processes that they are interacting with terminals rather than pipes.
  This may be used to trick programs like ssh into believing it's secure
  to prompt for a password, although passphraseless identities might be
  better for that.
  
  The "pty" conduit cannot separate STDERR from STDOUT, but the
  "pty-pipe" mode can.
  
  The "pty-pipe" conduit uses a pty for STDIN and STDOUT and a one-way
  pipe for STDERR.  The additional pipe keeps STDERR output separate
  from STDOUT.
  
  The L<IO::Pty> module is only loaded if "pty" or "pty-pipe" is used.
  It's not a dependency until it's actually needed.
  
  =for comment
  TODO - Example.
  
  =head4 Winsize
  
  Winsize sets the child process' terminal size.  Its value should be an
  arrayref with four elements.  The first two elements must be the
  number of lines and columns for the child's terminal window,
  respectively.  The second pair of elements describe the terminal's X
  and Y dimensions in pixels.  If the last pair is missing, they will be calculated 
  from the lines and columns using a 9x16 cell size.
  
    $_[HEAP]{child} = POE::Wheel::Run->new(
      # ... among other things ...
      Winsize => [ 25, 80, 720, 400 ],
    );
  
  Winsize is only valid for conduits that use pseudo-ttys: "pty" and
  "pty-pipe".  Other conduits don't simulate terminals, so they don't
  have window sizes.
  
  Winsize defaults to the parent process' window size, assuming the
  parent process has a terminal to query.
  
  =head4 CloseOnCall
  
  CloseOnCall, when true, turns on close-on-exec emulation for
  subprocesses that don't actually call exec().  These would be
  instances when the child is running a block of code rather than
  executing an external program.  For example:
  
    $_[HEAP]{child} = POE::Wheel::Run->new(
      # ... among other things ...
      CloseOnCall => 1,
      Program => \&some_function,
    );
  
  CloseOnCall is off (0) by default.
  
  CloseOnCall works by closing all file descriptors greater than $^F in
  the child process before calling the application's code.  For more
  details, please the discussion of $^F in L<perlvar>.
  
  =head4 StdioDriver
  
  StdioDriver specifies a single L<POE::Driver> object to be used for
  both STDIN and STDOUT.  It's equivalent to setting L</StdinDriver> and
  L</StdoutDriver> to the same L<POE::Driver> object.
  
  POE::Wheel::Run will create and use a L<POE::Driver::SysRW> driver of
  one isn't specified.  This is by far the most common use case, so it's
  the default.
  
  =head4 StdinDriver
  
  C<StdinDriver> sets the L<POE::Driver> used to write to the child
  process' STDIN IPC conduit.  It is almost never needed.  Omitting it
  will allow POE::Wheel::Run to use an internally created
  L<POE::Driver::SysRW> object.
  
  =head4 StdoutDriver
  
  C<StdoutDriver> sets the L<POE::Driver> object that will be used to
  read from the child process' STDOUT conduit.  It's almost never
  needed.  If omitted, POE::Wheel::Run will internally create and use
  a L<POE::Driver::SysRW> object.
  
  =head4 StderrDriver
  
  C<StderrDriver> sets the driver that will be used to read from the
  child process' STDERR conduit.  As with L</StdoutDriver>, it's almost
  always preferable to let POE::Wheel::Run instantiate its own driver.
  
  =head4 CloseEvent
  
  CloseEvent contains the name of an event that the wheel will emit when
  the child process closes its last open output handle.  This is a
  consistent notification that the child is done sending output.  Please
  note that it does not signal when the child process has exited.
  Programs should use sig_child() to detect that.
  
  While it is impossible for ErrorEvent or StdoutEvent to happen after
  CloseEvent, there is no such guarantee for CHLD, which may happen before
  or after CloseEvent.
  
  In addition to the usual POE parameters, each CloseEvent comes with
  one of its own:
  
  C<ARG0> contains the wheel's unique ID.  This can be used to keep
  several child processes separate when they're managed by the same
  session.
  
  A sample close event handler:
  
    sub close_state {
      my ($heap, $wheel_id) = @_[HEAP, ARG0];
  
      my $child = delete $heap->{child}->{$wheel_id};
      print "Child ", $child->PID, " has finished.\n";
    }
  
  =head4 ErrorEvent
  
  ErrorEvent contains the name of an event to emit if something fails.
  It is optional; if omitted, the wheel will not notify its session if
  any errors occur.  However, POE::Wheel::Run->new() will still throw an
  exception if it fails.
  
  C<ARG0> contains the name of the operation that failed.  It may be
  'read', 'write', 'fork', 'exec' or the name of some other function or
  task.  The actual values aren't yet defined.  They will probably not
  correspond so neatly to Perl builtin function names.
  
  C<ARG1> and C<ARG2> hold numeric and string values for C<$!>,
  respectively.  C<"$!"> will eq C<""> for read error 0 (child process
  closed the file handle).
  
  C<ARG3> contains the wheel's unique ID.
  
  C<ARG4> contains the name of the child filehandle that has the error.
  It may be "STDIN", "STDOUT", or "STDERR".  The sense of C<ARG0> will
  be the opposite of what you might normally expect for these handles.
  For example, POE::Wheel::Run will report a "read" error on "STDOUT"
  because it tried to read data from the child's STDOUT handle.
  
  A sample error event handler:
  
    sub error_state {
      my ($operation, $errnum, $errstr, $wheel_id) = @_[ARG0..ARG3];
      $errstr = "remote end closed" if $operation eq "read" and !$errnum;
      warn "Wheel $wheel_id generated $operation error $errnum: $errstr\n";
    }
  
  Note that unless you deactivate the signal pipe, you might also see C<EIO>
  (5) error during read operations.
  
  =head4 StdinEvent
  
  StdinEvent contains the name of an event that Wheel::Run emits
  whenever everything queued by its put() method has been flushed to the
  child's STDIN handle.  It is the equivalent to POE::Wheel::ReadWrite's
  FlushedEvent.
  
  StdinEvent comes with only one additional parameter: C<ARG0> contains
  the unique ID for the wheel that sent the event.
  
  =head4 StdoutEvent
  
  StdoutEvent contains the name of an event  that Wheel::Run emits
  whenever the child process writes something to its STDOUT filehandle.
  In other words, whatever the child prints to STDOUT, the parent
  receives a StdoutEvent---provided that the child prints something
  compatible with the parent's StdoutFilter.
  
  StdoutEvent comes with two parameters.  C<ARG0> contains the
  information that the child wrote to STDOUT.  C<ARG1> holds the unique
  ID of the wheel that read the output.
  
    sub stdout_state {
      my ($heap, $input, $wheel_id) = @_[HEAP, ARG0, ARG1];
      print "Child process in wheel $wheel_id wrote to STDOUT: $input\n";
    }
  
  =head4 StderrEvent
  
  StderrEvent behaves exactly as StdoutEvent, except for data the child
  process writes to its STDERR filehandle.
  
  StderrEvent comes with two parameters.  C<ARG0> contains the
  information that the child wrote to STDERR.  C<ARG1> holds the unique
  ID of the wheel that read the output.
  
    sub stderr_state {
      my ($heap, $input, $wheel_id) = @_[HEAP, ARG0, ARG1];
      print "Child process in wheel $wheel_id wrote to STDERR: $input\n";
    }
  
  =head4 RedirectStdout
  
  This is a filehandle or filename to which standard output will be redirected.
  It is an error to use this option together with StdoutEvent. This is useful
  in case your program needs to have standard I/O, but do not actually care for
  its contents to be visible to the parent.
  
  =head4 RedirectStderr
  
  Just like RedirectStdout, but with standard error. It is an error to use this
  together with StderrEvent
  
  =head4 RedirectStdin
  
  This is a filehandle or filename which the child process will use as its
  standard input. It is an error to use this option with StdinEvent
  
  =head4 RedirectOutput
  
  This will redirect stderr and stdout to the same filehandle. This is equivalent
  to do doing something like
  
    $ something > /path/to/output 2>&1
  
  in bourne shell.
  
  =head4 NoStdin
  
  While output filehandles will be closed if there are no events to be received on
  them, stdin is open by default - because lack of an event handler does not
  necessarily mean there is no desired input stream. This option explicitly
  disables the creation of an IPC stdin conduit.
  
  =head4 StdioFilter
  
  StdioFilter, if used, must contain an instance of a POE::Filter
  subclass.  This filter describes how the parent will format put() data
  for the child's STDIN, and how the parent will parse the child's
  STDOUT.
  
  If STDERR will also be parsed, then a separate StderrFilter will also
  be needed.
  
  StdioFilter defaults to a POE::Filter::Line instance, but only if both
  StdinFilter and StdoutFilter are not specified.  If either StdinFilter
  or StdoutFilter is used, then StdioFilter is illegal.
  
  =head4 StdinFilter
  
  StdinFilter may be used to specify a particular STDIN serializer that
  is different from the STDOUT parser.  If specified, it conflicts with
  StdioFilter.  StdinFilter's value, if specified, must be an instance
  of a POE::Filter subclass.
  
  Without a StdinEvent, StdinFilter is illegal.
  
  =head4 StdoutFilter
  
  StdoutFilter may be used to specify a particular STDOUT parser that is
  different from the STDIN serializer.  If specified, it conflicts with
  StdioFilter.  StdoutFilter's value, if specified, must be an instance
  of a POE::Filter subclass.
  
  Without a StdoutEvent, StdoutFilter is illegal.
  
  =head4 StderrFilter
  
  StderrFilter may be used to specify a filter for a child process'
  STDERR output.  If omitted, POE::Wheel::Run will create and use its
  own POE::Filter::Line instance, but only if a StderrEvent is
  specified.
  
  Without a StderrEvent, StderrFilter is illegal.
  
  =head4 Group
  
  Group contains a numeric group ID that the child process should run
  within.  By default, the child process will run in the same group as
  the parent.
  
  Group is not fully portable.  It may not work on systems that have no
  concept of user groups.  Also, the parent process may need to run with
  elevated privileges for the child to be able to change groups.
  
  =head4 User
  
  User contains a numeric user ID that should own the child process.  By
  default, the child process will run as the same user as the parent.
  
  User is not fully portable.  It may not work on systems that have no
  concept of users.  Also, the parent process may need to run with
  elevated privileges for the child to be able to change users.
  
  =head4 NoSetSid
  
  When true, NoSetSid disables setsid() in the child process.  By
  default, the child process calls setsid() is called so that it may
  execute in a separate UNIX session.
  
  =head4 NoSetPgrp
  
  When true, NoSetPgrp disables setprgp() in the child process. By
  default, the child process calls setpgrp() to change its process
  group, if the OS supports that.
  
  setsid() is used instead of setpgrp() if Conduit is pty or pty-pipe.
  See L</NoSetSid>.
  
  =head4 Priority
  
  Priority adjusts the child process' niceness or priority level,
  depending on which (if any) the underlying OS supports.  Priority
  contains a numeric offset which will be added to the parent's priority
  to determine the child's.
  
  The priority offset may be negative, which in UNIX represents a higher
  priority.  However UNIX requires elevated privileges to increase a
  process' priority.
  
  =head4 Program
  
  Program specifies the program to exec() or the block of code to run in
  the child process.  Program's type is significant.
  
  If Program holds a scalar, its value will be executed as
  exec($program).  Shell metacharacters are significant, per
  exec(SCALAR) semantics.
  
  If Program holds an array reference, it will executed as
  exec(@$program).  As per exec(ARRAY), shell metacharacters will not be
  significant.
  
  If Program holds a code reference, that code will be called in the
  child process.  This mode allows POE::Wheel::Run to execute
  long-running internal code asynchronously, while the usual modes
  execute external programs.  The child process will exit after that
  code is finished, in such a way as to avoid DESTROY and END block
  execution.  See L</Coderef Execution Side Effects> for more details.
  
  L<perlfunc> has more information about exec() and the different ways
  to call it.
  
  Please avoid calling exit() explicitly when executing a subroutine.
  The child process inherits all objects from the parent, including ones
  that may perform side effects.  POE::Wheel::Run takes special care to
  avoid object destructors and END blocks in the child process, but
  calling exit() will trigger them.
  
  =head4 ProgramArgs
  
  If specified, ProgramArgs should refer to a list of parameters for the
  program being run.
  
    my @parameters = qw(foo bar baz);  # will be passed to Program
    ProgramArgs => \@parameters;
  
  =head2 event EVENT_TYPE => EVENT_NAME, ...
  
  event() allows programs to change the events that Wheel::Run emits
  when certain activities occurs.  EVENT_TYPE may be one of the event
  parameters described in POE::Wheel::Run's constructor.
  
  This example changes the events that $wheel emits for STDIN flushing
  and STDOUT activity:
  
    $wheel->event(
      StdinEvent  => 'new-stdin-event',
      StdoutEvent => 'new-stdout-event',
    );
  
  Undefined EVENT_NAMEs disable events.
  
  =head2 put RECORDS
  
  put() queues up a list of RECORDS that will be sent to the child
  process' STDIN filehandle.  These records will first be serialized
  according to the wheel's StdinFilter.  The serialized RECORDS will be
  flushed asynchronously once the current event handler returns.
  
  =head2 get_stdin_filter
  
  get_stind_filter() returns the POE::Filter object currently being used
  to serialize put() records for the child's STDIN filehandle.  The
  return object may be used according to its own interface.
  
  =head2 get_stdout_filter
  
  get_stdout_filter() returns the POE::Filter object currently being
  used to parse what the child process writes to STDOUT.
  
  =head2 get_stderr_filter
  
  get_stderr_filter() returns the POE::Filter object currently being
  used to parse what the child process writes to STDERR.
  
  =head2 set_stdio_filter FILTER_OBJECT
  
  Set StdinFilter and StdoutFilter to the same new FILTER_OBJECT.
  Unparsed STDOUT data will be parsed later by the new FILTER_OBJECT.
  However, data already put() will remain serialized by the old filter.
  
  =head2 set_stdin_filter FILTER_OBJECT
  
  Set StdinFilter to a new FILTER_OBJECT.  Data already put() will
  remain serialized by the old filter.
  
  =head2 set_stdout_filter FILTER_OBJECT
  
  Set StdoutFilter to a new FILTER_OBJECT.  Unparsed STDOUT data will be
  parsed later by the new FILTER_OBJECT.
  
  =head2 set_stderr_filter FILTER_OBJECT
  
  Set StderrFilter to a new FILTER_OBJECT.  Unparsed STDERR data will be
  parsed later by the new FILTER_OBJECT.
  
  =head2 pause_stdout
  
  Pause reading of STDOUT from the child.  The child process may block
  if the STDOUT IPC conduit fills up.  Reading may be resumed with
  resume_stdout().
  
  =head2 pause_stderr
  
  Pause reading of STDERR from the child.  The child process may block
  if the STDERR IPC conduit fills up.  Reading may be resumed with
  resume_stderr().
  
  =head2 resume_stdout
  
  Resume reading from the child's STDOUT filehandle.  This is only
  meaningful if pause_stdout() has been called and remains in effect.
  
  =head2 resume_stderr
  
  Resume reading from the child's STDERR filehandle.  This is only
  meaningful if pause_stderr() has been called and remains in effect.
  
  =head2 shutdown_stdin
  
  shutdown_stdin() closes the child process' STDIN and stops the wheel
  from reporting StdinEvent.  It is extremely useful for running
  utilities that expect to receive EOF on STDIN before they respond.
  
  =head2 ID
  
  ID() returns the wheel's unique ID.  Every event generated by a
  POE::Wheel::Run object includes a wheel ID so that it can be matched
  to the wheel that emitted it.  This lets a single session manage
  several wheels without becoming confused about which one generated
  what event.
  
  ID() is not the same as PID().
  
  =head2 PID
  
  PID() returns the process ID for the child represented by the
  POE::Wheel::Run object.  It's often used as a parameter to
  sig_child().
  
  PID() is not the same as ID().
  
  =head2 kill SIGNAL
  
  POE::Wheel::Run's kill() method sends a SIGNAL to the child process
  the object represents.  kill() is often used to force a reluctant
  program to terminate.  SIGNAL is one of the operating signal names
  present in %SIG.
  
  kill() returns the number of processes successfully signaled: 1 on
  success, or 0 on failure, since the POE::Wheel::Run object only
  affects at most a single process.
  
  kill() sends SIGTERM if SIGNAL is undef or omitted.
  
  =head2 get_driver_out_messages
  
  get_driver_out_messages() returns the number of put() records
  remaining in whole or in part in POE::Wheel::Run's POE::Driver output
  queue.  It is often used to tell whether the wheel has more input for
  the child process.
  
  In most cases, StdinEvent may be used to trigger activity when all
  data has been sent to the child process.
  
  =head2 get_driver_out_octets
  
  get_driver_out_octets() returns the number of serialized octets
  remaining in POE::Wheel::Run's POE::Driver output queue.  It is often
  used to tell whether the wheel has more input for the child process.
  
  =head1 TIPS AND TRICKS
  
  =head2 MSWin32 Support
  
  In the past POE::Wheel::Run did not support MSWin32 and users had to
  use custom work-arounds. Then Chris Williams ( BINGOS ) arrived and
  saved the day with his L<POE::Wheel::Run::Win32> module. After some
  testing, it was decided to merge the win32 code into POE::Wheel::Run.
  Everyone was happy!
  
  However, after some investigation Apocalypse ( APOCAL ) found out that
  in some situations it still didn't behave properly. The root cause was
  that the win32 code path in POE::Wheel::Run didn't exit cleanly. This
  means DESTROY and END blocks got executed! After talking with more
  people, the solution was not pretty.
  
  The problem is that there is no equivalent of POSIX::_exit() for MSWin32.
  Hopefully, in a future version of Perl this can be fixed! In the meantime,
  POE::Wheel::Run will use CORE::kill() to terminate the child. However,
  this comes with a caveat: you will leak around 1KB per exec. The code
  has been improved so the chance of this happening has been reduced.
  
  As of now the most reliable way to trigger this is to exec an invalid
  binary. The definition of "invalid binary" depends on different things,
  but what it means is that Win32::Job->spawn() failed to run. This will
  force POE::Wheel::Run to use the workaround to exit the child. If this
  happens, a very big warning will be printed to the STDERR of the child
  and the parent process will receive it.
  
  If you are a Perl MSWin32 hacker, PLEASE help us with this situation! Go
  read rt.cpan.org bug #56417 and talk with us/p5p to see where you can
  contribute.
  
  Thanks again for your patience as we continue to improve POE::Wheel::Run
  on MSWin32!
  
  =head3 kill() and ClosedEvent on Windows
  
  Windows will often fail to report EOF on pipes when subprocesses are
  killed.  The work-around is to catch the signal in the subprocess, and
  exit normally:
  
    my $child = POE::Wheel::Run->new(
      Program => sub {
        $SIG{INT} = sub { exit };
        ...;
      },
      ...,
    );
  
  Be sure to kill() the subprocess using the same signal that it catches
  and exits upon.  Remember, not all signals can be caught by user code.
  
    $child->kill("INT");
  
  =head2 Execution Environment
  
  It's common to scrub a child process' environment, so that only
  required, secure values exist.  This amounts to clearing the contents
  of %ENV and repopulating it.
  
  Environment scrubbing is easy when the child process is running a
  subroutine, but it's not so easy---or at least not as intuitive---when
  executing external programs.
  
  The way we do it is to run a small subroutine in the child process
  that performs the exec() call for us.
  
    Program => \&exec_with_scrubbed_env,
  
    sub exec_with_scrubbed_env {
      delete @ENV{keys @ENV};
      $ENV{PATH} = "/bin";
      exec(@program_and_args);
    }
  
  That deletes everything from the environment and sets a simple, secure
  PATH before executing a program.
  
  =head2 Coderef Execution Side Effects
  
  The child process is created by fork(), which duplicates the parent
  process including a copy of POE::Kernel, all running Session
  instances, events in the queue, watchers, open filehandles, and so on.
  
  When executing an external program, the UNIX exec() call immediately
  replaces the copy of the parent with a completely new program.
  
  When executing internal coderefs, however, we must preserve the code
  and any memory it might reference.  This leads to some potential side
  effects.
  
  =head3 DESTROY and END Blocks Run Twice
  
  Objects that were created in the parent process are copied into the
  child.  When the child exits normally, any DESTROY and END blocks are
  executed there.  Later, when the parent exits, they may run again.
  
  POE::Wheel::Run takes steps to avoid running DESTROY and END blocks in
  the child process.  It uses POSIX::_exit() to bypass them.  If that
  fails, it may even kill() itself.
  
  If an application needs to exit explicitly, for example to return an
  error code to the parent process, then please use POSIX::_exit()
  rather than Perl's core exit().
  
  =head3 POE::Kernel's run() method was never called
  
  This warning is displayed from POE::Kernel's DESTROY method.  It's a
  side effect of calling exit() in a child process that was started
  before C<< POE::Kernel->run() >> could be called.  The child process
  receives a copy of POE::Kernel where run() wasn't called, even if it
  was called later in the parent process.
  
  The most direct solution is to call POSIX::_exit() rather than exit().
  This will bypass POE::Kernel's DESTROY, and the message it emits.
  
  =head3 Running POE::Kernel in the Child
  
  Calling C<< POE::Kernel->run() >> in the child process effectively
  resumes the copy of the parent process.  This is rarely (if ever)
  desired.
  
  More commonly, an application wants to run an entirely new POE::Kernel
  instance in the child process.  This is supported by first stop()ping
  the copied instance, starting one or more new sessions, and calling
  run() again.  For example:
  
    Program => sub {
      # Wipe the existing POE::Kernel clean.
      $poe_kernel->stop();
  
      # Start a new session, or more.
      POE::Session->create(
        ...
      );
  
      # Run the new sessions.
      POE::Kernel->run();
    }
  
  Strange things are bound to happen if the program does not call
  L<POE::Kernel/stop> before L<POE::Kernel/run>.  However this is
  vaguely supported in case it's the right thing to do at the time.
  
  =head1 SEE ALSO
  
  L<POE::Wheel> describes wheels in general.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 CAVEATS & TODOS
  
  POE::Wheel::Run's constructor should emit proper events when it fails.
  Instead, it just dies, carps or croaks.  This isn't necessarily bad; a
  program can trap the death in new() and move on.
  
  Priority is a delta, not an absolute niceness value.
  
  It might be nice to specify User by name rather than just UID.
  
  It might be nice to specify Group by name rather than just GID.
  
  POE::Pipe::OneWay and Two::Way don't require the rest of POE.  They
  should be spun off into a separate distribution for everyone to enjoy.
  
  If StdinFilter and StdoutFilter seem backwards, remember that it's the
  filters for the child process.  StdinFilter is the one that dictates
  what the child receives on STDIN.  StdoutFilter tells the parent how
  to parse the child's STDOUT.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_WHEEL_RUN

$fatpacked{"POE/Wheel/SocketFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POE_WHEEL_SOCKETFACTORY';
  package POE::Wheel::SocketFactory;
  
  use strict;
  
  use vars qw($VERSION @ISA);
  $VERSION = '1.364'; # NOTE - Should be #.### (three decimal places)
  
  use Carp qw( carp croak );
  use Symbol qw( gensym );
  
  use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
  use Errno qw(
    EWOULDBLOCK EADDRNOTAVAIL EINPROGRESS EADDRINUSE ECONNABORTED
    ESPIPE
  );
  
  use Socket qw(
    AF_INET SOCK_STREAM SOL_SOCKET AF_UNIX PF_UNIX 
    PF_INET SOCK_DGRAM SO_ERROR unpack_sockaddr_in 
    unpack_sockaddr_un PF_UNSPEC SO_REUSEADDR INADDR_ANY 
    pack_sockaddr_in pack_sockaddr_un inet_aton SOMAXCONN
  );
  
  use IO::Handle ();
  use FileHandle ();
  use POE qw( Wheel );
  push @ISA, qw(POE::Wheel);
  
  sub CRIMSON_SCOPE_HACK ($) { 0 }
  sub DEBUG () { 0 }
  
  sub MY_SOCKET_HANDLE   () {  0 }
  sub MY_UNIQUE_ID       () {  1 }
  sub MY_EVENT_SUCCESS   () {  2 }
  sub MY_EVENT_FAILURE   () {  3 }
  sub MY_SOCKET_DOMAIN   () {  4 }
  sub MY_STATE_ACCEPT    () {  5 }
  sub MY_STATE_CONNECT   () {  6 }
  sub MY_MINE_SUCCESS    () {  7 }
  sub MY_MINE_FAILURE    () {  8 }
  sub MY_SOCKET_PROTOCOL () {  9 }
  sub MY_SOCKET_TYPE     () { 10 }
  sub MY_STATE_ERROR     () { 11 }
  sub MY_SOCKET_SELECTED () { 12 }
  
  # Fletch has subclassed SSLSocketFactory from SocketFactory.
  # He's added new members after MY_SOCKET_SELECTED.  Be sure, if you
  # extend this, to extend add stuff BEFORE MY_SOCKET_SELECTED or let
  # Fletch know you've broken his module.
  
  # If IPv6 support can't be loaded, then provide dummies so the code at
  # least compiles.  Suggested in rt.cpan.org 27250.
  BEGIN {
  
    eval { Socket->import( qw(getaddrinfo getnameinfo unpack_sockaddr_in6) ) };
    if ($@) {
      *getaddrinfo = sub { Carp::confess("Unable to use IPv6: Socket doesn't provide getaddrinfo()") };
      *getnameinfo = sub { Carp::confess("Unable to use IPv6: Socket doesn't provide getnameinfo()") };
      *unpack_sockaddr_in6 = sub { Carp::confess("Unable to use IPv6: Socket doesn't provide unpack_sockaddr_in6()") };
    }
  
    # Socket6 provides AF_INET6 and PF_INET6 where earlier Perls' Socket don't.
    eval { Socket->import( qw(AF_INET6 PF_INET6) ) };
    if ($@) {
      eval { require Socket6; Socket6->import( qw(AF_INET6 PF_INET6) ) };
      if ($@) {
        *AF_INET6 = sub { -1 };
        *PF_INET6 = sub { -1 };
      }
    }
  }
  
  #------------------------------------------------------------------------------
  # These tables customize the socketfactory.  Many protocols share the
  # same operations, it seems, and this is a way to add new ones with a
  # minimum of additional code.
  
  sub DOM_UNIX  () { 'unix'  }  # UNIX domain socket
  sub DOM_INET  () { 'inet'  }  # INET domain socket
  sub DOM_INET6 () { 'inet6' }  # INET v6 domain socket
  
  # AF_XYZ and PF_XYZ may be different.
  my %map_family_to_domain = (
    AF_UNIX,  DOM_UNIX,  PF_UNIX,  DOM_UNIX,
    AF_INET,  DOM_INET,  PF_INET,  DOM_INET,
    AF_INET6, DOM_INET6,
    PF_INET6, DOM_INET6,
  );
  
  sub SVROP_LISTENS () { 'listens' }  # connect/listen sockets
  sub SVROP_NOTHING () { 'nothing' }  # connectionless sockets
  
  # Map family/protocol pairs to connection or connectionless
  # operations.
  my %supported_protocol = (
    DOM_UNIX, {
      none => SVROP_LISTENS
    },
    DOM_INET, {
      tcp  => SVROP_LISTENS,
      udp  => SVROP_NOTHING,
    },
    DOM_INET6, {
      tcp  => SVROP_LISTENS,
      udp  => SVROP_NOTHING,
    },
  );
  
  # Sane default socket types for each supported protocol.  TODO Maybe
  # this structure can be combined with %supported_protocol?
  my %default_socket_type = (
    DOM_UNIX, {
      none => SOCK_STREAM
    },
    DOM_INET, {
      tcp  => SOCK_STREAM,
      udp  => SOCK_DGRAM,
    },
    DOM_INET6, {
      tcp  => SOCK_STREAM,
      udp  => SOCK_DGRAM,
    },
  );
  
  #------------------------------------------------------------------------------
  # Perform system-dependent translations on Unix addresses, if
  # necessary.
  
  sub _condition_unix_address {
    my ($address) = @_;
  
    # OS/2 would like sockets to use backwhacks, and please place them
    # in the virtual \socket\ directory.  Thank you.
    if ($^O eq 'os2') {
      $address =~ tr[\\][/];
      if ($address !~ m{^/socket/}) {
        $address =~ s{^/?}{/socket/};
      }
      $address =~ tr[/][\\];
    }
  
    $address;
  }
  
  #------------------------------------------------------------------------------
  # Define the select handler that will accept connections.
  
  sub _define_accept_state {
    my $self = shift;
  
    # We do these stupid closure tricks to avoid putting $self in it
    # directly.  If you include $self in one of the state() closures,
    # the component will fail to shut down properly: there will be a
    # circular definition in the closure holding $self alive.
  
    my $domain = $map_family_to_domain{ $self->[MY_SOCKET_DOMAIN] };
    $domain = '(undef)' unless defined $domain;
    my $event_success = \$self->[MY_EVENT_SUCCESS];
    my $event_failure = \$self->[MY_EVENT_FAILURE];
    my $unique_id     =  $self->[MY_UNIQUE_ID];
  
    $poe_kernel->state(
      $self->[MY_STATE_ACCEPT] = ref($self) . "($unique_id) -> select accept",
      sub {
        # prevents SEGV
        0 && CRIMSON_SCOPE_HACK('<');
  
        # subroutine starts here
        my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];
  
        my $new_socket = gensym;
        my $peer = accept($new_socket, $handle);
  
        if ($peer) {
          my ($peer_addr, $peer_port);
          if ( $domain eq DOM_UNIX ) {
            $peer_port = undef;
            eval { $peer_addr = unpack_sockaddr_un($peer) };
            $peer_addr = undef if length $@;
          }
          elsif ( $domain eq DOM_INET ) {
            ($peer_port, $peer_addr) = unpack_sockaddr_in($peer);
          }
          elsif ( $domain eq DOM_INET6 ) {
            ($peer_addr, $peer_port) = unpack_sockaddr_in6($peer);
          }
          else {
            die "sanity failure: socket domain == $domain";
          }
          $k->call(
            $me, $$event_success,
            $new_socket, $peer_addr, $peer_port,
            $unique_id
          );
        }
        elsif ($! != EWOULDBLOCK and $! != ECONNABORTED and $! != ESPIPE) {
          # OSX reports ESPIPE, which isn't documented anywhere.
          $$event_failure && $k->call(
            $me, $$event_failure,
            'accept', ($!+0), $!, $unique_id
          );
        }
      }
    );
  
    $self->[MY_SOCKET_SELECTED] = 'yes';
    $poe_kernel->select_read(
      $self->[MY_SOCKET_HANDLE],
      $self->[MY_STATE_ACCEPT]
    );
  }
  
  #------------------------------------------------------------------------------
  # Define the select handler that will finalize an established
  # connection.
  
  sub _define_connect_state {
    my $self = shift;
  
    # We do these stupid closure tricks to avoid putting $self in it
    # directly.  If you include $self in one of the state() closures,
    # the component will fail to shut down properly: there will be a
    # circular definition in the closure holding $self alive.
  
    my $domain = $map_family_to_domain{ $self->[MY_SOCKET_DOMAIN] };
    $domain = '(undef)' unless defined $domain;
    my $event_success   = \$self->[MY_EVENT_SUCCESS];
    my $event_failure   = \$self->[MY_EVENT_FAILURE];
    my $unique_id       =  $self->[MY_UNIQUE_ID];
    my $socket_selected = \$self->[MY_SOCKET_SELECTED];
  
    my $socket_handle   = \$self->[MY_SOCKET_HANDLE];
    my $state_accept    = \$self->[MY_STATE_ACCEPT];
    my $state_connect   = \$self->[MY_STATE_CONNECT];
    my $mine_success    = \$self->[MY_MINE_SUCCESS];
    my $mine_failure    = \$self->[MY_MINE_FAILURE];
  
    $poe_kernel->state(
      $self->[MY_STATE_CONNECT] = (
        ref($self) .  "($unique_id) -> select connect"
      ),
      sub {
        # This prevents SEGV in older versions of Perl.
        0 && CRIMSON_SCOPE_HACK('<');
  
        # Grab some values and stop watching the socket.
        my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];
  
        _shutdown(
          $socket_selected, $socket_handle,
          $state_accept, $state_connect,
          $mine_success, $event_success,
          $mine_failure, $event_failure,
        );
  
        # Throw a failure if the connection failed.
        $! = unpack('i', getsockopt($handle, SOL_SOCKET, SO_ERROR));
        if ($!) {
          (defined $$event_failure) and $k->call(
            $me, $$event_failure,
            'connect', ($!+0), $!, $unique_id
          );
          return;
        }
  
        # Get the remote address, or throw an error if that fails.
        my $peer = getpeername($handle);
        if ($!) {
          (defined $$event_failure) and $k->call(
            $me, $$event_failure,
            'getpeername', ($!+0), $!, $unique_id
          );
          return;
        }
  
        # Parse the remote address according to the socket's domain.
        my ($peer_addr, $peer_port);
  
        # UNIX sockets have some trouble with peer addresses.
        if ($domain eq DOM_UNIX) {
          if (defined $peer) {
            eval { $peer_addr = unpack_sockaddr_un($peer) };
            $peer_addr = undef if length $@;
          }
        }
  
        # INET socket stacks tend not to.
        elsif ($domain eq DOM_INET) {
          if (defined $peer) {
            eval {
              ($peer_port, $peer_addr) = unpack_sockaddr_in($peer);
            };
            if (length $@) {
              $peer_port = $peer_addr = undef;
            }
          }
        }
  
        # INET6 socket stacks tend not to.
        elsif ($domain eq DOM_INET6) {
          if (defined $peer) {
            ((my $error), $peer_addr, $peer_port) = getnameinfo($peer);
            if ($error) {
              warn $error;
              $peer_port = $peer_addr = undef;
            }
          }
        }
  
        # What are we doing here?
        else {
          die "sanity failure: socket domain == $domain";
        }
  
        # Tell the session it went okay.  Also let go of the socket.
        $k->call(
          $me, $$event_success,
          $handle, $peer_addr, $peer_port, $unique_id
        );
      }
    );
  
    # Cygwin and Windows expect an error state registered to expedite.
    # This code is nearly identical the stuff above.
    if ($^O eq "cygwin" or $^O eq "MSWin32") {
      $poe_kernel->state(
        $self->[MY_STATE_ERROR] = (
          ref($self) .  "($unique_id) -> connect error"
        ),
        sub {
          # This prevents SEGV in older versions of Perl.
          0 && CRIMSON_SCOPE_HACK('<');
  
          # Grab some values and stop watching the socket.
          my ($k, $me, $handle) = @_[KERNEL, SESSION, ARG0];
  
          _shutdown(
            $socket_selected, $socket_handle,
            $state_accept, $state_connect,
            $mine_success, $event_success,
            $mine_failure, $event_failure,
          );
  
          # Throw a failure if the connection failed.
          $! = unpack('i', getsockopt($handle, SOL_SOCKET, SO_ERROR));
          if ($!) {
            (defined $$event_failure) and $k->call(
              $me, $$event_failure, 'connect', ($!+0), $!, $unique_id
            );
            return;
          }
        }
      );
      $poe_kernel->select_expedite(
        $self->[MY_SOCKET_HANDLE],
        $self->[MY_STATE_ERROR]
      );
    }
  
    $self->[MY_SOCKET_SELECTED] = 'yes';
    $poe_kernel->select_write(
      $self->[MY_SOCKET_HANDLE],
      $self->[MY_STATE_CONNECT]
    );
  }
  
  #------------------------------------------------------------------------------
  
  sub event {
    my $self = shift;
    push(@_, undef) if (scalar(@_) & 1);
  
    while (@_) {
      my ($name, $event) = splice(@_, 0, 2);
  
      if ($name eq 'SuccessEvent') {
        if (defined $event) {
          if (ref($event)) {
            carp "reference for SuccessEvent will be treated as an event name"
          }
          $self->[MY_EVENT_SUCCESS] = $event;
          undef $self->[MY_MINE_SUCCESS];
        }
        else {
          carp "SuccessEvent requires an event name.  ignoring undef";
        }
      }
      elsif ($name eq 'FailureEvent') {
        if (defined $event) {
          if (ref($event)) {
            carp "reference for FailureEvent will be treated as an event name";
          }
          $self->[MY_EVENT_FAILURE] = $event;
          undef $self->[MY_MINE_FAILURE];
        }
        else {
          carp "FailureEvent requires an event name.  ignoring undef";
        }
      }
      else {
        carp "ignoring unknown SocketFactory parameter '$name'";
      }
    }
  
    $self->[MY_SOCKET_SELECTED] = 'yes';
    if (defined $self->[MY_STATE_ACCEPT]) {
      $poe_kernel->select_read(
        $self->[MY_SOCKET_HANDLE],
        $self->[MY_STATE_ACCEPT]
       );
    }
    elsif (defined $self->[MY_STATE_CONNECT]) {
      $poe_kernel->select_write(
        $self->[MY_SOCKET_HANDLE],
        $self->[MY_STATE_CONNECT]
      );
      if ($^O eq "cygwin" or $^O eq "MSWin32") {
        $poe_kernel->select_expedite(
          $self->[MY_SOCKET_HANDLE],
          $self->[MY_STATE_ERROR]
        );
      }
    }
    else {
      die "POE developer error - no state defined";
    }
  }
  
  #------------------------------------------------------------------------------
  
  sub getsockname {
    my $self = shift;
    return undef unless (
      defined $self->[MY_SOCKET_HANDLE] and
      fileno($self->[MY_SOCKET_HANDLE])
    );
    return getsockname($self->[MY_SOCKET_HANDLE]);
  }
  
  sub ID {
    return $_[0]->[MY_UNIQUE_ID];
  }
  
  #------------------------------------------------------------------------------
  
  sub new {
    my $type = shift;
  
    # Don't take responsibility for a bad parameter count.
    croak "$type requires an even number of parameters" if @_ & 1;
  
    my %params = @_;
  
    # The calling convention experienced a hard deprecation.
    croak "wheels no longer require a kernel reference as their first parameter"
      if (@_ && (ref($_[0]) eq 'POE::Kernel'));
  
    # Ensure some of the basic things are present.
    croak "$type requires a working Kernel" unless (defined $poe_kernel);
    croak 'SuccessEvent required' unless (defined $params{SuccessEvent});
    croak 'FailureEvent required' unless (defined $params{FailureEvent});
    my $event_success = $params{SuccessEvent};
    my $event_failure = $params{FailureEvent};
  
    # Create the SocketServer.  Cache a copy of the socket handle.
    my $socket_handle = gensym();
    my $self = bless(
      [
        $socket_handle,                   # MY_SOCKET_HANDLE
        &POE::Wheel::allocate_wheel_id(), # MY_UNIQUE_ID
        $event_success,                   # MY_EVENT_SUCCESS
        $event_failure,                   # MY_EVENT_FAILURE
        undef,                            # MY_SOCKET_DOMAIN
        undef,                            # MY_STATE_ACCEPT
        undef,                            # MY_STATE_CONNECT
        undef,                            # MY_MINE_SUCCESS
        undef,                            # MY_MINE_FAILURE
        undef,                            # MY_SOCKET_PROTOCOL
        undef,                            # MY_SOCKET_TYPE
        undef,                            # MY_STATE_ERROR
        undef,                            # MY_SOCKET_SELECTED
      ],
      $type
    );
  
    # Default to Internet sockets.
    my $domain = delete $params{SocketDomain};
    if (defined $domain) {
      # [rt.cpan.org 76314] Untaint the domain.
      ($domain) = ($domain =~ /\A(.*)\z/s);
    }
    else {
      $domain = AF_INET;
    }
    $self->[MY_SOCKET_DOMAIN] = $domain;
  
    # Abstract the socket domain into something we don't have to keep
    # testing duplicates of.
    my $abstract_domain = $map_family_to_domain{$self->[MY_SOCKET_DOMAIN]};
    unless (defined $abstract_domain) {
      $poe_kernel->yield(
        $event_failure,
        'domain',
        0,
        "SocketDomain $domain is currently unsupported on this platform",
        $self->[MY_UNIQUE_ID]
      );
      return $self;
    }
  
    #---------------#
    # Create Socket #
    #---------------#
  
    # Declare the protocol name out here; it'll be needed by
    # getservbyname later.
    my $protocol_name;
  
    # Unix sockets don't use protocols; warn the programmer, and force
    # PF_UNSPEC.
    if ($abstract_domain eq DOM_UNIX) {
      carp 'SocketProtocol ignored for Unix socket'
        if defined $params{SocketProtocol};
      $self->[MY_SOCKET_PROTOCOL] = PF_UNSPEC;
      $protocol_name = 'none';
    }
  
    # Internet sockets use protocols.  Default the INET protocol to tcp,
    # and try to resolve it.
    elsif (
      $abstract_domain eq DOM_INET or
      $abstract_domain eq DOM_INET6
    ) {
      my $socket_protocol = (
        (defined $params{SocketProtocol})
        ? $params{SocketProtocol}
        : 'tcp'
      );
  
      if ($socket_protocol !~ /^\d+$/) {
        unless ($socket_protocol = getprotobyname($socket_protocol)) {
          $poe_kernel->yield(
            $event_failure, 'getprotobyname', $!+0, $!, $self->[MY_UNIQUE_ID]
          );
          return $self;
        }
      }
  
      # Get the protocol's name regardless of what was provided.  If the
      # protocol isn't supported, croak now instead of making the
      # programmer wonder why things fail later.
      $protocol_name = lc(getprotobynumber($socket_protocol));
      unless ($protocol_name) {
        $poe_kernel->yield(
          $event_failure, 'getprotobynumber', $!+0, $!, $self->[MY_UNIQUE_ID]
        );
        return $self;
      }
  
      unless (defined $supported_protocol{$abstract_domain}->{$protocol_name}) {
        croak "SocketFactory does not support Internet $protocol_name sockets";
      }
  
      $self->[MY_SOCKET_PROTOCOL] = $socket_protocol;
    }
    else {
      die "Mail this error to the author of POE: Internal consistency error";
    }
  
    # If no SocketType, default it to something appropriate.
    if (defined $params{SocketType}) {
      $self->[MY_SOCKET_TYPE] = $params{SocketType};
    }
    else {
      unless (defined $default_socket_type{$abstract_domain}->{$protocol_name}) {
        croak "SocketFactory does not support $abstract_domain $protocol_name";
      }
      $self->[MY_SOCKET_TYPE] =
        $default_socket_type{$abstract_domain}->{$protocol_name};
    }
  
    # o  create a dummy socket
    # o  cache the value of SO_OPENTYPE in $win32_socket_opt
    # o  set the overlapped io attribute
    # o  close dummy socket
    my $win32_socket_opt;
    if ( POE::Kernel::RUNNING_IN_HELL) {
  
      # Constants are evaluated first so they exist when the code uses
      # them.
      eval {
        *SO_OPENTYPE     = sub () { 0x7008 };
        *SO_SYNCHRONOUS_ALERT    = sub () { 0x10 };
        *SO_SYNCHRONOUS_NONALERT = sub () { 0x20 };
      };
      die "Could not install SO constants [$@]" if $@;
  
      # Turn on socket overlapped IO attribute per MSKB: Q181611. 
  
      eval {
        socket(POE, AF_INET, SOCK_STREAM, getprotobyname("tcp"))
          or die "socket failed: $!";
        my $opt = unpack("I", getsockopt(POE, SOL_SOCKET, SO_OPENTYPE()));
        $win32_socket_opt = $opt;
        $opt &= ~(SO_SYNCHRONOUS_ALERT()|SO_SYNCHRONOUS_NONALERT());
        setsockopt(POE, SOL_SOCKET, SO_OPENTYPE(), $opt);
        close POE;
      };
  
      die if $@;
    }
  
    # Create the socket.
    unless (
      socket( $socket_handle, $self->[MY_SOCKET_DOMAIN],
        $self->[MY_SOCKET_TYPE], $self->[MY_SOCKET_PROTOCOL]
      )
    ) {
      $poe_kernel->yield(
        $event_failure, 'socket', $!+0, $!, $self->[MY_UNIQUE_ID]
      );
      return $self;
    }
  
    # o  create a dummy socket
    # o  restore previous value of SO_OPENTYPE
    # o  close dummy socket
    #
    # This way we'd only be turning on the overlap attribute for
    # the socket we created... and not all subsequent sockets.
    if ( POE::Kernel::RUNNING_IN_HELL) {
      eval {
        socket(POE, AF_INET, SOCK_STREAM, getprotobyname("tcp"))
          or die "socket failed: $!";
        setsockopt(POE, SOL_SOCKET, SO_OPENTYPE(), $win32_socket_opt);
        close POE;
      };
  
      die if $@;
    }
    DEBUG && warn "socket";
  
    #------------------#
    # Configure Socket #
    #------------------#
  
    # Make the socket binary.  It's wrapped in eval{} because tied
    # filehandle classes may actually die in their binmode methods.
    eval { binmode($socket_handle) };
  
    # Don't block on socket operations, because the socket will be
    # driven by a select loop.
    $socket_handle->blocking(0);
  
    # Make the socket reusable, if requested.
    if (
      (defined $params{Reuse})
         and ( (lc($params{Reuse}) eq 'yes')
               or (lc($params{Reuse}) eq 'on')
               or ( ($params{Reuse} =~ /\d+/)
                    and $params{Reuse}
                  )
             )
       )
    {
      setsockopt($socket_handle, SOL_SOCKET, SO_REUSEADDR, 1) or do {
        $poe_kernel->yield(
          $event_failure,
          'setsockopt', $!+0, $!, $self->[MY_UNIQUE_ID]
        );
        return $self;
      };
    }
  
    #-------------#
    # Bind Socket #
    #-------------#
  
    my $bind_address;
  
    # Check SocketFactory /Bind.*/ parameters in an Internet socket
    # context, and translate them into parameters that bind()
    # understands.
    if ($abstract_domain eq DOM_INET) {
      # Don't bind if the creator doesn't specify a related parameter.
      if ((defined $params{BindAddress}) or (defined $params{BindPort})) {
  
        # Set the bind address, or default to INADDR_ANY.
        $bind_address = (
          (defined $params{BindAddress})
          ? $params{BindAddress}
          : INADDR_ANY
        );
  
        # Need to check lengths in octets, not characters.
        BEGIN { eval { require bytes } and bytes->import; }
  
        # Resolve the bind address if it's not already packed.
        unless (length($bind_address) == 4) {
          $bind_address = inet_aton($bind_address);
        }
  
        unless (defined $bind_address) {
          $! = EADDRNOTAVAIL;
          $poe_kernel->yield(
            $event_failure,
            "inet_aton", $!+0, $!, $self->[MY_UNIQUE_ID]
          );
          return $self;
        }
  
        # Set the bind port, or default to 0 (any) if none specified.
        # Resolve it to a number, if at all possible.
        my $bind_port = (defined $params{BindPort}) ? $params{BindPort} : 0;
        if ($bind_port =~ /[^0-9]/) {
          $bind_port = getservbyname($bind_port, $protocol_name);
          unless (defined $bind_port) {
            $! = EADDRNOTAVAIL;
            $poe_kernel->yield(
              $event_failure,
              'getservbyname', $!+0, $!, $self->[MY_UNIQUE_ID]
            );
            return $self;
          }
        }
  
        $bind_address = pack_sockaddr_in($bind_port, $bind_address);
        unless (defined $bind_address) {
          $poe_kernel->yield(
            $event_failure,
            "pack_sockaddr_in", $!+0, $!, $self->[MY_UNIQUE_ID]
          );
          return $self;
        }
      }
    }
  
    # Check SocketFactory /Bind.*/ parameters in an Internet socket
    # context, and translate them into parameters that bind()
    # understands.
    elsif ($abstract_domain eq DOM_INET6) {
  
      # Don't bind if the creator doesn't specify a related parameter.
      if ((defined $params{BindAddress}) or (defined $params{BindPort})) {
  
        # Set the bind address, or default to INADDR_ANY.
        $bind_address = (
          (defined $params{BindAddress})
          ? $params{BindAddress}
          : "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"  # XXX - Only Socket6 has?
        );
  
        # Set the bind port, or default to 0 (any) if none specified.
        # Resolve it to a number, if at all possible.
        my $bind_port = (defined $params{BindPort}) ? $params{BindPort} : 0;
        if ($bind_port =~ /[^0-9]/) {
          $bind_port = getservbyname($bind_port, $protocol_name);
          unless (defined $bind_port) {
            $! = EADDRNOTAVAIL;
            $poe_kernel->yield(
              $event_failure,
              'getservbyname', $!+0, $!, $self->[MY_UNIQUE_ID]
            );
            return $self;
          }
        }
  
        # Need to check lengths in octets, not characters.
        BEGIN { eval { require bytes } and bytes->import; }
  
        # Resolve the bind address.
        my ($error, @addresses) = getaddrinfo(
          $bind_address, $bind_port, {
            family   => $self->[MY_SOCKET_DOMAIN],
            socktype => $self->[MY_SOCKET_TYPE],
          }
        );
  
        unless (@addresses) {
          warn $error if $error;
  
          $! = EADDRNOTAVAIL;
          $poe_kernel->yield(
            $event_failure,
            "getaddrinfo", $!+0, $!, $self->[MY_UNIQUE_ID]
          );
          return $self;
        }
  
        $bind_address = $addresses[0]->{addr};
      }
    }
  
    # Check SocketFactory /Bind.*/ parameters in a Unix context, and
    # translate them into parameters bind() understands.
    elsif ($abstract_domain eq DOM_UNIX) {
      carp 'BindPort ignored for Unix socket' if defined $params{BindPort};
  
      if (defined $params{BindAddress}) {
        # Is this necessary, or will bind() return EADDRINUSE?
        if (defined $params{RemotePort}) {
          $! = EADDRINUSE;
          $poe_kernel->yield(
            $event_failure,
            'bind', $!+0, $!, $self->[MY_UNIQUE_ID]
          );
          return $self;
        }
  
        $bind_address = &_condition_unix_address($params{BindAddress});
        $bind_address = pack_sockaddr_un($bind_address);
        unless ($bind_address) {
          $poe_kernel->yield(
            $event_failure,
            'pack_sockaddr_un', $!+0, $!, $self->[MY_UNIQUE_ID]
          );
          return $self;
        }
      }
    }
  
    # This is an internal consistency error, and it should be hard
    # trapped right away.
    else {
      die "Mail this error to the author of POE: Internal consistency error";
    }
  
    # Perform the actual bind, if there's a bind address to bind to.
    if (defined $bind_address) {
      unless (bind($socket_handle, $bind_address)) {
        $poe_kernel->yield(
          $event_failure,
          'bind', $!+0, $!, $self->[MY_UNIQUE_ID]
        );
        return $self;
      }
  
      DEBUG && warn "bind";
    }
  
    #---------#
    # Connect #
    #---------#
  
    my $connect_address;
  
    if (defined $params{RemoteAddress}) {
  
      # Check SocketFactory /Remote.*/ parameters in an Internet socket
      # context, and translate them into parameters that connect()
      # understands.
      if (
        $abstract_domain eq DOM_INET or
        $abstract_domain eq DOM_INET6
      ) {
        # connecting if RemoteAddress
        croak 'RemotePort required' unless (defined $params{RemotePort});
        carp 'ListenQueue ignored' if (defined $params{ListenQueue});
  
        my $remote_port = $params{RemotePort};
        if ($remote_port =~ /[^0-9]/) {
          unless ($remote_port = getservbyname($remote_port, $protocol_name)) {
            $! = EADDRNOTAVAIL;
            $poe_kernel->yield(
              $event_failure,
              'getservbyname', $!+0, $!, $self->[MY_UNIQUE_ID]
            );
            return $self;
          }
        }
  
        my $error_tag;
        if ($abstract_domain eq DOM_INET) {
          $connect_address = inet_aton($params{RemoteAddress});
          $error_tag = "inet_aton";
        }
        elsif ($abstract_domain eq DOM_INET6) {
          my ($error, @addresses) = getaddrinfo(
            $params{RemoteAddress}, $remote_port, {
              family   => $self->[MY_SOCKET_DOMAIN],
              socktype => $self->[MY_SOCKET_TYPE],
            },
          );
  
          unless (@addresses) {
            warn $error if $error;
            $connect_address = undef;
          }
          else {
            $connect_address = $addresses[0]->{addr};
          }
  
          $error_tag = "getaddrinfo";
        }
        else {
          die "unknown domain $abstract_domain";
        }
  
        # TODO - If the gethostbyname2() code is removed, then we can
        # combine the previous code with the following code, and perhaps
        # remove one of these redundant $connect_address checks.  The
        # 0.29 release should tell us pretty quickly whether it's
        # needed.  If we reach 0.30 without incident, it's probably safe
        # to remove the old gethostbyname2() code and clean this up.
        unless (defined $connect_address) {
          $! = EADDRNOTAVAIL;
          $poe_kernel->yield(
            $event_failure,
            $error_tag, $!+0, $!, $self->[MY_UNIQUE_ID]
          );
          return $self;
        }
  
        if ($abstract_domain eq DOM_INET) {
          $connect_address = pack_sockaddr_in($remote_port, $connect_address);
          $error_tag = "pack_sockaddr_in";
        }
        elsif ($abstract_domain eq DOM_INET6) {
          $error_tag = "pack_sockaddr_in6";
        }
        else {
          die "unknown domain $abstract_domain";
        }
  
        unless ($connect_address) {
          $! = EADDRNOTAVAIL;
          $poe_kernel->yield(
            $event_failure,
            $error_tag, $!+0, $!, $self->[MY_UNIQUE_ID]
          );
          return $self;
        }
      }
  
      # Check SocketFactory /Remote.*/ parameters in a Unix socket
      # context, and translate them into parameters connect()
      # understands.
      elsif ($abstract_domain eq DOM_UNIX) {
  
        $connect_address = _condition_unix_address($params{RemoteAddress});
        $connect_address = pack_sockaddr_un($connect_address);
        unless (defined $connect_address) {
          $poe_kernel->yield(
            $event_failure,
            'pack_sockaddr_un', $!+0, $!, $self->[MY_UNIQUE_ID]
          );
          return $self;
        }
      }
  
      # This is an internal consistency error, and it should be trapped
      # right away.
      else {
        die "Mail this error to the author of POE: Internal consistency error";
      }
    }
  
    else {
      carp "RemotePort ignored without RemoteAddress"
        if defined $params{RemotePort};
    }
  
    # Perform the actual connection, if a connection was requested.  If
    # the connection can be established, then return the SocketFactory
    # handle.
    if (defined $connect_address) {
      unless (connect($socket_handle, $connect_address)) {
        if ($! and ($! != EINPROGRESS) and ($! != EWOULDBLOCK)) {
          $poe_kernel->yield(
            $event_failure,
            'connect', $!+0, $!, $self->[MY_UNIQUE_ID]
          );
          return $self;
        }
      }
  
      DEBUG && warn "connect";
  
      $self->[MY_SOCKET_HANDLE] = $socket_handle;
      $self->_define_connect_state();
      $self->event(
        SuccessEvent => $params{SuccessEvent},
        FailureEvent => $params{FailureEvent},
      );
      return $self;
    }
  
    #---------------------#
    # Listen, or Whatever #
    #---------------------#
  
    # A connection wasn't requested, so this must be a server socket.
    # Do whatever it is that needs to be done for whatever type of
    # server socket this is.
    if (exists $supported_protocol{$abstract_domain}->{$protocol_name}) {
      my $protocol_op = $supported_protocol{$abstract_domain}->{$protocol_name};
  
      DEBUG && warn "$abstract_domain + $protocol_name = $protocol_op";
  
      if ($protocol_op eq SVROP_LISTENS) {
        my $listen_queue = $params{ListenQueue} || SOMAXCONN;
        # <rmah> In SocketFactory, you limit the ListenQueue parameter
        #        to SOMAXCON (or is it SOCONNMAX?)...why?
        # <rmah> ah, here's czth, he'll have more to say on this issue
        # <czth> not really.  just that SOMAXCONN can lie, notably on
        #        Solaris and reportedly on BSDs too
        # 
        # ($listen_queue > SOMAXCONN) && ($listen_queue = SOMAXCONN);
        unless (listen($socket_handle, $listen_queue)) {
          $poe_kernel->yield(
            $event_failure,
            'listen', $!+0, $!, $self->[MY_UNIQUE_ID]
          );
          return $self;
        }
  
        DEBUG && warn "listen";
  
        $self->[MY_SOCKET_HANDLE] = $socket_handle;
        $self->_define_accept_state();
        $self->event(
          SuccessEvent => $params{SuccessEvent},
          FailureEvent => $params{FailureEvent},
        );
        return $self;
      }
      else {
        carp "Ignoring ListenQueue parameter for non-listening socket"
          if defined $params{ListenQueue};
        if ($protocol_op eq SVROP_NOTHING) {
          # Do nothing.  Duh.  Fire off a success event immediately, and
          # return.
          $poe_kernel->yield(
            $event_success,
            $socket_handle, undef, undef, $self->[MY_UNIQUE_ID]
          );
          return $self;
        }
        else {
          die "Mail this error to the author of POE: Internal consistency error";
        }
      }
    }
    else {
      die "SocketFactory doesn't support $abstract_domain $protocol_name socket";
    }
  
    die "Mail this error to the author of POE: Internal consistency error";
  }
  
  # Pause and resume accept.
  sub pause_accept {
    my $self = shift;
    if (
      defined $self->[MY_SOCKET_HANDLE] and
      defined $self->[MY_STATE_ACCEPT] and
      defined $self->[MY_SOCKET_SELECTED]
    ) {
      $poe_kernel->select_pause_read($self->[MY_SOCKET_HANDLE]);
    }
  }
  
  sub resume_accept {
    my $self = shift;
    if (
      defined $self->[MY_SOCKET_HANDLE] and
      defined $self->[MY_STATE_ACCEPT] and
      defined $self->[MY_SOCKET_SELECTED]
    ) {
      $poe_kernel->select_resume_read($self->[MY_SOCKET_HANDLE]);
    }
  }
  
  #------------------------------------------------------------------------------
  # DESTROY and _shutdown pass things by reference because _shutdown is
  # called from the state() closures above.  As a result, we can't
  # mention $self explicitly, or the wheel won't shut itself down
  # properly.  Rather, it will form a circular reference on $self.
  
  sub DESTROY {
    my $self = shift;
    _shutdown(
      \$self->[MY_SOCKET_SELECTED],
      \$self->[MY_SOCKET_HANDLE],
      \$self->[MY_STATE_ACCEPT],
      \$self->[MY_STATE_CONNECT],
      \$self->[MY_MINE_SUCCESS],
      \$self->[MY_EVENT_SUCCESS],
      \$self->[MY_MINE_FAILURE],
      \$self->[MY_EVENT_FAILURE],
    );
    &POE::Wheel::free_wheel_id($self->[MY_UNIQUE_ID]);
  }
  
  sub _shutdown {
    my (
      $socket_selected, $socket_handle,
      $state_accept, $state_connect,
      $mine_success, $event_success,
      $mine_failure, $event_failure,
    ) = @_;
  
    if (defined $$socket_selected) {
      $poe_kernel->select($$socket_handle);
      $$socket_selected = undef;
    }
  
    if (defined $$state_accept) {
      $poe_kernel->state($$state_accept);
      $$state_accept = undef;
    }
  
    if (defined $$state_connect) {
      $poe_kernel->state($$state_connect);
      $$state_connect = undef;
    }
  
    if (defined $$mine_success) {
      $poe_kernel->state($$event_success);
      $$mine_success = $$event_success = undef;
    }
  
    if (defined $$mine_failure) {
      $poe_kernel->state($$event_failure);
      $$mine_failure = $$event_failure = undef;
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  POE::Wheel::SocketFactory - non-blocking socket creation
  
  =head1 SYNOPSIS
  
  See L<POE::Component::Server::TCP/SYNOPSIS> for a much simpler version
  of this program.
  
    #!perl
  
    use warnings;
    use strict;
  
    use IO::Socket;
    use POE qw(Wheel::SocketFactory Wheel::ReadWrite);
  
    POE::Session->create(
      inline_states => {
        _start => sub {
          # Start the server.
          $_[HEAP]{server} = POE::Wheel::SocketFactory->new(
            BindPort => 12345,
            SuccessEvent => "on_client_accept",
            FailureEvent => "on_server_error",
          );
        },
        on_client_accept => sub {
          # Begin interacting with the client.
          my $client_socket = $_[ARG0];
          my $io_wheel = POE::Wheel::ReadWrite->new(
            Handle => $client_socket,
            InputEvent => "on_client_input",
            ErrorEvent => "on_client_error",
          );
          $_[HEAP]{client}{ $io_wheel->ID() } = $io_wheel;
        },
        on_server_error => sub {
          # Shut down server.
          my ($operation, $errnum, $errstr) = @_[ARG0, ARG1, ARG2];
          warn "Server $operation error $errnum: $errstr\n";
          delete $_[HEAP]{server};
        },
        on_client_input => sub {
          # Handle client input.
          my ($input, $wheel_id) = @_[ARG0, ARG1];
          $input =~ tr[a-zA-Z][n-za-mN-ZA-M]; # ASCII rot13
          $_[HEAP]{client}{$wheel_id}->put($input);
        },
        on_client_error => sub {
          # Handle client error, including disconnect.
          my $wheel_id = $_[ARG3];
          delete $_[HEAP]{client}{$wheel_id};
        },
      }
    );
  
    POE::Kernel->run();
    exit;
  
  =head1 DESCRIPTION
  
  POE::Wheel::SocketFactory creates sockets upon demand.  It can create
  connectionless UDP sockets, but it really shines for client/server
  work where establishing connections normally would block.
  
  =head1 PUBLIC METHODS
  
  =head2 new
  
  new() creates a new POE::Wheel::SocketFactory object.  For sockets
  which listen() for and accept() connections, the wheel will generate
  new sockets for each accepted client.  Socket factories for one-shot
  sockets, such as UDP peers or clients established by connect() only
  emit a single socket and can be destroyed afterwards without ill
  effects.
  
  new() always returns a POE::Wheel::SocketFactory object even if it
  fails to establish the socket.  This allows the object to be queried
  after it has sent its session a C<FailureEvent>.
  
  new() accepts a healthy number of named parameters, each governing
  some aspect of socket creation.
  
  =head3 Creating the Socket
  
  Socket creation is done with Perl's built-in socket() function.  The
  new() parameters beginning with C<Socket> determine how socket() will
  be called.
  
  =head4 SocketDomain
  
  C<SocketDomain> instructs the wheel to create a socket within a
  particular domain.  Supported domains are C<AF_UNIX>, C<AF_INET>,
  C<AF_INET6>, C<PF_UNIX>, C<PF_INET>, and C<PF_INET6>.  If omitted, the
  socket will be created in the C<AF_INET> domain.
  
  POE::Wheel::SocketFactory contains a table of supported domains and
  the instructions needed to create them.  Please send patches to
  support additional domains, as needed.
  
  Note: C<AF_INET6> and C<PF_INET6> are supplied by the L<Socket>
  module included in Perl 5.8.0 or later.  Perl versions before 5.8.0
  should not attempt to use IPv6 until someone contributes a workaround.
  
  IPv6 support requires a Socket module that implements getaddrinfo()
  and unpack_sockaddr_in6().  There may be other modules that perform
  these functions, but most if not all of them have been deprecated with
  the advent of proper core Socket support for IPv6.
  
  =for comment
  TODO - Example.
  
  =head4 SocketType
  
  C<SocketType> supplies the socket() call with a particular socket
  type, which may be C<SOCK_STREAM> or C<SOCK_DGRAM>.  C<SOCK_STREAM> is
  the default if C<SocketType> is not supplied.
  
  =for comment
  TODO - Example.
  
  =head4 SocketProtocol
  
  C<SocketProtocol> sets the socket() call's protocol.  Protocols may be
  specified by number or name.  C<SocketProtocol> is ignored for UNIX
  domain sockets.
  
  The protocol defaults to "tcp" for INET domain sockets.  There is no
  default for other socket domains.
  
  =for comment
  TODO - Example.
  
  =head3 Setting Socket Options
  
  POE::Wheel::SocketFactory uses ioctl(), fcntl() and setsockopt() to
  set socket options after the socket is created.  All sockets are set
  non-blocking, and bound sockets may be made reusable.
  
  =head4 Reuse
  
  When set, the C<Reuse> parameter allows a bound port to be reused
  immediately.  C<Reuse> is considered enabled if it contains "yes",
  "on", or a true numeric value.  All other values disable port reuse,
  as does omitting C<Reuse> entirely.
  
  For security purposes, a port cannot be reused for a minute or more
  after a server has released it.  This gives clients time to realize
  the port has been abandoned.  Otherwise a malicious service may snatch
  up the port and spoof the legitimate service.
  
  It's also terribly annoying to wait a minute or more between server
  invocations, especially during development.
  
  =head3 Bind the Socket to an Address and Port
  
  A socket may optionally be bound to a specific interface and port.
  The C<INADDR_ANY> address may be used to bind to a specific port
  across all interfaces.
  
  Sockets are bound using bind().  POE::Wheel::SocketFactory parameters
  beginning with C<Bind> control how bind() is called.
  
  =head4 BindAddress
  
  C<BindAddress> sets an address to bind the socket's local endpoint to.
  C<INADDR_ANY> will be used if C<BindAddress> is not specified.
  
  C<BindAddress> may contain either a string or a packed Internet
  address (for "INET" domain sockets).  The string parameter should be a
  dotted numeric address or a resolvable host name.  Note that the host
  name will be resolved with a blocking call.  If this is not desired,
  use POE::Component::Client::DNS to perform a non-blocking name
  resolution.
  
  When used to bind a "UNIX" domain socket, C<BindAddress> should
  contain a path describing the socket's filename.  This is required for
  server sockets and datagram client sockets.  C<BindAddress> has no
  default value for UNIX sockets.
  
  =for comment
  TODO - Example.
  
  =head4 BindPort
  
  C<BindPort> is only meaningful for "INET" domain sockets.  It contains
  a port on the C<BindAddress> interface where the socket will be bound.
  It defaults to 0 if omitted, which will cause the bind() call to
  choose an indeterminate unallocated port.
  
  C<BindPort> may be a port number or a name that can be looked up in
  the system's services (or equivalent) database.
  
  =for comment
  TODO - Example.
  
  =head3 Connectionless Sockets
  
  Connectionless sockets may interact with remote endpoints without
  needing to listen() for connections or connect() to remote addresses.
  
  This class of sockets is complete after the bind() call.
  
  =for comment
  TODO - Example.
  
  =head3 Connecting the Socket to a Remote Endpoint
  
  A socket may either listen for connections to arrive, initiate
  connections to a remote endpoint, or be connectionless (such as in the
  case of UDP sockets).
  
  POE::Wheel::SocketFactory will initiate a client connection when new()
  is capped with parameters that describe a remote endpoint.  In all
  other cases, the socket will either listen for connections or be
  connectionless depending on the socket type.
  
  The following parameters describe a socket's remote endpoint.  They
  determine how POE::Wheel::SocketFactory will call Perl's built-in
  connect() function.
  
  =head4 RemoteAddress
  
  C<RemoteAddress> specifies the remote address to which a socket should
  connect.  If present, POE::Wheel::SocketFactory will create a client
  socket that attempts to collect to the C<RemoteAddress>.  Otherwise,
  if the protocol warrants it, the wheel will create a listening socket
  and attempt to accept connections.
  
  As with the bind address, C<RemoteAddress> may be a string containing
  a dotted quad or a resolvable host name.  It may also be a packed
  Internet address, or a UNIX socket path.  It will be packed, with or
  without an accompanying C<RemotePort>, as necessary for the socket
  domain.
  
  =for comment
  TODO - Example.
  
  =head4 RemotePort
  
  C<RemotePort> is the port to which the socket should connect.  It is
  required for "INET" client sockets, since the remote endpoint must
  contain both an address and a port.
  
  The remote port may be numeric, or it may be a symbolic name found in
  /etc/services or the equivalent for your operating system.
  
  =for comment
  TODO - Example.
  
  =head3 Listening for Connections
  
  Streaming sockets that have no remote endpoint are considered to be
  server sockets.  POE::Wheel::SocketFactory will listen() for
  connections to these sockets, accept() the new clients, and send the
  application events with the new client sockets.
  
  POE::Wheel::SocketFactory constructor parameters beginning with
  C<Listen> control how the listen() function is called.
  
  =head4 ListenQueue
  
  C<ListenQueue> specifies the length of the socket's listen() queue.
  It defaults to C<SOMAXCONN> if omitted.  C<ListenQueue> values greater
  than C<SOMAXCONN> will be clipped to C<SOMAXCONN>.  Excessively large
  C<ListenQueue> values are not necessarily portable, and may cause
  errors in some rare cases.
  
  =for comment
  TODO - Example.
  
  =head3 Emitting Events
  
  POE::Wheel::SocketFactory emits a small number of events depending on
  what happens during socket setup or while listening for new
  connections.
  
  See L</PUBLIC EVENTS> for more details.
  
  =head4 SuccessEvent
  
  C<SuccessEvent> names the event that will be emitted whenever
  POE::Wheel::SocketFactory succeeds in creating a new socket.
  
  For connectionless sockets, C<SuccessEvent> happens just after the
  socket is created.
  
  For client connections, C<SuccessEvent> is fired when the connection
  has successfully been established with the remote endpoint.
  
  Server sockets emit a C<SuccessEvent> for every successfully accepted
  client.
  
  =head4 FailureEvent
  
  C<FailureEvent> names the event POE::Wheel::SocketFactory will emit
  whenever something goes wrong.  It usually represents some kind of
  built-in function call error.  See L</PUBLIC EVENTS> for details, as
  some errors are handled internally by this wheel.
  
  =head2 event
  
  event() allows a session to change the events emitted by a wheel
  without destroying and re-creating the wheel.  It accepts one or more
  of the events listed in L</PUBLIC EVENTS>.  Undefined event names
  disable those events.
  
  event() is described in more depth in L<POE::Wheel>.
  
  =for comment
  TODO - Example.
  
  =head2 getsockname
  
  getsockname() behaves like the built-in function of the same name.  It
  returns the local endpoint information for POE::Wheel::SocketFactory's
  encapsulated listening socket.
  
  getsockname() allows applications to determine the address and port
  to which POE::Wheel::SocketFactory has bound its listening socket.
  
  Test applications may use getsockname() to find the server socket
  after POE::Wheel::SocketFactory has bound to INADDR_ANY port 0.
  
  Since there is no event fired immediately after a successful creation of a
  listening socket, applications can use getsockname() to verify this.
  
   use Socket 'unpack_sockaddr_in';
  
   my $listener = POE::Wheel::SocketFactory->new(
       BindPort     => 123,
       SuccessEvent => 'got_client',
       FailureEvent => 'listener_failed',
       Reuse        => 'on',
   );
  
   my ($port, $addr) = unpack_sockaddr_in($listener->getsockname);
   print "Socket successfully bound\n" if $port;
  
  =head2 ID
  
  ID() returns the wheel's unique ID.  The ID will also be included in
  every event the wheel generates.  Applications can match events back
  to the objects that generated them.
  
  =for comment
  TODO - Example.
  
  =head2 pause_accept
  
  Applications may occasionally need to block incoming connections.
  pause_accept() pauses the event watcher that triggers accept().  New
  inbound connections will stack up in the socket's listen() queue until
  the queue overflows or the application calls resume_accept().
  
  Pausing accept() can limit the amount of load a server generates.
  It's also useful in pre-forking servers when the master process
  shouldn't accept connections at all.
  
  pause_accept() and resume_accept() is quicker and more reliable than
  dynamically destroying and re-creating a POE::Wheel::SocketFactory
  object.
  
  =for comment
  TODO - Example.
  
  =head2 resume_accept
  
  resume_accept() resumes the watcher that triggers accept().  See
  L</pause_accept> for a more detailed discussion.
  
  =head1 PUBLIC EVENTS
  
  POE::Wheel::SocketFactory emits two public events.
  
  =head2 SuccessEvent
  
  C<SuccessEvent> names an event that will be sent to the creating
  session whenever a POE::Wheel::SocketFactory has created a new socket.
  For connectionless sockets, it's when the socket is created.  For
  connecting clients, it's after the connection has been established.
  And for listening servers, C<SuccessEvent> is fired after each new
  client is accepted.
  
  =head3 Common SuccessEvent Parameters
  
  In all cases, C<$_[ARG0]> holds the new socket's filehandle, and
  C<$_[ARG3]> contains the POE::Wheel::SocketFactory's ID.  Other
  parameters vary depending on the socket's domain and whether it's
  listening or connecting.  See below for the differences.
  
  =head3 INET SuccessEvent Parameters
  
  For INET sockets, C<$_[ARG1]> and C<$_[ARG2]> hold the socket's remote
  address and port, respectively.  The address is packed; see
  L<Socket/inet_ntoa> if a human-readable IPv4 address is needed.
  L<Socket::GetAddrInfo/getnameinfo> provides numeric addresses for IPv4
  and IPv6 addresses.
  
    sub handle_new_client {
      my $accepted_socket = $_[ARG0];
  
      my $peer_host = inet_ntoa($_[ARG1]);
      print(
        "Wheel $_[ARG3] accepted a connection from ",
        "$peer_host port $peer_port\n"
      );
  
      spawn_connection_session($accepted_handle);
    }
  
  =head3 UNIX Client SuccessEvent Parameters
  
  For UNIX client sockets, C<$_[ARG1]> often (but not always) holds the
  server address.  Some systems cannot retrieve a UNIX socket's remote
  address.  C<$_[ARG2]> is always undef for UNIX client sockets.
  
  =head3 UNIX Server SuccessEvent Parameters
  
  According to I<Perl Cookbook>, the remote address returned by accept()
  on UNIX sockets is undefined, so C<$_[ARG1]> and C<$_[ARG2]> are also
  undefined in this case.
  
  =head2 FailureEvent
  
  C<FailureEvent> names the event that will be emitted when a socket
  error occurs.  POE::Wheel::SocketFactory handles C<EAGAIN> internally,
  so it doesn't count as an error.
  
  C<FailureEvent> events include the standard error event parameters:
  
  C<$_[ARG0]> describes which part of socket creation failed.  It often
  holds a Perl built-in function name.
  
  C<$_[ARG1]> and C<$_[ARG2]> describe how the operation failed.  They
  contain the numeric and stringified versions of C<$!>, respectively.
  An application cannot merely check the global C<$!> variable since it
  may change during event dispatch.
  
  Finally, C<$_[ARG3]> contains the ID for the POE::Wheel::SocketFactory
  instance that generated the event.  See L</ID> and L<POE::Wheel/ID>
  for uses for wheel IDs.
  
  A sample FailureEvent handler:
  
    sub handle_failure {
      my ($operation, $errnum, $errstr, $wheel_id) = @_[ARG0..ARG3];
      warn "Wheel $wheel_id generated $operation error $errnum: $errstr\n";
      delete $_[HEAP]{wheels}{$wheel_id}; # shut down that wheel
    }
  
  =head1 SEE ALSO
  
  L<POE::Wheel> describes the basic operations of all wheels in more
  depth.  You need to know this.
  
  L<Socket::GetAddrInfo> is required for IPv6 work.
  POE::Wheel::SocketFactory will load it automatically if it's
  installed.  SocketDomain => AF_INET6 is required to trigger IPv6
  behaviors.  AF_INET6 is exported by the Socket module on all but the
  oldest versions of Perl 5.  If your Socket doesn't provide AF_INET6,
  try installing Socket6 instead.
  
  The SEE ALSO section in L<POE> contains a table of contents covering
  the entire POE distribution.
  
  =head1 BUGS
  
  Many (if not all) of the croak/carp/warn/die statements should fire
  back C<FailureEvent> instead.
  
  SocketFactory is only tested with UNIX streams and INET sockets using
  the UDP and TCP protocols.  Others should work after the module's
  internal configuration tables are updated.  Please send patches.
  
  =head1 AUTHORS & COPYRIGHTS
  
  Please see L<POE> for more information about authors and contributors.
  
  =cut
  
  # rocco // vim: ts=2 sw=2 expandtab
  # TODO - Edit.
POE_WHEEL_SOCKETFACTORY

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.62";
  
  our ($ABS_REMOTE_LEADING_DOTS, $ABS_ALLOW_RELATIVE_SCHEME, $DEFAULT_QUERY_FORM_DELIMITER);
  
  my %implements;  # mapping from scheme to implementor class
  
  # Some "official" character classes
  
  our $reserved   = q(;/?:@&=+$,[]);
  our $mark       = q(-_.!~*'());                                    #'; emacs
  our $unreserved = "A-Za-z0-9\Q$mark\E";
  our $uric       = quotemeta($reserved) . $unreserved . "%";
  
  our $scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';
  
  use Carp ();
  use URI::Escape ();
  
  use overload ('""'     => sub { ${$_[0]} },
                '=='     => sub { _obj_eq(@_) },
                '!='     => sub { !_obj_eq(@_) },
                fallback => 1,
               );
  
  # Check if two objects are the same object
  sub _obj_eq {
      return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
  }
  
  sub new
  {
      my($class, $uri, $scheme) = @_;
  
      $uri = defined ($uri) ? "$uri" : "";   # stringify
      # Get rid of potential wrapping
      $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # 
      $uri =~ s/^"(.*)"$/$1/;
      $uri =~ s/^\s+//;
      $uri =~ s/\s+$//;
  
      my $impclass;
      if ($uri =~ m/^($scheme_re):/so) {
  	$scheme = $1;
      }
      else {
  	if (($impclass = ref($scheme))) {
  	    $scheme = $scheme->scheme;
  	}
  	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
  	    $scheme = $1;
          }
      }
      $impclass ||= implementor($scheme) ||
  	do {
  	    require URI::_foreign;
  	    $impclass = 'URI::_foreign';
  	};
  
      return $impclass->_init($uri, $scheme);
  }
  
  
  sub new_abs
  {
      my($class, $uri, $base) = @_;
      $uri = $class->new($uri, $base);
      $uri->abs($base);
  }
  
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      # find all funny characters and encode the bytes.
      $str = $class->_uric_escape($str);
      $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                   $class->_no_scheme_ok;
      my $self = bless \$str, $class;
      $self;
  }
  
  
  sub _uric_escape
  {
      my($class, $str) = @_;
      $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
      utf8::downgrade($str);
      return $str;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
      if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
  	require URI::_generic;
  	return "URI::_generic";
      }
  
      $scheme = lc($scheme);
  
      if ($impclass) {
  	# Set the implementor class for a given scheme
          my $old = $implements{$scheme};
          $impclass->_init_implementor($scheme);
          $implements{$scheme} = $impclass;
          return $old;
      }
  
      my $ic = $implements{$scheme};
      return $ic if $ic;
  
      # scheme not yet known, look for internal or
      # preloaded (with 'use') implementation
      $ic = "URI::$scheme";  # default location
  
      # turn scheme into a valid perl identifier by a simple transformation...
      $ic =~ s/\+/_P/g;
      $ic =~ s/\./_O/g;
      $ic =~ s/\-/_/g;
  
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          # Try to load it
          eval "require $ic";
          die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
          return undef unless @{"${ic}::ISA"};
      }
  
      $ic->_init_implementor($scheme);
      $implements{$scheme} = $ic;
      $ic;
  }
  
  
  sub _init_implementor
  {
      my($class, $scheme) = @_;
      # Remember that one implementor class may actually
      # serve to implement several URI schemes.
  }
  
  
  sub clone
  {
      my $self = shift;
      my $other = $$self;
      bless \$other, ref $self;
  }
  
  
  sub _no_scheme_ok { 0 }
  
  sub _scheme
  {
      my $self = shift;
  
      unless (@_) {
  	return undef unless $$self =~ /^($scheme_re):/o;
  	return $1;
      }
  
      my $old;
      my $new = shift;
      if (defined($new) && length($new)) {
  	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
  	$old = $1 if $$self =~ s/^($scheme_re)://o;
  	my $newself = URI->new("$new:$$self");
  	$$self = $$newself; 
  	bless $self, ref($newself);
      }
      else {
  	if ($self->_no_scheme_ok) {
  	    $old = $1 if $$self =~ s/^($scheme_re)://o;
  	    Carp::carp("Oops, opaque part now look like scheme")
  		if $^W && $$self =~ m/^$scheme_re:/o
  	}
  	else {
  	    $old = $1 if $$self =~ m/^($scheme_re):/o;
  	}
      }
  
      return $old;
  }
  
  sub scheme
  {
      my $scheme = shift->_scheme(@_);
      return undef unless defined $scheme;
      lc($scheme);
  }
  
  sub has_recognized_scheme {
      my $self = shift;
      return ref($self) !~ /^URI::_(?:foreign|generic)\z/;
  }
  
  sub opaque
  {
      my $self = shift;
  
      unless (@_) {
  	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
  	return $1;
      }
  
      $$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;
  
      my $old_scheme = $1;
      my $old_opaque = $2;
      my $old_frag   = $3;
  
      my $new_opaque = shift;
      $new_opaque = "" unless defined $new_opaque;
      $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;
      utf8::downgrade($new_opaque);
  
      $$self = defined($old_scheme) ? $old_scheme : "";
      $$self .= $new_opaque;
      $$self .= $old_frag if defined $old_frag;
  
      $old_opaque;
  }
  
  sub path { goto &opaque }  # alias
  
  
  sub fragment
  {
      my $self = shift;
      unless (@_) {
  	return undef unless $$self =~ /\#(.*)/s;
  	return $1;
      }
  
      my $old;
      $old = $1 if $$self =~ s/\#(.*)//s;
  
      my $new_frag = shift;
      if (defined $new_frag) {
  	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
  	utf8::downgrade($new_frag);
  	$$self .= "#$new_frag";
      }
      $old;
  }
  
  
  sub as_string
  {
      my $self = shift;
      $$self;
  }
  
  
  sub as_iri
  {
      my $self = shift;
      my $str = $$self;
      if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {
  	# All this crap because the more obvious:
  	#
  	#   Encode::decode("UTF-8", $str, sub { sprintf "%%%02X", shift })
  	#
  	# doesn't work before Encode 2.39.  Wait for a standard release
  	# to bundle that version.
  
  	require Encode;
  	my $enc = Encode::find_encoding("UTF-8");
  	my $u = "";
  	while (length $str) {
  	    $u .= $enc->decode($str, Encode::FB_QUIET());
  	    if (length $str) {
  		# escape next char
  		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
  	    }
  	}
  	$str = $u;
      }
      return $str;
  }
  
  
  sub canonical
  {
      # Make sure scheme is lowercased, that we don't escape unreserved chars,
      # and that we use upcase escape sequences.
  
      my $self = shift;
      my $scheme = $self->_scheme || "";
      my $uc_scheme = $scheme =~ /[A-Z]/;
      my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
      return $self unless $uc_scheme || $esc;
  
      my $other = $self->clone;
      if ($uc_scheme) {
  	$other->_scheme(lc $scheme);
      }
      if ($esc) {
  	$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge;
      }
      return $other;
  }
  
  # Compare two URIs, subclasses will provide a more correct implementation
  sub eq {
      my($self, $other) = @_;
      $self  = URI->new($self, $other) unless ref $self;
      $other = URI->new($other, $self) unless ref $other;
      ref($self) eq ref($other) &&                # same class
  	$self->canonical->as_string eq $other->canonical->as_string;
  }
  
  # generic-URI transformation methods
  sub abs { $_[0]; }
  sub rel { $_[0]; }
  
  sub secure { 0 }
  
  # help out Storable
  sub STORABLE_freeze {
         my($self, $cloning) = @_;
         return $$self;
  }
  
  sub STORABLE_thaw {
         my($self, $cloning, $str) = @_;
         $$self = $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI - Uniform Resource Identifiers (absolute and relative)
  
  =head1 SYNOPSIS
  
   $u1 = URI->new("http://www.perl.com");
   $u2 = URI->new("foo", "http");
   $u3 = $u2->abs($u1);
   $u4 = $u3->clone;
   $u5 = URI->new("HTTP://WWW.perl.com:80")->canonical;
  
   $str = $u->as_string;
   $str = "$u";
  
   $scheme = $u->scheme;
   $opaque = $u->opaque;
   $path   = $u->path;
   $frag   = $u->fragment;
  
   $u->scheme("ftp");
   $u->host("ftp.perl.com");
   $u->path("cpan/");
  
  =head1 DESCRIPTION
  
  This module implements the C<URI> class.  Objects of this class
  represent "Uniform Resource Identifier references" as specified in RFC
  2396 (and updated by RFC 2732).
  
  A Uniform Resource Identifier is a compact string of characters that
  identifies an abstract or physical resource.  A Uniform Resource
  Identifier can be further classified as either a Uniform Resource Locator
  (URL) or a Uniform Resource Name (URN).  The distinction between URL
  and URN does not matter to the C<URI> class interface. A
  "URI-reference" is a URI that may have additional information attached
  in the form of a fragment identifier.
  
  An absolute URI reference consists of three parts:  a I<scheme>, a
  I<scheme-specific part> and a I<fragment> identifier.  A subset of URI
  references share a common syntax for hierarchical namespaces.  For
  these, the scheme-specific part is further broken down into
  I<authority>, I<path> and I<query> components.  These URIs can also
  take the form of relative URI references, where the scheme (and
  usually also the authority) component is missing, but implied by the
  context of the URI reference.  The three forms of URI reference
  syntax are summarized as follows:
  
    <scheme>:<scheme-specific-part>#<fragment>
    <scheme>://<authority><path>?<query>#<fragment>
    <path>?<query>#<fragment>
  
  The components into which a URI reference can be divided depend on the
  I<scheme>.  The C<URI> class provides methods to get and set the
  individual components.  The methods available for a specific
  C<URI> object depend on the scheme.
  
  =head1 CONSTRUCTORS
  
  The following methods construct new C<URI> objects:
  
  =over 4
  
  =item $uri = URI->new( $str )
  
  =item $uri = URI->new( $str, $scheme )
  
  Constructs a new URI object.  The string
  representation of a URI is given as argument, together with an optional
  scheme specification.  Common URI wrappers like "" and <>, as well as
  leading and trailing white space, are automatically removed from
  the $str argument before it is processed further.
  
  The constructor determines the scheme, maps this to an appropriate
  URI subclass, constructs a new object of that class and returns it.
  
  If the scheme isn't one of those that URI recognizes, you still get
  an URI object back that you can access the generic methods on.  The
  C<< $uri->has_recognized_scheme >> method can be used to test for
  this.
  
  The $scheme argument is only used when $str is a
  relative URI.  It can be either a simple string that
  denotes the scheme, a string containing an absolute URI reference, or
  an absolute C<URI> object.  If no $scheme is specified for a relative
  URI $str, then $str is simply treated as a generic URI (no scheme-specific
  methods available).
  
  The set of characters available for building URI references is
  restricted (see L<URI::Escape>).  Characters outside this set are
  automatically escaped by the URI constructor.
  
  =item $uri = URI->new_abs( $str, $base_uri )
  
  Constructs a new absolute URI object.  The $str argument can
  denote a relative or absolute URI.  If relative, then it is
  absolutized using $base_uri as base. The $base_uri must be an absolute
  URI.
  
  =item $uri = URI::file->new( $filename )
  
  =item $uri = URI::file->new( $filename, $os )
  
  Constructs a new I<file> URI from a file name.  See L<URI::file>.
  
  =item $uri = URI::file->new_abs( $filename )
  
  =item $uri = URI::file->new_abs( $filename, $os )
  
  Constructs a new absolute I<file> URI from a file name.  See
  L<URI::file>.
  
  =item $uri = URI::file->cwd
  
  Returns the current working directory as a I<file> URI.  See
  L<URI::file>.
  
  =item $uri->clone
  
  Returns a copy of the $uri.
  
  =back
  
  =head1 COMMON METHODS
  
  The methods described in this section are available for all C<URI>
  objects.
  
  Methods that give access to components of a URI always return the
  old value of the component.  The value returned is C<undef> if the
  component was not present.  There is generally a difference between a
  component that is empty (represented as C<"">) and a component that is
  missing (represented as C<undef>).  If an accessor method is given an
  argument, it updates the corresponding component in addition to
  returning the old value of the component.  Passing an undefined
  argument removes the component (if possible).  The description of
  each accessor method indicates whether the component is passed as
  an escaped (percent-encoded) or an unescaped string.  A component that can be further
  divided into sub-parts are usually passed escaped, as unescaping might
  change its semantics.
  
  The common methods available for all URI are:
  
  =over 4
  
  =item $uri->scheme
  
  =item $uri->scheme( $new_scheme )
  
  Sets and returns the scheme part of the $uri.  If the $uri is
  relative, then $uri->scheme returns C<undef>.  If called with an
  argument, it updates the scheme of $uri, possibly changing the
  class of $uri, and returns the old scheme value.  The method croaks
  if the new scheme name is illegal; a scheme name must begin with a
  letter and must consist of only US-ASCII letters, numbers, and a few
  special marks: ".", "+", "-".  This restriction effectively means
  that the scheme must be passed unescaped.  Passing an undefined
  argument to the scheme method makes the URI relative (if possible).
  
  Letter case does not matter for scheme names.  The string
  returned by $uri->scheme is always lowercase.  If you want the scheme
  just as it was written in the URI in its original case,
  you can use the $uri->_scheme method instead.
  
  =item $uri->has_recognized_scheme
  
  Returns TRUE if the URI scheme is one that URI recognizes.
  
  It will also be TRUE for relative URLs where a recognized
  scheme was provided to the constructor, even if C<< $uri->scheme >>
  returns C<undef> for these.
  
  =item $uri->opaque
  
  =item $uri->opaque( $new_opaque )
  
  Sets and returns the scheme-specific part of the $uri
  (everything between the scheme and the fragment)
  as an escaped string.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the same value as $uri->opaque unless the URI
  supports the generic syntax for hierarchical namespaces.
  In that case the generic method is overridden to set and return
  the part of the URI between the I<host name> and the I<fragment>.
  
  =item $uri->fragment
  
  =item $uri->fragment( $new_frag )
  
  Returns the fragment identifier of a URI reference
  as an escaped string.
  
  =item $uri->as_string
  
  Returns a URI object to a plain ASCII string.  URI objects are
  also converted to plain strings automatically by overloading.  This
  means that $uri objects can be used as plain strings in most Perl
  constructs.
  
  =item $uri->as_iri
  
  Returns a Unicode string representing the URI.  Escaped UTF-8 sequences
  representing non-ASCII characters are turned into their corresponding Unicode
  code point.
  
  =item $uri->canonical
  
  Returns a normalized version of the URI.  The rules
  for normalization are scheme-dependent.  They usually involve
  lowercasing the scheme and Internet host name components,
  removing the explicit port specification if it matches the default port,
  uppercasing all escape sequences, and unescaping octets that can be
  better represented as plain characters.
  
  For efficiency reasons, if the $uri is already in normalized form,
  then a reference to it is returned instead of a copy.
  
  =item $uri->eq( $other_uri )
  
  =item URI::eq( $first_uri, $other_uri )
  
  Tests whether two URI references are equal.  URI references
  that normalize to the same string are considered equal.  The method
  can also be used as a plain function which can also test two string
  arguments.
  
  If you need to test whether two C<URI> object references denote the
  same object, use the '==' operator.
  
  =item $uri->abs( $base_uri )
  
  Returns an absolute URI reference.  If $uri is already
  absolute, then a reference to it is simply returned.  If the $uri
  is relative, then a new absolute URI is constructed by combining the
  $uri and the $base_uri, and returned.
  
  =item $uri->rel( $base_uri )
  
  Returns a relative URI reference if it is possible to
  make one that denotes the same resource relative to $base_uri.
  If not, then $uri is simply returned.
  
  =item $uri->secure
  
  Returns a TRUE value if the URI is considered to point to a resource on
  a secure channel, such as an SSL or TLS encrypted one.
  
  =back
  
  =head1 GENERIC METHODS
  
  The following methods are available to schemes that use the
  common/generic syntax for hierarchical namespaces.  The descriptions of
  schemes below indicate which these are.  Unrecognized schemes are
  assumed to support the generic syntax, and therefore the following
  methods:
  
  =over 4
  
  =item $uri->authority
  
  =item $uri->authority( $new_authority )
  
  Sets and returns the escaped authority component
  of the $uri.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the escaped path component of
  the $uri (the part between the host name and the query or fragment).
  The path can never be undefined, but it can be the empty string.
  
  =item $uri->path_query
  
  =item $uri->path_query( $new_path_query )
  
  Sets and returns the escaped path and query
  components as a single entity.  The path and the query are
  separated by a "?" character, but the query can itself contain "?".
  
  =item $uri->path_segments
  
  =item $uri->path_segments( $segment, ... )
  
  Sets and returns the path.  In a scalar context, it returns
  the same value as $uri->path.  In a list context, it returns the
  unescaped path segments that make up the path.  Path segments that
  have parameters are returned as an anonymous array.  The first element
  is the unescaped path segment proper;  subsequent elements are escaped
  parameter strings.  Such an anonymous array uses overloading so it can
  be treated as a string too, but this string does not include the
  parameters.
  
  Note that absolute paths have the empty string as their first
  I<path_segment>, i.e. the I<path> C</foo/bar> have 3
  I<path_segments>; "", "foo" and "bar".
  
  =item $uri->query
  
  =item $uri->query( $new_query )
  
  Sets and returns the escaped query component of
  the $uri.
  
  =item $uri->query_form
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ... )
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )
  
  =item $uri->query_form( \@key_value_pairs )
  
  =item $uri->query_form( \@key_value_pairs, $delim )
  
  =item $uri->query_form( \%hash )
  
  =item $uri->query_form( \%hash, $delim )
  
  Sets and returns query components that use the
  I<application/x-www-form-urlencoded> format.  Key/value pairs are
  separated by "&", and the key is separated from the value by a "="
  character.
  
  The form can be set either by passing separate key/value pairs, or via
  an array or hash reference.  Passing an empty array or an empty hash
  removes the query component, whereas passing no arguments at all leaves
  the component unchanged.  The order of keys is undefined if a hash
  reference is passed.  The old value is always returned as a list of
  separate key/value pairs.  Assigning this list to a hash is unwise as
  the keys returned might repeat.
  
  The values passed when setting the form can be plain strings or
  references to arrays of strings.  Passing an array of values has the
  same effect as passing the key repeatedly with one value at a time.
  All the following statements have the same effect:
  
      $uri->query_form(foo => 1, foo => 2);
      $uri->query_form(foo => [1, 2]);
      $uri->query_form([ foo => 1, foo => 2 ]);
      $uri->query_form([ foo => [1, 2] ]);
      $uri->query_form({ foo => [1, 2] });
  
  The $delim parameter can be passed as ";" to force the key/value pairs
  to be delimited by ";" instead of "&" in the query string.  This
  practice is often recommended for URLs embedded in HTML or XML
  documents as this avoids the trouble of escaping the "&" character.
  You might also set the $URI::DEFAULT_QUERY_FORM_DELIMITER variable to
  ";" for the same global effect.
  
  The C<URI::QueryParam> module can be loaded to add further methods to
  manipulate the form of a URI.  See L<URI::QueryParam> for details.
  
  =item $uri->query_keywords
  
  =item $uri->query_keywords( $keywords, ... )
  
  =item $uri->query_keywords( \@keywords )
  
  Sets and returns query components that use the
  keywords separated by "+" format.
  
  The keywords can be set either by passing separate keywords directly
  or by passing a reference to an array of keywords.  Passing an empty
  array removes the query component, whereas passing no arguments at
  all leaves the component unchanged.  The old value is always returned
  as a list of separate words.
  
  =back
  
  =head1 SERVER METHODS
  
  For schemes where the I<authority> component denotes an Internet host,
  the following methods are available in addition to the generic
  methods.
  
  =over 4
  
  =item $uri->userinfo
  
  =item $uri->userinfo( $new_userinfo )
  
  Sets and returns the escaped userinfo part of the
  authority component.
  
  For some schemes this is a user name and a password separated by
  a colon.  This practice is not recommended. Embedding passwords in
  clear text (such as URI) has proven to be a security risk in almost
  every case where it has been used.
  
  =item $uri->host
  
  =item $uri->host( $new_host )
  
  Sets and returns the unescaped hostname.
  
  If the $new_host string ends with a colon and a number, then this
  number also sets the port.
  
  For IPv6 addresses the brackets around the raw address is removed in the return
  value from $uri->host.  When setting the host attribute to an IPv6 address you
  can use a raw address or one enclosed in brackets.  The address needs to be
  enclosed in brackets if you want to pass in a new port value as well.
  
  =item $uri->ihost
  
  Returns the host in Unicode form.  Any IDNA A-labels are turned into U-labels.
  
  =item $uri->port
  
  =item $uri->port( $new_port )
  
  Sets and returns the port.  The port is a simple integer
  that should be greater than 0.
  
  If a port is not specified explicitly in the URI, then the URI scheme's default port
  is returned. If you don't want the default port
  substituted, then you can use the $uri->_port method instead.
  
  =item $uri->host_port
  
  =item $uri->host_port( $new_host_port )
  
  Sets and returns the host and port as a single
  unit.  The returned value includes a port, even if it matches the
  default port.  The host part and the port part are separated by a
  colon: ":".
  
  For IPv6 addresses the bracketing is preserved; thus
  URI->new("http://[::1]/")->host_port returns "[::1]:80".  Contrast this with
  $uri->host which will remove the brackets.
  
  =item $uri->default_port
  
  Returns the default port of the URI scheme to which $uri
  belongs.  For I<http> this is the number 80, for I<ftp> this
  is the number 21, etc.  The default port for a scheme can not be
  changed.
  
  =back
  
  =head1 SCHEME-SPECIFIC SUPPORT
  
  Scheme-specific support is provided for the following URI schemes.  For C<URI>
  objects that do not belong to one of these, you can only use the common and
  generic methods.
  
  =over 4
  
  =item B<data>:
  
  The I<data> URI scheme is specified in RFC 2397.  It allows inclusion
  of small data items as "immediate" data, as if it had been included
  externally.
  
  C<URI> objects belonging to the data scheme support the common methods
  and two new methods to access their scheme-specific components:
  $uri->media_type and $uri->data.  See L<URI::data> for details.
  
  =item B<file>:
  
  An old specification of the I<file> URI scheme is found in RFC 1738.
  A new RFC 2396 based specification in not available yet, but file URI
  references are in common use.
  
  C<URI> objects belonging to the file scheme support the common and
  generic methods.  In addition, they provide two methods for mapping file URIs
  back to local file names; $uri->file and $uri->dir.  See L<URI::file>
  for details.
  
  =item B<ftp>:
  
  An old specification of the I<ftp> URI scheme is found in RFC 1738.  A
  new RFC 2396 based specification in not available yet, but ftp URI
  references are in common use.
  
  C<URI> objects belonging to the ftp scheme support the common,
  generic and server methods.  In addition, they provide two methods for
  accessing the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<gopher>:
  
  The I<gopher> URI scheme is specified in
  <draft-murali-url-gopher-1996-12-04> and will hopefully be available
  as a RFC 2396 based specification.
  
  C<URI> objects belonging to the gopher scheme support the common,
  generic and server methods. In addition, they support some methods for
  accessing gopher-specific path components: $uri->gopher_type,
  $uri->selector, $uri->search, $uri->string.
  
  =item B<http>:
  
  The I<http> URI scheme is specified in RFC 2616.
  The scheme is used to reference resources hosted by HTTP servers.
  
  C<URI> objects belonging to the http scheme support the common,
  generic and server methods.
  
  =item B<https>:
  
  The I<https> URI scheme is a Netscape invention which is commonly
  implemented.  The scheme is used to reference HTTP servers through SSL
  connections.  Its syntax is the same as http, but the default
  port is different.
  
  =item B<ldap>:
  
  The I<ldap> URI scheme is specified in RFC 2255.  LDAP is the
  Lightweight Directory Access Protocol.  An ldap URI describes an LDAP
  search operation to perform to retrieve information from an LDAP
  directory.
  
  C<URI> objects belonging to the ldap scheme support the common,
  generic and server methods as well as ldap-specific methods: $uri->dn,
  $uri->attributes, $uri->scope, $uri->filter, $uri->extensions.  See
  L<URI::ldap> for details.
  
  =item B<ldapi>:
  
  Like the I<ldap> URI scheme, but uses a UNIX domain socket.  The
  server methods are not supported, and the local socket path is
  available as $uri->un_path.  The I<ldapi> scheme is used by the
  OpenLDAP package.  There is no real specification for it, but it is
  mentioned in various OpenLDAP manual pages.
  
  =item B<ldaps>:
  
  Like the I<ldap> URI scheme, but uses an SSL connection.  This
  scheme is deprecated, as the preferred way is to use the I<start_tls>
  mechanism.
  
  =item B<mailto>:
  
  The I<mailto> URI scheme is specified in RFC 2368.  The scheme was
  originally used to designate the Internet mailing address of an
  individual or service.  It has (in RFC 2368) been extended to allow
  setting of other mail header fields and the message body.
  
  C<URI> objects belonging to the mailto scheme support the common
  methods and the generic query methods.  In addition, they support the
  following mailto-specific methods: $uri->to, $uri->headers.
  
  Note that the "foo@example.com" part of a mailto is I<not> the
  C<userinfo> and C<host> but instead the C<path>.  This allows a
  mailto URI to contain multiple comma separated email addresses.
  
  =item B<mms>:
  
  The I<mms> URL specification can be found at L<http://sdp.ppona.com/>.
  C<URI> objects belonging to the mms scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<news>:
  
  The I<news>, I<nntp> and I<snews> URI schemes are specified in
  <draft-gilman-news-url-01> and will hopefully be available as an RFC
  2396 based specification soon.
  
  C<URI> objects belonging to the news scheme support the common,
  generic and server methods.  In addition, they provide some methods to
  access the path: $uri->group and $uri->message.
  
  =item B<nntp>:
  
  See I<news> scheme.
  
  =item B<pop>:
  
  The I<pop> URI scheme is specified in RFC 2384. The scheme is used to
  reference a POP3 mailbox.
  
  C<URI> objects belonging to the pop scheme support the common, generic
  and server methods.  In addition, they provide two methods to access the
  userinfo components: $uri->user and $uri->auth
  
  =item B<rlogin>:
  
  An old specification of the I<rlogin> URI scheme is found in RFC
  1738. C<URI> objects belonging to the rlogin scheme support the
  common, generic and server methods.
  
  =item B<rtsp>:
  
  The I<rtsp> URL specification can be found in section 3.2 of RFC 2326.
  C<URI> objects belonging to the rtsp scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<rtspu>:
  
  The I<rtspu> URI scheme is used to talk to RTSP servers over UDP
  instead of TCP.  The syntax is the same as rtsp.
  
  =item B<rsync>:
  
  Information about rsync is available from L<http://rsync.samba.org/>.
  C<URI> objects belonging to the rsync scheme support the common,
  generic and server methods.  In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sip>:
  
  The I<sip> URI specification is described in sections 19.1 and 25
  of RFC 3261.  C<URI> objects belonging to the sip scheme support the
  common, generic, and server methods with the exception of path related
  sub-components.  In addition, they provide two methods to get and set
  I<sip> parameters: $uri->params_form and $uri->params.
  
  =item B<sips>:
  
  See I<sip> scheme.  Its syntax is the same as sip, but the default
  port is different.
  
  =item B<snews>:
  
  See I<news> scheme.  Its syntax is the same as news, but the default
  port is different.
  
  =item B<telnet>:
  
  An old specification of the I<telnet> URI scheme is found in RFC
  1738. C<URI> objects belonging to the telnet scheme support the
  common, generic and server methods.
  
  =item B<tn3270>:
  
  These URIs are used like I<telnet> URIs but for connections to IBM
  mainframes.  C<URI> objects belonging to the tn3270 scheme support the
  common, generic and server methods.
  
  =item B<ssh>:
  
  Information about ssh is available at L<http://www.openssh.com/>.
  C<URI> objects belonging to the ssh scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<urn>:
  
  The syntax of Uniform Resource Names is specified in RFC 2141.  C<URI>
  objects belonging to the urn scheme provide the common methods, and also the
  methods $uri->nid and $uri->nss, which return the Namespace Identifier
  and the Namespace-Specific String respectively.
  
  The Namespace Identifier basically works like the Scheme identifier of
  URIs, and further divides the URN namespace.  Namespace Identifier
  assignments are maintained at
  L<http://www.iana.org/assignments/urn-namespaces>.
  
  Letter case is not significant for the Namespace Identifier.  It is
  always returned in lower case by the $uri->nid method.  The $uri->_nid
  method can be used if you want it in its original case.
  
  =item B<urn>:B<isbn>:
  
  The C<urn:isbn:> namespace contains International Standard Book
  Numbers (ISBNs) and is described in RFC 3187.  A C<URI> object belonging
  to this namespace has the following extra methods (if the
  Business::ISBN module is available): $uri->isbn,
  $uri->isbn_publisher_code, $uri->isbn_group_code (formerly isbn_country_code,
  which is still supported by issues a deprecation warning), $uri->isbn_as_ean.
  
  =item B<urn>:B<oid>:
  
  The C<urn:oid:> namespace contains Object Identifiers (OIDs) and is
  described in RFC 3061.  An object identifier consists of sequences of digits
  separated by dots.  A C<URI> object belonging to this namespace has an
  additional method called $uri->oid that can be used to get/set the oid
  value.  In a list context, oid numbers are returned as separate elements.
  
  =back
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over 4
  
  =item $URI::ABS_ALLOW_RELATIVE_SCHEME
  
  Some older parsers used to allow the scheme name to be present in the
  relative URL if it was the same as the base URL scheme.  RFC 2396 says
  that this should be avoided, but you can enable this old behaviour by
  setting the $URI::ABS_ALLOW_RELATIVE_SCHEME variable to a TRUE value.
  The difference is demonstrated by the following examples:
  
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:foo"
  
    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:/host/a/foo"
  
  
  =item $URI::ABS_REMOTE_LEADING_DOTS
  
  You can also have the abs() method ignore excess ".."
  segments in the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS
  to a TRUE value.  The difference is demonstrated by the following
  examples:
  
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/../../foo"
  
    local $URI::ABS_REMOTE_LEADING_DOTS = 1;
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/foo"
  
  =item $URI::DEFAULT_QUERY_FORM_DELIMITER
  
  This value can be set to ";" to have the query form C<key=value> pairs
  delimited by ";" instead of "&" which is the default.
  
  =back
  
  =head1 BUGS
  
  There are some things that are not quite right:
  
  =over
  
  =item *
  
  Using regexp variables like $1 directly as arguments to the URI accessor methods
  does not work too well with current perl implementations.  I would argue
  that this is actually a bug in perl.  The workaround is to quote
  them. Example:
  
     /(...)/ || die;
     $u->query("$1");
  
  
  =item *
  
  The escaping (percent encoding) of chars in the 128 .. 255 range passed to the
  URI constructor or when setting URI parts using the accessor methods depend on
  the state of the internal UTF8 flag (see utf8::is_utf8) of the string passed.
  If the UTF8 flag is set the UTF-8 encoded version of the character is percent
  encoded.  If the UTF8 flag isn't set the Latin-1 version (byte) of the
  character is percent encoded.  This basically exposes the internal encoding of
  Perl strings.
  
  =back
  
  =head1 PARSING URIs WITH REGEXP
  
  As an alternative to this module, the following (official) regular
  expression can be used to decode a URI:
  
    my($scheme, $authority, $path, $query, $fragment) =
    $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  
  The C<URI::Split> module provides the function uri_split() as a
  readable alternative.
  
  =head1 SEE ALSO
  
  L<URI::file>, L<URI::WithBase>, L<URI::QueryParam>, L<URI::Escape>,
  L<URI::Split>, L<URI::Heuristic>
  
  RFC 2396: "Uniform Resource Identifiers (URI): Generic Syntax",
  Berners-Lee, Fielding, Masinter, August 1998.
  
  L<http://www.iana.org/assignments/uri-schemes>
  
  L<http://www.iana.org/assignments/urn-namespaces>
  
  L<http://www.w3.org/Addressing/>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  Copyright 1995 Martijn Koster.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHORS / ACKNOWLEDGMENTS
  
  This module is based on the C<URI::URL> module, which in turn was
  (distantly) based on the C<wwwurl.pl> code in the libwww-perl for
  perl4 developed by Roy Fielding, as part of the Arcadia project at the
  University of California, Irvine, with contributions from Brooks
  Cutter.
  
  C<URI::URL> was developed by Gisle Aas, Tim Bunce, Roy Fielding and
  Martijn Koster with input from other people on the libwww-perl mailing
  list.
  
  C<URI> and related subclasses was developed by Gisle Aas.
  
  =cut
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  URI::Escape - Percent-encode and percent-decode unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to percent-encode and percent-decode URI strings as
  defined by RFC 3986. Percent-encoding URI's is informally called "URI escaping".
  This is the terminology used by this module, which predates the formalization of the
  terms by the RFC by several years.
  
  A URI consists of a restricted set of characters.  The restricted set
  of characters consists of digits, letters, and a few graphic symbols
  chosen from those common to most of the character encodings and input
  facilities available to Internet users.  They are made up of the
  "unreserved" and "reserved" character sets as defined in RFC 3986.
  
     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
                     "!" / "$" / "&" / "'" / "(" / ")"
                   / "*" / "+" / "," / ";" / "="
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet.
  
  Some of the characters are I<reserved> for use as delimiters or as
  part of certain URI components.  These must be escaped if they are to
  be treated as ordinary data.  Read RFC 3986 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<unreserved> character class shown above as well
  as the reserved characters.  I.e. the default is:
  
      "^A-Za-z0-9\-\._~"
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able to deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  Equivalent to:
  
      utf8::encode($string);
      my $uri = uri_escape($string);
  
  Note: JavaScript has a function called escape() that produces the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  use Exporter 'import';
  our %escapes;
  our @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
  our @EXPORT_OK = qw(%escapes);
  our $VERSION = "3.31";
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patterns
  
  my %Unsafe = (
      RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
      RFC3986 => qr/[^A-Za-z0-9\-\._~]/,
  );
  
  sub uri_escape {
      my($text, $patn) = @_;
      return undef unless defined $text;
      if (defined $patn){
          unless (exists  $subst{$patn}) {
              # Because we can't compile the regex we fake it with a cached sub
              (my $tmp = $patn) =~ s,/,\\/,g;
              eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
              Carp::croak("uri_escape: $@") if $@;
          }
          &{$subst{$patn}}($text);
      } else {
          $text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;
      }
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8 {
      my $text = shift;
      utf8::encode($text);
      return uri_escape($text, @_);
  }
  
  sub uri_unescape {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
          # not executed for the common case of a single argument
          my @str = ($str, @_);  # need to copy
          for (@str) {
              s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
          }
          return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  # XXX FIXME escape_char is buggy as it assigns meaning to the string's storage format.
  sub escape_char {
      if (utf8::is_utf8($_[0])) {
          my $s = $_[0];
          utf8::encode($s);
          unshift(@_, $s);
      }
  
      return join '', @URI::Escape::escapes{$_[0] =~ /(.)/sg};
  }
  
  1;
URI_ESCAPE

$fatpacked{"URI/Find.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FIND';
  # Copyright (c) 2000, 2009 Michael G. Schwern.  All rights reserved.
  # This program is free software; you can redistribute it and/or modify
  # it under the same terms as Perl itself.
  
  package URI::Find;
  
  require 5.006;
  
  use strict;
  use base qw(Exporter);
  use vars qw($VERSION @EXPORT);
  
  $VERSION        = 20140709;
  @EXPORT         = qw(find_uris);
  
  use constant YES => (1==1);
  use constant NO  => !YES;
  
  use Carp        qw(croak);
  
  require URI;
  
  my $reserved   = q(;/?:@&=+$,[]);
  my $mark       = q(-_.!~*'());
  my $unreserved = "A-Za-z0-9\Q$mark\E";
  my $uric       = quotemeta($reserved) . '\p{isAlpha}' . $unreserved . "%";
  
  # URI scheme pattern without the non-alpha numerics.
  # Those are extremely uncommon and interfere with the match.
  my($schemeRe) = qr/[a-zA-Z][a-zA-Z0-9\+]*/;
  my($uricSet)  = $uric; # use new set
  
  # Some schemes which URI.pm does not explicitly support.
  my $extraSchemesRe = qr{^(?:git|svn|ssh|svn\+ssh)$};
  
  # We need to avoid picking up 'HTTP::Request::Common' so we have a
  # subset of uric without a colon ("I have no colon and yet I must poop")
  my($uricCheat) = __PACKAGE__->uric_set;
  $uricCheat =~ tr/://d;
  
  # Identifying characters accidentally picked up with a URI.
  my($cruftSet) = q{])\},.'";}; #'#
  
  
  =head1 NAME
  
  URI::Find - Find URIs in arbitrary text
  
  =head1 SYNOPSIS
  
    require URI::Find;
  
    my $finder = URI::Find->new(\&callback);
  
    $how_many_found = $finder->find(\$text);
  
  =head1 DESCRIPTION
  
  This module does one thing: Finds URIs and URLs in plain text.  It
  finds them quickly and it finds them B<all> (or what URI.pm considers
  a URI to be.)  It only finds URIs which include a scheme (http:// or
  the like), for something a bit less strict have a look at
  L<URI::Find::Schemeless|URI::Find::Schemeless>.
  
  For a command-line interface, L<urifind> is provided.
  
  =head2 Public Methods
  
  =over 4
  
  =item B<new>
  
    my $finder = URI::Find->new(\&callback);
  
  Creates a new URI::Find object.
  
  &callback is a function which is called on each URI found.  It is
  passed two arguments, the first is a URI object representing the URI
  found.  The second is the original text of the URI found.  The return
  value of the callback will replace the original URI in the text.
  
  =cut
  
  sub new {
      @_ == 2 || __PACKAGE__->badinvo;
      my($proto, $callback) = @_;
      my($class) = ref $proto || $proto;
      my $self = bless {}, $class;
  
      $self->{callback} = $callback;
  
      return $self;
  }
  
  =item B<find>
  
    my $how_many_found = $finder->find(\$text);
  
  $text is a string to search and possibly modify with your callback.
  
  Alternatively, C<find> can be called with a replacement function for
  the rest of the text:
  
    use CGI qw(escapeHTML);
    # ...
    my $how_many_found = $finder->find(\$text, \&escapeHTML);
  
  will not only call the callback function for every URL found (and
  perform the replacement instructions therein), but also run the rest
  of the text through C<escapeHTML()>. This makes it easier to turn
  plain text which contains URLs into HTML (see example below).
  
  =cut
  
  sub find {
      @_ == 2 || @_ == 3 || __PACKAGE__->badinvo;
      my($self, $r_text, $escape_func) = @_;
  
      # Might be slower, but it makes the code simpler
      $escape_func ||= sub { return $_[0] };
  
      # Store the escape func in the object temporarily for use
      # by other methods.
      local $self->{escape_func} = $escape_func;
  
      $self->{_uris_found} = 0;
  
      # Yes, evil.  Basically, look for something vaguely resembling a URL,
      # then hand it off to URI for examination.  If it passes, throw
      # it to a callback and put the result in its place.
      local $SIG{__DIE__} = 'DEFAULT';
      my $uri_cand;
      my $uri;
  
      my $uriRe = sprintf '(?:%s|%s)', $self->uri_re, $self->schemeless_uri_re;
  
      $$r_text =~ s{ (.*?) (?:(<(?:URL:)?)(.+?)(>)|($uriRe)) | (.+?)$ }{
          my $replace = '';
          if( defined $6 ) {
              $replace = $escape_func->($6);
          }
          else {
              my $maybe_uri = '';
  
              $replace = $escape_func->($1) if length $1;
  
              if( defined $2 ) {
                  $maybe_uri = $3;
                  my $is_uri = do {  # Don't alter $1...
                      $maybe_uri =~ s/\s+//g;
                      $maybe_uri =~ /^$uriRe/;
                  };
  
                  if( $is_uri ) {
                      $replace .= $escape_func->($2);
                      $replace .= $self->_uri_filter($maybe_uri);
                      $replace .= $escape_func->($4);
                  }
                  else {
                      # the whole text inside of the <...> was not a url, but
                      # maybe it has a url (like an HTML <a> link)
                      my $has_uri = do { # Don't alter $1...
                          $maybe_uri = $3;
                          $maybe_uri =~ /$uriRe/;
                      };
                      if( $has_uri ) {
                          my $pre = $2;
                          my $post = $4;
                          do { $self->find(\$maybe_uri, $escape_func) };
                          $replace .= $escape_func->($pre);
                          $replace .= $maybe_uri;  # already escaped by find()
                          $replace .= $escape_func->($post);
                      }
                      else {
                          $replace .= $escape_func->($2.$3.$4);
                      }
                  }
              }
              else {
                  $replace .= $self->_uri_filter($5);
              }
          }
  
          $replace;
      }gsex;
  
      return $self->{_uris_found};
  }
  
  
  sub _uri_filter {
      my($self, $orig_match) = @_;
  
      # A heuristic.  Often you'll see things like:
      # "I saw this site, http://www.foo.com, and its really neat!"
      # or "Foo Industries (at http://www.foo.com)"
      # We want to avoid picking up the trailing paren, period or comma.
      # Of course, this might wreck a perfectly valid URI, more often than
      # not it corrects a parse mistake.
      $orig_match = $self->decruft($orig_match);
  
      my $replacement = '';
      if( my $uri = $self->_is_uri(\$orig_match) ) {
          # It's a URI
          $self->{_uris_found}++;
          $replacement = $self->{callback}->($uri, $orig_match);
      }
      else {
          # False alarm
          $replacement = $self->{escape_func}->($orig_match);
      }
  
      # Return recrufted replacement
      return $self->recruft($replacement);
  }
  
  
  =back
  
  =head2 Protected Methods
  
  I got a bunch of mail from people asking if I'd add certain features
  to URI::Find.  Most wanted the search to be less restrictive, do more
  heuristics, etc...  Since many of the requests were contradictory, I'm
  letting people create their own custom subclasses to do what they
  want.
  
  The following are methods internal to URI::Find which a subclass can
  override to change the way URI::Find acts.  They are only to be called
  B<inside> a URI::Find subclass.  Users of this module are NOT to use
  these methods.
  
  =over
  
  =item B<uri_re>
  
    my $uri_re = $self->uri_re;
  
  Returns the regex for finding absolute, schemed URIs
  (http://www.foo.com and such).  This, combined with
  schemeless_uri_re() is what finds candidate URIs.
  
  Usually this method does not have to be overridden.
  
  =cut
  
  sub uri_re {
      @_ == 1 || __PACKAGE__->badinvo;
      my($self) = shift;
      return sprintf '%s:[%s][%s#]*', $schemeRe,
                                      $uricCheat,
                                      $self->uric_set;
  }
  
  =item B<schemeless_uri_re>
  
    my $schemeless_re = $self->schemeless_uri_re;
  
  Returns the regex for finding schemeless URIs (www.foo.com and such) and
  other things which might be URIs.  By default this will match nothing
  (though it used to try to find schemeless URIs which started with C<www>
  and C<ftp>).
  
  Many people will want to override this method.  See L<URI::Find::Schemeless>
  for a subclass does a reasonable job of finding URIs which might be missing
  the scheme.
  
  =cut
  
  sub schemeless_uri_re {
      @_ == 1 || __PACKAGE__->badinvo;
      my($self) = shift;
      return qr/\b\B/; # match nothing
  }
  
  =item B<uric_set>
  
    my $uric_set = $self->uric_set;
  
  Returns a set matching the 'uric' set defined in RFC 2396 suitable for
  putting into a character set ([]) in a regex.
  
  You almost never have to override this.
  
  =cut
  
  sub uric_set {
      @_ == 1 || __PACKAGE__->badinvo;
      return $uricSet;
  }
  
  =item B<cruft_set>
  
    my $cruft_set = $self->cruft_set;
  
  Returns a set of characters which are considered garbage.  Used by
  decruft().
  
  =cut
  
  sub cruft_set {
      @_ == 1 || __PACKAGE__->badinvo;
      return $cruftSet;
  }
  
  =item B<decruft>
  
    my $uri = $self->decruft($uri);
  
  Sometimes garbage characters like periods and parenthesis get
  accidentally matched along with the URI.  In order for the URI to be
  properly identified, it must sometimes be "decrufted", the garbage
  characters stripped.
  
  This method takes a candidate URI and strips off any cruft it finds.
  
  =cut
  
  my %balanced_cruft = (
      '('         => ')',
      '{'         => '}',
      '['         => ']',
      '"'         => '"',
      q[']        => q['],
  );
  
  sub decruft {
      @_ == 2 || __PACKAGE__->badinvo;
      my($self, $orig_match) = @_;
  
      $self->{start_cruft} = '';
      $self->{end_cruft} = '';
  
      if( $orig_match =~ s/([\Q$cruftSet\E]+)$// ) {
          # urls can end with HTML entities if found in HTML so let's put back semicolons
          # if this looks like the case
          my $cruft = $1;
          if( $cruft =~ /^;/ && $orig_match =~ /\&(\#[1-9]\d{1,3}|[a-zA-Z]{2,8})$/) {
              $orig_match .= ';';
              $cruft =~ s/^;//;
          }
  
          while( my($open, $close) = each %balanced_cruft ) {
              $self->recruft_balanced(\$orig_match, \$cruft, $open, $close);
          }
  
          $self->{end_cruft} = $cruft if $cruft;
      }
  
      return $orig_match;
  }
  
  
  sub recruft_balanced {
      my $self = shift;
      my($orig_match, $cruft, $open, $close) = @_;
  
      my $open_count  = () = $$orig_match =~ m{\Q$open}g;
      my $close_count = () = $$orig_match =~ m{\Q$close}g;
  
      if ( $$cruft =~ /\Q$close\E$/ && $open_count == ( $close_count + 1 ) ) {
          $$orig_match .= $close;
          $$cruft =~ s/\Q$close\E$//;
      }
  
      return;
  }
  
  
  =item B<recruft>
  
    my $uri = $self->recruft($uri);
  
  This method puts back the cruft taken off with decruft().  This is necessary
  because the cruft is destructively removed from the string before invoking
  the user's callback, so it has to be put back afterwards.
  
  =cut
  
  #'#
  
  sub recruft {
      @_ == 2 || __PACKAGE__->badinvo;
      my($self, $uri) = @_;
  
      return $self->{start_cruft} . $uri . $self->{end_cruft};
  }
  
  =item B<schemeless_to_schemed>
  
    my $schemed_uri = $self->schemeless_to_schemed($schemeless_uri);
  
  This takes a schemeless URI and returns an absolute, schemed URI.  The
  standard implementation supplies ftp:// for URIs which start with ftp.,
  and http:// otherwise.
  
  =cut
  
  sub schemeless_to_schemed {
      @_ == 2 || __PACKAGE__->badinvo;
      my($self, $uri_cand) = @_;
  
      $uri_cand =~ s|^(<?)ftp\.|$1ftp://ftp\.|
          or $uri_cand =~ s|^(<?)|${1}http://|;
  
      return $uri_cand;
  }
  
  =item B<is_schemed>
  
    $obj->is_schemed($uri);
  
  Returns whether or not the given URI is schemed or schemeless.  True for
  schemed, false for schemeless.
  
  =cut
  
  sub is_schemed {
      @_ == 2 || __PACKAGE__->badinvo;
      my($self, $uri) = @_;
      return scalar $uri =~ /^<?$schemeRe:/;
  }
  
  =item I<badinvo>
  
    __PACKAGE__->badinvo($extra_levels, $msg)
  
  This is used to complain about bogus subroutine/method invocations.
  The args are optional.
  
  =cut
  
  sub badinvo {
      my $package = shift;
      my $level   = @_ ? shift : 0;
      my $msg     = @_ ? " (" . shift() . ")" : '';
      my $subname = (caller $level + 1)[3];
      croak "Bogus invocation of $subname$msg";
  }
  
  =back
  
  =head2 Old Functions
  
  The old find_uri() function is still around and it works, but its
  deprecated.
  
  =cut
  
  # Old interface.
  sub find_uris (\$&) {
      @_ == 2 || __PACKAGE__->badinvo;
      my($r_text, $callback) = @_;
  
      my $self = __PACKAGE__->new($callback);
      return $self->find($r_text);
  }
  
  
  =head1 EXAMPLES
  
  Store a list of all URIs (normalized) in the document.
  
    my @uris;
    my $finder = URI::Find->new(sub {
        my($uri) = shift;
        push @uris, $uri;
    });
    $finder->find(\$text);
  
  Print the original URI text found and the normalized representation.
  
    my $finder = URI::Find->new(sub {
        my($uri, $orig_uri) = @_;
        print "The text '$orig_uri' represents '$uri'\n";
        return $orig_uri;
    });
    $finder->find(\$text);
  
  Check each URI in document to see if it exists.
  
    use LWP::Simple;
  
    my $finder = URI::Find->new(sub {
        my($uri, $orig_uri) = @_;
        if( head $uri ) {
            print "$orig_uri is okay\n";
        }
        else {
            print "$orig_uri cannot be found\n";
        }
        return $orig_uri;
    });
    $finder->find(\$text);
  
  
  Turn plain text into HTML, with each URI found wrapped in an HTML anchor.
  
    use CGI qw(escapeHTML);
    use URI::Find;
  
    my $finder = URI::Find->new(sub {
        my($uri, $orig_uri) = @_;
        return qq|<a href="$uri">$orig_uri</a>|;
    });
    $finder->find(\$text, \&escapeHTML);
    print "<pre>$text</pre>";
  
  =cut
  
  
  sub _is_uri {
      @_ == 2 || __PACKAGE__->badinvo;
      my($self, $r_uri_cand) = @_;
  
      my $uri = $$r_uri_cand;
  
      # Translate schemeless to schemed if necessary.
      $uri = $self->schemeless_to_schemed($uri) if
        $uri =~ $self->schemeless_uri_re   and
        $uri !~ /^<?$schemeRe:/;
  
      eval {
          $uri = URI->new($uri);
  
          # Throw out anything with an invalid scheme.
          my $has_invalid_scheme = $uri->isa("URI::_foreign") &&
                                   $uri->scheme !~ $extraSchemesRe;
  
          # Toss out things like http:// but keep file:///
          my $is_empty = $uri =~ m{^$schemeRe://$};
  
          undef $uri if $has_invalid_scheme || $is_empty;
      };
  
      if($@ || !defined $uri) {   # leave everything untouched, its not a URI.
          return NO;
      }
      else {                      # Its a URI.
          return $uri;
      }
  }
  
  
  =head1 NOTES
  
  Will not find URLs with Internationalized Domain Names or pretty much
  any non-ascii stuff in them.  See
  L<http://rt.cpan.org/Ticket/Display.html?id=44226>
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with insight from Uri Gutman,
  Greg Bacon, Jeff Pinyan, Roderick Schertler and others.
  
  Roderick Schertler <roderick@argon.org> maintained versions 0.11 to 0.16.
  
  Darren Chamberlain wrote urifind.
  
  
  =head1 LICENSE
  
  Copyright 2000, 2009-2010 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or 
  modify it under the same terms as Perl itself.
  
  See F<http://www.perlfoundation.org/artistic_license_1_0>
  
  =head1 SEE ALSO
  
  L<urifind>, L<URI::Find::Schemeless>, L<URI>, RFC 3986 Appendix C
  
  =cut
  
  1;
URI_FIND

$fatpacked{"URI/Find/Schemeless.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FIND_SCHEMELESS';
  # Copyright (c) 2000, 2009 Michael G. Schwern.  All rights reserved.
  # This program is free software; you can redistribute it and/or modify
  # it under the same terms as Perl itself.
  
  package URI::Find::Schemeless;
  
  use strict;
  use base qw(URI::Find);
  
  # base.pm error in 5.005_03 prevents it from loading URI::Find if I'm
  # required first.
  use URI::Find ();
  
  use vars qw($VERSION);
  $VERSION = 20140709;
  
  my($dnsSet) = '\p{isAlpha}A-Za-z0-9-'; # extended for IDNA domains
  
  my($cruftSet) = __PACKAGE__->cruft_set . '<>?}';
  
  my($tldRe) = __PACKAGE__->top_level_domain_re;
  
  my($uricSet) = __PACKAGE__->uric_set;
  
  =head1 NAME
  
  URI::Find::Schemeless - Find schemeless URIs in arbitrary text.
  
  
  =head1 SYNOPSIS
  
    require URI::Find::Schemeless;
  
    my $finder = URI::Find::Schemeless->new(\&callback);
  
    The rest is the same as URI::Find.
  
  
  =head1 DESCRIPTION
  
  URI::Find finds absolute URIs in plain text with some weak heuristics
  for finding schemeless URIs.  This subclass is for finding things
  which might be URIs in free text.  Things like "www.foo.com" and
  "lifes.a.bitch.if.you.aint.got.net".
  
  The heuristics are such that it hopefully finds a minimum of false
  positives, but there's no easy way for it know if "COMMAND.COM" refers
  to a web site or a file.
  
  =cut
  
  sub schemeless_uri_re {
      @_ == 1 || __PACKAGE__->badinvo;
      return qr{
                # Originally I constrained what couldn't be before the match
                # like this:  don't match email addresses, and don't start
                # anywhere but at the beginning of a host name
                #    (?<![\@.$dnsSet])
                # but I switched to saying what can be there after seeing a
                # false match of "Lite.pm" via "MIME/Lite.pm".
                (?: ^ | (?<=[\s<>()\{\}\[\]]) )
                # hostname
                (?: [$dnsSet]+(?:\.[$dnsSet]+)*\.$tldRe
                    | (?:\d{1,3}\.){3}\d{1,3} ) # not inet_aton() complete
                (?:
                    (?=[\s\Q$cruftSet\E]) # followed by unrelated thing
                    (?!\.\w)              #   but don't stop mid foo.xx.bar
                        (?<!\.p[ml])      #   but exclude Foo.pm and Foo.pl
                    |$                    # or end of line
                        (?<!\.p[ml])      #   but exclude Foo.pm and Foo.pl
                    |/[$uricSet#]*        # or slash and URI chars
                )
             }x;
  }
  
  =head3 top_level_domain_re
  
    my $tld_re = $self->top_level_domain_re;
  
  Returns the regex for matching top level DNS domains.  The regex shouldn't
  be anchored, it shouldn't do any capturing matches, and it should make
  itself ignore case.
  
  =cut
  
  sub top_level_domain_re {
      @_ == 1 || __PACKAGE__->badinvo;
      my($self) = shift;
  
      use utf8;
      # Updated from http://www.iana.org/domains/root/db/ with new TLDs
      my $plain = join '|', qw(
          AERO
          ARPA
          ASIA
          BIZ
          CAT
          COM
          COOP
          EDU
          GOV
          INFO
          INT
          JOBS
          MIL
          MOBI
          MUSEUM
          NAME
          NET
          ORG
          PRO
          TEL
          TRAVEL
          ac
          academy
          accountants
          active
          actor
          ad
          ae
          aero
          af
          ag
          agency
          ai
          airforce
          al
          am
          an
          ao
          aq
          ar
          archi
          army
          arpa
          as
          asia
          associates
          at
          attorney
          au
          audio
          autos
          aw
          ax
          axa
          az
          ba
          bar
          bargains
          bayern
          bb
          bd
          be
          beer
          berlin
          best
          bf
          bg
          bh
          bi
          bid
          bike
          bio
          biz
          bj
          bl
          black
          blackfriday
          blue
          bm
          bmw
          bn
          bo
          boutique
          bq
          br
          brussels
          bs
          bt
          build
          builders
          buzz
          bv
          bw
          by
          bz
          bzh
          ca
          cab
          camera
          camp
          capetown
          capital
          cards
          care
          career
          careers
          cash
          cat
          catering
          cc
          cd
          center
          ceo
          cf
          cg
          ch
          cheap
          christmas
          church
          ci
          citic
          ck
          cl
          claims
          cleaning
          clinic
          clothing
          club
          cm
          cn
          co
          codes
          coffee
          college
          cologne
          com
          community
          company
          computer
          condos
          construction
          consulting
          contractors
          cooking
          cool
          coop
          country
          cr
          credit
          creditcard
          cruises
          cu
          cv
          cw
          cx
          cy
          cz
          dance
          dating
          de
          degree
          democrat
          dental
          dentist
          desi
          diamonds
          digital
          directory
          discount
          dj
          dk
          dm
          dnp
          do
          domains
          durban
          dz
          ec
          edu
          education
          ee
          eg
          eh
          email
          engineer
          engineering
          enterprises
          equipment
          er
          es
          estate
          et
          eu
          eus
          events
          exchange
          expert
          exposed
          fail
          farm
          feedback
          fi
          finance
          financial
          fish
          fishing
          fitness
          fj
          fk
          flights
          florist
          fm
          fo
          foo
          foundation
          fr
          frogans
          fund
          furniture
          futbol
          ga
          gal
          gallery
          gb
          gd
          ge
          gf
          gg
          gh
          gi
          gift
          gives
          gl
          glass
          global
          globo
          gm
          gmo
          gn
          gop
          gov
          gp
          gq
          gr
          graphics
          gratis
          green
          gripe
          gs
          gt
          gu
          guide
          guitars
          guru
          gw
          gy
          hamburg
          haus
          hiphop
          hiv
          hk
          hm
          hn
          holdings
          holiday
          homes
          horse
          host
          house
          hr
          ht
          hu
          id
          ie
          il
          im
          immobilien
          in
          industries
          info
          ink
          institute
          insure
          int
          international
          investments
          io
          iq
          ir
          is
          it
          je
          jetzt
          jm
          jo
          jobs
          joburg
          jp
          juegos
          kaufen
          ke
          kg
          kh
          ki
          kim
          kitchen
          kiwi
          km
          kn
          koeln
          kp
          kr
          kred
          kw
          ky
          kz
          la
          land
          lawyer
          lb
          lc
          lease
          li
          life
          lighting
          limited
          limo
          link
          lk
          loans
          london
          lotto
          lr
          ls
          lt
          lu
          luxe
          luxury
          lv
          ly
          ma
          maison
          management
          mango
          market
          marketing
          mc
          md
          me
          media
          meet
          menu
          mf
          mg
          mh
          miami
          mil
          mini
          mk
          ml
          mm
          mn
          mo
          mobi
          moda
          moe
          monash
          mortgage
          moscow
          motorcycles
          mp
          mq
          mr
          ms
          mt
          mu
          museum
          mv
          mw
          mx
          my
          mz
          na
          nagoya
          name
          navy
          nc
          ne
          net
          neustar
          nf
          ng
          nhk
          ni
          ninja
          nl
          no
          np
          nr
          nu
          nyc
          nz
          okinawa
          om
          onl
          org
          organic
          ovh
          pa
          paris
          partners
          parts
          pe
          pf
          pg
          ph
          photo
          photography
          photos
          physio
          pics
          pictures
          pink
          pk
          pl
          plumbing
          pm
          pn
          post
          pr
          press
          pro
          productions
          properties
          ps
          pt
          pub
          pw
          py
          qa
          qpon
          quebec
          re
          recipes
          red
          rehab
          reise
          reisen
          ren
          rentals
          repair
          report
          republican
          rest
          reviews
          rich
          rio
          ro
          rocks
          rodeo
          rs
          ru
          ruhr
          rw
          ryukyu
          sa
          saarland
          sb
          sc
          schule
          scot
          sd
          se
          services
          sexy
          sg
          sh
          shiksha
          shoes
          si
          singles
          sj
          sk
          sl
          sm
          sn
          so
          social
          software
          sohu
          solar
          solutions
          soy
          space
          sr
          ss
          st
          su
          supplies
          supply
          support
          surf
          surgery
          sv
          sx
          sy
          systems
          sz
          tattoo
          tax
          tc
          td
          technology
          tel
          tf
          tg
          th
          tienda
          tips
          tirol
          tj
          tk
          tl
          tm
          tn
          to
          today
          tokyo
          tools
          town
          toys
          tp
          tr
          trade
          training
          travel
          tt
          tv
          tw
          tz
          ua
          ug
          uk
          um
          university
          uno
          us
          uy
          uz
          va
          vacations
          vc
          ve
          vegas
          ventures
          versicherung
          vet
          vg
          vi
          viajes
          villas
          vision
          vlaanderen
          vn
          vodka
          vote
          voting
          voto
          voyage
          vu
          wang
          watch
          webcam
          website
          wed
          wf
          wien
          wiki
          works
          ws
          wtc
          wtf
          测试
             परीक्षा
          集团
          在线
          한국
           ভারত
          موقع
           বাংলা
          公益
          公司
          移动
          我爱你
          москва
          испытание
          қаз
          онлайн
          сайт
          срб
          테스트
          орг
          삼성
            சிங்கப்பூர்
          商标
          商城
          дети
          мкд
          טעסט
          中文网
          中信
          中国
          中國
                       భారత్
                 ලංකා
          測試
                  ભારત
             भारत
          آزمایشی
             பரிட்சை
             संगठन
          网络
          укр
          香港
          δοκιμή
          إختبار
          台湾
          台灣
          мон
          الجزائر
          عمان
          ایران
          امارات
          بازار
          پاکستان
          الاردن
          بھارت
          المغرب
          السعودية
          سودان
          مليسيا
          شبكة
          გე
          机构
          组织机构
                       ไทย
          سورية
          рф
          تونس
          みんな
          世界
                       ਭਾਰਤ
          网址
          游戏
          مصر
          قطر
            இலங்கை
            இந்தியா
          新加坡
          فلسطين
          テスト
          政务
          xxx
          xyz
          yachts
          ye
          yokohama
          yt
          za
          zm
          zone
          zw
      );
      
      return qr/(?:$plain)/i;
  }
  
  =head1 AUTHOR
  
  Original code by Roderick Schertler <roderick@argon.org>, adapted by
  Michael G Schwern <schwern@pobox.com>.
  
  Currently maintained by Roderick Schertler <roderick@argon.org>.
  
  =head1 SEE ALSO
  
    L<URI::Find>
  
  =cut
  
  1;
URI_FIND_SCHEMELESS

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;
  
  =head1 NAME
  
  URI::Heuristic - Expand URI using heuristics
  
  =head1 SYNOPSIS
  
   use URI::Heuristic qw(uf_uristr);
   $u = uf_uristr("perl");             # http://www.perl.com
   $u = uf_uristr("www.sol.no/sol");   # http://www.sol.no/sol
   $u = uf_uristr("aas");              # http://www.aas.no
   $u = uf_uristr("ftp.funet.fi");     # ftp://ftp.funet.fi
   $u = uf_uristr("/etc/passwd");      # file:/etc/passwd
  
  =head1 DESCRIPTION
  
  This module provides functions that expand strings into real absolute
  URIs using some built-in heuristics.  Strings that already represent
  absolute URIs (i.e. that start with a C<scheme:> part) are never modified
  and are returned unchanged.  The main use of these functions is to
  allow abbreviated URIs similar to what many web browsers allow for URIs
  typed in by the user.
  
  The following functions are provided:
  
  =over 4
  
  =item uf_uristr($str)
  
  Tries to make the argument string
  into a proper absolute URI string.  The "uf_" prefix stands for "User 
  Friendly".  Under MacOS, it assumes that any string with a common URL 
  scheme (http, ftp, etc.) is a URL rather than a local path.  So don't name 
  your volumes after common URL schemes and expect uf_uristr() to construct 
  valid file: URL's on those volumes for you, because it won't.
  
  =item uf_uri($str)
  
  Works the same way as uf_uristr() but
  returns a C<URI> object.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the hostname portion of a URI does not contain any dots, then
  certain qualified guesses are made.  These guesses are governed by
  the following environment variables:
  
  =over 10
  
  =item COUNTRY
  
  The two-letter country code (ISO 3166) for your location.  If
  the domain name of your host ends with two letters, then it is taken
  to be the default country. See also L<Locale::Country>.
  
  =item HTTP_ACCEPT_LANGUAGE, LC_ALL, LANG
  
  If COUNTRY is not set, these standard environment variables are
  examined and country (not language) information possibly found in them
  is used as the default country.
  
  =item URL_GUESS_PATTERN
  
  Contains a space-separated list of URL patterns to try.  The string
  "ACME" is for some reason used as a placeholder for the host name in
  the URL provided.  Example:
  
   URL_GUESS_PATTERN="www.ACME.no www.ACME.se www.ACME.com"
   export URL_GUESS_PATTERN
  
  Specifying URL_GUESS_PATTERN disables any guessing rules based on
  country.  An empty URL_GUESS_PATTERN disables any guessing that
  involves host name lookups.
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  use warnings;
  
  use Exporter 'import';
  our @EXPORT_OK = qw(uf_uri uf_uristr uf_url uf_urlstr);
  our $VERSION = "4.20";
  
  our ($MY_COUNTRY, $DEBUG);
  
  sub MY_COUNTRY() {
      for ($MY_COUNTRY) {
  	return $_ if defined;
  
  	# First try the environment.
  	$_ = $ENV{COUNTRY};
  	return $_ if defined;
  
  	# Try the country part of LC_ALL and LANG from environment
  	my @srcs = ($ENV{LC_ALL}, $ENV{LANG});
  	# ...and HTTP_ACCEPT_LANGUAGE before those if present
  	if (my $httplang = $ENV{HTTP_ACCEPT_LANGUAGE}) {
  	    # TODO: q-value processing/ordering
  	    for $httplang (split(/\s*,\s*/, $httplang)) {
  		if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/) {
  		    unshift(@srcs, "${1}_${2}");
  		    last;
  		}
  	    }
  	}
  	for (@srcs) {
  	    next unless defined;
  	    return lc($1) if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/;
  	}
  
  	# Last bit of domain name.  This may access the network.
  	require Net::Domain;
  	my $fqdn = Net::Domain::hostfqdn();
  	$_ = lc($1) if $fqdn =~ /\.([a-zA-Z]{2})$/;
  	return $_ if defined;
  
  	# Give up.  Defined but false.
  	return ($_ = 0);
      }
  }
  
  our %LOCAL_GUESSING =
  (
   'us' => [qw(www.ACME.gov www.ACME.mil)],
   'gb' => [qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],
   'au' => [qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],
   'il' => [qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],
   # send corrections and new entries to <gisle@aas.no>
  );
  # Backwards compatibility; uk != United Kingdom in ISO 3166
  $LOCAL_GUESSING{uk} = $LOCAL_GUESSING{gb};
  
  
  sub uf_uristr ($)
  {
      local($_) = @_;
      print STDERR "uf_uristr: resolving $_\n" if $DEBUG;
      return unless defined;
  
      s/^\s+//;
      s/\s+$//;
  
      if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = "http://$_";
  
      } elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = lc($1) . "://$_";
  
      } elsif ($^O ne "MacOS" && 
  	    (m,^/,      ||          # absolute file name
  	     m,^\.\.?/, ||          # relative file name
  	     m,^[a-zA-Z]:[/\\],)    # dosish file name
  	    )
      {
  	$_ = "file:$_";
  
      } elsif ($^O eq "MacOS" && m/:/) {
          # potential MacOS file name
  	unless (m/^(ftp|gopher|news|wais|http|https|mailto):/) {
  	    require URI::file;
  	    my $a = URI::file->new($_)->as_string;
  	    $_ = ($a =~ m/^file:/) ? $a : "file:$a";
  	}
      } elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/) {
  	$_ = "mailto:$_";
  
      } elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/) {      # no scheme specified
  	if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/) {
  	    my $host = $1;
  
  	    my $scheme = "http";
  	    if (/^:(\d+)\b/) {
  		# Some more or less well known ports
  		if ($1 =~ /^[56789]?443$/) {
  		    $scheme = "https";
  		} elsif ($1 eq "21") {
  		    $scheme = "ftp";
  		}
  	    }
  
  	    if ($host !~ /\./ && $host ne "localhost") {
  		my @guess;
  		if (exists $ENV{URL_GUESS_PATTERN}) {
  		    @guess = map { s/\bACME\b/$host/; $_ }
  		             split(' ', $ENV{URL_GUESS_PATTERN});
  		} else {
  		    if (MY_COUNTRY()) {
  			my $special = $LOCAL_GUESSING{MY_COUNTRY()};
  			if ($special) {
  			    my @special = @$special;
  			    push(@guess, map { s/\bACME\b/$host/; $_ }
                                                 @special);
  			} else {
  			    push(@guess, "www.$host." . MY_COUNTRY());
  			}
  		    }
  		    push(@guess, map "www.$host.$_",
  			             "com", "org", "net", "edu", "int");
  		}
  
  
  		my $guess;
  		for $guess (@guess) {
  		    print STDERR "uf_uristr: gethostbyname('$guess.')..."
  		      if $DEBUG;
  		    if (gethostbyname("$guess.")) {
  			print STDERR "yes\n" if $DEBUG;
  			$host = $guess;
  			last;
  		    }
  		    print STDERR "no\n" if $DEBUG;
  		}
  	    }
  	    $_ = "$scheme://$host$_";
  
  	} else {
  	    # pure junk, just return it unchanged...
  
  	}
      }
      print STDERR "uf_uristr: ==> $_\n" if $DEBUG;
  
      $_;
  }
  
  sub uf_uri ($)
  {
      require URI;
      URI->new(uf_uristr($_[0]));
  }
  
  # legacy
  *uf_urlstr = \*uf_uristr;
  
  sub uf_url ($)
  {
      require URI::URL;
      URI::URL->new(uf_uristr($_[0]));
  }
  
  1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;
  
  # Experimental
  
  use strict;
  use warnings;
  use URI ();
  
  use overload '""' => sub { shift->as_string };
  
  sub new {
      my($class, $uri, $scheme) = @_;
      utf8::upgrade($uri);
      return bless {
  	uri => URI->new($uri, $scheme),
      }, $class;
  }
  
  sub clone {
      my $self = shift;
      return bless {
  	uri => $self->{uri}->clone,
      }, ref($self);
  }
  
  sub as_string {
      my $self = shift;
      return $self->{uri}->as_iri;
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->{uri}->$method(@_) };
      goto &$method;
  }
  
  sub DESTROY {}   # avoid AUTOLOADing it
  
  1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;
  
  use strict;
  use warnings;
  
  sub URI::_query::query_param {
      my $self = shift;
      my @old = $self->query_form;
  
      if (@_ == 0) {
  	# get keys
  	my (%seen, $i);
  	return grep !($i++ % 2 || $seen{$_}++), @old;
      }
  
      my $key = shift;
      my @i = grep $_ % 2 == 0 && $old[$_] eq $key, 0 .. $#old;
  
      if (@_) {
  	my @new = @old;
  	my @new_i = @i;
  	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  
  	while (@new_i > @vals) {
  	    splice @new, pop @new_i, 2;
  	}
  	if (@vals > @new_i) {
  	    my $i = @new_i ? $new_i[-1] + 2 : @new;
  	    my @splice = splice @vals, @new_i, @vals - @new_i;
  
  	    splice @new, $i, 0, map { $key => $_ } @splice;
  	}
  	if (@vals) {
  	    #print "SET $new_i[0]\n";
  	    @new[ map $_ + 1, @new_i ] = @vals;
  	}
  
  	$self->query_form(\@new);
      }
  
      return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
  }
  
  sub URI::_query::query_param_append {
      my $self = shift;
      my $key = shift;
      my @vals = map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_;
      $self->query_form($self->query_form, $key => \@vals);  # XXX
      return;
  }
  
  sub URI::_query::query_param_delete {
      my $self = shift;
      my $key = shift;
      my @old = $self->query_form;
      my @vals;
  
      for (my $i = @old - 2; $i >= 0; $i -= 2) {
  	next if $old[$i] ne $key;
  	push(@vals, (splice(@old, $i, 2))[1]);
      }
      $self->query_form(\@old) if @vals;
      return wantarray ? reverse @vals : $vals[-1];
  }
  
  sub URI::_query::query_form_hash {
      my $self = shift;
      my @old = $self->query_form;
      if (@_) {
  	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
      }
      my %hash;
      while (my($k, $v) = splice(@old, 0, 2)) {
  	if (exists $hash{$k}) {
  	    for ($hash{$k}) {
  		$_ = [$_] unless ref($_) eq "ARRAY";
  		push(@$_, $v);
  	    }
  	}
  	else {
  	    $hash{$k} = $v;
  	}
      }
      return \%hash;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::QueryParam - Additional query methods for URIs
  
  =head1 SYNOPSIS
  
    use URI;
    use URI::QueryParam;
  
    $u = URI->new("", "http");
    $u->query_param(foo => 1, 2, 3);
    print $u->query;    # prints foo=1&foo=2&foo=3
  
    for my $key ($u->query_param) {
        print "$key: ", join(", ", $u->query_param($key)), "\n";
    }
  
  =head1 DESCRIPTION
  
  Loading the C<URI::QueryParam> module adds some extra methods to
  URIs that support query methods.  These methods provide an alternative
  interface to the $u->query_form data.
  
  The query_param_* methods have deliberately been made identical to the
  interface of the corresponding C<CGI.pm> methods.
  
  The following additional methods are made available:
  
  =over
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash);
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<CGI>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Gisle Aas.
  
  =cut
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;
  
  use strict;
  use warnings;
  
  use Exporter 'import';
  our @EXPORT_OK = qw(uri_split uri_join);
  
  use URI::Escape ();
  
  sub uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub uri_join {
      my($scheme, $auth, $path, $query, $frag) = @_;
      my $uri = defined($scheme) ? "$scheme:" : "";
      $path = "" unless defined $path;
      if (defined $auth) {
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$uri .= "//$auth";
  	$path = "/$path" if length($path) && $path !~ m,^/,;
      }
      elsif ($path =~ m,^//,) {
  	$uri .= "//";  # XXX force empty auth
      }
      unless (length $uri) {
  	$path =~ s,(:), URI::Escape::escape_char($1),e while $path =~ m,^[^:/?\#]+:,;
      }
      $path =~ s,([?\#]), URI::Escape::escape_char($1),eg;
      $uri .= $path;
      if (defined $query) {
  	$query =~ s,(\#), URI::Escape::escape_char($1),eg;
  	$uri .= "?$query";
      }
      $uri .= "#$frag" if defined $frag;
      $uri;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::Split - Parse and compose URI strings
  
  =head1 SYNOPSIS
  
   use URI::Split qw(uri_split uri_join);
   ($scheme, $auth, $path, $query, $frag) = uri_split($uri);
   $uri = uri_join($scheme, $auth, $path, $query, $frag);
  
  =head1 DESCRIPTION
  
  Provides functions to parse and compose URI
  strings.  The following functions are provided:
  
  =over
  
  =item ($scheme, $auth, $path, $query, $frag) = uri_split($uri)
  
  Breaks up a URI string into its component
  parts.  An C<undef> value is returned for those parts that are not
  present.  The $path part is always present (but can be the empty
  string) and is thus never returned as C<undef>.
  
  No sensible value is returned if this function is called in a scalar
  context.
  
  =item $uri = uri_join($scheme, $auth, $path, $query, $frag)
  
  Puts together a URI string from its parts.
  Missing parts are signaled by passing C<undef> for the corresponding
  argument.
  
  Minimal escaping is applied to parts that contain reserved chars
  that would confuse a parser.  For instance, any occurrence of '?' or '#'
  in $path is always escaped, as it would otherwise be parsed back
  as a query or fragment.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::Escape>
  
  =head1 COPYRIGHT
  
  Copyright 2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;
  
  use strict;
  use warnings;
  
  use parent 'URI::WithBase';
  
  our $VERSION = "5.04";
  
  # Provide as much as possible of the old URI::URL interface for backwards
  # compatibility...
  
  use Exporter 'import';
  our @EXPORT = qw(url);
  
  # Easy to use constructor
  sub url ($;$) { URI::URL->new(@_); }
  
  use URI::Escape qw(uri_unescape);
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
      $self->[0] = $self->[0]->canonical;
      $self;
  }
  
  sub newlocal
  {
      my $class = shift;
      require URI::file;
      bless [URI::file->new_abs(shift)], $class;
  }
  
  {package URI::_foreign;
      sub _init  # hope it is not defined
      {
  	my $class = shift;
  	die "Unknown URI::URL scheme $_[1]:" if $URI::URL::STRICT;
  	$class->SUPER::_init(@_);
      }
  }
  
  sub strict
  {
      my $old = $URI::URL::STRICT;
      $URI::URL::STRICT = shift if @_;
      $old;
  }
  
  sub print_on
  {
      my $self = shift;
      require Data::Dumper;
      print STDERR Data::Dumper::Dumper($self);
  }
  
  sub _try
  {
      my $self = shift;
      my $method = shift;
      scalar(eval { $self->$method(@_) });
  }
  
  sub crack
  {
      # should be overridden by subclasses
      my $self = shift;
      (scalar($self->scheme),
       $self->_try("user"),
       $self->_try("password"),
       $self->_try("host"),
       $self->_try("port"),
       $self->_try("path"),
       $self->_try("params"),
       $self->_try("query"),
       scalar($self->fragment),
      )
  }
  
  sub full_path
  {
      my $self = shift;
      my $path = $self->path_query;
      $path = "/" unless length $path;
      $path;
  }
  
  sub netloc
  {
      shift->authority(@_);
  }
  
  sub epath
  {
      my $path = shift->SUPER::path(@_);
      $path =~ s/;.*//;
      $path;
  }
  
  sub eparams
  {
      my $self = shift;
      my @p = $self->path_segments;
      return undef unless ref($p[-1]);
      @p = @{$p[-1]};
      shift @p;
      join(";", @p);
  }
  
  sub params { shift->eparams(@_); }
  
  sub path {
      my $self = shift;
      my $old = $self->epath(@_);
      return unless defined wantarray;
      return '/' if !defined($old) || !length($old);
      Carp::croak("Path components contain '/' (you must call epath)")
  	if $old =~ /%2[fF]/ and !@_;
      $old = "/$old" if $old !~ m|^/| && defined $self->netloc;
      return uri_unescape($old);
  }
  
  sub path_components {
      shift->path_segments(@_);
  }
  
  sub query {
      my $self = shift;
      my $old = $self->equery(@_);
      if (defined(wantarray) && defined($old)) {
  	if ($old =~ /%(?:26|2[bB]|3[dD])/) {  # contains escaped '=' '&' or '+'
  	    my $mess;
  	    for ($old) {
  		$mess = "Query contains both '+' and '%2B'"
  		  if /\+/ && /%2[bB]/;
  		$mess = "Form query contains escaped '=' or '&'"
  		  if /=/  && /%(?:3[dD]|26)/;
  	    }
  	    if ($mess) {
  		Carp::croak("$mess (you must call equery)");
  	    }
  	}
  	# Now it should be safe to unescape the string without losing
  	# information
  	return uri_unescape($old);
      }
      undef;
  
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift;
      my $allow_scheme = shift;
      $allow_scheme = $URI::URL::ABS_ALLOW_RELATIVE_SCHEME
  	unless defined $allow_scheme;
      local $URI::ABS_ALLOW_RELATIVE_SCHEME = $allow_scheme;
      local $URI::ABS_REMOTE_LEADING_DOTS = $URI::URL::ABS_REMOTE_LEADING_DOTS;
      $self->SUPER::abs($base);
  }
  
  sub frag { shift->fragment(@_); }
  sub keywords { shift->query_keywords(@_); }
  
  # file:
  sub local_path { shift->file; }
  sub unix_path  { shift->file("unix"); }
  sub dos_path   { shift->file("dos");  }
  sub mac_path   { shift->file("mac");  }
  sub vms_path   { shift->file("vms");  }
  
  # mailto:
  sub address { shift->to(@_); }
  sub encoded822addr { shift->to(@_); }
  sub URI::mailto::authority { shift->to(@_); }  # make 'netloc' method work
  
  # news:
  sub groupart { shift->_group(@_); }
  sub article  { shift->message(@_); }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::URL - Uniform Resource Locators
  
  =head1 SYNOPSIS
  
   $u1 = URI::URL->new($str, $base);
   $u2 = $u1->abs;
  
  =head1 DESCRIPTION
  
  This module is provided for backwards compatibility with modules that
  depend on the interface provided by the C<URI::URL> class that used to
  be distributed with the libwww-perl library.
  
  The following differences exist compared to the C<URI> class interface:
  
  =over 3
  
  =item *
  
  The URI::URL module exports the url() function as an alternate
  constructor interface.
  
  =item *
  
  The constructor takes an optional $base argument.  The C<URI::URL>
  class is a subclass of C<URI::WithBase>.
  
  =item *
  
  The URI::URL->newlocal class method is the same as URI::file->new_abs.
  
  =item *
  
  URI::URL::strict(1)
  
  =item *
  
  $url->print_on method
  
  =item *
  
  $url->crack method
  
  =item *
  
  $url->full_path: same as ($uri->abs_path || "/")
  
  =item *
  
  $url->netloc: same as $uri->authority
  
  =item *
  
  $url->epath, $url->equery: same as $uri->path, $uri->query
  
  =item *
  
  $url->path and $url->query pass unescaped strings.
  
  =item *
  
  $url->path_components: same as $uri->path_segments (if you don't
  consider path segment parameters)
  
  =item *
  
  $url->params and $url->eparams methods
  
  =item *
  
  $url->base method.  See L<URI::WithBase>.
  
  =item *
  
  $url->abs and $url->rel have an optional $base argument.  See
  L<URI::WithBase>.
  
  =item *
  
  $url->frag: same as $uri->fragment
  
  =item *
  
  $url->keywords: same as $uri->query_keywords
  
  =item *
  
  $url->localpath and friends map to $uri->file.
  
  =item *
  
  $url->address and $url->encoded822addr: same as $uri->to for mailto URI
  
  =item *
  
  $url->groupart method for news URI
  
  =item *
  
  $url->article: same as $uri->message
  
  =back
  
  
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::WithBase>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2000 Gisle Aas.
  
  =cut
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;
  
  use strict;
  use warnings;
  
  use URI;
  
  our $VERSION = "2.20";
  
  use overload '""' => "as_string", fallback => 1;
  
  sub as_string;  # help overload find it
  
  sub new
  {
      my($class, $uri, $base) = @_;
      my $ibase = $base;
      if ($base && ref($base) && UNIVERSAL::isa($base, __PACKAGE__)) {
  	$base = $base->abs;
  	$ibase = $base->[0];
      }
      bless [URI->new($uri, $ibase), $base], $class;
  }
  
  sub new_abs
  {
      my $class = shift;
      my $self = $class->new(@_);
      $self->abs;
  }
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      bless [URI->new($str, $scheme), undef], $class;
  }
  
  sub eq
  {
      my($self, $other) = @_;
      $other = $other->[0] if UNIVERSAL::isa($other, __PACKAGE__);
      $self->[0]->eq($other);
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $self = shift;
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      return if $method eq "DESTROY";
      $self->[0]->$method(@_);
  }
  
  sub can {                                  # override UNIVERSAL::can
      my $self = shift;
      $self->SUPER::can(@_) || (
        ref($self)
        ? $self->[0]->can(@_)
        : undef
      )
  }
  
  sub base {
      my $self = shift;
      my $base  = $self->[1];
  
      if (@_) { # set
  	my $new_base = shift;
  	# ensure absoluteness
  	$new_base = $new_base->abs if ref($new_base) && $new_base->isa(__PACKAGE__);
  	$self->[1] = $new_base;
      }
      return unless defined wantarray;
  
      # The base attribute supports 'lazy' conversion from URL strings
      # to URL objects. Strings may be stored but when a string is
      # fetched it will automatically be converted to a URL object.
      # The main benefit is to make it much cheaper to say:
      #   URI::WithBase->new($random_url_string, 'http:')
      if (defined($base) && !ref($base)) {
  	$base = ref($self)->new($base);
  	$self->[1] = $base unless @_;
      }
      $base;
  }
  
  sub clone
  {
      my $self = shift;
      my $base = $self->[1];
      $base = $base->clone if ref($base);
      bless [$self->[0]->clone, $base], ref($self);
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->abs($base, @_), $base], ref($self);
  }
  
  sub rel
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->rel($base, @_), $base], ref($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::WithBase - URIs which remember their base
  
  =head1 SYNOPSIS
  
   $u1 = URI::WithBase->new($str, $base);
   $u2 = $u1->abs;
  
   $base = $u1->base;
   $u1->base( $new_base )
  
  =head1 DESCRIPTION
  
  This module provides the C<URI::WithBase> class.  Objects of this class
  are like C<URI> objects, but can keep their base too.  The base
  represents the context where this URI was found and can be used to
  absolutize or relativize the URI.  All the methods described in L<URI>
  are supported for C<URI::WithBase> objects.
  
  The methods provided in addition to or modified from those of C<URI> are:
  
  =over 4
  
  =item $uri = URI::WithBase->new($str, [$base])
  
  The constructor takes an optional base URI as the second argument.
  If provided, this argument initializes the base attribute.
  
  =item $uri->base( [$new_base] )
  
  Can be used to get or set the value of the base attribute.
  The return value, which is the old value, is a URI object or C<undef>.
  
  =item $uri->abs( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is returned even if $uri is already
  absolute (while plain URI objects simply return themselves in
  that case).
  
  =item $uri->rel( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is always returned.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2002 Gisle Aas.
  
  =cut
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;
  
  use strict;
  use warnings;
  
  use parent qw(URI URI::_query);
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  my $ACHAR = $URI::uric;  $ACHAR =~ s,\\[/?],,g;
  my $PCHAR = $URI::uric;  $PCHAR =~ s,\\[?],,g;
  
  sub _no_scheme_ok { 1 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;
  
      if (@_) {
  	my $auth = shift;
  	$$self = $1;
  	my $rest = $3;
  	if (defined $auth) {
  	    $auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($auth);
  	    $$self .= "//$auth";
  	}
  	_check_path($rest, $$self);
  	$$self .= $rest;
      }
      $2;
  }
  
  sub path
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub path_query
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub _check_path
  {
      my($path, $pre) = @_;
      my $prefix;
      if ($pre =~ m,/,) {  # authority present
  	$prefix = "/" if length($path) && $path !~ m,^[/?\#],;
      }
      else {
  	if ($path =~ m,^//,) {
  	    Carp::carp("Path starting with double slash is confusing")
  		if $^W;
  	}
  	elsif (!length($pre) && $path =~ m,^[^:/?\#]+:,) {
  	    Carp::carp("Path might look like scheme, './' prepended")
  		if $^W;
  	    $prefix = "./";
  	}
      }
      substr($_[0], 0, 0) = $prefix if defined $prefix;
  }
  
  sub path_segments
  {
      my $self = shift;
      my $path = $self->path;
      if (@_) {
  	my @arg = @_;  # make a copy
  	for (@arg) {
  	    if (ref($_)) {
  		my @seg = @$_;
  		$seg[0] =~ s/%/%25/g;
  		for (@seg) { s/;/%3B/g; }
  		$_ = join(";", @seg);
  	    }
  	    else {
  		 s/%/%25/g; s/;/%3B/g;
  	    }
  	    s,/,%2F,g;
  	}
  	$self->path(join("/", @arg));
      }
      return $path unless wantarray;
      map {/;/ ? $self->_split_segment($_)
               : uri_unescape($_) }
          split('/', $path, -1);
  }
  
  
  sub _split_segment
  {
      my $self = shift;
      require URI::_segment;
      URI::_segment->new(@_);
  }
  
  
  sub abs
  {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
  
      if (my $scheme = $self->scheme) {
  	return $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;
  	$base = URI->new($base) unless ref $base;
  	return $self unless $scheme eq $base->scheme;
      }
  
      $base = URI->new($base) unless ref $base;
      my $abs = $self->clone;
      $abs->scheme($base->scheme);
      return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;
      $abs->authority($base->authority);
  
      my $path = $self->path;
      return $abs if $path =~ m,^/,;
  
      if (!length($path)) {
  	my $abs = $base->clone;
  	my $query = $self->query;
  	$abs->query($query) if defined $query;
  	my $fragment = $self->fragment;
  	$abs->fragment($fragment) if defined $fragment;
  	return $abs;
      }
  
      my $p = $base->path;
      $p =~ s,[^/]+$,,;
      $p .= $path;
      my @p = split('/', $p, -1);
      shift(@p) if @p && !length($p[0]);
      my $i = 1;
      while ($i < @p) {
  	#print "$i ", join("/", @p), " ($p[$i])\n";
  	if ($p[$i-1] eq ".") {
  	    splice(@p, $i-1, 1);
  	    $i-- if $i > 1;
  	}
  	elsif ($p[$i] eq ".." && $p[$i-1] ne "..") {
  	    splice(@p, $i-1, 2);
  	    if ($i > 1) {
  		$i--;
  		push(@p, "") if $i == @p;
  	    }
  	}
  	else {
  	    $i++;
  	}
      }
      $p[-1] = "" if @p && $p[-1] eq ".";  # trailing "/."
      if ($URI::ABS_REMOTE_LEADING_DOTS) {
          shift @p while @p && $p[0] =~ /^\.\.?$/;
      }
      $abs->path("/" . join("/", @p));
      $abs;
  }
  
  # The opposite of $url->abs.  Return a URI which is as relative as possible
  sub rel {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
      my $rel = $self->clone;
      $base = URI->new($base) unless ref $base;
  
      #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};
      my $scheme = $rel->scheme;
      my $auth   = $rel->canonical->authority;
      my $path   = $rel->path;
  
      if (!defined($scheme) && !defined($auth)) {
  	# it is already relative
  	return $rel;
      }
  
      #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};
      my $bscheme = $base->scheme;
      my $bauth   = $base->canonical->authority;
      my $bpath   = $base->path;
  
      for ($bscheme, $bauth, $auth) {
  	$_ = '' unless defined
      }
  
      unless ($scheme eq $bscheme && $auth eq $bauth) {
  	# different location, can't make it relative
  	return $rel;
      }
  
      for ($path, $bpath) {  $_ = "/$_" unless m,^/,; }
  
      # Make it relative by eliminating scheme and authority
      $rel->scheme(undef);
      $rel->authority(undef);
  
      # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.
      # First we calculate common initial path components length ($li).
      my $li = 1;
      while (1) {
  	my $i = index($path, '/', $li);
  	last if $i < 0 ||
                  $i != index($bpath, '/', $li) ||
  	        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);
  	$li=$i+1;
      }
      # then we nuke it from both paths
      substr($path, 0,$li) = '';
      substr($bpath,0,$li) = '';
  
      if ($path eq $bpath &&
          defined($rel->fragment) &&
          !defined($rel->query)) {
          $rel->path("");
      }
      else {
          # Add one "../" for each path component left in the base path
          $path = ('../' x $bpath =~ tr|/|/|) . $path;
  	$path = "./" if $path eq "";
          $rel->path($path);
      }
  
      $rel;
  }
  
  1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;
  
  # This module implements the RFCs 3490 (IDNA) and 3491 (Nameprep)
  # based on Python-2.6.4/Lib/encodings/idna.py
  
  use strict;
  use warnings;
  
  use URI::_punycode qw(encode_punycode decode_punycode);
  use Carp qw(croak);
  
  BEGIN {
    *URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS = $] < 5.008_003
      ? sub () { 1 }
      : sub () { 0 }
    ;
  }
  
  my $ASCII = qr/^[\x00-\x7F]*\z/;
  
  sub encode {
      my $idomain = shift;
      my @labels = split(/\./, $idomain, -1);
      my @last_empty;
      push(@last_empty, pop @labels) if @labels > 1 && $labels[-1] eq "";
      for (@labels) {
  	$_ = ToASCII($_);
      }
  
      return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;
      return join(".", @labels, @last_empty);
  }
  
  sub decode {
      my $domain = shift;
      return join(".", map ToUnicode($_), split(/\./, $domain, -1))
  }
  
  sub nameprep { # XXX real implementation missing
      my $label = shift;
      $label = lc($label);
      return $label;
  }
  
  sub check_size {
      my $label = shift;
      croak "Label empty" if $label eq "";
      croak "Label too long" if length($label) > 63;
      return $label;
  }
  
  sub ToASCII {
      my $label = shift;
      return check_size($label) if $label =~ $ASCII;
  
      # Step 2: nameprep
      $label = nameprep($label);
      # Step 3: UseSTD3ASCIIRules is false
      # Step 4: try ASCII again
      return check_size($label) if $label =~ $ASCII;
  
      # Step 5: Check ACE prefix
      if ($label =~ /^xn--/) {
          croak "Label starts with ACE prefix";
      }
  
      # Step 6: Encode with PUNYCODE
      $label = encode_punycode($label);
  
      # Step 7: Prepend ACE prefix
      $label = "xn--$label";
  
      # Step 8: Check size
      return check_size($label);
  }
  
  sub ToUnicode {
      my $label = shift;
      $label = nameprep($label) unless $label =~ $ASCII;
      return $label unless $label =~ /^xn--/;
      my $result = decode_punycode(substr($label, 4));
      my $label2 = ToASCII($result);
      if (lc($label) ne $label2) {
  	croak "IDNA does not round-trip: '\L$label\E' vs '$label2'";
      }
      return $result;
  }
  
  1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::_ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.62";
  
  use URI::Escape qw(uri_unescape);
  
  sub _ldap_elem {
    my $self  = shift;
    my $elem  = shift;
    my $query = $self->query;
    my @bits  = (split(/\?/,defined($query) ? $query : ""),("")x4);
    my $old   = $bits[$elem];
  
    if (@_) {
      my $new = shift;
      $new =~ s/\?/%3F/g;
      $bits[$elem] = $new;
      $query = join("?",@bits);
      $query =~ s/\?+$//;
      $query = undef unless length($query);
      $self->query($query);
    }
  
    $old;
  }
  
  sub dn {
    my $old = shift->path(@_);
    $old =~ s:^/::;
    uri_unescape($old);
  }
  
  sub attributes {
    my $self = shift;
    my $old = _ldap_elem($self,0, @_ ? join(",", map { my $tmp = $_; $tmp =~ s/,/%2C/g; $tmp } @_) : ());
    return $old unless wantarray;
    map { uri_unescape($_) } split(/,/,$old);
  }
  
  sub _scope {
    my $self = shift;
    my $old = _ldap_elem($self,1, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old);
  }
  
  sub scope {
    my $old = &_scope;
    $old = "base" unless length $old;
    $old;
  }
  
  sub _filter {
    my $self = shift;
    my $old = _ldap_elem($self,2, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old); # || "(objectClass=*)";
  }
  
  sub filter {
    my $old = &_filter;
    $old = "(objectClass=*)" unless length $old;
    $old;
  }
  
  sub extensions {
    my $self = shift;
    my @ext;
    while (@_) {
      my $key = shift;
      my $value = shift;
      push(@ext, join("=", map { $_="" unless defined; s/,/%2C/g; $_ } $key, $value));
    }
    @ext = join(",", @ext) if @ext;
    my $old = _ldap_elem($self,3, @ext);
    return $old unless wantarray;
    map { uri_unescape($_) } map { /^([^=]+)=(.*)$/ } split(/,/,$old);
  }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->_nonldap_canonical;
  
      # The stuff below is not as efficient as one might hope...
  
      $other = $other->clone if $other == $self;
  
      $other->dn(_normalize_dn($other->dn));
  
      # Should really know about mixed case "postalAddress", etc...
      $other->attributes(map lc, $other->attributes);
  
      # Lowercase scope, remove default
      my $old_scope = $other->scope;
      my $new_scope = lc($old_scope);
      $new_scope = "" if $new_scope eq "base";
      $other->scope($new_scope) if $new_scope ne $old_scope;
  
      # Remove filter if default
      my $old_filter = $other->filter;
      $other->filter("") if lc($old_filter) eq "(objectclass=*)" ||
  	                  lc($old_filter) eq "objectclass=*";
  
      # Lowercase extensions types and deal with known extension values
      my @ext = $other->extensions;
      for (my $i = 0; $i < @ext; $i += 2) {
  	my $etype = $ext[$i] = lc($ext[$i]);
  	if ($etype =~ /^!?bindname$/) {
  	    $ext[$i+1] = _normalize_dn($ext[$i+1]);
  	}
      }
      $other->extensions(@ext) if @ext;
      
      $other;
  }
  
  sub _normalize_dn  # RFC 2253
  {
      my $dn = shift;
  
      return $dn;
      # The code below will fail if the "+" or "," is embedding in a quoted
      # string or simply escaped...
  
      my @dn = split(/([+,])/, $dn);
      for (@dn) {
  	s/^([a-zA-Z]+=)/lc($1)/e;
      }
      join("", @dn);
  }
  
  1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  # Generic terminal logins.  This is used as a base class for 'telnet',
  # 'tn3270', and 'rlogin' URL schemes.
  
  1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.62";
  
  use Exporter 'import';
  our @EXPORT = qw(encode_punycode decode_punycode);
  
  use integer;
  
  our $DEBUG = 0;
  
  use constant BASE => 36;
  use constant TMIN => 1;
  use constant TMAX => 26;
  use constant SKEW => 38;
  use constant DAMP => 700;
  use constant INITIAL_BIAS => 72;
  use constant INITIAL_N => 128;
  
  my $Delimiter = chr 0x2D;
  my $BasicRE   = qr/[\x00-\x7f]/;
  
  sub _croak { require Carp; Carp::croak(@_); }
  
  sub digit_value {
      my $code = shift;
      return ord($code) - ord("A") if $code =~ /[A-Z]/;
      return ord($code) - ord("a") if $code =~ /[a-z]/;
      return ord($code) - ord("0") + 26 if $code =~ /[0-9]/;
      return;
  }
  
  sub code_point {
      my $digit = shift;
      return $digit + ord('a') if 0 <= $digit && $digit <= 25;
      return $digit + ord('0') - 26 if 26 <= $digit && $digit <= 36;
      die 'NOT COME HERE';
  }
  
  sub adapt {
      my($delta, $numpoints, $firsttime) = @_;
      $delta = $firsttime ? $delta / DAMP : $delta / 2;
      $delta += $delta / $numpoints;
      my $k = 0;
      while ($delta > ((BASE - TMIN) * TMAX) / 2) {
  	$delta /= BASE - TMIN;
  	$k += BASE;
      }
      return $k + (((BASE - TMIN + 1) * $delta) / ($delta + SKEW));
  }
  
  sub decode_punycode {
      my $code = shift;
  
      my $n      = INITIAL_N;
      my $i      = 0;
      my $bias   = INITIAL_BIAS;
      my @output;
  
      if ($code =~ s/(.*)$Delimiter//o) {
  	push @output, map ord, split //, $1;
  	return _croak('non-basic code point') unless $1 =~ /^$BasicRE*$/o;
      }
  
      while ($code) {
  	my $oldi = $i;
  	my $w    = 1;
      LOOP:
  	for (my $k = BASE; 1; $k += BASE) {
  	    my $cp = substr($code, 0, 1, '');
  	    my $digit = digit_value($cp);
  	    defined $digit or return _croak("invalid punycode input");
  	    $i += $digit * $w;
  	    my $t = ($k <= $bias) ? TMIN
  		: ($k >= $bias + TMAX) ? TMAX : $k - $bias;
  	    last LOOP if $digit < $t;
  	    $w *= (BASE - $t);
  	}
  	$bias = adapt($i - $oldi, @output + 1, $oldi == 0);
  	warn "bias becomes $bias" if $DEBUG;
  	$n += $i / (@output + 1);
  	$i = $i % (@output + 1);
  	splice(@output, $i, 0, $n);
  	warn join " ", map sprintf('%04x', $_), @output if $DEBUG;
  	$i++;
      }
      return join '', map chr, @output;
  }
  
  sub encode_punycode {
      my $input = shift;
      my @input = split //, $input;
  
      my $n     = INITIAL_N;
      my $delta = 0;
      my $bias  = INITIAL_BIAS;
  
      my @output;
      my @basic = grep /$BasicRE/, @input;
      my $h = my $b = @basic;
      push @output, @basic;
      push @output, $Delimiter if $b && $h < @input;
      warn "basic codepoints: (@output)" if $DEBUG;
  
      while ($h < @input) {
  	my $m = min(grep { $_ >= $n } map ord, @input);
  	warn sprintf "next code point to insert is %04x", $m if $DEBUG;
  	$delta += ($m - $n) * ($h + 1);
  	$n = $m;
  	for my $i (@input) {
  	    my $c = ord($i);
  	    $delta++ if $c < $n;
  	    if ($c == $n) {
  		my $q = $delta;
  	    LOOP:
  		for (my $k = BASE; 1; $k += BASE) {
  		    my $t = ($k <= $bias) ? TMIN :
  			($k >= $bias + TMAX) ? TMAX : $k - $bias;
  		    last LOOP if $q < $t;
  		    my $cp = code_point($t + (($q - $t) % (BASE - $t)));
  		    push @output, chr($cp);
  		    $q = ($q - $t) / (BASE - $t);
  		}
  		push @output, chr(code_point($q));
  		$bias = adapt($delta, $h + 1, $h == $b);
  		warn "bias becomes $bias" if $DEBUG;
  		$delta = 0;
  		$h++;
  	    }
  	}
  	$delta++;
  	$n++;
      }
      return join '', @output;
  }
  
  sub min {
      my $min = shift;
      for (@_) { $min = $_ if $_ <= $min }
      return $min;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  URI::_punycode - encodes Unicode string in Punycode
  
  =head1 SYNOPSIS
  
    use URI::_punycode;
    $punycode = encode_punycode($unicode);
    $unicode  = decode_punycode($punycode);
  
  =head1 DESCRIPTION
  
  URI::_punycode is a module to encode / decode Unicode strings into
  Punycode, an efficient encoding of Unicode for use with IDNA.
  
  This module requires Perl 5.6.0 or over to handle UTF8 flagged Unicode
  strings.
  
  =head1 FUNCTIONS
  
  This module exports following functions by default.
  
  =over 4
  
  =item encode_punycode
  
    $punycode = encode_punycode($unicode);
  
  takes Unicode string (UTF8-flagged variable) and returns Punycode
  encoding for it.
  
  =item decode_punycode
  
    $unicode = decode_punycode($punycode)
  
  takes Punycode encoding and returns original Unicode string.
  
  =back
  
  These functions throw exceptions on failure. You can catch 'em via
  C<eval>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt> is the author of
  IDNA::Punycode v0.02 which was the basis for this module.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<IDNA::Punycode>, RFC 3492
  
  =cut
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;
  
  use strict;
  use warnings;
  
  use URI ();
  use URI::Escape qw(uri_unescape);
  
  sub query
  {
      my $self = shift;
      $$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;
  
      if (@_) {
  	my $q = shift;
  	$$self = $1;
  	if (defined $q) {
  	    $q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($q);
  	    $$self .= "?$q";
  	}
  	$$self .= $3;
      }
      $2;
  }
  
  # Handle ...?foo=bar&bar=foo type of query
  sub query_form {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
          my $delim;
          my $r = $_[0];
          if (ref($r) eq "ARRAY") {
              $delim = $_[1];
              @_ = @$r;
          }
          elsif (ref($r) eq "HASH") {
              $delim = $_[1];
              @_ = %$r;
          }
          $delim = pop if @_ % 2;
  
          my @query;
          while (my($key,$vals) = splice(@_, 0, 2)) {
              $key = '' unless defined $key;
  	    $key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
  	    $key =~ s/ /+/g;
  	    $vals = [ref($vals) eq "ARRAY" ? @$vals : $vals];
              for my $val (@$vals) {
                  $val = '' unless defined $val;
  		$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
                  $val =~ s/ /+/g;
                  push(@query, "$key=$val");
              }
          }
          if (@query) {
              unless ($delim) {
                  $delim = $1 if $old && $old =~ /([&;])/;
                  $delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&";
              }
              $self->query(join($delim, @query));
          }
          else {
              $self->query(undef);
          }
      }
      return if !defined($old) || !length($old) || !defined(wantarray);
      return unless $old =~ /=/; # not a form
      map { s/\+/ /g; uri_unescape($_) }
           map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/[&;]/, $old);
  }
  
  # Handle ...?dog+bones type of query
  sub query_keywords
  {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @copy = @_;
  	@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq "ARRAY";
  	for (@copy) { s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg; }
  	$self->query(@copy ? join('+', @copy) : undef);
      }
      return if !defined($old) || !defined(wantarray);
      return if $old =~ /=/;  # not keywords, but a form
      map { uri_unescape($_) } split(/\+/, $old, -1);
  }
  
  # Some URI::URL compatibility stuff
  sub equery { goto &query }
  
  1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;
  
  # Represents a generic path_segment so that it can be treated as
  # a string too.
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  use overload '""' => sub { $_[0]->[0] },
               fallback => 1;
  
  sub new
  {
      my $class = shift;
      my @segment = split(';', shift, -1);
      $segment[0] = uri_unescape($segment[0]);
      bless \@segment, $class;
  }
  
  1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  use URI::Escape qw(uri_unescape);
  
  sub _uric_escape {
      my($class, $str) = @_;
      if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	my($scheme, $host, $rest) = ($1, $2, $3);
  	my $ui = $host =~ s/(.*@)// ? $1 : "";
  	my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	if (_host_escape($host)) {
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $class->SUPER::_uric_escape($str);
  }
  
  sub _host_escape {
      return unless $_[0] =~ /[^$URI::uric]/;
      eval {
  	require URI::_idna;
  	$_[0] = URI::_idna::encode($_[0]);
      };
      return 0 if $@;
      return 1;
  }
  
  sub as_iri {
      my $self = shift;
      my $str = $self->SUPER::as_iri;
      if ($str =~ /\bxn--/) {
  	if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	    my($scheme, $host, $rest) = ($1, $2, $3);
  	    my $ui = $host =~ s/(.*@)// ? $1 : "";
  	    my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	    require URI::_idna;
  	    $host = URI::_idna::decode($host);
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $str;
  }
  
  sub userinfo
  {
      my $self = shift;
      my $old = $self->authority;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/.*@//;  # remove old stuff
  	my $ui = shift;
  	if (defined $ui) {
  	    $ui =~ s/@/%40/g;   # protect @
  	    $new = "$ui\@$new";
  	}
  	$self->authority($new);
      }
      return undef if !defined($old) || $old !~ /(.*)@/;
      return $1;
  }
  
  sub host
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $tmp = $old;
  	$tmp = "" unless defined $tmp;
  	my $ui = ($tmp =~ /(.*@)/) ? $1 : "";
  	my $port = ($tmp =~ /(:\d+)$/) ? $1 : "";
  	my $new = shift;
  	$new = "" unless defined $new;
  	if (length $new) {
  	    $new =~ s/[@]/%40/g;   # protect @
  	    if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/) {
  		$new =~ s/(:\d*)\z// || die "Assert";
  		$port = $1;
  	    }
  	    $new = "[$new]" if $new =~ /:/ && $new !~ /^\[/; # IPv6 address
  	    _host_escape($new);
  	}
  	$self->authority("$ui$new$port");
      }
      return undef unless defined $old;
      $old =~ s/.*@//;
      $old =~ s/:\d+$//;          # remove the port
      $old =~ s{^\[(.*)\]$}{$1};  # remove brackets around IPv6 (RFC 3986 3.2.2)
      return uri_unescape($old);
  }
  
  sub ihost
  {
      my $self = shift;
      my $old = $self->host(@_);
      if ($old =~ /(^|\.)xn--/) {
  	require URI::_idna;
  	$old = URI::_idna::decode($old);
      }
      return $old;
  }
  
  sub _port
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $new = $old;
  	$new =~ s/:\d*$//;
  	my $port = shift;
  	$new .= ":$port" if defined $port;
  	$self->authority($new);
      }
      return $1 if defined($old) && $old =~ /:(\d*)$/;
      return;
  }
  
  sub port
  {
      my $self = shift;
      my $port = $self->_port(@_);
      $port = $self->default_port if !defined($port) || $port eq "";
      $port;
  }
  
  sub host_port
  {
      my $self = shift;
      my $old = $self->authority;
      $self->host(shift) if @_;
      return undef unless defined $old;
      $old =~ s/.*@//;        # zap userinfo
      $old =~ s/:$//;         # empty port should be treated the same a no port
      $old .= ":" . $self->port unless $old =~ /:\d+$/;
      $old;
  }
  
  
  sub default_port { undef }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
      my $host = $other->host || "";
      my $port = $other->_port;
      my $uc_host = $host =~ /[A-Z]/;
      my $def_port = defined($port) && ($port eq "" ||
                                        $port == $self->default_port);
      if ($uc_host || $def_port) {
  	$other = $other->clone if $other == $self;
  	$other->host(lc $host) if $uc_host;
  	$other->port(undef)    if $def_port;
      }
      $other;
  }
  
  1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  sub user
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $pass = defined($info) ? $info : "";
  	$pass =~ s/^[^:]*//;
  
  	if (!defined($new) && !length($pass)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $new =~ s/:/%3A/g;
  	    $self->userinfo("$new$pass");
  	}
      }
      return undef unless defined $info;
      $info =~ s/:.*//;
      uri_unescape($info);
  }
  
  sub password
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $user = defined($info) ? $info : "";
  	$user =~ s/:.*//;
  
  	if (!defined($new) && !length($user)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $self->userinfo("$user:$new");
  	}
      }
      return undef unless defined $info;
      return undef unless $info =~ s/^[^:]*://;
      uri_unescape($info);
  }
  
  1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;  # RFC 2397
  
  use strict;
  use warnings;
  
  use parent 'URI';
  
  our $VERSION = '1.62';
  
  use MIME::Base64 qw(encode_base64 decode_base64);
  use URI::Escape  qw(uri_unescape);
  
  sub media_type
  {
      my $self = shift;
      my $opaque = $self->opaque;
      $opaque =~ /^([^,]*),?/ or die;
      my $old = $1;
      my $base64;
      $base64 = $1 if $old =~ s/(;base64)$//i;
      if (@_) {
  	my $new = shift;
  	$new = "" unless defined $new;
  	$new =~ s/%/%25/g;
  	$new =~ s/,/%2C/g;
  	$base64 = "" unless defined $base64;
  	$opaque =~ s/^[^,]*,?/$new$base64,/;
  	$self->opaque($opaque);
      }
      return uri_unescape($old) if $old;  # media_type can't really be "0"
      "text/plain;charset=US-ASCII";      # default type
  }
  
  sub data
  {
      my $self = shift;
      my($enc, $data) = split(",", $self->opaque, 2);
      unless (defined $data) {
  	$data = "";
  	$enc  = "" unless defined $enc;
      }
      my $base64 = ($enc =~ /;base64$/i);
      if (@_) {
  	$enc =~ s/;base64$//i if $base64;
  	my $new = shift;
  	$new = "" unless defined $new;
  	my $uric_count = _uric_count($new);
  	my $urienc_len = $uric_count + (length($new) - $uric_count) * 3;
  	my $base64_len = int((length($new)+2) / 3) * 4;
  	$base64_len += 7;  # because of ";base64" marker
  	if ($base64_len < $urienc_len || $_[0]) {
  	    $enc .= ";base64";
  	    $new = encode_base64($new, "");
  	} else {
  	    $new =~ s/%/%25/g;
  	}
  	$self->opaque("$enc,$new");
      }
      return unless defined wantarray;
      $data = uri_unescape($data);
      return $base64 ? decode_base64($data) : $data;
  }
  
  # I could not find a better way to interpolate the tr/// chars from
  # a variable.
  my $ENC = $URI::uric;
  $ENC =~ s/%//;
  
  eval <<EOT; die $@ if $@;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::data - URI that contains immediate data
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u = URI->new("data:");
   $u->media_type("image/gif");
   $u->data(scalar(`cat camel.gif`));
   print "$u\n";
   open(XV, "|xv -") and print XV $u->data;
  
  =head1 DESCRIPTION
  
  The C<URI::data> class supports C<URI> objects belonging to the I<data>
  URI scheme.  The I<data> URI scheme is specified in RFC 2397.  It
  allows inclusion of small data items as "immediate" data, as if it had
  been included externally.  Examples:
  
    data:,Perl%20is%20good
  
    data:image/gif;base64,R0lGODdhIAAgAIAAAAAAAPj8+CwAAAAAI
      AAgAAAClYyPqcu9AJyCjtIKc5w5xP14xgeO2tlY3nWcajmZZdeJcG
      Kxrmimms1KMTa1Wg8UROx4MNUq1HrycMjHT9b6xKxaFLM6VRKzI+p
      KS9XtXpcbdun6uWVxJXA8pNPkdkkxhxc21LZHFOgD2KMoQXa2KMWI
      JtnE2KizVUkYJVZZ1nczBxXlFopZBtoJ2diXGdNUymmJdFMAADs=
  
  
  
  C<URI> objects belonging to the data scheme support the common methods
  (described in L<URI>) and the following two scheme-specific methods:
  
  =over 4
  
  =item $uri->media_type( [$new_media_type] )
  
  Can be used to get or set the media type specified in the
  URI.  If no media type is specified, then the default
  C<"text/plain;charset=US-ASCII"> is returned.
  
  =item $uri->data( [$new_data] )
  
  Can be used to get or set the data contained in the URI.
  The data is passed unescaped (in binary form).  The decision about
  whether to base64 encode the data in the URI is taken automatically,
  based on the encoding that produces the shorter URI string.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  our $VERSION = "4.21";
  
  use URI::Escape qw(uri_unescape);
  
  our $DEFAULT_AUTHORITY = "";
  
  # Map from $^O values to implementation classes.  The Unix
  # class is the default.
  our %OS_CLASS = (
       os2     => "OS2",
       mac     => "Mac",
       MacOS   => "Mac",
       MSWin32 => "Win32",
       win32   => "Win32",
       msdos   => "FAT",
       dos     => "FAT",
       qnx     => "QNX",
  );
  
  sub os_class
  {
      my($OS) = shift || $^O;
  
      my $class = "URI::file::" . ($OS_CLASS{$OS} || "Unix");
      no strict 'refs';
      unless (%{"$class\::"}) {
  	eval "require $class";
  	die $@ if $@;
      }
      $class;
  }
  
  sub host { uri_unescape(shift->authority(@_)) }
  
  sub new
  {
      my($class, $path, $os) = @_;
      os_class($os)->new($path);
  }
  
  sub new_abs
  {
      my $class = shift;
      my $file = $class->new(@_);
      return $file->abs($class->cwd) unless $$file =~ /^file:/;
      $file;
  }
  
  sub cwd
  {
      my $class = shift;
      require Cwd;
      my $cwd = Cwd::cwd();
      $cwd = VMS::Filespec::unixpath($cwd) if $^O eq 'VMS';
      $cwd = $class->new($cwd);
      $cwd .= "/" unless substr($cwd, -1, 1) eq "/";
      $cwd;
  }
  
  sub canonical {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $scheme = $other->scheme;
      my $auth = $other->authority;
      return $other if !defined($scheme) && !defined($auth);  # relative
  
      if (!defined($auth) ||
  	$auth eq "" ||
  	lc($auth) eq "localhost" ||
  	(defined($DEFAULT_AUTHORITY) && lc($auth) eq lc($DEFAULT_AUTHORITY))
         )
      {
  	# avoid cloning if $auth already match
  	if ((defined($auth) || defined($DEFAULT_AUTHORITY)) &&
  	    (!defined($auth) || !defined($DEFAULT_AUTHORITY) || $auth ne $DEFAULT_AUTHORITY)
  	   )
  	{
  	    $other = $other->clone if $self == $other;
  	    $other->authority($DEFAULT_AUTHORITY);
          }
      }
  
      $other;
  }
  
  sub file
  {
      my($self, $os) = @_;
      os_class($os)->file($self);
  }
  
  sub dir
  {
      my($self, $os) = @_;
      os_class($os)->dir($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::file - URI that maps to local file names
  
  =head1 SYNOPSIS
  
   use URI::file;
   
   $u1 = URI->new("file:/foo/bar");
   $u2 = URI->new("foo/bar", "file");
   
   $u3 = URI::file->new($path);
   $u4 = URI::file->new("c:\\windows\\", "win32");
   
   $u1->file;
   $u1->file("mac");
  
  =head1 DESCRIPTION
  
  The C<URI::file> class supports C<URI> objects belonging to the I<file>
  URI scheme.  This scheme allows us to map the conventional file names
  found on various computer systems to the URI name space.  An old
  specification of the I<file> URI scheme is found in RFC 1738.  Some
  older background information is also in RFC 1630. There are no newer
  specifications as far as I know.
  
  If you simply want to construct I<file> URI objects from URI strings,
  use the normal C<URI> constructor.  If you want to construct I<file>
  URI objects from the actual file names used by various systems, then
  use one of the following C<URI::file> constructors:
  
  =over 4
  
  =item $u = URI::file->new( $filename, [$os] )
  
  Maps a file name to the I<file:> URI name space, creates a URI object
  and returns it.  The $filename is interpreted as belonging to the
  indicated operating system ($os), which defaults to the value of the
  $^O variable.  The $filename can be either absolute or relative, and
  the corresponding type of URI object for $os is returned.
  
  =item $u = URI::file->new_abs( $filename, [$os] )
  
  Same as URI::file->new, but makes sure that the URI returned
  represents an absolute file name.  If the $filename argument is
  relative, then the name is resolved relative to the current directory,
  i.e. this constructor is really the same as:
  
    URI::file->new($filename)->abs(URI::file->cwd);
  
  =item $u = URI::file->cwd
  
  Returns a I<file> URI that represents the current working directory.
  See L<Cwd>.
  
  =back
  
  The following methods are supported for I<file> URI (in addition to
  the common and generic methods described in L<URI>):
  
  =over 4
  
  =item $u->file( [$os] )
  
  Returns a file name.  It maps from the URI name space
  to the file name space of the indicated operating system.
  
  It might return C<undef> if the name can not be represented in the
  indicated file system.
  
  =item $u->dir( [$os] )
  
  Some systems use a different form for names of directories than for plain
  files.  Use this method if you know you want to use the name for
  a directory.
  
  =back
  
  The C<URI::file> module can be used to map generic file names to names
  suitable for the current system.  As such, it can work as a nice
  replacement for the C<File::Spec> module.  For instance, the following
  code translates the UNIX-style file name F<Foo/Bar.pm> to a name
  suitable for the local system:
  
    $file = URI::file->new("Foo/Bar.pm", "unix")->file;
    die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
    open(FILE, $file) || die "Can't open '$file': $!";
    # do something with FILE
  
  =head1 MAPPING NOTES
  
  Most computer systems today have hierarchically organized file systems.
  Mapping the names used in these systems to the generic URI syntax
  allows us to work with relative file URIs that behave as they should
  when resolved using the generic algorithm for URIs (specified in RFC
  2396).  Mapping a file name to the generic URI syntax involves mapping
  the path separator character to "/" and encoding any reserved
  characters that appear in the path segments of the file name.  If
  path segments consisting of the strings "." or ".." have a
  different meaning than what is specified for generic URIs, then these
  must be encoded as well.
  
  If the file system has device, volume or drive specifications as
  the root of the name space, then it makes sense to map them to the
  authority field of the generic URI syntax.  This makes sure that
  relative URIs can not be resolved "above" them, i.e. generally how
  relative file names work in those systems.
  
  Another common use of the authority field is to encode the host on which
  this file name is valid.  The host name "localhost" is special and
  generally has the same meaning as a missing or empty authority
  field.  This use is in conflict with using it as a device
  specification, but can often be resolved for device specifications
  having characters not legal in plain host names.
  
  File name to URI mapping in normally not one-to-one.  There are
  usually many URIs that map to any given file name.  For instance, an
  authority of "localhost" maps the same as a URI with a missing or empty
  authority.
  
  Example 1: The Mac classic (Mac OS 9 and earlier) used ":" as path separator,
  but not in the same way as a generic URI. ":foo" was a relative name.  "foo:bar"
  was an absolute name.  Also, path segments could contain the "/" character as well
  as the literal "." or "..".  So the mapping looks like this:
  
    Mac classic           URI
    ----------            -------------------
    :foo:bar     <==>     foo/bar
    :            <==>     ./
    ::foo:bar    <==>     ../foo/bar
    :::          <==>     ../../
    foo:bar      <==>     file:/foo/bar
    foo:bar:     <==>     file:/foo/bar/
    ..           <==>     %2E%2E
    <undef>      <==      /
    foo/         <==      file:/foo%2F
    ./foo.txt    <==      file:/.%2Ffoo.txt
  
  Note that if you want a relative URL, you *must* begin the path with a :.  Any
  path that begins with [^:] is treated as absolute.
  
  Example 2: The UNIX file system is easy to map, as it uses the same path
  separator as URIs, has a single root, and segments of "." and ".."
  have the same meaning.  URIs that have the character "\0" or "/" as
  part of any path segment can not be turned into valid UNIX file names.
  
    UNIX                  URI
    ----------            ------------------
    foo/bar      <==>     foo/bar
    /foo/bar     <==>     file:/foo/bar
    /foo/bar     <==      file://localhost/foo/bar
    file:         ==>     ./file:
    <undef>      <==      file:/fo%00/bar
    /            <==>     file:/
  
  =cut
  
  
  RFC 1630
  
     [...]
  
     There is clearly a danger of confusion that a link made to a local
     file should be followed by someone on a different system, with
     unexpected and possibly harmful results.  Therefore, the convention
     is that even a "file" URL is provided with a host part.  This allows
     a client on another system to know that it cannot access the file
     system, or perhaps to use some other local mechanism to access the
     file.
  
     The special value "localhost" is used in the host field to indicate
     that the filename should really be used on whatever host one is.
     This for example allows links to be made to files which are
     distributed on many machines, or to "your unix local password file"
     subject of course to consistency across the users of the data.
  
     A void host field is equivalent to "localhost".
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over
  
  =item %URI::file::OS_CLASS
  
  This hash maps OS identifiers to implementation classes.  You might
  want to add or modify this if you want to plug in your own file
  handler class.  Normally the keys should match the $^O values in use.
  
  If there is no mapping then the "Unix" implementation is used.
  
  =item $URI::file::DEFAULT_AUTHORITY
  
  This determine what "authority" string to include in absolute file
  URIs.  It defaults to "".  If you prefer verbose URIs you might set it
  to be "localhost".
  
  Setting this value to C<undef> force behaviour compatible to URI v1.31
  and earlier.  In this mode host names in UNC paths and drive letters
  are mapped to the authority component on Windows, while we produce
  authority-less URIs on Unix.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>, L<File::Spec>, L<perlport>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998,2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;
  
  use strict;
  use warnings;
  
  use URI::Escape qw();
  
  sub new
  {
      my $class = shift;
      my $path  = shift;
      $path = "" unless defined $path;
  
      my($auth, $escaped_auth, $escaped_path);
  
      ($auth, $escaped_auth) = $class->_file_extract_authority($path);
      ($path, $escaped_path) = $class->_file_extract_path($path);
  
      if (defined $auth) {
  	$auth =~ s,%,%25,g unless $escaped_auth;
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$auth = "//$auth";
  	if (defined $path) {
  	    $path = "/$path" unless substr($path, 0, 1) eq "/";
  	} else {
  	    $path = "";
  	}
      } else {
  	return undef unless defined $path;
  	$auth = "";
      }
  
      $path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless $escaped_path;
      $path =~ s/\#/%23/g;
  
      my $uri = $auth . $path;
      $uri = "file:$uri" if substr($uri, 0, 1) eq "/";
  
      URI->new($uri, "file");
  }
  
  sub _file_extract_authority
  {
      my($class, $path) = @_;
      return undef unless $class->_file_is_absolute($path);
      return $URI::file::DEFAULT_AUTHORITY;
  }
  
  sub _file_extract_path
  {
      return undef;
  }
  
  sub _file_is_absolute
  {
      return 0;
  }
  
  sub _file_is_localhost
  {
      shift; # class
      my $host = lc(shift);
      return 1 if $host eq "localhost";
      eval {
  	require Net::Domain;
  	lc(Net::Domain::hostfqdn()) eq $host ||
  	lc(Net::Domain::hostname()) eq $host;
      };
  }
  
  sub file
  {
      undef;
  }
  
  sub dir
  {
      my $self = shift;
      $self->file(@_);
  }
  
  1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  sub fix_path
  {
      shift; # class
      for (@_) {
  	# turn it into 8.3 names
  	my @p = map uc, split(/\./, $_, -1);
  	return if @p > 2;     # more than 1 dot is not allowed
  	@p = ("") unless @p;  # split bug? (returns nothing when splitting "")
  	$_ = substr($p[0], 0, 8);
          if (@p > 1) {
  	    my $ext = substr($p[1], 0, 3);
  	    $_ .= ".$ext" if length $ext;
  	}
      }
      1;  # ok
  }
  
  1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  
  
  sub _file_extract_path
  {
      my $class = shift;
      my $path = shift;
  
      my @pre;
      if ($path =~ s/^(:+)//) {
  	if (length($1) == 1) {
  	    @pre = (".") unless length($path);
  	} else {
  	    @pre = ("..") x (length($1) - 1);
  	}
      } else { #absolute
  	$pre[0] = "";
      }
  
      my $isdir = ($path =~ s/:$//);
      $path =~ s,([%/;]), URI::Escape::escape_char($1),eg;
  
      my @path = split(/:/, $path, -1);
      for (@path) {
  	if ($_ eq "." || $_ eq "..") {
  	    $_ = "%2E" x length($_);
  	}
  	$_ = ".." unless length($_);
      }
      push (@path,"") if $isdir;
      (join("/", @pre, @path), 1);
  }
  
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined $auth) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    my $u_auth = uri_unescape($auth);
  	    if (!$class->_file_is_localhost($u_auth)) {
  		# some other host (use it as volume name)
  		@path = ("", $auth);
  		# XXX or just return to make it illegal;
  	    }
  	}
      }
      my @ps = split("/", $uri->path, -1);
      shift @ps if @path;
      push(@path, @ps);
  
      my $pre = "";
      if (!@path) {
  	return;  # empty path; XXX return ":" instead?
      } elsif ($path[0] eq "") {
  	# absolute
  	shift(@path);
  	if (@path == 1) {
  	    return if $path[0] eq "";  # not root directory
  	    push(@path, "");           # volume only, effectively append ":"
  	}
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      } else {
  	$pre = ":";
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      }
      return unless $pre || @path;
      for (@path) {
  	s/;.*//;  # get rid of parameters
  	#return unless length; # XXX
  	$_ = uri_unescape($_);
  	return if /\0/;
  	return if /:/;  # Should we?
      }
      $pre . join(":", @path);
  }
  
  sub dir
  {
      my $class = shift;
      my $path = $class->file(@_);
      return unless defined $path;
      $path .= ":" unless $path =~ /:$/;
      $path;
  }
  
  1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  # The Win32 version translates k:/foo to file://k:/foo  (?!)
  # We add an empty host
  
  sub _file_extract_authority
  {
      my $class = shift;
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ m#^[a-zA-Z]{1,2}:#) {	      # allow for ab: drives
  	return "";
      }
      return;
  }
  
  sub file {
    my $p = &URI::file::Win32::file;
    return unless defined $p;
    $p =~ s,\\,/,g;
    $p;
  }
  
  1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Unix';
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      # tidy path
      $path =~ s,(.)//+,$1/,g; # ^// is correct
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
      $path;
  }
  
  1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
  
      # tidy path
      $path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^/,;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined($auth)) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    $auth = uri_unescape($auth);
  	    unless ($class->_file_is_localhost($auth)) {
  		push(@path, "", "", $auth);
  	    }
  	}
      }
  
      my @ps = $uri->path_segments;
      shift @ps if @path;
      push(@path, @ps);
  
      for (@path) {
  	# Unix file/directory names are not allowed to contain '\0' or '/'
  	return undef if /\0/;
  	return undef if /\//;  # should we really?
      }
  
      return join("/", @path);
  }
  
  1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  sub _file_extract_authority
  {
      my $class = shift;
  
      return $class->SUPER::_file_extract_authority($_[0])
  	if defined $URI::file::DEFAULT_AUTHORITY;
  
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ s,^([a-zA-Z]:),,) {
  	my $auth = $1;
  	$auth .= "relative" if $_[0] !~ m,^[\\/],;
  	return $auth;
      }
      return undef;
  }
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      $path =~ s,\\,/,g;
      #$path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
  
      if (defined $URI::file::DEFAULT_AUTHORITY) {
  	$path =~ s,^([a-zA-Z]:),/$1,;
      }
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my $auth = $uri->authority;
      my $rel; # is filename relative to drive specified in authority
      if (defined $auth) {
          $auth = uri_unescape($auth);
  	if ($auth =~ /^([a-zA-Z])[:|](relative)?/) {
  	    $auth = uc($1) . ":";
  	    $rel++ if $2;
  	} elsif (lc($auth) eq "localhost") {
  	    $auth = "";
  	} elsif (length $auth) {
  	    $auth = "\\\\" . $auth;  # UNC
  	}
      } else {
  	$auth = "";
      }
  
      my @path = $uri->path_segments;
      for (@path) {
  	return undef if /\0/;
  	return undef if /\//;
  	#return undef if /\\/;        # URLs with "\" is not uncommon
      }
      return undef unless $class->fix_path(@path);
  
      my $path = join("\\", @path);
      $path =~ s/^\\// if $rel;
      $path = $auth . $path;
      $path =~ s,^\\([a-zA-Z])[:|],\u$1:,;
  
      return $path;
  }
  
  sub fix_path { 1; }
  
  1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 21 }
  
  sub path { shift->path_query(@_) }  # XXX
  
  sub _user     { shift->SUPER::user(@_);     }
  sub _password { shift->SUPER::password(@_); }
  
  sub user
  {
      my $self = shift;
      my $user = $self->_user(@_);
      $user = "anonymous" unless defined $user;
      $user;
  }
  
  sub password
  {
      my $self = shift;
      my $pass = $self->_password(@_);
      unless (defined $pass) {
  	my $user = $self->user;
  	if ($user eq 'anonymous' || $user eq 'ftp') {
  	    # anonymous ftp login password
              # If there is no ftp anonymous password specified
              # then we'll just use 'anonymous@'
              # We don't try to send the read e-mail address because:
              # - We want to remain anonymous
              # - We want to stop SPAM
              # - We don't want to let ftp sites to discriminate by the user,
              #   host, country or ftp client being used.
  	    $pass = 'anonymous@';
  	}
      }
      $pass;
  }
  
  1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;  # <draft-murali-url-gopher>, Dec 4, 1996
  
  use strict;
  use warnings;
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  #  A Gopher URL follows the common internet scheme syntax as defined in 
  #  section 4.3 of [RFC-URL-SYNTAX]:
  #
  #        gopher://<host>[:<port>]/<gopher-path>
  #
  #  where
  #
  #        <gopher-path> :=  <gopher-type><selector> | 
  #                          <gopher-type><selector>%09<search> |
  #                          <gopher-type><selector>%09<search>%09<gopher+_string>
  #
  #        <gopher-type> := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
  #                         '8' | '9' | '+' | 'I' | 'g' | 'T'
  #
  #        <selector>    := *pchar     Refer to RFC 1808 [4]
  #        <search>      := *pchar
  #        <gopher+_string> := *uchar  Refer to RFC 1738 [3]
  #        
  #  If the optional port is omitted, the port defaults to 70. 
  
  sub default_port { 70 }
  
  sub _gopher_type
  {
      my $self = shift;
      my $path = $self->path_query;
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s/^(.)//s;
      if (@_) {
  	my $new_type = shift;
  	if (defined($new_type)) {
  	    Carp::croak("Bad gopher type '$new_type'")
                 unless length($new_type) == 1;
  	    substr($path, 0, 0) = $new_type;
  	    $self->path_query($path);
  	} else {
  	    Carp::croak("Can't delete gopher type when selector is present")
  		if length($path);
  	    $self->path_query(undef);
  	}
      }
      return $gtype;
  }
  
  sub gopher_type
  {
      my $self = shift;
      my $gtype = $self->_gopher_type(@_);
      $gtype = "1" unless defined $gtype;
      $gtype;
  }
  
  sub gtype { goto &gopher_type }  # URI::URL compatibility
  
  sub selector { shift->_gfield(0, @_) }
  sub search   { shift->_gfield(1, @_) }
  sub string   { shift->_gfield(2, @_) }
  
  sub _gfield
  {
      my $self = shift;
      my $fno  = shift;
      my $path = $self->path_query;
  
      # not according to spec., but many popular browsers accept
      # gopher URLs with a '?' before the search string.
      $path =~ s/\?/\t/;
      $path = uri_unescape($path);
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s,^(.),,s;
      my @path = split(/\t/, $path, 3);
      if (@_) {
  	# modify
  	my $new = shift;
  	$path[$fno] = $new;
  	pop(@path) while @path && !defined($path[-1]);
  	for (@path) { $_="" unless defined }
  	$path = $gtype;
  	$path = "1" unless defined $path;
  	$path .= join("\t", @path);
  	$self->path_query($path);
      }
      $path[$fno];
  }
  
  1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;
  
  use strict;
  use warnings;
  
  use parent 'URI::_server';
  
  sub default_port { 80 }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $slash_path = defined($other->authority) &&
          !length($other->path) && !defined($other->query);
  
      if ($slash_path) {
  	$other = $other->clone if $other == $self;
  	$other->path("/");
      }
      $other;
  }
  
  1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;
  
  use strict;
  use warnings;
  
  use parent 'URI::http';
  
  sub default_port { 443 }
  
  sub secure { 1 }
  
  1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.62";
  
  use parent qw(URI::_ldap URI::_server);
  
  sub default_port { 389 }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_server::canonical(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::ldap - LDAP Uniform Resource Locators
  
  =head1 SYNOPSIS
  
    use URI;
  
    $uri = URI->new("ldap:$uri_string");
    $dn     = $uri->dn;
    $filter = $uri->filter;
    @attr   = $uri->attributes;
    $scope  = $uri->scope;
    %extn   = $uri->extensions;
    
    $uri = URI->new("ldap:");  # start empty
    $uri->host("ldap.itd.umich.edu");
    $uri->dn("o=University of Michigan,c=US");
    $uri->attributes(qw(postalAddress));
    $uri->scope('sub');
    $uri->filter('(cn=Babs Jensen)');
    print $uri->as_string,"\n";
  
  =head1 DESCRIPTION
  
  C<URI::ldap> provides an interface to parse an LDAP URI into its
  constituent parts and also to build a URI as described in
  RFC 2255.
  
  =head1 METHODS
  
  C<URI::ldap> supports all the generic and server methods defined by
  L<URI>, plus the following.
  
  Each of the following methods can be used to set or get the value in
  the URI. The values are passed in unescaped form.  None of these
  return undefined values, but elements without a default can be empty.
  If arguments are given, then a new value is set for the given part
  of the URI.
  
  =over 4
  
  =item $uri->dn( [$new_dn] )
  
  Sets or gets the I<Distinguished Name> part of the URI.  The DN
  identifies the base object of the LDAP search.
  
  =item $uri->attributes( [@new_attrs] )
  
  Sets or gets the list of attribute names which are
  returned by the search.
  
  =item $uri->scope( [$new_scope] )
  
  Sets or gets the scope to be used by the search. The value can be one of
  C<"base">, C<"one"> or C<"sub">. If none is given in the URI then the
  return value defaults to C<"base">.
  
  =item $uri->_scope( [$new_scope] )
  
  Same as scope(), but does not default to anything.
  
  =item $uri->filter( [$new_filter] )
  
  Sets or gets the filter to be used by the search. If none is given in
  the URI then the return value defaults to C<"(objectClass=*)">.
  
  =item $uri->_filter( [$new_filter] )
  
  Same as filter(), but does not default to anything.
  
  =item $uri->extensions( [$etype => $evalue,...] )
  
  Sets or gets the extensions used for the search. The list passed should
  be in the form etype1 => evalue1, etype2 => evalue2,... This is also
  the form of list that is returned.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://tools.ietf.org/html/rfc2255>
  
  =head1 AUTHOR
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  Slightly modified by Gisle Aas to fit into the URI distribution.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1998 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_ldap URI::_generic);
  
  require URI::Escape;
  
  sub un_path {
      my $self = shift;
      my $old = URI::Escape::uri_unescape($self->authority);
      if (@_) {
  	my $p = shift;
  	$p =~ s/:/%3A/g;
  	$p =~ s/\@/%40/g;
  	$self->authority($p);
      }
      return $old;
  }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_generic::canonical(@_);
  }
  
  1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;
  
  use strict;
  use warnings;
  
  use parent 'URI::ldap';
  
  sub default_port { 636 }
  
  sub secure { 1 }
  
  1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;  # RFC 2368
  
  use strict;
  use warnings;
  
  use parent qw(URI URI::_query);
  
  sub to
  {
      my $self = shift;
      my @old = $self->headers;
      if (@_) {
  	my @new = @old;
  	# get rid of any other to: fields
  	for (my $i = 0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		splice(@new, $i, 2);
  		redo;
  	    }
  	}
  
  	my $to = shift;
  	$to = "" unless defined $to;
  	unshift(@new, "to" => $to);
  	$self->headers(@new);
      }
      return unless defined wantarray;
  
      my @to;
      while (@old) {
  	my $h = shift @old;
  	my $v = shift @old;
  	push(@to, $v) if lc($h) eq "to";
      }
      join(",", @to);
  }
  
  
  sub headers
  {
      my $self = shift;
  
      # The trick is to just treat everything as the query string...
      my $opaque = "to=" . $self->opaque;
      $opaque =~ s/\?/&/;
  
      if (@_) {
  	my @new = @_;
  
  	# strip out any "to" fields
  	my @to;
  	for (my $i=0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		push(@to, (splice(@new, $i, 2))[1]);  # remove header
  		redo;
  	    }
  	}
  
  	my $new = join(",",@to);
  	$new =~ s/%/%25/g;
  	$new =~ s/\?/%3F/g;
  	$self->opaque($new);
  	$self->query_form(@new) if @new;
      }
      return unless defined wantarray;
  
      # I am lazy today...
      URI->new("mailto:?$opaque")->query_form;
  }
  
  1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;
  
  use strict;
  use warnings;
  
  use parent 'URI::http';
  
  sub default_port { 1755 }
  
  1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  sub default_port { 119 }
  
  #   newsURL      =  scheme ":" [ news-server ] [ refbygroup | message ]
  #   scheme       =  "news" | "snews" | "nntp"
  #   news-server  =  "//" server "/"
  #   refbygroup   = group [ "/" messageno [ "-" messageno ] ]
  #   message      = local-part "@" domain
  
  sub _group
  {
      my $self = shift;
      my $old = $self->path;
      if (@_) {
  	my($group,$from,$to) = @_;
  	if ($group =~ /\@/) {
              $group =~ s/^<(.*)>$/$1/;  # "<" and ">" should not be part of it
  	}
  	$group =~ s,%,%25,g;
  	$group =~ s,/,%2F,g;
  	my $path = $group;
  	if (defined $from) {
  	    $path .= "/$from";
  	    $path .= "-$to" if defined $to;
  	}
  	$self->path($path);
      }
  
      $old =~ s,^/,,;
      if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray) {
  	my $extra = $1;
  	return (uri_unescape($old), split(/-/, $extra));
      }
      uri_unescape($old);
  }
  
  
  sub group
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Group name can't contain '\@'") if $_[0] =~ /\@/;
      }
      my @old = $self->_group(@_);
      return if $old[0] =~ /\@/;
      wantarray ? @old : $old[0];
  }
  
  sub message
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Message must contain '\@'") unless $_[0] =~ /\@/;
      }
      my $old = $self->_group(@_);
      return undef unless $old =~ /\@/;
      return $old;
  }
  
  1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  use parent 'URI::news';
  
  1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;   # RFC 2384
  
  use strict;
  use warnings;
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  sub default_port { 110 }
  
  #pop://<user>;auth=<auth>@<host>:<port>
  
  sub user
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new_info = $old;
  	$new_info = "" unless defined $new_info;
  	$new_info =~ s/^[^;]*//;
  
  	my $new = shift;
  	if (!defined($new) && !length($new_info)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined $new;
  	    $new =~ s/%/%25/g;
  	    $new =~ s/;/%3B/g;
  	    $self->userinfo("$new$new_info");
  	}
      }
  
      return undef unless defined $old;
      $old =~ s/;.*//;
      return uri_unescape($old);
  }
  
  sub auth
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/(^[^;]*)//;
  	my $user = $1;
  	$new =~ s/;auth=[^;]*//i;
  
  	
  	my $auth = shift;
  	if (defined $auth) {
  	    $auth =~ s/%/%25/g;
  	    $auth =~ s/;/%3B/g;
  	    $new = ";AUTH=$auth$new";
  	}
  	$self->userinfo("$user$new");
  	
      }
  
      return undef unless defined $old;
      $old =~ s/^[^;]*//;
      return uri_unescape($1) if $old =~ /;auth=(.*)/i;
      return;
  }
  
  1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;
  
  use strict;
  use warnings;
  
  use parent 'URI::_login';
  
  sub default_port { 513 }
  
  1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;  # http://rsync.samba.org/
  
  # rsync://[USER@]HOST[:PORT]/SRC
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 873 }
  
  1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;
  
  use strict;
  use warnings;
  
  use parent 'URI::http';
  
  sub default_port { 554 }
  
  1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;
  
  use strict;
  use warnings;
  
  use parent 'URI::rtsp';
  
  sub default_port { 554 }
  
  1;
URI_RTSPU

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  #
  # Written by Ryan Kereliuk <ryker@ryker.org>.  This file may be
  # distributed under the same terms as Perl itself.
  #
  # The RFC 3261 sip URI is <scheme>:<authority>;<params>?<query>.
  #
  
  package URI::sip;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.62";
  
  sub default_port { 5060 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;
      my $old = $2;
  
      if (@_) {
          my $auth = shift;
          $$self = defined($1) ? $1 : "";
          my $rest = $3;
          if (defined $auth) {
              $auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
              $$self .= "$auth";
          }
          $$self .= $rest;
      }
      $old;
  }
  
  sub params_form
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my @args = @_; 
          $$self = $1 . $2;
          my $rest = $4;
  	my @new;
  	for (my $i=0; $i < @args; $i += 2) {
  	    push(@new, "$args[$i]=$args[$i+1]");
  	}
  	$paramstr = join(";", @new);
  	$$self .= ";" . $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return split(/[;=]/, $paramstr);
  }
  
  sub params
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my $new = shift; 
          $$self = $1 . $2;
          my $rest = $4;
  	$$self .= $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return $paramstr;
  }
  
  # Inherited methods that make no sense for a SIP URI.
  sub path {}
  sub path_query {}
  sub path_segments {}
  sub abs { shift }
  sub rel { shift }
  sub query_keywords {}
  
  1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;
  
  use strict;
  use warnings;
  
  use parent 'URI::sip';
  
  sub default_port { 5061 }
  
  sub secure { 1 }
  
  1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  use parent 'URI::news';
  
  sub default_port { 563 }
  
  sub secure { 1 }
  
  1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;
  
  use strict;
  use warnings;
  
  use parent 'URI::_login';
  
  # ssh://[USER@]HOST[:PORT]/SRC
  
  sub default_port { 22 }
  
  sub secure { 1 }
  
  1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;
  
  use strict;
  use warnings;
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;
  
  use strict;
  use warnings;
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;  # RFC 2141
  
  use strict;
  use warnings;
  
  use parent 'URI';
  
  use Carp qw(carp);
  
  my %implementor;
  
  sub _init {
      my $class = shift;
      my $self = $class->SUPER::_init(@_);
      my $nid = $self->nid;
  
      my $impclass = $implementor{$nid};
      return $impclass->_urn_init($self, $nid) if $impclass;
  
      $impclass = "URI::urn";
      if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/) {
  	my $id = $nid;
  	# make it a legal perl identifier
  	$id =~ s/-/_/g;
  	$id = "_$id" if $id =~ /^\d/;
  
  	$impclass = "URI::urn::$id";
  	no strict 'refs';
  	unless (@{"${impclass}::ISA"}) {
  	    # Try to load it
  	    eval "require $impclass";
  	    die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
  	    $impclass = "URI::urn" unless @{"${impclass}::ISA"};
  	}
      }
      else {
  	carp("Illegal namespace identifier '$nid' for URN '$self'") if $^W;
      }
      $implementor{$nid} = $impclass;
  
      return $impclass->_urn_init($self, $nid);
  }
  
  sub _urn_init {
      my($class, $self, $nid) = @_;
      bless $self, $class;
  }
  
  sub _nid {
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	$v =~ s/[^:]*/$new/;
  	$self->opaque($v);
  	# XXX possible rebless
      }
      $opaque =~ s/:.*//s;
      return $opaque;
  }
  
  sub nid {  # namespace identifier
      my $self = shift;
      my $nid = $self->_nid(@_);
      $nid = lc($nid) if defined($nid);
      return $nid;
  }
  
  sub nss {  # namespace specific string
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	if (defined $new) {
  	    $v =~ s/(:|\z).*/:$new/;
  	}
  	else {
  	    $v =~ s/:.*//s;
  	}
  	$self->opaque($v);
      }
      return undef unless $opaque =~ s/^[^:]*://;
      return $opaque;
  }
  
  sub canonical {
      my $self = shift;
      my $nid = $self->_nid;
      my $new = $self->SUPER::canonical;
      return $new if $nid !~ /[A-Z]/ || $nid =~ /%/;
      $new = $new->clone if $new == $self;
      $new->nid(lc($nid));
      return $new;
  }
  
  1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;  # RFC 3187
  
  use strict;
  use warnings;
  
  use parent 'URI::urn';
  
  use Carp qw(carp);
  
  BEGIN {
      require Business::ISBN;
      
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      warn "Using Business::ISBN version " . Business::ISBN->VERSION . 
          " which is deprecated.\nUpgrade to Business::ISBN version 2\n"
          if Business::ISBN->VERSION < 2;
      }
      
  sub _isbn {
      my $nss = shift;
      $nss = $nss->nss if ref($nss);
      my $isbn = Business::ISBN->new($nss);
      $isbn = undef if $isbn && !$isbn->is_valid;
      return $isbn;
  }
  
  sub _nss_isbn {
      my $self = shift;
      my $nss = $self->nss(@_);
      my $isbn = _isbn($nss);
      $isbn = $isbn->as_string if $isbn;
      return($nss, $isbn);
  }
  
  sub isbn {
      my $self = shift;
      my $isbn;
      (undef, $isbn) = $self->_nss_isbn(@_);
      return $isbn;
  }
  
  sub isbn_publisher_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->publisher_code;
  }
  
  BEGIN {
  my $group_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code';
      };
  
  sub isbn_group_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->$group_method;
  }
  }
  
  sub isbn_country_code {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn_group_code instead";
      
      no strict 'refs';
      &isbn_group_code;
  }
  
  BEGIN {
  my $isbn13_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean';
      };
  
  sub isbn13 {
      my $isbn = shift->_isbn || return undef;
      
      # Business::ISBN 1.x didn't put hyphens in the EAN, and it was just a string
      # Business::ISBN 2.0 doesn't do EAN, but it does ISBN-13 objects
      #   and it uses the hyphens, so call as_string with an empty anon array
      # or, adjust the test and features to say that it comes out with hyphens.
      my $thingy = $isbn->$isbn13_method;
      return eval { $thingy->can( 'as_string' ) } ? $thingy->as_string([]) : $thingy;
  }
  }
  
  sub isbn_as_ean {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn13 instead";
  
      no strict 'refs';
      &isbn13;
  }
  
  sub canonical {
      my $self = shift;
      my($nss, $isbn) = $self->_nss_isbn;
      my $new = $self->SUPER::canonical;
      return $new unless $nss && $isbn && $nss ne $isbn;
      $new = $new->clone if $new == $self;
      $new->nss($isbn);
      return $new;
  }
  
  1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;  # RFC 2061
  
  use strict;
  use warnings;
  
  use parent 'URI::urn';
  
  sub oid {
      my $self = shift;
      my $old = $self->nss;
      if (@_) {
  	$self->nss(join(".", @_));
      }
      return split(/\./, $old) if wantarray;
      return $old;
  }
  
  1;
URI_URN_OID

$fatpacked{"WWW/Shorten.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WWW_SHORTEN';
  #$Id$
  
  =head1 NAME
  
  WWW::Shorten - Interface to URL shortening sites.
  
  =head1 SYNOPSIS
  
    use WWW::Shorten 'Linkz';
    use WWW::Shorten 'MakeAShorterLink';
    use WWW::Shorten 'Metamark';
    use WWW::Shorten 'NotLong';
    use WWW::Shorten 'OneShortLink';
    use WWW::Shorten 'Shorl';
    use WWW::Shorten 'TinyClick';
    use WWW::Shorten 'TinyLink';
    use WWW::Shorten 'TinyURL';
  
    # Individual modules have have their
    # own syntactic variations.
  
    # See the documentation for the particular
    # module you intend to use for details, trips
    # and traps.
  
    $short_url = makeashorterlink($long_url);
  
    $long_url  = makealongerlink($short_url);
  
    # If you don't like the function names:
    use WWW::Shorten 'Metamark', ':short';
    $short_url = short_link( $long_url );
    $long_url = long_link( $short_url );
  
  =head1 ABSTRACT
  
  A Perl interface to URL shortening sites. These sites maintain
  databases of long URLs, each of which has a unique identifier.
  
  =head1 DESCRIPTION
  
  The function C<makeashorterlink> will call the relevant web site
  passing it your long URL and will return the shorter version.
  
  The function C<makealongerlink> does the reverse. C<makealongerlink>
  will accept as an argument either the full shortened URL or just the
  identifier.
  
  If anything goes wrong, then either function will return C<undef>.
  
  =cut
  
  package WWW::Shorten;
  
  use 5.006;
  use strict;
  use warnings;
  
  use base qw(WWW::Shorten::generic);
  our @EXPORT = qw(makeashorterlink makealongerlink);
  our $VERSION = '3.05';
  
  our $DEFAULT_SERVICE = 'Metamark';
  
  use Carp;
  
  my $style;
  
  =head1 Subroutines
  
  =head2 import
  
  Called when the module is C<use>d. Loads the correct sub-module
  
  =cut
  
  sub import {
      my $class = shift;
      $style = shift;
      $style = $DEFAULT_SERVICE unless defined $style;
      my $package = "${class}::${style}";
      eval {
  	my $file = $package;
  	$file =~ s/::/\//g;
  	require "$file.pm";
      };
      croak $@ if $@;
      $package->import( @_ );
  }
  
  1;
  
  __END__
  
  =head2 EXPORT
  
  makeashorterlink, makealongerlink
  
  Or, if you specify C<:short> on the import line, you instead
  get C<short_link> and C<long_link>. If you explicitly want the
  default set, use C<:default>.
  
  Actually these functions are exported from the relevant subclass.
  
  =head1 COMMAND LINE PROGRAM
  
  A very simple program called F<shorten> is supplied in the
  distribution's F<bin> folder. This program takes a URL and
  gives you a shortened version of it.
  
  =head1 EXAMPLES and PROGRAMS
  
  Adam Kessel wrote F<shorlfilter>, a program that uses C<WWW::Shorten>
  to filter a file, converting long URLs to short ones.
  
      http://bostoncoop.net/adam/shorlfilter
  
  There is also a F<bin> directory in this distribution which contains a
  sample program.
  
  =head1 NO LONGER SUPPORTED
  
  The URL-shortening industry is pretty volatile. Many sites exist for a
  while and then go away. The most famous of those is probably Make A Shorter
  Link (the site that originally inspired this suite of modules). MASL has
  been acquired by TinyURL.com and no longer exists.
  
  Here is a list of sites that were once supported by this module and are no
  longer with us:
  
  =over 4
  
  =item MakeAShorterLink
  
  =item BabyURL
  
  =item EkDk
  
  =item qURL (although the differently capitalised Qurl.com now uses their old domain)
  
  =item ShortLink
  
  =item SmLnk
  
  =item URLjr
  
  =item V3
  
  =back
  
  See Joshua Schachter's blog entry at
  L<http://joshua.schachter.org/2009/04/on-url-shorteners.html> for some
  very interesting discussion on some problems that can be caused by the
  volatility of this part of the web industry.
  
  =head1 RELATED MODULES
  
  =head2 Similar Aim
  
  L<WWW::MakeAShorterLink> is what this module was originally based upon.
  That module is obsoleted by L<WWW::Shorten::MakeAShorterLink>, one of
  the many subclasses of L<WWW::Shorten>. Of course, with the demise of
  Make A Shorter Link, neither the obsolete module nor its replacement are
  of any use.
  
  =head2 Same Area, Different Purpose
  
  L<CGI::Shorten> provides building blocks for you to create your own URL
  shortening service. It provides routines to shoretn a URL, lengthen one,
  and it keeps a store. Nice and easy.
  
  =head1 THANKS
  
  Dave Cross for L<WWW::MakeAShorterLink>
  
  Alex Page for the original LWP hacking on which Dave based his code.
  
  Simon Batistoni for giving the C<makealongerlink> idea to Dave.
  
  Eric Hammond for writing the NotLong variant.
  
  Shashank Tripathi <shank@shank.com> for providing both SnipURL.com and
  advice on the module.
  
  Kevin Gilbertson (Gilby) supplied information on the TinyURL API.
  
  Matt Felsen (mattf) wanted shorter function names.
  
  Ask Bjoern Hansen for providing both Metamark.net and advice on the
  module.
  
  Martin Thurn for helping me notice a bug and for a suggestion regarding
  F<MASL.pm>.
  
  Jon and William (jon and wjr at smlnk.com respectively) for providing
  SmLnk.com.
  
  P J Goodwin for providing the code for L<WWW::Shorten::OneShortLink>.
  
  And especial thanks to all providers of these services.
  
  =head1 BUGS, REQUESTS, COMMENTS
  
  Support for this module is supplied using the CPAN RT system via the web
  or email:
  
      http://rt.cpan.org/NoAuth/ReportBug.html?Queue=WWW-Shorten
      ( shorter URL: http://xrl.us/rfb )
  
      bug-www-shorten@rt.cpan.org
  
  This makes it much easier for me to track things and thus means
  your problem is less likely to be neglected.
  
  =head1 LICENCE AND COPYRIGHT
  
  WWW::Shorten::NotLong copyright (c) Eric Hammond <ehammond@thinksome.com>.
  
  Other modules copyright (c) Magnum Solutions Ltd., 2007. All rights
  reserved.
  
  This module is free software.  You can redistribute it and/or
  modify it under the terms of the Artistic License 2.0.
  
  This program is distributed in the hope that it will be useful,
  but without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Original Iain Truskett <spoon@cpan.org>
  
  Based on WWW::MakeAShorterLink by Dave Cross <dave@mag-sol.com>
  
  In 2004 Dave Cross took over the maintenance of this distribution
  following the death of Iain Truskett.
  
  =head1 SEE ALSO
  
  L<perl>, L<CGI::Shorten>.
  
  =cut
WWW_SHORTEN

$fatpacked{"WWW/Shorten/LinkToolbot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WWW_SHORTEN_LINKTOOLBOT';
  # $Id: MakeAShorterLink.pm 48 2007-04-15 15:03:55Z dave $
  package WWW::Shorten::LinkToolbot;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.90';
  require WWW::Shorten::_dead;
  
  0;
  
  __END__
  
  =head1 NAME
  
  WWW::Shorten::LinkToolbot - Perl interface to link.toolbot.com
  
  =head1 SYNOPSIS
  
      # No appropriate synopsis.
  
  =head1 DESCRIPTION
  
  A Perl interface to the web site link.toolbot.com.
  
  Unfortunately, this service became inactive at some point between 1.89
  and 1.90, so this module will merely give you an error if you try to use
  it. Feel free to pick a different L<service|WWW::Shorten>.
  
  =head1 SUPPORT, LICENCE, THANKS and SUCH
  
  See the main L<WWW::Shorten> docs.
  
  =head1 AUTHOR
  
  Iain Truskett <spoon@cpan.org>, Dave Cross <dave@mag-sol.com>
  
  =head1 SEE ALSO
  
  L<WWW::Shorten>, L<perl>
  
  =cut
WWW_SHORTEN_LINKTOOLBOT

$fatpacked{"WWW/Shorten/Linkz.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WWW_SHORTEN_LINKZ';
  # $Id$
  
  =head1 NAME
  
  WWW::Shorten::Linkz - Perl interface to lin.kz
  
  =head1 SYNOPSIS
  
    use WWW::Shorten 'Linkz';
  
    $short_url = makeashorterlink($long_url);
  
    $long_url  = makealongerlink($short_url);
    $long_url  = makealongerlink($nickname);
  
  =head1 DESCRIPTION
  
  A Perl interface to the web site lin.kz. lin.kz simply
  maintains a database of long URLs, each of which has a unique
  identifier.
  
  =cut
  
  package WWW::Shorten::Linkz;
  
  use 5.006;
  use strict;
  use warnings;
  
  use base qw( WWW::Shorten::generic Exporter );
  our @EXPORT = qw(makeashorterlink makealongerlink);
  our $VERSION = '1.90';
  
  use Carp;
  
  #POST http://lin.kz/make.php
  #    url=
  #    <NONAME>=Shorten URL!           (submit)
  #    privkey=
  #
  
  =head1 Functions
  
  =head2 makeashorterlink
  
  The function C<makeashorterlink> will call the lin.kz web site
  passing it your long URL and will return the shorter (Linkz) version.
  
  Multiple submissions of the same URL will result in different codes
  being returned.
  
  =cut
  
  sub makeashorterlink
  {
      my $url = shift or croak 'No URL passed to makeashorterlink';
      my $ua = __PACKAGE__->ua();
      my $resp = $ua->post( 'http://lin.kz/make.php', [
          url => $url,
          ],
      );
      return unless $resp->is_success;
      if ($resp->content =~ m!
          \Q<a href="\E(\Qhttp://lin.kz/?\E\w+)"
  	!x) {
  	return $1;
      }
      return;
  }
  
  =head2 makealongerlink
  
  The function C<makealongerlink> does the reverse. C<makealongerlink>
  will accept as an argument either the full Linkz URL or just the
  Linkz identifier/nickname.
  
  If anything goes wrong, then either function will return C<undef>.
  
  =cut
  
  sub makealongerlink
  {
      my $code = shift
  	or croak 'No Linkz nickname/URL passed to makealongerlink';
      my $ua = __PACKAGE__->ua();
      $code = "http://lin.kz/?$code" unless $code =~ m!^http://!i;
  
      my $resp = $ua->get($code);
      my $location = $resp->header('Location');
      return $location if defined $location;
      return;
  }
  
  1;
  
  __END__
  
  =head2 EXPORT
  
  makeashorterlink, makealongerlink
  
  =head1 SUPPORT, LICENCE, THANKS and SUCH
  
  See the main L<WWW::Shorten> docs.
  
  =head1 AUTHOR
  
  Iain Truskett <spoon@cpan.org>
  
  =head1 SEE ALSO
  
  L<WWW::Shorten>, L<perl>, L<http://lin.kz/>
  
  =cut
WWW_SHORTEN_LINKZ

$fatpacked{"WWW/Shorten/MakeAShorterLink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WWW_SHORTEN_MAKEASHORTERLINK';
  # $Id$
  package WWW::Shorten::MakeAShorterLink;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.90';
  require WWW::Shorten::_dead;
  
  0;
  
  __END__
  
  =head1 NAME
  
  WWW::Shorten::MakeAShorterLink - Perl interface to makeashorterlink.com
  
  =head1 SYNOPSIS
  
      # No appropriate synopsis.
  
  =head1 DESCRIPTION
  
  A Perl interface to the web site babyurl.com.
  
  Unfortunately, this service became inactive at some point between 1.89
  and 1.90, so this module will merely give you an error if you try to use
  it. Feel free to pick a different L<service|WWW::Shorten>.
  
  =head1 SUPPORT, LICENCE, THANKS and SUCH
  
  See the main L<WWW::Shorten> docs.
  
  =head1 AUTHOR
  
  Iain Truskett <spoon@cpan.org>, Dave Cross <dave@mag-sol.com>
  
  =head1 SEE ALSO
  
  L<WWW::Shorten>, L<perl>
  
  =cut
WWW_SHORTEN_MAKEASHORTERLINK

$fatpacked{"WWW/Shorten/Metamark.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WWW_SHORTEN_METAMARK';
  # $Id$
  
  =head1 NAME
  
  WWW::Shorten::Metamark - Perl interface to metamark.net
  
  =head1 SYNOPSIS
  
    use WWW::Shorten::Metamark;
  
    use WWW::Shorten 'Metamark';
  
    $short_url = makeashorterlink($long_url);
  
    $long_url  = makealongerlink($short_url);
  
  =head1 DESCRIPTION
  
  A Perl interface to the web site metamark.net. Metamark simply maintains
  a database of long URLs, each of which has a unique identifier.
  
  =cut
  
  package WWW::Shorten::Metamark;
  
  use 5.006;
  use strict;
  use warnings;
  
  use base qw( WWW::Shorten::generic Exporter );
  our @EXPORT = qw(makeashorterlink makealongerlink);
  our $VERSION = '1.91';
  
  use Carp;
  
  =head1 Functions
  
  =head2 makeashorterlink
  
  The function C<makeashorterlink> will call the Metamark web site passing it
  your long URL and will return the shorter Metamark version.
  
  =cut
  
  sub makeashorterlink
  {
      my $url = shift or croak 'No URL passed to makeashorterlink';
      my $ua = __PACKAGE__->ua();
      my $resp  = $ua->post( 'http://metamark.net/api/rest/simple', [
          long_url => $url,
      ] );
      return unless $resp->is_success;
      return if $resp->content =~ /^ERROR:/;
      # I love REST. It's so simple when done properly.
      return $resp->content;
  }
  
  =head2 makealongerlink
  
  The function C<makealongerlink> does the reverse. C<makealongerlink>
  will accept as an argument either the full Metamark URL or just the
  Metamark identifier.
  
  If anything goes wrong, then either function will return C<undef>.
  
  =cut
  
  sub makealongerlink
  {
      my $short_url = shift 
  	or croak 'No Metamark key / URL passed to makealongerlink';
      my $ua = __PACKAGE__->ua();
  
      my $resp  = $ua->post( 'http://metamark.net/api/rest/simple', [
          short_url => $short_url,
      ] );
      return unless $resp->is_success;
      return if $resp->content =~ /^ERROR:/;
      # I love REST. It's so simple when done properly.
      return $resp->content;
  }
  
  1;
  
  __END__
  
  =head2 EXPORT
  
  makeashorterlink, makealongerlink
  
  =head1 SUPPORT, LICENCE, THANKS and SUCH
  
  See the main L<WWW::Shorten> docs.
  
  =head1 AUTHOR
  
  Iain Truskett <spoon@cpan.org>
  
  Based on WWW::MakeAShorterLink by Dave Cross <dave@dave.org.uk>
  
  =head1 SEE ALSO
  
  L<WWW::Shorten>, L<perl>, L<http://metamark.net/>
  
  =cut
WWW_SHORTEN_METAMARK

$fatpacked{"WWW/Shorten/TinyClick.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WWW_SHORTEN_TINYCLICK';
  # $Id$
  package WWW::Shorten::TinyClick;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.90';
  require WWW::Shorten::_dead;
  
  0;
  
  __END__
  
  =head1 NAME
  
  WWW::Shorten::TinyClick - Perl interface to tinyclick.com
  
  =head1 SYNOPSIS
  
      # No appropriate synopsis.
  
  =head1 DESCRIPTION
  
  A Perl interface to the web site tinyclick.com.
  
  Unfortunately, this service became inactive at some point between 1.89
  and 1.90, so this module will merely give you an error if you try to use
  it. Feel free to pick a different L<service|WWW::Shorten>.
  
  =head1 SUPPORT, LICENCE, THANKS and SUCH
  
  See the main L<WWW::Shorten> docs.
  
  =head1 AUTHOR
  
  Iain Truskett <spoon@cpan.org>, Dave Cross <dave@mag-sol.com>
  
  =head1 SEE ALSO
  
  L<WWW::Shorten>, L<perl>
  
  =cut
WWW_SHORTEN_TINYCLICK

$fatpacked{"WWW/Shorten/TinyURL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WWW_SHORTEN_TINYURL';
  # $Id$
  
  =head1 NAME
  
  WWW::Shorten::TinyURL - Perl interface to tinyurl.com
  
  =head1 SYNOPSIS
  
    use WWW::Shorten::TinyURL;
    use WWW::Shorten 'TinyURL';
  
    $short_url = makeashorterlink($long_url);
  
    $long_url  = makealongerlink($short_url);
  
  =head1 DESCRIPTION
  
  A Perl interface to the web site tinyurl.com.  TinyURL simply maintains
  a database of long URLs, each of which has a unique identifier.
  
  =cut
  
  package WWW::Shorten::TinyURL;
  
  use 5.006;
  use strict;
  use warnings;
  
  use base qw( WWW::Shorten::generic Exporter );
  our @EXPORT = qw( makeashorterlink makealongerlink );
  our $VERSION = '1.90';
  
  use Carp;
  
  =head1 Functions
  
  =head2 makeashorterlink
  
  The function C<makeashorterlink> will call the TinyURL web site passing
  it your long URL and will return the shorter TinyURL version.
  
  =cut
  
  sub makeashorterlink
  {
      my $url = shift or croak 'No URL passed to makeashorterlink';
      my $ua = __PACKAGE__->ua();
      my $tinyurl = 'http://tinyurl.com/api-create.php';
      my $resp = $ua->post($tinyurl, [
  	url => $url,
  	source => "PerlAPI-$VERSION",
  	]);
      return undef unless $resp->is_success;
      my $content = $resp->content;
      return undef if $content =~ /Error/;
      if ($resp->content =~ m!(\Qhttp://tinyurl.com/\E\w+)!x) {
  	return $1;
      }
      return;
  }
  
  =head2 makealongerlink
  
  The function C<makealongerlink> does the reverse. C<makealongerlink>
  will accept as an argument either the full TinyURL URL or just the
  TinyURL identifier.
  
  If anything goes wrong, then either function will return C<undef>.
  
  =cut
  
  sub makealongerlink
  {
      my $tinyurl_url = shift 
  	or croak 'No TinyURL key / URL passed to makealongerlink';
      my $ua = __PACKAGE__->ua();
  
      $tinyurl_url = "http://tinyurl.com/$tinyurl_url"
      unless $tinyurl_url =~ m!^http://!i;
  
      my $resp = $ua->get($tinyurl_url);
  
      return undef unless $resp->is_redirect;
      my $url = $resp->header('Location');
      return $url;
  
  }
  
  1;
  
  __END__
  
  =head2 EXPORT
  
  makeashorterlink, makealongerlink
  
  =head1 SUPPORT, LICENCE, THANKS and SUCH
  
  See the main L<WWW::Shorten> docs.
  
  =head1 AUTHOR
  
  Iain Truskett <spoon@cpan.org>
  
  =head1 SEE ALSO
  
  L<WWW::Shorten>, L<perl>, L<http://tinyurl.com/>
  
  =cut
WWW_SHORTEN_TINYURL

$fatpacked{"WWW/Shorten/Tinylink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WWW_SHORTEN_TINYLINK';
  # $Id$
  
  use strict;
  use warnings;
  
  our $VERSION = '1.91';
  require WWW::Shorten::_dead;
  
  0;
  __END__
  
  =head1 NAME
  
  WWW::Shorten::Tinylink - Perl interface to Tinylink.com
  
  =head1 SYNOPSIS
  
    # No appropriate solution
  
  =head1 DESCRIPTION
  
  A Perl interface to the web site Tinylink.com. Tinylink.com simply
  maintains a database of long URLs, each of which has a unique
  identifier.
  
  Unfortunately, at some point in the middle of 2008, Tinylink.com stopped
  returning useable URLs and therefore this module is now deprecated.
  
  =cut
  
  package WWW::Shorten::Tinylink;
  
  use 5.006;
  use strict;
  use warnings;
  
  use base qw( WWW::Shorten::generic Exporter );
  our @EXPORT = qw(makeashorterlink makealongerlink);
  our $VERSION = '1.90';
  
  use Carp;
  
  =head1 Functions
  
  =head2 makeashorterlink
  
  The function C<makeashorterlink> will call the Tinylink.com web site
  passing it your long URL and will return the shorter (tinylink) version.
  
  Multiple submissions of the same URL will result in different codes
  being returned.
  
  =cut
  
  sub makeashorterlink
  {
      my $url = shift or croak 'No URL passed to makeashorterlink';
      my $ua = __PACKAGE__->ua();
      my $resp = $ua->post( 'http://www.digipills.com/tinylink/ajout.php', [
          lurl => $url,
          ],
      );
      return unless $resp->is_success;
      if ($resp->content =~ m!
          \Q<a href="\E(\Qhttp://tinylink.com/?\E\w+)"
  	!x) {
  	return $1;
      }
      return;
  }
  
  =head2 makealongerlink
  
  The function C<makealongerlink> does the reverse. C<makealongerlink>
  will accept as an argument either the full Tinylink URL or just the
  Tinylink identifier/nickname.
  
  If anything goes wrong, then either function will return C<undef>.
  
  =cut
  
  sub makealongerlink
  {
      my $code = shift
  	or croak 'No Tinylink nickname/URL passed to makealongerlink';
      my $ua = __PACKAGE__->ua();
  
      my $short;
      unless ( $code =~ m!^http://!i )
      {
          $short = $code;
          $code = "http://tinylink.com/?$code";
      }
      else
      {
          ($short) = $code =~ /\?(\w+)/;
      }
  
      my $resp = $ua->get($code);
      while ( my $location = $resp->header('Location') )
      {
          $resp = $ua->get( $location );
      }
      if ( my $refresh = $resp->header('Refresh') )
      {
          return $2 if $refresh =~ m/; *URL=(['"]?)(.*)\1$/i;
      }
  
      return;
  }
  
  1;
  
  __END__
  
  =head2 EXPORT
  
  makeashorterlink, makealongerlink
  
  =head1 SUPPORT, LICENCE, THANKS and SUCH
  
  See the main L<WWW::Shorten> docs.
  
  =head1 AUTHOR
  
  Iain Truskett <spoon@cpan.org>
  
  =head1 SEE ALSO
  
  L<WWW::Shorten>, L<perl>, L<http://tinylink.com/>
  
  =cut
WWW_SHORTEN_TINYLINK

$fatpacked{"WWW/Shorten/UserAgent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WWW_SHORTEN_USERAGENT';
  package WWW::Shorten::UserAgent;
  
  use strict;
  use warnings;
  
  use base 'LWP::UserAgent';
  
  =head1 NAME
  
  WWW::Shorten::UserAgent - LWP::UserAgent subclass for WWW::Shorten modules.
  
  =head1 SYNOPSIS
  
    use WWW::Shorten::UserAgent;
  
    my $ua = WWW::Shorten::UserAgent->new;
  
    my $resp = eval {
      $ua->get($url);
    };
  
  =head1 DESCRIPTION
  
  Subclass of LWP::UserAgent which works the same way as the supoerclass
  except that it throws an exception if the C<get> or C<post> method returns
  an error.
  
  See L<LWP::UserAgent> for the full documentation.
  
  =head1 METHODS
  
  =head2 get
  
  Makes an HTTP GET request and throws an exception on error.
  
  =cut
  
  sub get {
    my $self = shift;
    my $resp = $self->SUPER::get(@_);
  
    die $resp->status_line if $resp->is_error;
  
    return $resp;
  }
  
  =head2 post
  
  Makes an HTTP POST request and throws an exception on error.
  
  =cut
  
  sub post {
    my $self = shift;
    my $resp = $self->SUPER::post(@_);
  
    die $resp->status_line if $resp->is_error;
  
    return $resp;
  }
  
  1;
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) Magnum Solutions Ltd., 2012. All rights reserved.
  
  This module is free software.  You can redistribute it and/or
  modify it under the terms of the Artistic License 2.0.
  
  This program is distributed in the hope that it will be useful,
  but without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Dave Cross <dave@mag-sol.com>
  
  =cut
WWW_SHORTEN_USERAGENT

$fatpacked{"WWW/Shorten/_dead.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WWW_SHORTEN__DEAD';
  # $Id$
  package WWW::Shorten::_dead;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.92';
  die <<'EOF';
  
  This WWW::Shorten service is inactive.
  Please use a different one.
  
  EOF
  
  1;
  
  =head1 NAME
  
  WWW::Shorten::_dead - Where dead link-shortening services got
  
  =head1 SYNOPSIS
  
    # No appropriate synopsis
  
  =head1 DESCRIPTION
  
  This is just a module that we use for link-shortening services that
  we used to support but which no longer exist.
WWW_SHORTEN__DEAD

$fatpacked{"WWW/Shorten/generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WWW_SHORTEN_GENERIC';
  # $Id$
  
  =head1 NAME
  
  WWW::Shorten::generic - Methods shared across all WWW::Shorten modules
  
  =head1 SYNOPSIS
  
    use WWW::Shorten 'SomeSubclass';
  
  =head1 DESCRIPTION
  
  Contains methds that are shared across all WWW::Shorten implemenation
  modules.
  
  =cut
  
  package WWW::Shorten::generic;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $VERSION = 1.92;
  
  use WWW::Shorten::UserAgent;
  use Carp;
  
  my %name_sets =
  (
      default	=> [qw( makeashorterlink makealongerlink )],
      short	=> [qw( short_link long_link )],
  );
  
  sub import
  {
      my $class = shift;
      my ($package) = caller;
      ($package) = caller(1) if $package eq 'WWW::Shorten';
      my $set = shift;
      if (defined $set and $set =~ /^ : (\w+) $/x) {
  	$set = $1;
      } else {
  	$set = 'default';
      }
      if ( exists $name_sets{$set} )
      {
  	no strict 'refs';
  	*{"${package}::$name_sets{$set}[0]"} =
  	    *{ "${class}::$name_sets{default}[0]"};
  	*{"${package}::$name_sets{$set}[1]"} =
  	    *{ "${class}::$name_sets{default}[1]"};
      }
      else
      {
  	croak "Unknown function set - $set.";
      }
  }
  
  my $ua;
  
  =head1 FUNCTIONS
  
  =head2 ua
  
  Returns the object's LWP::Useragent attribute. Creates a new one if one
  doesn't already exist.
  
  =cut
  
  sub ua
  {
      my $self = shift;
      return $ua if defined $ua;
      my $v = $self->VERSION();
      $ua = WWW::Shorten::UserAgent->new(
  	env_proxy => 1,
  	timeout => 30,
  	agent => "$self/$v",
  	requests_redirectable => [],
      );
      return $ua;
  }
  
  1;
WWW_SHORTEN_GENERIC

$fatpacked{"x86_64-linux/IO/Pty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_PTY';
  # Documentation at the __END__
  
  package IO::Pty;
  
  use strict;
  use Carp;
  use IO::Tty qw(TIOCSCTTY TCSETCTTY TIOCNOTTY);
  use IO::File;
  require POSIX;
  
  use vars qw(@ISA $VERSION);
  
  $VERSION = '1.11'; # keep same as in Tty.pm
  
  @ISA = qw(IO::Handle);
  eval { local $^W = 0; undef local $SIG{__DIE__}; require IO::Stty };
  push @ISA, "IO::Stty" if (not $@);  # if IO::Stty is installed
  
  sub new {
    my ($class) = $_[0] || "IO::Pty";
    $class = ref($class) if ref($class);
    @_ <= 1 or croak 'usage: new $class';
  
    my ($ptyfd, $ttyfd, $ttyname) = pty_allocate();
  
    croak "Cannot open a pty" if not defined $ptyfd;
  
    my $pty = $class->SUPER::new_from_fd($ptyfd, "r+");
    croak "Cannot create a new $class from fd $ptyfd: $!" if not $pty;
    $pty->autoflush(1);
    bless $pty => $class;
  
    my $slave = IO::Tty->new_from_fd($ttyfd, "r+");
    croak "Cannot create a new IO::Tty from fd $ttyfd: $!" if not $slave;
    $slave->autoflush(1);
  
    ${*$pty}{'io_pty_slave'} = $slave;
    ${*$pty}{'io_pty_ttyname'} = $ttyname;
    ${*$slave}{'io_tty_ttyname'} = $ttyname;
  
    return $pty;
  }
  
  sub ttyname {
    @_ == 1 or croak 'usage: $pty->ttyname();';
    my $pty = shift;
    ${*$pty}{'io_pty_ttyname'};
  }
  
  
  sub close_slave {
    @_ == 1 or croak 'usage: $pty->close_slave();';
  
    my $master = shift;
  
    if (exists ${*$master}{'io_pty_slave'}) {
      close ${*$master}{'io_pty_slave'};
      delete ${*$master}{'io_pty_slave'};
    }
  }
  
  sub slave {
    @_ == 1 or croak 'usage: $pty->slave();';
  
    my $master = shift;
  
    if (exists ${*$master}{'io_pty_slave'}) {
      return ${*$master}{'io_pty_slave'};
    }
  
    my $tty = ${*$master}{'io_pty_ttyname'};
  
    my $slave = new IO::Tty;
  
    $slave->open($tty, O_RDWR | O_NOCTTY) ||
      croak "Cannot open slave $tty: $!";
  
    return $slave;
  }
  
  sub make_slave_controlling_terminal {
    @_ == 1 or croak 'usage: $pty->make_slave_controlling_terminal();';
  
    my $self = shift;
    local(*DEVTTY);
  
    # loose controlling terminal explicitly
    if (defined TIOCNOTTY) {
      if (open (\*DEVTTY, "/dev/tty")) {
        ioctl( \*DEVTTY, TIOCNOTTY, 0 );
        close \*DEVTTY;
      }
    }
  
    # Create a new 'session', lose controlling terminal.
    if (not POSIX::setsid()) {
      warn "setsid() failed, strange behavior may result: $!\r\n" if $^W;
    }
  
    if (open(\*DEVTTY, "/dev/tty")) {
      warn "Could not disconnect from controlling terminal?!\n" if $^W;
      close \*DEVTTY;
    }
  
    # now open slave, this should set it as controlling tty on some systems
    my $ttyname = ${*$self}{'io_pty_ttyname'};
    my $slv = new IO::Tty;
    $slv->open($ttyname, O_RDWR)
      or croak "Cannot open slave $ttyname: $!";
  
    if (not exists ${*$self}{'io_pty_slave'}) {
      ${*$self}{'io_pty_slave'} = $slv;
    } else {
      $slv->close;
    }
  
    # Acquire a controlling terminal if this doesn't happen automatically
    if (not open(\*DEVTTY, "/dev/tty")) {
      if (defined TIOCSCTTY) {
        if (not defined ioctl( ${*$self}{'io_pty_slave'}, TIOCSCTTY, 0 )) {
          warn "warning: TIOCSCTTY failed, slave might not be set as controlling terminal: $!" if $^W;
        }
      } elsif (defined TCSETCTTY) {
        if (not defined ioctl( ${*$self}{'io_pty_slave'}, TCSETCTTY, 0 )) {
          warn "warning: TCSETCTTY failed, slave might not be set as controlling terminal: $!" if $^W;
        }
      } else {
        warn "warning: You have neither TIOCSCTTY nor TCSETCTTY on your system\n" if $^W;
        return 0;
      }
    }
  
    if (not open(\*DEVTTY, "/dev/tty")) {
      warn "Error: could not connect pty as controlling terminal!\n";
      return undef;
    } else {
      close \*DEVTTY;
    }
    
    return 1;
  }
  
  *clone_winsize_from = \&IO::Tty::clone_winsize_from;
  *get_winsize = \&IO::Tty::get_winsize;
  *set_winsize = \&IO::Tty::set_winsize;
  *set_raw = \&IO::Tty::set_raw;
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Pty - Pseudo TTY object class
  
  =head1 VERSION
  
  1.11
  
  =head1 SYNOPSIS
  
      use IO::Pty;
  
      $pty = new IO::Pty;
  
      $slave  = $pty->slave;
  
      foreach $val (1..10) {
  	print $pty "$val\n";
  	$_ = <$slave>;
  	print "$_";
      }
  
      close($slave);
  
  
  =head1 DESCRIPTION
  
  C<IO::Pty> provides an interface to allow the creation of a pseudo tty.
  
  C<IO::Pty> inherits from C<IO::Handle> and so provide all the methods
  defined by the C<IO::Handle> package.
  
  Please note that pty creation is very system-dependend.  If you have
  problems, see L<IO::Tty> for help.
  
  
  =head1 CONSTRUCTOR
  
  =over 3
  
  =item new
  
  The C<new> constructor takes no arguments and returns a new file
  object which is the master side of the pseudo tty.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item ttyname()
  
  Returns the name of the slave pseudo tty. On UNIX machines this will
  be the pathname of the device.  Use this name for informational
  purpose only, to get a slave filehandle, use slave().
  
  =item slave()
  
  The C<slave> method will return the slave filehandle of the given
  master pty, opening it anew if necessary.  If IO::Stty is installed,
  you can then call C<$slave-E<gt>stty()> to modify the terminal settings.
  
  =item close_slave()
  
  The slave filehandle will be closed and destroyed.  This is necessary
  in the parent after forking to get rid of the open filehandle,
  otherwise the parent will not notice if the child exits.  Subsequent
  calls of C<slave()> will return a newly opened slave filehandle.
  
  =item make_slave_controlling_terminal()
  
  This will set the slave filehandle as the controlling terminal of the
  current process, which will become a session leader, so this should
  only be called by a child process after a fork(), e.g. in the callback
  to C<sync_exec()> (see L<Proc::SyncExec>).  See the C<try> script
  (also C<test.pl>) for an example how to correctly spawn a subprocess.
  
  =item set_raw()
  
  Will set the pty to raw.  Note that this is a one-way operation, you
  need IO::Stty to set the terminal settings to anything else.
  
  On some systems, the master pty is not a tty.  This method checks for
  that and returns success anyway on such systems.  Note that this
  method must be called on the slave, and probably should be called on
  the master, just to be sure, i.e.
  
    $pty->slave->set_raw();
    $pty->set_raw();
  
  
  =item clone_winsize_from(\*FH)
  
  Gets the terminal size from filehandle FH (which must be a terminal)
  and transfers it to the pty.  Returns true on success and undef on
  failure.  Note that this must be called upon the I<slave>, i.e.
  
   $pty->slave->clone_winsize_from(\*STDIN);
  
  On some systems, the master pty also isatty.  I actually have no
  idea if setting terminal sizes there is passed through to the slave,
  so if this method is called for a master that is not a tty, it
  silently returns OK.
  
  See the C<try> script for example code how to propagate SIGWINCH.
  
  =item get_winsize()
  
  Returns the terminal size, in a 4-element list.
  
   ($row, $col, $xpixel, $ypixel) = $tty->get_winsize()
  
  =item set_winsize($row, $col, $xpixel, $ypixel)
  
  Sets the terminal size. If not specified, C<$xpixel> and C<$ypixel> are set to
  0.  As with C<clone_winsize_from>, this must be called upon the I<slave>.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<IO::Tty>, L<IO::Tty::Constant>, L<IO::Handle>, L<Expect>, L<Proc::SyncExec>
  
  
  =head1 MAILING LISTS
  
  As this module is mainly used by Expect, support for it is available
  via the two Expect mailing lists, expectperl-announce and
  expectperl-discuss, at
  
    http://lists.sourceforge.net/lists/listinfo/expectperl-announce
  
  and
  
    http://lists.sourceforge.net/lists/listinfo/expectperl-discuss
  
  
  =head1 AUTHORS
  
  Originally by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>, based on the
  Ptty module by Nick Ing-Simmons E<lt>F<nik@tiuk.ti.com>E<gt>.
  
  Now maintained and heavily rewritten by Roland Giersig
  E<lt>F<RGiersig@cpan.org>E<gt>.
  
  Contains copyrighted stuff from openssh v3.0p1, authored by 
  Tatu Ylonen <ylo@cs.hut.fi>, Markus Friedl and Todd C. Miller
  <Todd.Miller@courtesan.com>.
  
  
  =head1 COPYRIGHT
  
  Now all code is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Nevertheless the above AUTHORS retain their copyrights to the various
  parts and want to receive credit if their source code is used.
  See the source for details.
  
  
  =head1 DISCLAIMER
  
  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGE.
  
  In other words: Use at your own risk.  Provided as is.  Your mileage
  may vary.  Read the source, Luke!
  
  And finally, just to be sure:
  
  Any Use of This Product, in Any Manner Whatsoever, Will Increase the
  Amount of Disorder in the Universe. Although No Liability Is Implied
  Herein, the Consumer Is Warned That This Process Will Ultimately Lead
  to the Heat Death of the Universe.
  
  =cut
  
X86_64-LINUX_IO_PTY

$fatpacked{"x86_64-linux/IO/Tty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_TTY';
  # Documentation at the __END__
  # -*-cperl-*-
  
  package IO::Tty;
  
  use IO::Handle;
  use IO::File;
  use IO::Tty::Constant;
  use Carp;
  
  require POSIX;
  require DynaLoader;
  
  use vars qw(@ISA $VERSION $XS_VERSION $CONFIG $DEBUG);
  
  $VERSION = '1.11';
  $XS_VERSION = "1.11";
  @ISA = qw(IO::Handle);
  
  eval { local $^W = 0; undef local $SIG{__DIE__}; require IO::Stty };
  push @ISA, "IO::Stty" if (not $@);  # if IO::Stty is installed
  
  BOOT_XS: {
      # If I inherit DynaLoader then I inherit AutoLoader and I DON'T WANT TO
      require DynaLoader;
  
      # DynaLoader calls dl_load_flags as a static method.
      *dl_load_flags = DynaLoader->can('dl_load_flags');
  
      do {
  	defined(&bootstrap)
  		? \&bootstrap
  		: \&DynaLoader::bootstrap
      }->(__PACKAGE__);
  }
  
  sub import {
      IO::Tty::Constant->export_to_level(1, @_);
  }
  
  sub open {
      my($tty,$dev,$mode) = @_;
  
      IO::File::open($tty,$dev,$mode) or
  	return undef;
  
      $tty->autoflush;
  
      1;
  }
  
  sub clone_winsize_from {
    my ($self, $fh) = @_;
    croak "Given filehandle is not a tty in clone_winsize_from, called"
      if not POSIX::isatty($fh);  
    return 1 if not POSIX::isatty($self);  # ignored for master ptys
    my $winsize = " "x1024; # preallocate memory
    ioctl($fh, &IO::Tty::Constant::TIOCGWINSZ, $winsize)
      and ioctl($self, &IO::Tty::Constant::TIOCSWINSZ, $winsize)
        and return 1;
    warn "clone_winsize_from: error: $!" if $^W;
    return undef;
  }
  
  # ioctl() doesn't tell us how long the structure is, so we'll have to trim it
  # after TIOCGWINSZ
  my $SIZEOF_WINSIZE = length IO::Tty::pack_winsize(0,0,0,0);
  
  sub get_winsize {
    my $self = shift;
    ioctl($self, IO::Tty::Constant::TIOCGWINSZ(), my $winsize)
      or croak "Cannot TIOCGWINSZ - $!";
    substr($winsize, $SIZEOF_WINSIZE) = "";
    return IO::Tty::unpack_winsize($winsize);
  }
  
  sub set_winsize {
    my $self = shift;
    my $winsize = IO::Tty::pack_winsize(@_);
    ioctl($self, IO::Tty::Constant::TIOCSWINSZ(), $winsize)
      or croak "Cannot TIOCSWINSZ - $!";
  }
  
  sub set_raw($) {
    require POSIX;
    my $self = shift;
    return 1 if not POSIX::isatty($self);
    my $ttyno = fileno($self);
    my $termios = new POSIX::Termios;
    unless ($termios) {
      warn "set_raw: new POSIX::Termios failed: $!";
      return undef;
    }
    unless ($termios->getattr($ttyno)) {
      warn "set_raw: getattr($ttyno) failed: $!";
      return undef;
    }
    $termios->setiflag(0);
    $termios->setoflag(0);
    $termios->setlflag(0);
    $termios->setcc(&POSIX::VMIN, 1);
    $termios->setcc(&POSIX::VTIME, 0);
    unless ($termios->setattr($ttyno, &POSIX::TCSANOW)) {
      warn "set_raw: setattr($ttyno) failed: $!";
      return undef;
    }
    return 1;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Tty - Low-level allocate a pseudo-Tty, import constants.
  
  =head1 VERSION
  
  1.11
  
  =head1 SYNOPSIS
  
      use IO::Tty qw(TIOCNOTTY);
      ...
      # use only to import constants, see IO::Pty to create ptys.
  
  =head1 DESCRIPTION
  
  C<IO::Tty> is used internally by C<IO::Pty> to create a pseudo-tty.
  You wouldn't want to use it directly except to import constants, use
  C<IO::Pty>.  For a list of importable constants, see
  L<IO::Tty::Constant>.
  
  Windows is now supported, but ONLY under the Cygwin
  environment, see L<http://sources.redhat.com/cygwin/>.
  
  Please note that pty creation is very system-dependend.  From my
  experience, any modern POSIX system should be fine.  Find below a list
  of systems that C<IO::Tty> should work on.  A more detailed table
  (which is slowly getting out-of-date) is available from the project
  pages document manager at SourceForge
  L<http://sourceforge.net/projects/expectperl/>.
  
  If you have problems on your system and your system is listed in the
  "verified" list, you probably have some non-standard setup, e.g. you
  compiled your Linux-kernel yourself and disabled ptys (bummer!).
  Please ask your friendly sysadmin for help.
  
  If your system is not listed, unpack the latest version of C<IO::Tty>,
  do a C<'perl Makefile.PL; make; make test; uname -a'> and send me
  (F<RGiersig@cpan.org>) the results and I'll see what I can deduce from
  that.  There are chances that it will work right out-of-the-box...
  
  If it's working on your system, please send me a short note with
  details (version number, distribution, etc. 'uname -a' and 'perl -V'
  is a good start; also, the output from "perl Makefile.PL" contains a
  lot of interesting info, so please include that as well) so I can get
  an overview.  Thanks!
  
  
  =head1 VERIFIED SYSTEMS, KNOWN ISSUES
  
  This is a list of systems that C<IO::Tty> seems to work on ('make
  test' passes) with comments about "features":
  
  =over 4
  
  =item * AIX 4.3
  
  Returns EIO instead of EOF when the slave is closed.  Benign.
  
  =item * AIX 5.x
  
  =item * FreeBSD 4.4
  
  EOF on the slave tty is not reported back to the master.
  
  =item * OpenBSD 2.8
  
  The ioctl TIOCSCTTY sometimes fails.  This is also known in
  Tcl/Expect, see http://expect.nist.gov/FAQ.html
  
  EOF on the slave tty is not reported back to the master.
  
  =item * Darwin 7.9.0
  
  =item * HPUX 10.20 & 11.00
  
  EOF on the slave tty is not reported back to the master.
  
  =item * IRIX 6.5
  
  =item * Linux 2.2.x & 2.4.x
  
  Returns EIO instead of EOF when the slave is closed.  Benign.
  
  =item * OSF 4.0
  
  EOF on the slave tty is not reported back to the master.
  
  =item * Solaris 8, 2.7, 2.6
  
  Has the "feature" of returning EOF just once?!
  
  EOF on the slave tty is not reported back to the master.
  
  =item * Windows NT/2k/XP (under Cygwin)
  
  When you send (print) a too long line (>160 chars) to a non-raw pty,
  the call just hangs forever and even alarm() cannot get you out.
  Don't complain to me...
  
  EOF on the slave tty is not reported back to the master.
  
  =item * z/OS
  
  =back
  
  The following systems have not been verified yet for this version, but
  a previous version worked on them:
  
  =over 4
  
  =item * SCO Unix
  
  =item * NetBSD
  
  probably the same as the other *BSDs...
  
  =back
  
  If you have additions to these lists, please mail them to
  E<lt>F<RGiersig@cpan.org>E<gt>.
  
  
  =head1 SEE ALSO
  
  L<IO::Pty>, L<IO::Tty::Constant>
  
  
  =head1 MAILING LISTS
  
  As this module is mainly used by Expect, support for it is available
  via the two Expect mailing lists, expectperl-announce and
  expectperl-discuss, at
  
    http://lists.sourceforge.net/lists/listinfo/expectperl-announce
  
  and
  
    http://lists.sourceforge.net/lists/listinfo/expectperl-discuss
  
  
  =head1 AUTHORS
  
  Originally by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>, based on the
  Ptty module by Nick Ing-Simmons E<lt>F<nik@tiuk.ti.com>E<gt>.
  
  Now maintained and heavily rewritten by Roland Giersig
  E<lt>F<RGiersig@cpan.org>E<gt>.
  
  Contains copyrighted stuff from openssh v3.0p1, authored by Tatu
  Ylonen <ylo@cs.hut.fi>, Markus Friedl and Todd C. Miller
  <Todd.Miller@courtesan.com>.  I also got a lot of inspiration from
  the pty code in Xemacs.
  
  
  =head1 COPYRIGHT
  
  Now all code is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Nevertheless the above AUTHORS retain their copyrights to the various
  parts and want to receive credit if their source code is used.
  See the source for details.
  
  
  =head1 DISCLAIMER
  
  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGE.
  
  In other words: Use at your own risk.  Provided as is.  Your mileage
  may vary.  Read the source, Luke!
  
  And finally, just to be sure:
  
  Any Use of This Product, in Any Manner Whatsoever, Will Increase the
  Amount of Disorder in the Universe. Although No Liability Is Implied
  Herein, the Consumer Is Warned That This Process Will Ultimately Lead
  to the Heat Death of the Universe.
  
  =cut
X86_64-LINUX_IO_TTY

$fatpacked{"x86_64-linux/IO/Tty/Constant.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_TTY_CONSTANT';
  
  package IO::Tty::Constant;
  
  use vars qw(@ISA @EXPORT_OK);
  require Exporter;
  
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(B0 B110 B115200 B1200 B134 B150 B153600 B1800 B19200 B200 B230400 B2400 B300 B307200 B38400 B460800 B4800 B50 B57600 B600 B75 B76800 B9600 BRKINT BS0 BS1 BSDLY CBAUD CBAUDEXT CBRK CCTS_OFLOW CDEL CDSUSP CEOF CEOL CEOL2 CEOT CERASE CESC CFLUSH CIBAUD CIBAUDEXT CINTR CKILL CLNEXT CLOCAL CNSWTCH CNUL CQUIT CR0 CR1 CR2 CR3 CRDLY CREAD CRPRNT CRTSCTS CRTSXOFF CRTS_IFLOW CS5 CS6 CS7 CS8 CSIZE CSTART CSTOP CSTOPB CSUSP CSWTCH CWERASE DEFECHO DIOC DIOCGETP DIOCSETP DOSMODE ECHO ECHOCTL ECHOE ECHOK ECHOKE ECHONL ECHOPRT EXTA EXTB FF0 FF1 FFDLY FIORDCHK FLUSHO HUPCL ICANON ICRNL IEXTEN IGNBRK IGNCR IGNPAR IMAXBEL INLCR INPCK ISIG ISTRIP IUCLC IXANY IXOFF IXON KBENABLED LDCHG LDCLOSE LDDMAP LDEMAP LDGETT LDGMAP LDIOC LDNMAP LDOPEN LDSETT LDSMAP LOBLK NCCS NL0 NL1 NLDLY NOFLSH OCRNL OFDEL OFILL OLCUC ONLCR ONLRET ONOCR OPOST PAGEOUT PARENB PAREXT PARMRK PARODD PENDIN RCV1EN RTS_TOG TAB0 TAB1 TAB2 TAB3 TABDLY TCDSET TCFLSH TCGETA TCGETS TCIFLUSH TCIOFF TCIOFLUSH TCION TCOFLUSH TCOOFF TCOON TCSADRAIN TCSAFLUSH TCSANOW TCSBRK TCSETA TCSETAF TCSETAW TCSETCTTY TCSETS TCSETSF TCSETSW TCXONC TERM_D40 TERM_D42 TERM_H45 TERM_NONE TERM_TEC TERM_TEX TERM_V10 TERM_V61 TIOCCBRK TIOCCDTR TIOCCONS TIOCEXCL TIOCFLUSH TIOCGETD TIOCGETC TIOCGETP TIOCGLTC TIOCSETC TIOCSETN TIOCSETP TIOCSLTC TIOCGPGRP TIOCGSID TIOCGSOFTCAR TIOCGWINSZ TIOCHPCL TIOCKBOF TIOCKBON TIOCLBIC TIOCLBIS TIOCLGET TIOCLSET TIOCMBIC TIOCMBIS TIOCMGET TIOCMSET TIOCM_CAR TIOCM_CD TIOCM_CTS TIOCM_DSR TIOCM_DTR TIOCM_LE TIOCM_RI TIOCM_RNG TIOCM_RTS TIOCM_SR TIOCM_ST TIOCNOTTY TIOCNXCL TIOCOUTQ TIOCREMOTE TIOCSBRK TIOCSCTTY TIOCSDTR TIOCSETD TIOCSIGNAL TIOCSPGRP TIOCSSID TIOCSSOFTCAR TIOCSTART TIOCSTI TIOCSTOP TIOCSWINSZ TM_ANL TM_CECHO TM_CINVIS TM_LCF TM_NONE TM_SET TM_SNL TOSTOP VCEOF VCEOL VDISCARD VDSUSP VEOF VEOL VEOL2 VERASE VINTR VKILL VLNEXT VMIN VQUIT VREPRINT VSTART VSTOP VSUSP VSWTCH VT0 VT1 VTDLY VTIME VWERASE WRAP XCASE XCLUDE XMT1EN XTABS);
  
  __END__
  
  =head1 NAME
  
  IO::Tty::Constant - Terminal Constants (autogenerated)
  
  =head1 SYNOPSIS
  
   use IO::Tty::Constant qw(TIOCNOTTY);
   ...
  
  =head1 DESCRIPTION
  
  This package defines constants usually found in <termio.h> or
  <termios.h> (and their #include hierarchy).  Find below an
  autogenerated alphabetic list of all known constants and whether they
  are defined on your system (prefixed with '+') and have compilation
  problems ('o').  Undefined or problematic constants are set to 'undef'.
  
  =head1 DEFINED CONSTANTS
  
  =item +
  
  B0
  
  =item +
  
  B110
  
  =item +
  
  B115200
  
  =item +
  
  B1200
  
  =item +
  
  B134
  
  =item +
  
  B150
  
  =item -
  
  B153600
  
  =item +
  
  B1800
  
  =item +
  
  B19200
  
  =item +
  
  B200
  
  =item +
  
  B230400
  
  =item +
  
  B2400
  
  =item +
  
  B300
  
  =item -
  
  B307200
  
  =item +
  
  B38400
  
  =item +
  
  B460800
  
  =item +
  
  B4800
  
  =item +
  
  B50
  
  =item +
  
  B57600
  
  =item +
  
  B600
  
  =item +
  
  B75
  
  =item -
  
  B76800
  
  =item +
  
  B9600
  
  =item +
  
  BRKINT
  
  =item +
  
  BS0
  
  =item +
  
  BS1
  
  =item +
  
  BSDLY
  
  =item +
  
  CBAUD
  
  =item -
  
  CBAUDEXT
  
  =item +
  
  CBRK
  
  =item -
  
  CCTS_OFLOW
  
  =item -
  
  CDEL
  
  =item +
  
  CDSUSP
  
  =item +
  
  CEOF
  
  =item +
  
  CEOL
  
  =item -
  
  CEOL2
  
  =item +
  
  CEOT
  
  =item +
  
  CERASE
  
  =item -
  
  CESC
  
  =item +
  
  CFLUSH
  
  =item +
  
  CIBAUD
  
  =item -
  
  CIBAUDEXT
  
  =item +
  
  CINTR
  
  =item +
  
  CKILL
  
  =item +
  
  CLNEXT
  
  =item +
  
  CLOCAL
  
  =item -
  
  CNSWTCH
  
  =item -
  
  CNUL
  
  =item +
  
  CQUIT
  
  =item +
  
  CR0
  
  =item +
  
  CR1
  
  =item +
  
  CR2
  
  =item +
  
  CR3
  
  =item +
  
  CRDLY
  
  =item +
  
  CREAD
  
  =item +
  
  CRPRNT
  
  =item +
  
  CRTSCTS
  
  =item -
  
  CRTSXOFF
  
  =item -
  
  CRTS_IFLOW
  
  =item +
  
  CS5
  
  =item +
  
  CS6
  
  =item +
  
  CS7
  
  =item +
  
  CS8
  
  =item +
  
  CSIZE
  
  =item +
  
  CSTART
  
  =item +
  
  CSTOP
  
  =item +
  
  CSTOPB
  
  =item +
  
  CSUSP
  
  =item -
  
  CSWTCH
  
  =item +
  
  CWERASE
  
  =item -
  
  DEFECHO
  
  =item -
  
  DIOC
  
  =item -
  
  DIOCGETP
  
  =item -
  
  DIOCSETP
  
  =item -
  
  DOSMODE
  
  =item +
  
  ECHO
  
  =item +
  
  ECHOCTL
  
  =item +
  
  ECHOE
  
  =item +
  
  ECHOK
  
  =item +
  
  ECHOKE
  
  =item +
  
  ECHONL
  
  =item +
  
  ECHOPRT
  
  =item +
  
  EXTA
  
  =item +
  
  EXTB
  
  =item +
  
  FF0
  
  =item +
  
  FF1
  
  =item +
  
  FFDLY
  
  =item -
  
  FIORDCHK
  
  =item +
  
  FLUSHO
  
  =item +
  
  HUPCL
  
  =item +
  
  ICANON
  
  =item +
  
  ICRNL
  
  =item +
  
  IEXTEN
  
  =item +
  
  IGNBRK
  
  =item +
  
  IGNCR
  
  =item +
  
  IGNPAR
  
  =item +
  
  IMAXBEL
  
  =item +
  
  INLCR
  
  =item +
  
  INPCK
  
  =item +
  
  ISIG
  
  =item +
  
  ISTRIP
  
  =item +
  
  IUCLC
  
  =item +
  
  IXANY
  
  =item +
  
  IXOFF
  
  =item +
  
  IXON
  
  =item -
  
  KBENABLED
  
  =item -
  
  LDCHG
  
  =item -
  
  LDCLOSE
  
  =item -
  
  LDDMAP
  
  =item -
  
  LDEMAP
  
  =item -
  
  LDGETT
  
  =item -
  
  LDGMAP
  
  =item -
  
  LDIOC
  
  =item -
  
  LDNMAP
  
  =item -
  
  LDOPEN
  
  =item -
  
  LDSETT
  
  =item -
  
  LDSMAP
  
  =item -
  
  LOBLK
  
  =item +
  
  NCCS
  
  =item +
  
  NL0
  
  =item +
  
  NL1
  
  =item +
  
  NLDLY
  
  =item +
  
  NOFLSH
  
  =item +
  
  OCRNL
  
  =item +
  
  OFDEL
  
  =item +
  
  OFILL
  
  =item +
  
  OLCUC
  
  =item +
  
  ONLCR
  
  =item +
  
  ONLRET
  
  =item +
  
  ONOCR
  
  =item +
  
  OPOST
  
  =item -
  
  PAGEOUT
  
  =item +
  
  PARENB
  
  =item -
  
  PAREXT
  
  =item +
  
  PARMRK
  
  =item +
  
  PARODD
  
  =item +
  
  PENDIN
  
  =item -
  
  RCV1EN
  
  =item -
  
  RTS_TOG
  
  =item +
  
  TAB0
  
  =item +
  
  TAB1
  
  =item +
  
  TAB2
  
  =item +
  
  TAB3
  
  =item +
  
  TABDLY
  
  =item -
  
  TCDSET
  
  =item +
  
  TCFLSH
  
  =item +
  
  TCGETA
  
  =item +
  
  TCGETS
  
  =item +
  
  TCIFLUSH
  
  =item +
  
  TCIOFF
  
  =item +
  
  TCIOFLUSH
  
  =item +
  
  TCION
  
  =item +
  
  TCOFLUSH
  
  =item +
  
  TCOOFF
  
  =item +
  
  TCOON
  
  =item +
  
  TCSADRAIN
  
  =item +
  
  TCSAFLUSH
  
  =item +
  
  TCSANOW
  
  =item +
  
  TCSBRK
  
  =item +
  
  TCSETA
  
  =item +
  
  TCSETAF
  
  =item +
  
  TCSETAW
  
  =item -
  
  TCSETCTTY
  
  =item +
  
  TCSETS
  
  =item +
  
  TCSETSF
  
  =item +
  
  TCSETSW
  
  =item +
  
  TCXONC
  
  =item -
  
  TERM_D40
  
  =item -
  
  TERM_D42
  
  =item -
  
  TERM_H45
  
  =item -
  
  TERM_NONE
  
  =item -
  
  TERM_TEC
  
  =item -
  
  TERM_TEX
  
  =item -
  
  TERM_V10
  
  =item -
  
  TERM_V61
  
  =item +
  
  TIOCCBRK
  
  =item -
  
  TIOCCDTR
  
  =item +
  
  TIOCCONS
  
  =item +
  
  TIOCEXCL
  
  =item -
  
  TIOCFLUSH
  
  =item +
  
  TIOCGETD
  
  =item -
  
  TIOCGETC
  
  =item -
  
  TIOCGETP
  
  =item -
  
  TIOCGLTC
  
  =item -
  
  TIOCSETC
  
  =item -
  
  TIOCSETN
  
  =item -
  
  TIOCSETP
  
  =item -
  
  TIOCSLTC
  
  =item +
  
  TIOCGPGRP
  
  =item +
  
  TIOCGSID
  
  =item +
  
  TIOCGSOFTCAR
  
  =item +
  
  TIOCGWINSZ
  
  =item -
  
  TIOCHPCL
  
  =item -
  
  TIOCKBOF
  
  =item -
  
  TIOCKBON
  
  =item -
  
  TIOCLBIC
  
  =item -
  
  TIOCLBIS
  
  =item -
  
  TIOCLGET
  
  =item -
  
  TIOCLSET
  
  =item +
  
  TIOCMBIC
  
  =item +
  
  TIOCMBIS
  
  =item +
  
  TIOCMGET
  
  =item +
  
  TIOCMSET
  
  =item +
  
  TIOCM_CAR
  
  =item +
  
  TIOCM_CD
  
  =item +
  
  TIOCM_CTS
  
  =item +
  
  TIOCM_DSR
  
  =item +
  
  TIOCM_DTR
  
  =item +
  
  TIOCM_LE
  
  =item +
  
  TIOCM_RI
  
  =item +
  
  TIOCM_RNG
  
  =item +
  
  TIOCM_RTS
  
  =item +
  
  TIOCM_SR
  
  =item +
  
  TIOCM_ST
  
  =item +
  
  TIOCNOTTY
  
  =item +
  
  TIOCNXCL
  
  =item +
  
  TIOCOUTQ
  
  =item -
  
  TIOCREMOTE
  
  =item +
  
  TIOCSBRK
  
  =item +
  
  TIOCSCTTY
  
  =item -
  
  TIOCSDTR
  
  =item +
  
  TIOCSETD
  
  =item -
  
  TIOCSIGNAL
  
  =item +
  
  TIOCSPGRP
  
  =item -
  
  TIOCSSID
  
  =item +
  
  TIOCSSOFTCAR
  
  =item -
  
  TIOCSTART
  
  =item +
  
  TIOCSTI
  
  =item -
  
  TIOCSTOP
  
  =item +
  
  TIOCSWINSZ
  
  =item -
  
  TM_ANL
  
  =item -
  
  TM_CECHO
  
  =item -
  
  TM_CINVIS
  
  =item -
  
  TM_LCF
  
  =item -
  
  TM_NONE
  
  =item -
  
  TM_SET
  
  =item -
  
  TM_SNL
  
  =item +
  
  TOSTOP
  
  =item -
  
  VCEOF
  
  =item -
  
  VCEOL
  
  =item +
  
  VDISCARD
  
  =item -
  
  VDSUSP
  
  =item +
  
  VEOF
  
  =item +
  
  VEOL
  
  =item +
  
  VEOL2
  
  =item +
  
  VERASE
  
  =item +
  
  VINTR
  
  =item +
  
  VKILL
  
  =item +
  
  VLNEXT
  
  =item +
  
  VMIN
  
  =item +
  
  VQUIT
  
  =item +
  
  VREPRINT
  
  =item +
  
  VSTART
  
  =item +
  
  VSTOP
  
  =item +
  
  VSUSP
  
  =item -
  
  VSWTCH
  
  =item +
  
  VT0
  
  =item +
  
  VT1
  
  =item +
  
  VTDLY
  
  =item +
  
  VTIME
  
  =item +
  
  VWERASE
  
  =item -
  
  WRAP
  
  =item +
  
  XCASE
  
  =item -
  
  XCLUDE
  
  =item -
  
  XMT1EN
  
  =item +
  
  XTABS
  
  
  =head1 FOR MORE INFO SEE
  
  L<IO::Tty>
  
  =cut
  
X86_64-LINUX_IO_TTY_CONSTANT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use lib "/var/lib/stickshift/53acbc524382ecfba5000016/app-root/data/899281/Lib/lib/perl5/";
use Modern::Perl;
use autodie;
package racbot;
use base qw( Bot::BasicBot );
use WWW::Shorten 'Metamark', ':short';
use URI::Find::Schemeless;

our $nick = 'racbot';
our $password = 'hiddenforsecurity';

#save keys and values using syntax key>>value
sub save_memory{

   my $mem_file = shift;
   my $key = shift;
   my $value = shift;
   
   open my $fh, ">>", $mem_file or die "$!";
   
   print $fh "$key>>$value\n";
   
   close $fh;
   return 1;
}

#load from a memory file to a hash following the syntax key>>value
sub load_memory{
   my $mem_file = shift;
   my $hashref;
   open my $fh, "<", $mem_file;
   
   while (<$fh>){
      
      my ($key, $value) = split />>/, $_;
      $hashref->{$key} = $value;
           
   }

   close $fh;
   return $hashref;
}

#store messages sent to the bot in a log file
sub log_messages{
   my $logfile = shift;
   my $msg = shift;
   open my $log, ">>", $logfile;
   
   say $log $msg;
   
   close $log;
}


#the 'ear' of the bot, here he listen every message and parses it and then
#return the message
sub said {
   my ($self, $message) = @_;
      
   if($message->{address} eq $nick or #messages to bot
      $message->{address} eq 'msg') {
      
      my $msgs = "$message->{raw_nick} ($message->{address}) $message->{body}";
      $msgs .= " in ".scalar localtime;
      log_messages("log.txt", $msgs);
      say $msgs;
   
      if ($message->{body} =~ /(.*)\+\+/ ) #find things like 'word++'
      {
         
         my $name = $1;
         my $refer = load_memory("minix.txt");
                 
         my $check;
         foreach ( keys %$refer){
            
            if ($1 =~ /\b$_\b/){
               save_memory("minix.txt", $name, ++$refer->{$_});
               $check++;
               last;
            }
         }
         save_memory("minix.txt", $name, ++$refer->{$_}) unless $check;
      }
      
      my $refer = load_memory("memory.txt");
         
      if ($message->{body} =~ /^exp (.*)/ )#find things like 'exp word'
      {
      
         my $refer = load_memory("minix.txt");
         my $save = $1;
         
         foreach (keys %$refer){
         
            if ($1 =~ /\b$_\b/){
               chomp($refer->{$_});
               return "$save has $refer->{$_} minix exp";
            }
            
            else{
               return "$save has no minix exp";
            
            }
         }
      }
      
      if ($message->{body} =~ /(.+) =save (.+)/ ) { # key =save value
        
        #replacing links
         my $text = $message->{body};

         my @uris;
         my $finder = URI::Find::Schemeless->new(sub {
             my $uri = shift;
             push @uris, $uri;
         });

         print "@uris\n";
         my $count = 1;
         if ($finder->find(\$text)){

            foreach (@uris){
               
               my $short = short_link($_);
                
                if (!short_link($_)){
               
                  $short = $_;
                }
               $text =~ s/$count/$short/g;
               $count++;
                
            }

        }
        
        if ($text =~ /(.+) =save (.+)/){
                        
           save_memory("memory.txt", $1, $2);
           my $refer = load_memory("memory.txt");
                  
           return "The key '$1' is stored with value '$2'"; #message of storage
        }
      }
      
      my $text = $message->{body};
   
      my @uris;
      my $finder = URI::Find::Schemeless->new(sub {
          my($uri) = shift;
          push @uris, $uri;
      });
      
      my $tinyurlmsg = "Shorter urls: ";
      my $copy = $tinyurlmsg;
      if ( $finder->find(\$text) ){
      
         foreach ( @uris){
         
            
            $tinyurlmsg .= " ".short_link($_);
         
         }
         unless ($copy eq $tinyurlmsg){
            return $tinyurlmsg; #shorter urls are returned
         }
      }
      
      foreach ( keys %$refer) {
      
         if ($message->{body} =~ /\b$_\b/i) {
            return $refer->{$_};
         }
      }
      
      my $fl = substr $message->{body}, 0, 1;
      
      my @mem_list = grep { $_ =~ /^$fl/i} keys %$refer;
      my $words = join ' : ', @mem_list;
      
      if(@mem_list){
         return "Did you mean: $words";
      }
      elsif ( $message->{body} =~ /(.*)\+\+/ ){
         return;
      }
      else{
         return "Key not found! Try again! :(";
      }
   }
   
      if ($message->{body} =~ /(.*)\+\+/ ) #search in memory for added names
      {
         my $name = $1;
         my $refer = load_memory("minix.txt");
                  
         my $check;
         foreach ( keys %$refer){
            
            if ($1 =~ /\b$_\b/){
               save_memory("minix.txt", $name, ++$refer->{$_});
               $check++;
               return;
            }
         }
         save_memory("minix.txt", $name, ++$refer->{$_}) unless $check;
      }
   return;
}

sub tick{
  
  my @time = localtime;
   
  
  if ( !($time[1] % 30) and $time[0] == 0 ) {
    my $msg = "Ack at ".scalar localtime;
    say $msg;
    log_messages('ack.txt', $msg);
   
  }
  
  return 1;
      
}

#help of the bot
sub help { "Bot of #minix, always ready to help you! Please save only useful things using key =save value syntax, thanks very much! :)" }

#attributes of the bot

racbot->new(
   server => 'irc.freenode.net',
   #port => '8002',
   channels => [ '#minix', '#minix-dev'],
   nick => $nick,
   password => $password,
